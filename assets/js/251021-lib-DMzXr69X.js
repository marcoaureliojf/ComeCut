function e(e) {
    const t = Object.create(null);
    for (const n of e.split(",")) t[n] = 1;
    return (e) => e in t;
}
const t = {},
    n = [],
    r = () => {},
    i = () => !1,
    s = (e) => 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),
    a = (e) => e.startsWith("onUpdate:"),
    o = Object.assign,
    c = (e, t) => {
        const n = e.indexOf(t);
        n > -1 && e.splice(n, 1);
    },
    l = Object.prototype.hasOwnProperty,
    u = (e, t) => l.call(e, t),
    d = Array.isArray,
    h = (e) => "[object Map]" === _(e),
    m = (e) => "[object Set]" === _(e),
    p = (e) => "[object Date]" === _(e),
    f = (e) => "[object RegExp]" === _(e),
    g = (e) => "function" == typeof e,
    b = (e) => "string" == typeof e,
    y = (e) => "symbol" == typeof e,
    w = (e) => null !== e && "object" == typeof e,
    k = (e) => (w(e) || g(e)) && g(e.then) && g(e.catch),
    T = Object.prototype.toString,
    _ = (e) => T.call(e),
    v = (e) => _(e).slice(8, -1),
    S = (e) => "[object Object]" === _(e),
    E = (e) => b(e) && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e,
    C = e(
        ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    ),
    I = e("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"),
    x = (e) => {
        const t = Object.create(null);
        return (n) => t[n] || (t[n] = e(n));
    },
    A = /-(\w)/g,
    P = x((e) => e.replace(A, (e, t) => (t ? t.toUpperCase() : ""))),
    O = /\B([A-Z])/g,
    N = x((e) => e.replace(O, "-$1").toLowerCase()),
    R = x((e) => e.charAt(0).toUpperCase() + e.slice(1)),
    M = x((e) => (e ? `on${R(e)}` : "")),
    D = (e, t) => !Object.is(e, t),
    F = (e, ...t) => {
        for (let n = 0; n < e.length; n++) e[n](...t);
    },
    L = (e, t, n, r = !1) => {
        Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: r, value: n });
    },
    B = (e) => {
        const t = parseFloat(e);
        return isNaN(t) ? e : t;
    },
    z = (e) => {
        const t = b(e) ? Number(e) : NaN;
        return isNaN(t) ? e : t;
    };
let U;
const $ = () =>
        U ||
        (U =
            "undefined" != typeof globalThis
                ? globalThis
                : "undefined" != typeof self
                  ? self
                  : "undefined" != typeof window
                    ? window
                    : "undefined" != typeof global
                      ? global
                      : {}),
    V = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
const W = {
        1: "TEXT",
        2: "CLASS",
        4: "STYLE",
        8: "PROPS",
        16: "FULL_PROPS",
        32: "NEED_HYDRATION",
        64: "STABLE_FRAGMENT",
        128: "KEYED_FRAGMENT",
        256: "UNKEYED_FRAGMENT",
        512: "NEED_PATCH",
        1024: "DYNAMIC_SLOTS",
        2048: "DEV_ROOT_FRAGMENT",
        [-1]: "CACHED",
        [-2]: "BAIL",
    },
    j = { 1: "STABLE", 2: "DYNAMIC", 3: "FORWARDED" },
    H = e(
        "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol"
    ),
    q = H;
function X(e, t = 0, n = e.length) {
    if ((t = Math.max(0, Math.min(t, e.length))) > (n = Math.max(0, Math.min(n, e.length)))) return "";
    let r = e.split(/(\r?\n)/);
    const i = r.filter((e, t) => t % 2 == 1);
    r = r.filter((e, t) => t % 2 == 0);
    let s = 0;
    const a = [];
    for (let o = 0; o < r.length; o++)
        if (((s += r[o].length + ((i[o] && i[o].length) || 0)), s >= t)) {
            for (let e = o - 2; e <= o + 2 || n > s; e++) {
                if (e < 0 || e >= r.length) continue;
                const c = e + 1;
                a.push(`${c}${" ".repeat(Math.max(3 - String(c).length, 0))}|  ${r[e]}`);
                const l = r[e].length,
                    u = (i[e] && i[e].length) || 0;
                if (e === o) {
                    const e = t - (s - (l + u)),
                        r = Math.max(1, n > s ? l - e : n - t);
                    a.push("   |  " + " ".repeat(e) + "^".repeat(r));
                } else if (e > o) {
                    if (n > s) {
                        const e = Math.max(Math.min(n - s, l), 1);
                        a.push("   |  " + "^".repeat(e));
                    }
                    s += l + u;
                }
            }
            break;
        }
    return a.join("\n");
}
function G(e) {
    if (d(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const r = e[n],
                i = b(r) ? J(r) : G(r);
            if (i) for (const e in i) t[e] = i[e];
        }
        return t;
    }
    if (b(e) || w(e)) return e;
}
const K = /;(?![^(]*\))/g,
    Y = /:([^]+)/,
    Q = /\/\*[^]*?\*\//g;
function J(e) {
    const t = {};
    return (
        e
            .replace(Q, "")
            .split(K)
            .forEach((e) => {
                if (e) {
                    const n = e.split(Y);
                    n.length > 1 && (t[n[0].trim()] = n[1].trim());
                }
            }),
        t
    );
}
function Z(e) {
    let t = "";
    if (b(e)) t = e;
    else if (d(e))
        for (let n = 0; n < e.length; n++) {
            const r = Z(e[n]);
            r && (t += r + " ");
        }
    else if (w(e)) for (const n in e) e[n] && (t += n + " ");
    return t.trim();
}
function ee(e) {
    if (!e) return null;
    let { class: t, style: n } = e;
    return t && !b(t) && (e.class = Z(t)), n && (e.style = G(n)), e;
}
const te = e(
        "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot"
    ),
    ne = e(
        "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view"
    ),
    re = e(
        "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics"
    ),
    ie = e("area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr"),
    se = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    ae = e(se),
    oe = e(
        se +
            ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"
    );
function ce(e) {
    return !!e || "" === e;
}
const le = /[>/="'\u0009\u000a\u000c\u0020]/,
    ue = {};
const de = e(
        "accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"
    ),
    he = e(
        "xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan"
    ),
    me = e(
        "accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns"
    );
const pe = /["'&<>]/;
const fe = /^-?>|<!--|-->|--!>|<!-$/g;
const ge = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
function be(e, t) {
    if (e === t) return !0;
    let n = p(e),
        r = p(t);
    if (n || r) return !(!n || !r) && e.getTime() === t.getTime();
    if (((n = y(e)), (r = y(t)), n || r)) return e === t;
    if (((n = d(e)), (r = d(t)), n || r))
        return (
            !(!n || !r) &&
            (function (e, t) {
                if (e.length !== t.length) return !1;
                let n = !0;
                for (let r = 0; n && r < e.length; r++) n = be(e[r], t[r]);
                return n;
            })(e, t)
        );
    if (((n = w(e)), (r = w(t)), n || r)) {
        if (!n || !r) return !1;
        if (Object.keys(e).length !== Object.keys(t).length) return !1;
        for (const n in e) {
            const r = e.hasOwnProperty(n),
                i = t.hasOwnProperty(n);
            if ((r && !i) || (!r && i) || !be(e[n], t[n])) return !1;
        }
    }
    return String(e) === String(t);
}
function ye(e, t) {
    return e.findIndex((e) => be(e, t));
}
const we = (e) => !(!e || !0 !== e.__v_isRef),
    ke = (e) =>
        b(e)
            ? e
            : null == e
              ? ""
              : d(e) || (w(e) && (e.toString === T || !g(e.toString)))
                ? we(e)
                    ? ke(e.value)
                    : JSON.stringify(e, Te, 2)
                : String(e),
    Te = (e, t) =>
        we(t)
            ? Te(e, t.value)
            : h(t)
              ? { [`Map(${t.size})`]: [...t.entries()].reduce((e, [t, n], r) => ((e[_e(t, r) + " =>"] = n), e), {}) }
              : m(t)
                ? { [`Set(${t.size})`]: [...t.values()].map((e) => _e(e)) }
                : y(t)
                  ? _e(t)
                  : !w(t) || d(t) || S(t)
                    ? t
                    : String(t),
    _e = (e, t = "") => {
        var n;
        return y(e) ? `Symbol(${null != (n = e.description) ? n : t})` : e;
    },
    ve = Object.freeze(
        Object.defineProperty(
            {
                __proto__: null,
                EMPTY_ARR: n,
                EMPTY_OBJ: t,
                NO: i,
                NOOP: r,
                PatchFlagNames: W,
                PatchFlags: {
                    TEXT: 1,
                    1: "TEXT",
                    CLASS: 2,
                    2: "CLASS",
                    STYLE: 4,
                    4: "STYLE",
                    PROPS: 8,
                    8: "PROPS",
                    FULL_PROPS: 16,
                    16: "FULL_PROPS",
                    NEED_HYDRATION: 32,
                    32: "NEED_HYDRATION",
                    STABLE_FRAGMENT: 64,
                    64: "STABLE_FRAGMENT",
                    KEYED_FRAGMENT: 128,
                    128: "KEYED_FRAGMENT",
                    UNKEYED_FRAGMENT: 256,
                    256: "UNKEYED_FRAGMENT",
                    NEED_PATCH: 512,
                    512: "NEED_PATCH",
                    DYNAMIC_SLOTS: 1024,
                    1024: "DYNAMIC_SLOTS",
                    DEV_ROOT_FRAGMENT: 2048,
                    2048: "DEV_ROOT_FRAGMENT",
                    CACHED: -1,
                    "-1": "CACHED",
                    BAIL: -2,
                    "-2": "BAIL",
                },
                ShapeFlags: {
                    ELEMENT: 1,
                    1: "ELEMENT",
                    FUNCTIONAL_COMPONENT: 2,
                    2: "FUNCTIONAL_COMPONENT",
                    STATEFUL_COMPONENT: 4,
                    4: "STATEFUL_COMPONENT",
                    TEXT_CHILDREN: 8,
                    8: "TEXT_CHILDREN",
                    ARRAY_CHILDREN: 16,
                    16: "ARRAY_CHILDREN",
                    SLOTS_CHILDREN: 32,
                    32: "SLOTS_CHILDREN",
                    TELEPORT: 64,
                    64: "TELEPORT",
                    SUSPENSE: 128,
                    128: "SUSPENSE",
                    COMPONENT_SHOULD_KEEP_ALIVE: 256,
                    256: "COMPONENT_SHOULD_KEEP_ALIVE",
                    COMPONENT_KEPT_ALIVE: 512,
                    512: "COMPONENT_KEPT_ALIVE",
                    COMPONENT: 6,
                    6: "COMPONENT",
                },
                SlotFlags: { STABLE: 1, 1: "STABLE", DYNAMIC: 2, 2: "DYNAMIC", FORWARDED: 3, 3: "FORWARDED" },
                camelize: P,
                capitalize: R,
                cssVarNameEscapeSymbolsRE: ge,
                def: L,
                escapeHtml: function (e) {
                    const t = "" + e,
                        n = pe.exec(t);
                    if (!n) return t;
                    let r,
                        i,
                        s = "",
                        a = 0;
                    for (i = n.index; i < t.length; i++) {
                        switch (t.charCodeAt(i)) {
                            case 34:
                                r = "&quot;";
                                break;
                            case 38:
                                r = "&amp;";
                                break;
                            case 39:
                                r = "&#39;";
                                break;
                            case 60:
                                r = "&lt;";
                                break;
                            case 62:
                                r = "&gt;";
                                break;
                            default:
                                continue;
                        }
                        a !== i && (s += t.slice(a, i)), (a = i + 1), (s += r);
                    }
                    return a !== i ? s + t.slice(a, i) : s;
                },
                escapeHtmlComment: function (e) {
                    return e.replace(fe, "");
                },
                extend: o,
                genCacheKey: function (e, t) {
                    return e + JSON.stringify(t, (e, t) => ("function" == typeof t ? t.toString() : t));
                },
                genPropsAccessExp: function (e) {
                    return V.test(e) ? `__props.${e}` : `__props[${JSON.stringify(e)}]`;
                },
                generateCodeFrame: X,
                getEscapedCssVarName: function (e, t) {
                    return e.replace(ge, (e) => (t ? ('"' === e ? '\\\\\\"' : `\\\\${e}`) : `\\${e}`));
                },
                getGlobalThis: $,
                hasChanged: D,
                hasOwn: u,
                hyphenate: N,
                includeBooleanAttr: ce,
                invokeArrayFns: F,
                isArray: d,
                isBooleanAttr: oe,
                isBuiltInDirective: I,
                isDate: p,
                isFunction: g,
                isGloballyAllowed: H,
                isGloballyWhitelisted: q,
                isHTMLTag: te,
                isIntegerKey: E,
                isKnownHtmlAttr: de,
                isKnownMathMLAttr: me,
                isKnownSvgAttr: he,
                isMap: h,
                isMathMLTag: re,
                isModelListener: a,
                isObject: w,
                isOn: s,
                isPlainObject: S,
                isPromise: k,
                isRegExp: f,
                isRenderableAttrValue: function (e) {
                    if (null == e) return !1;
                    const t = typeof e;
                    return "string" === t || "number" === t || "boolean" === t;
                },
                isReservedProp: C,
                isSSRSafeAttrName: function (e) {
                    if (ue.hasOwnProperty(e)) return ue[e];
                    const t = le.test(e);
                    return (ue[e] = !t);
                },
                isSVGTag: ne,
                isSet: m,
                isSpecialBooleanAttr: ae,
                isString: b,
                isSymbol: y,
                isVoidTag: ie,
                looseEqual: be,
                looseIndexOf: ye,
                looseToNumber: B,
                makeMap: e,
                normalizeClass: Z,
                normalizeProps: ee,
                normalizeStyle: G,
                objectToString: T,
                parseStringStyle: J,
                propsToAttrMap: {
                    acceptCharset: "accept-charset",
                    className: "class",
                    htmlFor: "for",
                    httpEquiv: "http-equiv",
                },
                remove: c,
                slotFlagsText: j,
                stringifyStyle: function (e) {
                    if (!e) return "";
                    if (b(e)) return e;
                    let t = "";
                    for (const n in e) {
                        const r = e[n];
                        if (b(r) || "number" == typeof r) {
                            t += `${n.startsWith("--") ? n : N(n)}:${r};`;
                        }
                    }
                    return t;
                },
                toDisplayString: ke,
                toHandlerKey: M,
                toNumber: z,
                toRawType: v,
                toTypeString: _,
            },
            Symbol.toStringTag,
            { value: "Module" }
        )
    );
let Se, Ee;
class Ce {
    constructor(e = !1) {
        (this.detached = e),
            (this._active = !0),
            (this._on = 0),
            (this.effects = []),
            (this.cleanups = []),
            (this._isPaused = !1),
            (this.parent = Se),
            !e && Se && (this.index = (Se.scopes || (Se.scopes = [])).push(this) - 1);
    }
    get active() {
        return this._active;
    }
    pause() {
        if (this._active) {
            let e, t;
            if (((this._isPaused = !0), this.scopes))
                for (e = 0, t = this.scopes.length; e < t; e++) this.scopes[e].pause();
            for (e = 0, t = this.effects.length; e < t; e++) this.effects[e].pause();
        }
    }
    resume() {
        if (this._active && this._isPaused) {
            let e, t;
            if (((this._isPaused = !1), this.scopes))
                for (e = 0, t = this.scopes.length; e < t; e++) this.scopes[e].resume();
            for (e = 0, t = this.effects.length; e < t; e++) this.effects[e].resume();
        }
    }
    run(e) {
        if (this._active) {
            const t = Se;
            try {
                return (Se = this), e();
            } finally {
                Se = t;
            }
        }
    }
    on() {
        1 === ++this._on && ((this.prevScope = Se), (Se = this));
    }
    off() {
        this._on > 0 && 0 === --this._on && ((Se = this.prevScope), (this.prevScope = void 0));
    }
    stop(e) {
        if (this._active) {
            let t, n;
            for (this._active = !1, t = 0, n = this.effects.length; t < n; t++) this.effects[t].stop();
            for (this.effects.length = 0, t = 0, n = this.cleanups.length; t < n; t++) this.cleanups[t]();
            if (((this.cleanups.length = 0), this.scopes)) {
                for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].stop(!0);
                this.scopes.length = 0;
            }
            if (!this.detached && this.parent && !e) {
                const e = this.parent.scopes.pop();
                e && e !== this && ((this.parent.scopes[this.index] = e), (e.index = this.index));
            }
            this.parent = void 0;
        }
    }
}
function Ie() {
    return Se;
}
const xe = new WeakSet();
class Ae {
    constructor(e) {
        (this.fn = e),
            (this.deps = void 0),
            (this.depsTail = void 0),
            (this.flags = 5),
            (this.next = void 0),
            (this.cleanup = void 0),
            (this.scheduler = void 0),
            Se && Se.active && Se.effects.push(this);
    }
    pause() {
        this.flags |= 64;
    }
    resume() {
        64 & this.flags && ((this.flags &= -65), xe.has(this) && (xe.delete(this), this.trigger()));
    }
    notify() {
        (2 & this.flags && !(32 & this.flags)) || 8 & this.flags || Re(this);
    }
    run() {
        if (!(1 & this.flags)) return this.fn();
        (this.flags |= 2), qe(this), Fe(this);
        const e = Ee,
            t = Ve;
        (Ee = this), (Ve = !0);
        try {
            return this.fn();
        } finally {
            Le(this), (Ee = e), (Ve = t), (this.flags &= -3);
        }
    }
    stop() {
        if (1 & this.flags) {
            for (let e = this.deps; e; e = e.nextDep) Ue(e);
            (this.deps = this.depsTail = void 0), qe(this), this.onStop && this.onStop(), (this.flags &= -2);
        }
    }
    trigger() {
        64 & this.flags ? xe.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
    }
    runIfDirty() {
        Be(this) && this.run();
    }
    get dirty() {
        return Be(this);
    }
}
let Pe,
    Oe,
    Ne = 0;
function Re(e, t = !1) {
    if (((e.flags |= 8), t)) return (e.next = Oe), void (Oe = e);
    (e.next = Pe), (Pe = e);
}
function Me() {
    Ne++;
}
function De() {
    if (--Ne > 0) return;
    if (Oe) {
        let e = Oe;
        for (Oe = void 0; e; ) {
            const t = e.next;
            (e.next = void 0), (e.flags &= -9), (e = t);
        }
    }
    let e;
    for (; Pe; ) {
        let n = Pe;
        for (Pe = void 0; n; ) {
            const r = n.next;
            if (((n.next = void 0), (n.flags &= -9), 1 & n.flags))
                try {
                    n.trigger();
                } catch (t) {
                    e || (e = t);
                }
            n = r;
        }
    }
    if (e) throw e;
}
function Fe(e) {
    for (let t = e.deps; t; t = t.nextDep)
        (t.version = -1), (t.prevActiveLink = t.dep.activeLink), (t.dep.activeLink = t);
}
function Le(e) {
    let t,
        n = e.depsTail,
        r = n;
    for (; r; ) {
        const e = r.prevDep;
        -1 === r.version ? (r === n && (n = e), Ue(r), $e(r)) : (t = r),
            (r.dep.activeLink = r.prevActiveLink),
            (r.prevActiveLink = void 0),
            (r = e);
    }
    (e.deps = t), (e.depsTail = n);
}
function Be(e) {
    for (let t = e.deps; t; t = t.nextDep)
        if (t.dep.version !== t.version || (t.dep.computed && (ze(t.dep.computed) || t.dep.version !== t.version)))
            return !0;
    return !!e._dirty;
}
function ze(e) {
    if (4 & e.flags && !(16 & e.flags)) return;
    if (((e.flags &= -17), e.globalVersion === Xe)) return;
    if (((e.globalVersion = Xe), !e.isSSR && 128 & e.flags && ((!e.deps && !e._dirty) || !Be(e)))) return;
    e.flags |= 2;
    const t = e.dep,
        n = Ee,
        r = Ve;
    (Ee = e), (Ve = !0);
    try {
        Fe(e);
        const n = e.fn(e._value);
        (0 === t.version || D(n, e._value)) && ((e.flags |= 128), (e._value = n), t.version++);
    } catch (i) {
        throw (t.version++, i);
    } finally {
        (Ee = n), (Ve = r), Le(e), (e.flags &= -3);
    }
}
function Ue(e, t = !1) {
    const { dep: n, prevSub: r, nextSub: i } = e;
    if (
        (r && ((r.nextSub = i), (e.prevSub = void 0)),
        i && ((i.prevSub = r), (e.nextSub = void 0)),
        n.subs === e && ((n.subs = r), !r && n.computed))
    ) {
        n.computed.flags &= -5;
        for (let e = n.computed.deps; e; e = e.nextDep) Ue(e, !0);
    }
    t || --n.sc || !n.map || n.map.delete(n.key);
}
function $e(e) {
    const { prevDep: t, nextDep: n } = e;
    t && ((t.nextDep = n), (e.prevDep = void 0)), n && ((n.prevDep = t), (e.nextDep = void 0));
}
let Ve = !0;
const We = [];
function je() {
    We.push(Ve), (Ve = !1);
}
function He() {
    const e = We.pop();
    Ve = void 0 === e || e;
}
function qe(e) {
    const { cleanup: t } = e;
    if (((e.cleanup = void 0), t)) {
        const e = Ee;
        Ee = void 0;
        try {
            t();
        } finally {
            Ee = e;
        }
    }
}
let Xe = 0;
class Ge {
    constructor(e, t) {
        (this.sub = e),
            (this.dep = t),
            (this.version = t.version),
            (this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0);
    }
}
class Ke {
    constructor(e) {
        (this.computed = e),
            (this.version = 0),
            (this.activeLink = void 0),
            (this.subs = void 0),
            (this.map = void 0),
            (this.key = void 0),
            (this.sc = 0),
            (this.__v_skip = !0);
    }
    track(e) {
        if (!Ee || !Ve || Ee === this.computed) return;
        let t = this.activeLink;
        if (void 0 === t || t.sub !== Ee)
            (t = this.activeLink = new Ge(Ee, this)),
                Ee.deps
                    ? ((t.prevDep = Ee.depsTail), (Ee.depsTail.nextDep = t), (Ee.depsTail = t))
                    : (Ee.deps = Ee.depsTail = t),
                Ye(t);
        else if (-1 === t.version && ((t.version = this.version), t.nextDep)) {
            const e = t.nextDep;
            (e.prevDep = t.prevDep),
                t.prevDep && (t.prevDep.nextDep = e),
                (t.prevDep = Ee.depsTail),
                (t.nextDep = void 0),
                (Ee.depsTail.nextDep = t),
                (Ee.depsTail = t),
                Ee.deps === t && (Ee.deps = e);
        }
        return t;
    }
    trigger(e) {
        this.version++, Xe++, this.notify(e);
    }
    notify(e) {
        Me();
        try {
            0;
            for (let e = this.subs; e; e = e.prevSub) e.sub.notify() && e.sub.dep.notify();
        } finally {
            De();
        }
    }
}
function Ye(e) {
    if ((e.dep.sc++, 4 & e.sub.flags)) {
        const t = e.dep.computed;
        if (t && !e.dep.subs) {
            t.flags |= 20;
            for (let e = t.deps; e; e = e.nextDep) Ye(e);
        }
        const n = e.dep.subs;
        n !== e && ((e.prevSub = n), n && (n.nextSub = e)), (e.dep.subs = e);
    }
}
const Qe = new WeakMap(),
    Je = Symbol(""),
    Ze = Symbol(""),
    et = Symbol("");
function tt(e, t, n) {
    if (Ve && Ee) {
        let t = Qe.get(e);
        t || Qe.set(e, (t = new Map()));
        let r = t.get(n);
        r || (t.set(n, (r = new Ke())), (r.map = t), (r.key = n)), r.track();
    }
}
function nt(e, t, n, r, i, s) {
    const a = Qe.get(e);
    if (!a) return void Xe++;
    const o = (e) => {
        e && e.trigger();
    };
    if ((Me(), "clear" === t)) a.forEach(o);
    else {
        const i = d(e),
            s = i && E(n);
        if (i && "length" === n) {
            const e = Number(r);
            a.forEach((t, n) => {
                ("length" === n || n === et || (!y(n) && n >= e)) && o(t);
            });
        } else
            switch (((void 0 !== n || a.has(void 0)) && o(a.get(n)), s && o(a.get(et)), t)) {
                case "add":
                    i ? s && o(a.get("length")) : (o(a.get(Je)), h(e) && o(a.get(Ze)));
                    break;
                case "delete":
                    i || (o(a.get(Je)), h(e) && o(a.get(Ze)));
                    break;
                case "set":
                    h(e) && o(a.get(Je));
            }
    }
    De();
}
function rt(e) {
    const t = jt(e);
    return t === e ? t : (tt(t, 0, et), Vt(e) ? t : t.map(qt));
}
function it(e) {
    return tt((e = jt(e)), 0, et), e;
}
const st = {
    __proto__: null,
    [Symbol.iterator]() {
        return at(this, Symbol.iterator, qt);
    },
    concat(...e) {
        return rt(this).concat(...e.map((e) => (d(e) ? rt(e) : e)));
    },
    entries() {
        return at(this, "entries", (e) => ((e[1] = qt(e[1])), e));
    },
    every(e, t) {
        return ct(this, "every", e, t, void 0, arguments);
    },
    filter(e, t) {
        return ct(this, "filter", e, t, (e) => e.map(qt), arguments);
    },
    find(e, t) {
        return ct(this, "find", e, t, qt, arguments);
    },
    findIndex(e, t) {
        return ct(this, "findIndex", e, t, void 0, arguments);
    },
    findLast(e, t) {
        return ct(this, "findLast", e, t, qt, arguments);
    },
    findLastIndex(e, t) {
        return ct(this, "findLastIndex", e, t, void 0, arguments);
    },
    forEach(e, t) {
        return ct(this, "forEach", e, t, void 0, arguments);
    },
    includes(...e) {
        return ut(this, "includes", e);
    },
    indexOf(...e) {
        return ut(this, "indexOf", e);
    },
    join(e) {
        return rt(this).join(e);
    },
    lastIndexOf(...e) {
        return ut(this, "lastIndexOf", e);
    },
    map(e, t) {
        return ct(this, "map", e, t, void 0, arguments);
    },
    pop() {
        return dt(this, "pop");
    },
    push(...e) {
        return dt(this, "push", e);
    },
    reduce(e, ...t) {
        return lt(this, "reduce", e, t);
    },
    reduceRight(e, ...t) {
        return lt(this, "reduceRight", e, t);
    },
    shift() {
        return dt(this, "shift");
    },
    some(e, t) {
        return ct(this, "some", e, t, void 0, arguments);
    },
    splice(...e) {
        return dt(this, "splice", e);
    },
    toReversed() {
        return rt(this).toReversed();
    },
    toSorted(e) {
        return rt(this).toSorted(e);
    },
    toSpliced(...e) {
        return rt(this).toSpliced(...e);
    },
    unshift(...e) {
        return dt(this, "unshift", e);
    },
    values() {
        return at(this, "values", qt);
    },
};
function at(e, t, n) {
    const r = it(e),
        i = r[t]();
    return (
        r === e ||
            Vt(e) ||
            ((i._next = i.next),
            (i.next = () => {
                const e = i._next();
                return e.value && (e.value = n(e.value)), e;
            })),
        i
    );
}
const ot = Array.prototype;
function ct(e, t, n, r, i, s) {
    const a = it(e),
        o = a !== e && !Vt(e),
        c = a[t];
    if (c !== ot[t]) {
        const t = c.apply(e, s);
        return o ? qt(t) : t;
    }
    let l = n;
    a !== e &&
        (o
            ? (l = function (t, r) {
                  return n.call(this, qt(t), r, e);
              })
            : n.length > 2 &&
              (l = function (t, r) {
                  return n.call(this, t, r, e);
              }));
    const u = c.call(a, l, r);
    return o && i ? i(u) : u;
}
function lt(e, t, n, r) {
    const i = it(e);
    let s = n;
    return (
        i !== e &&
            (Vt(e)
                ? n.length > 3 &&
                  (s = function (t, r, i) {
                      return n.call(this, t, r, i, e);
                  })
                : (s = function (t, r, i) {
                      return n.call(this, t, qt(r), i, e);
                  })),
        i[t](s, ...r)
    );
}
function ut(e, t, n) {
    const r = jt(e);
    tt(r, 0, et);
    const i = r[t](...n);
    return (-1 !== i && !1 !== i) || !Wt(n[0]) ? i : ((n[0] = jt(n[0])), r[t](...n));
}
function dt(e, t, n = []) {
    je(), Me();
    const r = jt(e)[t].apply(e, n);
    return De(), He(), r;
}
const ht = e("__proto__,__v_isRef,__isVue"),
    mt = new Set(
        Object.getOwnPropertyNames(Symbol)
            .filter((e) => "arguments" !== e && "caller" !== e)
            .map((e) => Symbol[e])
            .filter(y)
    );
function pt(e) {
    y(e) || (e = String(e));
    const t = jt(this);
    return tt(t, 0, e), t.hasOwnProperty(e);
}
class ft {
    constructor(e = !1, t = !1) {
        (this._isReadonly = e), (this._isShallow = t);
    }
    get(e, t, n) {
        if ("__v_skip" === t) return e.__v_skip;
        const r = this._isReadonly,
            i = this._isShallow;
        if ("__v_isReactive" === t) return !r;
        if ("__v_isReadonly" === t) return r;
        if ("__v_isShallow" === t) return i;
        if ("__v_raw" === t)
            return n === (r ? (i ? Mt : Rt) : i ? Nt : Ot).get(e) ||
                Object.getPrototypeOf(e) === Object.getPrototypeOf(n)
                ? e
                : void 0;
        const s = d(e);
        if (!r) {
            let e;
            if (s && (e = st[t])) return e;
            if ("hasOwnProperty" === t) return pt;
        }
        const a = Reflect.get(e, t, Gt(e) ? e : n);
        return (y(t) ? mt.has(t) : ht(t))
            ? a
            : (r || tt(e, 0, t), i ? a : Gt(a) ? (s && E(t) ? a : a.value) : w(a) ? (r ? Lt(a) : Dt(a)) : a);
    }
}
class gt extends ft {
    constructor(e = !1) {
        super(!1, e);
    }
    set(e, t, n, r) {
        let i = e[t];
        if (!this._isShallow) {
            const t = $t(i);
            if ((Vt(n) || $t(n) || ((i = jt(i)), (n = jt(n))), !d(e) && Gt(i) && !Gt(n)))
                return !t && ((i.value = n), !0);
        }
        const s = d(e) && E(t) ? Number(t) < e.length : u(e, t),
            a = Reflect.set(e, t, n, Gt(e) ? e : r);
        return e === jt(r) && (s ? D(n, i) && nt(e, "set", t, n) : nt(e, "add", t, n)), a;
    }
    deleteProperty(e, t) {
        const n = u(e, t);
        e[t];
        const r = Reflect.deleteProperty(e, t);
        return r && n && nt(e, "delete", t, void 0), r;
    }
    has(e, t) {
        const n = Reflect.has(e, t);
        return (y(t) && mt.has(t)) || tt(e, 0, t), n;
    }
    ownKeys(e) {
        return tt(e, 0, d(e) ? "length" : Je), Reflect.ownKeys(e);
    }
}
class bt extends ft {
    constructor(e = !1) {
        super(!0, e);
    }
    set(e, t) {
        return !0;
    }
    deleteProperty(e, t) {
        return !0;
    }
}
const yt = new gt(),
    wt = new bt(),
    kt = new gt(!0),
    Tt = new bt(!0),
    _t = (e) => e,
    vt = (e) => Reflect.getPrototypeOf(e);
function St(e) {
    return function (...t) {
        return "delete" !== e && ("clear" === e ? void 0 : this);
    };
}
function Et(e, t) {
    const n = {
        get(n) {
            const r = this.__v_raw,
                i = jt(r),
                s = jt(n);
            e || (D(n, s) && tt(i, 0, n), tt(i, 0, s));
            const { has: a } = vt(i),
                o = t ? _t : e ? Xt : qt;
            return a.call(i, n) ? o(r.get(n)) : a.call(i, s) ? o(r.get(s)) : void (r !== i && r.get(n));
        },
        get size() {
            const t = this.__v_raw;
            return !e && tt(jt(t), 0, Je), Reflect.get(t, "size", t);
        },
        has(t) {
            const n = this.__v_raw,
                r = jt(n),
                i = jt(t);
            return e || (D(t, i) && tt(r, 0, t), tt(r, 0, i)), t === i ? n.has(t) : n.has(t) || n.has(i);
        },
        forEach(n, r) {
            const i = this,
                s = i.__v_raw,
                a = jt(s),
                o = t ? _t : e ? Xt : qt;
            return !e && tt(a, 0, Je), s.forEach((e, t) => n.call(r, o(e), o(t), i));
        },
    };
    o(
        n,
        e
            ? { add: St("add"), set: St("set"), delete: St("delete"), clear: St("clear") }
            : {
                  add(e) {
                      t || Vt(e) || $t(e) || (e = jt(e));
                      const n = jt(this);
                      return vt(n).has.call(n, e) || (n.add(e), nt(n, "add", e, e)), this;
                  },
                  set(e, n) {
                      t || Vt(n) || $t(n) || (n = jt(n));
                      const r = jt(this),
                          { has: i, get: s } = vt(r);
                      let a = i.call(r, e);
                      a || ((e = jt(e)), (a = i.call(r, e)));
                      const o = s.call(r, e);
                      return r.set(e, n), a ? D(n, o) && nt(r, "set", e, n) : nt(r, "add", e, n), this;
                  },
                  delete(e) {
                      const t = jt(this),
                          { has: n, get: r } = vt(t);
                      let i = n.call(t, e);
                      i || ((e = jt(e)), (i = n.call(t, e))), r && r.call(t, e);
                      const s = t.delete(e);
                      return i && nt(t, "delete", e, void 0), s;
                  },
                  clear() {
                      const e = jt(this),
                          t = 0 !== e.size,
                          n = e.clear();
                      return t && nt(e, "clear", void 0, void 0), n;
                  },
              }
    );
    return (
        ["keys", "values", "entries", Symbol.iterator].forEach((r) => {
            n[r] = (function (e, t, n) {
                return function (...r) {
                    const i = this.__v_raw,
                        s = jt(i),
                        a = h(s),
                        o = "entries" === e || (e === Symbol.iterator && a),
                        c = "keys" === e && a,
                        l = i[e](...r),
                        u = n ? _t : t ? Xt : qt;
                    return (
                        !t && tt(s, 0, c ? Ze : Je),
                        {
                            next() {
                                const { value: e, done: t } = l.next();
                                return t ? { value: e, done: t } : { value: o ? [u(e[0]), u(e[1])] : u(e), done: t };
                            },
                            [Symbol.iterator]() {
                                return this;
                            },
                        }
                    );
                };
            })(r, e, t);
        }),
        n
    );
}
function Ct(e, t) {
    const n = Et(e, t);
    return (t, r, i) =>
        "__v_isReactive" === r
            ? !e
            : "__v_isReadonly" === r
              ? e
              : "__v_raw" === r
                ? t
                : Reflect.get(u(n, r) && r in t ? n : t, r, i);
}
const It = { get: Ct(!1, !1) },
    xt = { get: Ct(!1, !0) },
    At = { get: Ct(!0, !1) },
    Pt = { get: Ct(!0, !0) },
    Ot = new WeakMap(),
    Nt = new WeakMap(),
    Rt = new WeakMap(),
    Mt = new WeakMap();
function Dt(e) {
    return $t(e) ? e : zt(e, !1, yt, It, Ot);
}
function Ft(e) {
    return zt(e, !1, kt, xt, Nt);
}
function Lt(e) {
    return zt(e, !0, wt, At, Rt);
}
function Bt(e) {
    return zt(e, !0, Tt, Pt, Mt);
}
function zt(e, t, n, r, i) {
    if (!w(e)) return e;
    if (e.__v_raw && (!t || !e.__v_isReactive)) return e;
    const s =
        (a = e).__v_skip || !Object.isExtensible(a)
            ? 0
            : (function (e) {
                  switch (e) {
                      case "Object":
                      case "Array":
                          return 1;
                      case "Map":
                      case "Set":
                      case "WeakMap":
                      case "WeakSet":
                          return 2;
                      default:
                          return 0;
                  }
              })(v(a));
    var a;
    if (0 === s) return e;
    const o = i.get(e);
    if (o) return o;
    const c = new Proxy(e, 2 === s ? r : n);
    return i.set(e, c), c;
}
function Ut(e) {
    return $t(e) ? Ut(e.__v_raw) : !(!e || !e.__v_isReactive);
}
function $t(e) {
    return !(!e || !e.__v_isReadonly);
}
function Vt(e) {
    return !(!e || !e.__v_isShallow);
}
function Wt(e) {
    return !!e && !!e.__v_raw;
}
function jt(e) {
    const t = e && e.__v_raw;
    return t ? jt(t) : e;
}
function Ht(e) {
    return !u(e, "__v_skip") && Object.isExtensible(e) && L(e, "__v_skip", !0), e;
}
const qt = (e) => (w(e) ? Dt(e) : e),
    Xt = (e) => (w(e) ? Lt(e) : e);
function Gt(e) {
    return !!e && !0 === e.__v_isRef;
}
function Kt(e) {
    return Qt(e, !1);
}
function Yt(e) {
    return Qt(e, !0);
}
function Qt(e, t) {
    return Gt(e) ? e : new Jt(e, t);
}
class Jt {
    constructor(e, t) {
        (this.dep = new Ke()),
            (this.__v_isRef = !0),
            (this.__v_isShallow = !1),
            (this._rawValue = t ? e : jt(e)),
            (this._value = t ? e : qt(e)),
            (this.__v_isShallow = t);
    }
    get value() {
        return this.dep.track(), this._value;
    }
    set value(e) {
        const t = this._rawValue,
            n = this.__v_isShallow || Vt(e) || $t(e);
        (e = n ? e : jt(e)), D(e, t) && ((this._rawValue = e), (this._value = n ? e : qt(e)), this.dep.trigger());
    }
}
function Zt(e) {
    return Gt(e) ? e.value : e;
}
const en = {
    get: (e, t, n) => ("__v_raw" === t ? e : Zt(Reflect.get(e, t, n))),
    set: (e, t, n, r) => {
        const i = e[t];
        return Gt(i) && !Gt(n) ? ((i.value = n), !0) : Reflect.set(e, t, n, r);
    },
};
function tn(e) {
    return Ut(e) ? e : new Proxy(e, en);
}
class nn {
    constructor(e) {
        (this.__v_isRef = !0), (this._value = void 0);
        const t = (this.dep = new Ke()),
            { get: n, set: r } = e(t.track.bind(t), t.trigger.bind(t));
        (this._get = n), (this._set = r);
    }
    get value() {
        return (this._value = this._get());
    }
    set value(e) {
        this._set(e);
    }
}
function rn(e) {
    return new nn(e);
}
function sn(e) {
    const t = d(e) ? new Array(e.length) : {};
    for (const n in e) t[n] = cn(e, n);
    return t;
}
class an {
    constructor(e, t, n) {
        (this._object = e), (this._key = t), (this._defaultValue = n), (this.__v_isRef = !0), (this._value = void 0);
    }
    get value() {
        const e = this._object[this._key];
        return (this._value = void 0 === e ? this._defaultValue : e);
    }
    set value(e) {
        this._object[this._key] = e;
    }
    get dep() {
        return (function (e, t) {
            const n = Qe.get(e);
            return n && n.get(t);
        })(jt(this._object), this._key);
    }
}
class on {
    constructor(e) {
        (this._getter = e), (this.__v_isRef = !0), (this.__v_isReadonly = !0), (this._value = void 0);
    }
    get value() {
        return (this._value = this._getter());
    }
}
function cn(e, t, n) {
    const r = e[t];
    return Gt(r) ? r : new an(e, t, n);
}
class ln {
    constructor(e, t, n) {
        (this.fn = e),
            (this.setter = t),
            (this._value = void 0),
            (this.dep = new Ke(this)),
            (this.__v_isRef = !0),
            (this.deps = void 0),
            (this.depsTail = void 0),
            (this.flags = 16),
            (this.globalVersion = Xe - 1),
            (this.next = void 0),
            (this.effect = this),
            (this.__v_isReadonly = !t),
            (this.isSSR = n);
    }
    notify() {
        if (((this.flags |= 16), !(8 & this.flags) && Ee !== this)) return Re(this, !0), !0;
    }
    get value() {
        const e = this.dep.track();
        return ze(this), e && (e.version = this.dep.version), this._value;
    }
    set value(e) {
        this.setter && this.setter(e);
    }
}
const un = {},
    dn = new WeakMap();
let hn;
function mn(e, t = !1, n = hn) {
    if (n) {
        let t = dn.get(n);
        t || dn.set(n, (t = [])), t.push(e);
    }
}
function pn(e, t = 1 / 0, n) {
    if (t <= 0 || !w(e) || e.__v_skip) return e;
    if ((n = n || new Set()).has(e)) return e;
    if ((n.add(e), t--, Gt(e))) pn(e.value, t, n);
    else if (d(e)) for (let r = 0; r < e.length; r++) pn(e[r], t, n);
    else if (m(e) || h(e))
        e.forEach((e) => {
            pn(e, t, n);
        });
    else if (S(e)) {
        for (const r in e) pn(e[r], t, n);
        for (const r of Object.getOwnPropertySymbols(e))
            Object.prototype.propertyIsEnumerable.call(e, r) && pn(e[r], t, n);
    }
    return e;
}
const fn = [];
const gn = {
    sp: "serverPrefetch hook",
    bc: "beforeCreate hook",
    c: "created hook",
    bm: "beforeMount hook",
    m: "mounted hook",
    bu: "beforeUpdate hook",
    u: "updated",
    bum: "beforeUnmount hook",
    um: "unmounted hook",
    a: "activated hook",
    da: "deactivated hook",
    ec: "errorCaptured hook",
    rtc: "renderTracked hook",
    rtg: "renderTriggered hook",
    0: "setup function",
    1: "render function",
    2: "watcher getter",
    3: "watcher callback",
    4: "watcher cleanup function",
    5: "native event handler",
    6: "component event handler",
    7: "vnode hook",
    8: "directive hook",
    9: "transition hook",
    10: "app errorHandler",
    11: "app warnHandler",
    12: "ref function",
    13: "async component loader",
    14: "scheduler flush",
    15: "component update",
    16: "app unmount cleanup function",
};
function bn(e, t, n, r) {
    try {
        return r ? e(...r) : e();
    } catch (i) {
        wn(i, t, n);
    }
}
function yn(e, t, n, r) {
    if (g(e)) {
        const i = bn(e, t, n, r);
        return (
            i &&
                k(i) &&
                i.catch((e) => {
                    wn(e, t, n);
                }),
            i
        );
    }
    if (d(e)) {
        const i = [];
        for (let s = 0; s < e.length; s++) i.push(yn(e[s], t, n, r));
        return i;
    }
}
function wn(e, n, r, i = !0) {
    n && n.vnode;
    const { errorHandler: s, throwUnhandledErrorInProduction: a } = (n && n.appContext.config) || t;
    if (n) {
        let t = n.parent;
        const i = n.proxy,
            a = `https://vuejs.org/error-reference/#runtime-${r}`;
        for (; t; ) {
            const n = t.ec;
            if (n) for (let t = 0; t < n.length; t++) if (!1 === n[t](e, i, a)) return;
            t = t.parent;
        }
        if (s) return je(), bn(s, null, 10, [e, i, a]), void He();
    }
    !(function (e, t, n, r = !0, i = !1) {
        if (i) throw e;
    })(e, 0, 0, i, a);
}
const kn = [];
let Tn = -1;
const _n = [];
let vn = null,
    Sn = 0;
const En = Promise.resolve();
let Cn = null;
function In(e) {
    const t = Cn || En;
    return e ? t.then(this ? e.bind(this) : e) : t;
}
function xn(e) {
    if (!(1 & e.flags)) {
        const t = Rn(e),
            n = kn[kn.length - 1];
        !n || (!(2 & e.flags) && t >= Rn(n))
            ? kn.push(e)
            : kn.splice(
                  (function (e) {
                      let t = Tn + 1,
                          n = kn.length;
                      for (; t < n; ) {
                          const r = (t + n) >>> 1,
                              i = kn[r],
                              s = Rn(i);
                          s < e || (s === e && 2 & i.flags) ? (t = r + 1) : (n = r);
                      }
                      return t;
                  })(t),
                  0,
                  e
              ),
            (e.flags |= 1),
            An();
    }
}
function An() {
    Cn || (Cn = En.then(Mn));
}
function Pn(e) {
    d(e) ? _n.push(...e) : vn && -1 === e.id ? vn.splice(Sn + 1, 0, e) : 1 & e.flags || (_n.push(e), (e.flags |= 1)),
        An();
}
function On(e, t, n = Tn + 1) {
    for (; n < kn.length; n++) {
        const t = kn[n];
        if (t && 2 & t.flags) {
            if (e && t.id !== e.uid) continue;
            kn.splice(n, 1), n--, 4 & t.flags && (t.flags &= -2), t(), 4 & t.flags || (t.flags &= -2);
        }
    }
}
function Nn(e) {
    if (_n.length) {
        const e = [...new Set(_n)].sort((e, t) => Rn(e) - Rn(t));
        if (((_n.length = 0), vn)) return void vn.push(...e);
        for (vn = e, Sn = 0; Sn < vn.length; Sn++) {
            const e = vn[Sn];
            4 & e.flags && (e.flags &= -2), 8 & e.flags || e(), (e.flags &= -2);
        }
        (vn = null), (Sn = 0);
    }
}
const Rn = (e) => (null == e.id ? (2 & e.flags ? -1 : 1 / 0) : e.id);
function Mn(e) {
    try {
        for (Tn = 0; Tn < kn.length; Tn++) {
            const e = kn[Tn];
            !e ||
                8 & e.flags ||
                (4 & e.flags && (e.flags &= -2), bn(e, e.i, e.i ? 15 : 14), 4 & e.flags || (e.flags &= -2));
        }
    } finally {
        for (; Tn < kn.length; Tn++) {
            const e = kn[Tn];
            e && (e.flags &= -2);
        }
        (Tn = -1), (kn.length = 0), Nn(), (Cn = null), (kn.length || _n.length) && Mn();
    }
}
let Dn,
    Fn = [];
let Ln = null,
    Bn = null;
function zn(e) {
    const t = Ln;
    return (Ln = e), (Bn = (e && e.type.__scopeId) || null), t;
}
function Un(e, t = Ln, n) {
    if (!t) return e;
    if (e._n) return e;
    const r = (...n) => {
        r._d && Ls(-1);
        const i = zn(t);
        let s;
        try {
            s = e(...n);
        } finally {
            zn(i), r._d && Ls(1);
        }
        return s;
    };
    return (r._n = !0), (r._c = !0), (r._d = !0), r;
}
function $n(e, n) {
    if (null === Ln) return e;
    const r = ka(Ln),
        i = e.dirs || (e.dirs = []);
    for (let s = 0; s < n.length; s++) {
        let [e, a, o, c = t] = n[s];
        e &&
            (g(e) && (e = { mounted: e, updated: e }),
            e.deep && pn(a),
            i.push({ dir: e, instance: r, value: a, oldValue: void 0, arg: o, modifiers: c }));
    }
    return e;
}
function Vn(e, t, n, r) {
    const i = e.dirs,
        s = t && t.dirs;
    for (let a = 0; a < i.length; a++) {
        const o = i[a];
        s && (o.oldValue = s[a].value);
        let c = o.dir[r];
        c && (je(), yn(c, n, 8, [e.el, o, e, t]), He());
    }
}
const Wn = Symbol("_vte"),
    jn = (e) => e.__isTeleport,
    Hn = (e) => e && (e.disabled || "" === e.disabled),
    qn = (e) => e && (e.defer || "" === e.defer),
    Xn = (e) => "undefined" != typeof SVGElement && e instanceof SVGElement,
    Gn = (e) => "function" == typeof MathMLElement && e instanceof MathMLElement,
    Kn = (e, t) => {
        const n = e && e.to;
        if (b(n)) {
            if (t) {
                return t(n);
            }
            return null;
        }
        return n;
    },
    Yn = {
        name: "Teleport",
        __isTeleport: !0,
        process(e, t, n, r, i, s, a, o, c, l) {
            const {
                    mc: u,
                    pc: d,
                    pbc: h,
                    o: { insert: m, querySelector: p, createText: f, createComment: g },
                } = l,
                b = Hn(t.props);
            let { shapeFlag: y, children: w, dynamicChildren: k } = t;
            if (null == e) {
                const e = (t.el = f("")),
                    l = (t.anchor = f(""));
                m(e, n, r), m(l, n, r);
                const d = (e, t) => {
                        16 & y && (i && i.isCE && (i.ce._teleportTarget = e), u(w, e, t, i, s, a, o, c));
                    },
                    h = () => {
                        const e = (t.target = Kn(t.props, p)),
                            n = er(e, t, f, m);
                        e &&
                            ("svg" !== a && Xn(e) ? (a = "svg") : "mathml" !== a && Gn(e) && (a = "mathml"),
                            b || (d(e, n), Zn(t, !1)));
                    };
                b && (d(n, l), Zn(t, !0)),
                    qn(t.props)
                        ? ((t.el.__isMounted = !1),
                          Gi(() => {
                              h(), delete t.el.__isMounted;
                          }, s))
                        : h();
            } else {
                if (qn(t.props) && !1 === e.el.__isMounted)
                    return void Gi(() => {
                        Yn.process(e, t, n, r, i, s, a, o, c, l);
                    }, s);
                (t.el = e.el), (t.targetStart = e.targetStart);
                const u = (t.anchor = e.anchor),
                    m = (t.target = e.target),
                    f = (t.targetAnchor = e.targetAnchor),
                    g = Hn(e.props),
                    y = g ? n : m,
                    w = g ? u : f;
                if (
                    ("svg" === a || Xn(m) ? (a = "svg") : ("mathml" === a || Gn(m)) && (a = "mathml"),
                    k ? (h(e.dynamicChildren, k, y, i, s, a, o), ts(e, t, !0)) : c || d(e, t, y, w, i, s, a, o, !1),
                    b)
                )
                    g
                        ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to)
                        : Qn(t, n, u, l, 1);
                else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
                    const e = (t.target = Kn(t.props, p));
                    e && Qn(t, e, null, l, 0);
                } else g && Qn(t, m, f, l, 1);
                Zn(t, b);
            }
        },
        remove(e, t, n, { um: r, o: { remove: i } }, s) {
            const { shapeFlag: a, children: o, anchor: c, targetStart: l, targetAnchor: u, target: d, props: h } = e;
            if ((d && (i(l), i(u)), s && i(c), 16 & a)) {
                const e = s || !Hn(h);
                for (let i = 0; i < o.length; i++) {
                    const s = o[i];
                    r(s, t, n, e, !!s.dynamicChildren);
                }
            }
        },
        move: Qn,
        hydrate: function (
            e,
            t,
            n,
            r,
            i,
            s,
            { o: { nextSibling: a, parentNode: o, querySelector: c, insert: l, createText: u } },
            d
        ) {
            const h = (t.target = Kn(t.props, c));
            if (h) {
                const c = Hn(t.props),
                    m = h._lpa || h.firstChild;
                if (16 & t.shapeFlag)
                    if (c) (t.anchor = d(a(e), t, o(e), n, r, i, s)), (t.targetStart = m), (t.targetAnchor = m && a(m));
                    else {
                        t.anchor = a(e);
                        let o = m;
                        for (; o; ) {
                            if (o && 8 === o.nodeType)
                                if ("teleport start anchor" === o.data) t.targetStart = o;
                                else if ("teleport anchor" === o.data) {
                                    (t.targetAnchor = o), (h._lpa = t.targetAnchor && a(t.targetAnchor));
                                    break;
                                }
                            o = a(o);
                        }
                        t.targetAnchor || er(h, t, u, l), d(m && a(m), t, h, n, r, i, s);
                    }
                Zn(t, c);
            }
            return t.anchor && a(t.anchor);
        },
    };
function Qn(e, t, n, { o: { insert: r }, m: i }, s = 2) {
    0 === s && r(e.targetAnchor, t, n);
    const { el: a, anchor: o, shapeFlag: c, children: l, props: u } = e,
        d = 2 === s;
    if ((d && r(a, t, n), (!d || Hn(u)) && 16 & c)) for (let h = 0; h < l.length; h++) i(l[h], t, n, 2);
    d && r(o, t, n);
}
const Jn = Yn;
function Zn(e, t) {
    const n = e.ctx;
    if (n && n.ut) {
        let r, i;
        for (t ? ((r = e.el), (i = e.anchor)) : ((r = e.targetStart), (i = e.targetAnchor)); r && r !== i; )
            1 === r.nodeType && r.setAttribute("data-v-owner", n.uid), (r = r.nextSibling);
        n.ut();
    }
}
function er(e, t, n, r) {
    const i = (t.targetStart = n("")),
        s = (t.targetAnchor = n(""));
    return (i[Wn] = s), e && (r(i, e), r(s, e)), s;
}
const tr = Symbol("_leaveCb"),
    nr = Symbol("_enterCb");
function rr() {
    const e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map() };
    return (
        Vr(() => {
            e.isMounted = !0;
        }),
        Hr(() => {
            e.isUnmounting = !0;
        }),
        e
    );
}
const ir = [Function, Array],
    sr = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: ir,
        onEnter: ir,
        onAfterEnter: ir,
        onEnterCancelled: ir,
        onBeforeLeave: ir,
        onLeave: ir,
        onAfterLeave: ir,
        onLeaveCancelled: ir,
        onBeforeAppear: ir,
        onAppear: ir,
        onAfterAppear: ir,
        onAppearCancelled: ir,
    },
    ar = (e) => {
        const t = e.subTree;
        return t.component ? ar(t.component) : t;
    };
function or(e) {
    let t = e[0];
    if (e.length > 1)
        for (const n of e)
            if (n.type !== Ps) {
                t = n;
                break;
            }
    return t;
}
const cr = {
    name: "BaseTransition",
    props: sr,
    setup(e, { slots: t }) {
        const n = aa(),
            r = rr();
        return () => {
            const i = t.default && pr(t.default(), !0);
            if (!i || !i.length) return;
            const s = or(i),
                a = jt(e),
                { mode: o } = a;
            if (r.isLeaving) return dr(s);
            const c = hr(s);
            if (!c) return dr(s);
            let l = ur(c, a, r, n, (e) => (l = e));
            c.type !== Ps && mr(c, l);
            let u = n.subTree && hr(n.subTree);
            if (u && u.type !== Ps && !Vs(c, u) && ar(n).type !== Ps) {
                let e = ur(u, a, r, n);
                if ((mr(u, e), "out-in" === o && c.type !== Ps))
                    return (
                        (r.isLeaving = !0),
                        (e.afterLeave = () => {
                            (r.isLeaving = !1), 8 & n.job.flags || n.update(), delete e.afterLeave, (u = void 0);
                        }),
                        dr(s)
                    );
                "in-out" === o && c.type !== Ps
                    ? (e.delayLeave = (e, t, n) => {
                          (lr(r, u)[String(u.key)] = u),
                              (e[tr] = () => {
                                  t(), (e[tr] = void 0), delete l.delayedLeave, (u = void 0);
                              }),
                              (l.delayedLeave = () => {
                                  n(), delete l.delayedLeave, (u = void 0);
                              });
                      })
                    : (u = void 0);
            } else u && (u = void 0);
            return s;
        };
    },
};
function lr(e, t) {
    const { leavingVNodes: n } = e;
    let r = n.get(t.type);
    return r || ((r = Object.create(null)), n.set(t.type, r)), r;
}
function ur(e, t, n, r, i) {
    const {
            appear: s,
            mode: a,
            persisted: o = !1,
            onBeforeEnter: c,
            onEnter: l,
            onAfterEnter: u,
            onEnterCancelled: h,
            onBeforeLeave: m,
            onLeave: p,
            onAfterLeave: f,
            onLeaveCancelled: g,
            onBeforeAppear: b,
            onAppear: y,
            onAfterAppear: w,
            onAppearCancelled: k,
        } = t,
        T = String(e.key),
        _ = lr(n, e),
        v = (e, t) => {
            e && yn(e, r, 9, t);
        },
        S = (e, t) => {
            const n = t[1];
            v(e, t), d(e) ? e.every((e) => e.length <= 1) && n() : e.length <= 1 && n();
        },
        E = {
            mode: a,
            persisted: o,
            beforeEnter(t) {
                let r = c;
                if (!n.isMounted) {
                    if (!s) return;
                    r = b || c;
                }
                t[tr] && t[tr](!0);
                const i = _[T];
                i && Vs(e, i) && i.el[tr] && i.el[tr](), v(r, [t]);
            },
            enter(e) {
                let t = l,
                    r = u,
                    i = h;
                if (!n.isMounted) {
                    if (!s) return;
                    (t = y || l), (r = w || u), (i = k || h);
                }
                let a = !1;
                const o = (e[nr] = (t) => {
                    a || ((a = !0), v(t ? i : r, [e]), E.delayedLeave && E.delayedLeave(), (e[nr] = void 0));
                });
                t ? S(t, [e, o]) : o();
            },
            leave(t, r) {
                const i = String(e.key);
                if ((t[nr] && t[nr](!0), n.isUnmounting)) return r();
                v(m, [t]);
                let s = !1;
                const a = (t[tr] = (n) => {
                    s || ((s = !0), r(), v(n ? g : f, [t]), (t[tr] = void 0), _[i] === e && delete _[i]);
                });
                (_[i] = e), p ? S(p, [t, a]) : a();
            },
            clone(e) {
                const s = ur(e, t, n, r, i);
                return i && i(s), s;
            },
        };
    return E;
}
function dr(e) {
    if (Pr(e)) return ((e = Gs(e)).children = null), e;
}
function hr(e) {
    if (!Pr(e)) return jn(e.type) && e.children ? or(e.children) : e;
    if (e.component) return e.component.subTree;
    const { shapeFlag: t, children: n } = e;
    if (n) {
        if (16 & t) return n[0];
        if (32 & t && g(n.default)) return n.default();
    }
}
function mr(e, t) {
    6 & e.shapeFlag && e.component
        ? ((e.transition = t), mr(e.component.subTree, t))
        : 128 & e.shapeFlag
          ? ((e.ssContent.transition = t.clone(e.ssContent)), (e.ssFallback.transition = t.clone(e.ssFallback)))
          : (e.transition = t);
}
function pr(e, t = !1, n) {
    let r = [],
        i = 0;
    for (let s = 0; s < e.length; s++) {
        let a = e[s];
        const o = null == n ? a.key : String(n) + String(null != a.key ? a.key : s);
        a.type === xs
            ? (128 & a.patchFlag && i++, (r = r.concat(pr(a.children, t, o))))
            : (t || a.type !== Ps) && r.push(null != o ? Gs(a, { key: o }) : a);
    }
    if (i > 1) for (let s = 0; s < r.length; s++) r[s].patchFlag = -2;
    return r;
}
function fr(e, t) {
    return g(e) ? (() => o({ name: e.name }, t, { setup: e }))() : e;
}
function gr(e) {
    e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0];
}
function br(e, n, r, i, s = !1) {
    if (d(e)) return void e.forEach((e, t) => br(e, n && (d(n) ? n[t] : n), r, i, s));
    if (xr(i) && !s)
        return void (
            512 & i.shapeFlag &&
            i.type.__asyncResolved &&
            i.component.subTree.component &&
            br(e, n, r, i.component.subTree)
        );
    const a = 4 & i.shapeFlag ? ka(i.component) : i.el,
        o = s ? null : a,
        { i: l, r: h } = e,
        m = n && n.r,
        p = l.refs === t ? (l.refs = {}) : l.refs,
        f = l.setupState,
        y = jt(f),
        w = f === t ? () => !1 : (e) => u(y, e);
    if ((null != m && m !== h && (b(m) ? ((p[m] = null), w(m) && (f[m] = null)) : Gt(m) && (m.value = null)), g(h)))
        bn(h, l, 12, [o, p]);
    else {
        const t = b(h),
            n = Gt(h);
        if (t || n) {
            const i = () => {
                if (e.f) {
                    const n = t ? (w(h) ? f[h] : p[h]) : h.value;
                    s
                        ? d(n) && c(n, a)
                        : d(n)
                          ? n.includes(a) || n.push(a)
                          : t
                            ? ((p[h] = [a]), w(h) && (f[h] = p[h]))
                            : ((h.value = [a]), e.k && (p[e.k] = h.value));
                } else t ? ((p[h] = o), w(h) && (f[h] = o)) : n && ((h.value = o), e.k && (p[e.k] = o));
            };
            o ? ((i.id = -1), Gi(i, r)) : i();
        }
    }
}
let yr = !1;
const wr = () => {
        yr || (yr = !0);
    },
    kr = (e) => {
        if (1 === e.nodeType)
            return ((e) => e.namespaceURI.includes("svg") && "foreignObject" !== e.tagName)(e)
                ? "svg"
                : ((e) => e.namespaceURI.includes("MathML"))(e)
                  ? "mathml"
                  : void 0;
    },
    Tr = (e) => 8 === e.nodeType;
function _r(e) {
    const {
            mt: t,
            p: n,
            o: { patchProp: r, createText: i, nextSibling: a, parentNode: o, remove: c, insert: l, createComment: u },
        } = e,
        d = (n, r, s, c, u, w = !1) => {
            w = w || !!r.dynamicChildren;
            const k = Tr(n) && "[" === n.data,
                T = () => f(n, r, s, c, u, k),
                { type: _, ref: v, shapeFlag: S, patchFlag: E } = r;
            let C = n.nodeType;
            (r.el = n), -2 === E && ((w = !1), (r.dynamicChildren = null));
            let I = null;
            switch (_) {
                case As:
                    3 !== C
                        ? "" === r.children
                            ? (l((r.el = i("")), o(n), n), (I = n))
                            : (I = T())
                        : (n.data !== r.children && (wr(), (n.data = r.children)), (I = a(n)));
                    break;
                case Ps:
                    y(n) ? ((I = a(n)), b((r.el = n.content.firstChild), n, s)) : (I = 8 !== C || k ? T() : a(n));
                    break;
                case Os:
                    if ((k && (C = (n = a(n)).nodeType), 1 === C || 3 === C)) {
                        I = n;
                        const e = !r.children.length;
                        for (let t = 0; t < r.staticCount; t++)
                            e && (r.children += 1 === I.nodeType ? I.outerHTML : I.data),
                                t === r.staticCount - 1 && (r.anchor = I),
                                (I = a(I));
                        return k ? a(I) : I;
                    }
                    T();
                    break;
                case xs:
                    I = k ? p(n, r, s, c, u, w) : T();
                    break;
                default:
                    if (1 & S)
                        I =
                            (1 === C && r.type.toLowerCase() === n.tagName.toLowerCase()) || y(n)
                                ? h(n, r, s, c, u, w)
                                : T();
                    else if (6 & S) {
                        r.slotScopeIds = u;
                        const e = o(n);
                        if (
                            ((I = k
                                ? g(n)
                                : Tr(n) && "teleport start" === n.data
                                  ? g(n, n.data, "teleport end")
                                  : a(n)),
                            t(r, e, null, s, c, kr(e), w),
                            xr(r) && !r.type.__asyncResolved)
                        ) {
                            let t;
                            k
                                ? ((t = qs(xs)), (t.anchor = I ? I.previousSibling : e.lastChild))
                                : (t = 3 === n.nodeType ? Ks("") : qs("div")),
                                (t.el = n),
                                (r.component.subTree = t);
                        }
                    } else
                        64 & S
                            ? (I = 8 !== C ? T() : r.type.hydrate(n, r, s, c, u, w, e, m))
                            : 128 & S && (I = r.type.hydrate(n, r, s, c, kr(o(n)), u, w, e, d));
            }
            return null != v && br(v, null, c, r), I;
        },
        h = (e, t, n, i, a, o) => {
            o = o || !!t.dynamicChildren;
            const { type: l, props: u, patchFlag: d, shapeFlag: h, dirs: p, transition: f } = t,
                g = "input" === l || "option" === l;
            if (g || -1 !== d) {
                p && Vn(t, null, n, "created");
                let l,
                    w = !1;
                if (y(e)) {
                    w = es(null, f) && n && n.vnode.props && n.vnode.props.appear;
                    const r = e.content.firstChild;
                    if (w) {
                        const e = r.getAttribute("class");
                        e && (r.$cls = e), f.beforeEnter(r);
                    }
                    b(r, e, n), (t.el = e = r);
                }
                if (16 & h && (!u || (!u.innerHTML && !u.textContent))) {
                    let r = m(e.firstChild, t, e, n, i, a, o);
                    for (; r; ) {
                        Er(e, 1) || wr();
                        const t = r;
                        (r = r.nextSibling), c(t);
                    }
                } else if (8 & h) {
                    let n = t.children;
                    "\n" !== n[0] || ("PRE" !== e.tagName && "TEXTAREA" !== e.tagName) || (n = n.slice(1)),
                        e.textContent !== n && (Er(e, 0) || wr(), (e.textContent = t.children));
                }
                if (u)
                    if (g || !o || 48 & d) {
                        const t = e.tagName.includes("-");
                        for (const i in u)
                            ((g && (i.endsWith("value") || "indeterminate" === i)) ||
                                (s(i) && !C(i)) ||
                                "." === i[0] ||
                                t) &&
                                r(e, i, null, u[i], void 0, n);
                    } else if (u.onClick) r(e, "onClick", null, u.onClick, void 0, n);
                    else if (4 & d && Ut(u.style)) for (const e in u.style) u.style[e];
                (l = u && u.onVnodeBeforeMount) && ta(l, n, t),
                    p && Vn(t, null, n, "beforeMount"),
                    ((l = u && u.onVnodeMounted) || p || w) &&
                        Cs(() => {
                            l && ta(l, n, t), w && f.enter(e), p && Vn(t, null, n, "mounted");
                        }, i);
            }
            return e.nextSibling;
        },
        m = (e, t, r, s, o, c, u) => {
            u = u || !!t.dynamicChildren;
            const h = t.children,
                m = h.length;
            for (let p = 0; p < m; p++) {
                const t = u ? h[p] : (h[p] = Qs(h[p])),
                    f = t.type === As;
                e
                    ? (f &&
                          !u &&
                          p + 1 < m &&
                          Qs(h[p + 1]).type === As &&
                          (l(i(e.data.slice(t.children.length)), r, a(e)), (e.data = t.children)),
                      (e = d(e, t, s, o, c, u)))
                    : f && !t.children
                      ? l((t.el = i("")), r)
                      : (Er(r, 1) || wr(), n(null, t, r, null, s, o, kr(r), c));
            }
            return e;
        },
        p = (e, t, n, r, i, s) => {
            const { slotScopeIds: c } = t;
            c && (i = i ? i.concat(c) : c);
            const d = o(e),
                h = m(a(e), t, d, n, r, i, s);
            return h && Tr(h) && "]" === h.data ? a((t.anchor = h)) : (wr(), l((t.anchor = u("]")), d, h), h);
        },
        f = (e, t, r, i, s, l) => {
            if ((Er(e.parentElement, 1) || wr(), (t.el = null), l)) {
                const t = g(e);
                for (;;) {
                    const n = a(e);
                    if (!n || n === t) break;
                    c(n);
                }
            }
            const u = a(e),
                d = o(e);
            return c(e), n(null, t, d, u, r, i, kr(d), s), r && ((r.vnode.el = t.el), ws(r, t.el)), u;
        },
        g = (e, t = "[", n = "]") => {
            let r = 0;
            for (; e; )
                if ((e = a(e)) && Tr(e) && (e.data === t && r++, e.data === n)) {
                    if (0 === r) return a(e);
                    r--;
                }
            return e;
        },
        b = (e, t, n) => {
            const r = t.parentNode;
            r && r.replaceChild(e, t);
            let i = n;
            for (; i; ) i.vnode.el === t && (i.vnode.el = i.subTree.el = e), (i = i.parent);
        },
        y = (e) => 1 === e.nodeType && "TEMPLATE" === e.tagName;
    return [
        (e, t) => {
            if (!t.hasChildNodes()) return n(null, e, t), Nn(), void (t._vnode = e);
            d(t.firstChild, e, null, null, null), Nn(), (t._vnode = e);
        },
        d,
    ];
}
const vr = "data-allow-mismatch",
    Sr = { 0: "text", 1: "children", 2: "class", 3: "style", 4: "attribute" };
function Er(e, t) {
    if (0 === t || 1 === t) for (; e && !e.hasAttribute(vr); ) e = e.parentElement;
    const n = e && e.getAttribute(vr);
    if (null == n) return !1;
    if ("" === n) return !0;
    {
        const e = n.split(",");
        return !(0 !== t || !e.includes("children")) || e.includes(Sr[t]);
    }
}
const Cr = $().requestIdleCallback || ((e) => setTimeout(e, 1)),
    Ir = $().cancelIdleCallback || ((e) => clearTimeout(e));
const xr = (e) => !!e.type.__asyncLoader;
function Ar(e, t) {
    const { ref: n, props: r, children: i, ce: s } = t.vnode,
        a = qs(e, r, i);
    return (a.ref = n), (a.ce = s), delete t.vnode.ce, a;
}
const Pr = (e) => e.type.__isKeepAlive,
    Or = {
        name: "KeepAlive",
        __isKeepAlive: !0,
        props: { include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] },
        setup(e, { slots: t }) {
            const n = aa(),
                r = n.ctx;
            if (!r.renderer)
                return () => {
                    const e = t.default && t.default();
                    return e && 1 === e.length ? e[0] : e;
                };
            const i = new Map(),
                s = new Set();
            let a = null;
            const o = n.suspense,
                {
                    renderer: {
                        p: c,
                        m: l,
                        um: u,
                        o: { createElement: d },
                    },
                } = r,
                h = d("div");
            function m(e) {
                Lr(e), u(e, n, o, !0);
            }
            function p(e) {
                i.forEach((t, n) => {
                    const r = Ta(t.type);
                    r && !e(r) && f(n);
                });
            }
            function f(e) {
                const t = i.get(e);
                !t || (a && Vs(t, a)) ? a && Lr(a) : m(t), i.delete(e), s.delete(e);
            }
            (r.activate = (e, t, n, r, i) => {
                const s = e.component;
                l(e, t, n, 0, o),
                    c(s.vnode, e, t, n, s, o, r, e.slotScopeIds, i),
                    Gi(() => {
                        (s.isDeactivated = !1), s.a && F(s.a);
                        const t = e.props && e.props.onVnodeMounted;
                        t && ta(t, s.parent, e);
                    }, o);
            }),
                (r.deactivate = (e) => {
                    const t = e.component;
                    rs(t.m),
                        rs(t.a),
                        l(e, h, null, 1, o),
                        Gi(() => {
                            t.da && F(t.da);
                            const n = e.props && e.props.onVnodeUnmounted;
                            n && ta(n, t.parent, e), (t.isDeactivated = !0);
                        }, o);
                }),
                os(
                    () => [e.include, e.exclude],
                    ([e, t]) => {
                        e && p((t) => Nr(e, t)), t && p((e) => !Nr(t, e));
                    },
                    { flush: "post", deep: !0 }
                );
            let g = null;
            const b = () => {
                null != g &&
                    (ks(n.subTree.type)
                        ? Gi(() => {
                              i.set(g, Br(n.subTree));
                          }, n.subTree.suspense)
                        : i.set(g, Br(n.subTree)));
            };
            return (
                Vr(b),
                jr(b),
                Hr(() => {
                    i.forEach((e) => {
                        const { subTree: t, suspense: r } = n,
                            i = Br(t);
                        if (e.type === i.type && e.key === i.key) {
                            Lr(i);
                            const e = i.component.da;
                            return void (e && Gi(e, r));
                        }
                        m(e);
                    });
                }),
                () => {
                    if (((g = null), !t.default)) return (a = null);
                    const n = t.default(),
                        r = n[0];
                    if (n.length > 1) return (a = null), n;
                    if (!($s(r) && (4 & r.shapeFlag || 128 & r.shapeFlag))) return (a = null), r;
                    let o = Br(r);
                    if (o.type === Ps) return (a = null), o;
                    const c = o.type,
                        l = Ta(xr(o) ? o.type.__asyncResolved || {} : c),
                        { include: u, exclude: d, max: h } = e;
                    if ((u && (!l || !Nr(u, l))) || (d && l && Nr(d, l))) return (o.shapeFlag &= -257), (a = o), r;
                    const m = null == o.key ? c : o.key,
                        p = i.get(m);
                    return (
                        o.el && ((o = Gs(o)), 128 & r.shapeFlag && (r.ssContent = o)),
                        (g = m),
                        p
                            ? ((o.el = p.el),
                              (o.component = p.component),
                              o.transition && mr(o, o.transition),
                              (o.shapeFlag |= 512),
                              s.delete(m),
                              s.add(m))
                            : (s.add(m), h && s.size > parseInt(h, 10) && f(s.values().next().value)),
                        (o.shapeFlag |= 256),
                        (a = o),
                        ks(r.type) ? r : o
                    );
                }
            );
        },
    };
function Nr(e, t) {
    return d(e) ? e.some((e) => Nr(e, t)) : b(e) ? e.split(",").includes(t) : !!f(e) && ((e.lastIndex = 0), e.test(t));
}
function Rr(e, t) {
    Dr(e, "a", t);
}
function Mr(e, t) {
    Dr(e, "da", t);
}
function Dr(e, t, n = sa) {
    const r =
        e.__wdc ||
        (e.__wdc = () => {
            let t = n;
            for (; t; ) {
                if (t.isDeactivated) return;
                t = t.parent;
            }
            return e();
        });
    if ((zr(t, r, n), n)) {
        let e = n.parent;
        for (; e && e.parent; ) Pr(e.parent.vnode) && Fr(r, t, n, e), (e = e.parent);
    }
}
function Fr(e, t, n, r) {
    const i = zr(t, e, r, !0);
    qr(() => {
        c(r[t], i);
    }, n);
}
function Lr(e) {
    (e.shapeFlag &= -257), (e.shapeFlag &= -513);
}
function Br(e) {
    return 128 & e.shapeFlag ? e.ssContent : e;
}
function zr(e, t, n = sa, r = !1) {
    if (n) {
        const i = n[e] || (n[e] = []),
            s =
                t.__weh ||
                (t.__weh = (...r) => {
                    je();
                    const i = la(n),
                        s = yn(t, n, e, r);
                    return i(), He(), s;
                });
        return r ? i.unshift(s) : i.push(s), s;
    }
}
const Ur =
        (e) =>
        (t, n = sa) => {
            (pa && "sp" !== e) || zr(e, (...e) => t(...e), n);
        },
    $r = Ur("bm"),
    Vr = Ur("m"),
    Wr = Ur("bu"),
    jr = Ur("u"),
    Hr = Ur("bum"),
    qr = Ur("um"),
    Xr = Ur("sp"),
    Gr = Ur("rtg"),
    Kr = Ur("rtc");
function Yr(e, t = sa) {
    zr("ec", e, t);
}
const Qr = "components";
function Jr(e, t) {
    return ni(Qr, e, !0, t) || e;
}
const Zr = Symbol.for("v-ndc");
function ei(e) {
    return b(e) ? ni(Qr, e, !1) || e : e || Zr;
}
function ti(e) {
    return ni("directives", e);
}
function ni(e, t, n = !0, r = !1) {
    const i = Ln || sa;
    if (i) {
        const n = i.type;
        if (e === Qr) {
            const e = Ta(n, !1);
            if (e && (e === t || e === P(t) || e === R(P(t)))) return n;
        }
        const s = ri(i[e] || n[e], t) || ri(i.appContext[e], t);
        return !s && r ? n : s;
    }
}
function ri(e, t) {
    return e && (e[t] || e[P(t)] || e[R(P(t))]);
}
function ii(e, t, n, r) {
    let i;
    const s = n && n[r],
        a = d(e);
    if (a || b(e)) {
        let n = !1,
            r = !1;
        a && Ut(e) && ((n = !Vt(e)), (r = $t(e)), (e = it(e))), (i = new Array(e.length));
        for (let a = 0, o = e.length; a < o; a++)
            i[a] = t(n ? (r ? Xt(qt(e[a])) : qt(e[a])) : e[a], a, void 0, s && s[a]);
    } else if ("number" == typeof e) {
        i = new Array(e);
        for (let n = 0; n < e; n++) i[n] = t(n + 1, n, void 0, s && s[n]);
    } else if (w(e))
        if (e[Symbol.iterator]) i = Array.from(e, (e, n) => t(e, n, void 0, s && s[n]));
        else {
            const n = Object.keys(e);
            i = new Array(n.length);
            for (let r = 0, a = n.length; r < a; r++) {
                const a = n[r];
                i[r] = t(e[a], a, r, s && s[r]);
            }
        }
    else i = [];
    return n && (n[r] = i), i;
}
function si(e, t) {
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        if (d(r)) for (let t = 0; t < r.length; t++) e[r[t].name] = r[t].fn;
        else
            r &&
                (e[r.name] = r.key
                    ? (...e) => {
                          const t = r.fn(...e);
                          return t && (t.key = r.key), t;
                      }
                    : r.fn);
    }
    return e;
}
function ai(e, t, n = {}, r, i) {
    if (Ln.ce || (Ln.parent && xr(Ln.parent) && Ln.parent.ce))
        return "default" !== t && (n.name = t), Ms(), Us(xs, null, [qs("slot", n, r && r())], 64);
    let s = e[t];
    s && s._c && (s._d = !1), Ms();
    const a = s && oi(s(n)),
        o = n.key || (a && a.key),
        c = Us(
            xs,
            { key: (o && !y(o) ? o : `_${t}`) + (!a && r ? "_fb" : "") },
            a || (r ? r() : []),
            a && 1 === e._ ? 64 : -2
        );
    return !i && c.scopeId && (c.slotScopeIds = [c.scopeId + "-s"]), s && s._c && (s._d = !0), c;
}
function oi(e) {
    return e.some((e) => !$s(e) || (e.type !== Ps && !(e.type === xs && !oi(e.children)))) ? e : null;
}
function ci(e, t) {
    const n = {};
    for (const r in e) n[t && /[A-Z]/.test(r) ? `on:${r}` : M(r)] = e[r];
    return n;
}
const li = (e) => (e ? (da(e) ? ka(e) : li(e.parent)) : null),
    ui = o(Object.create(null), {
        $: (e) => e,
        $el: (e) => e.vnode.el,
        $data: (e) => e.data,
        $props: (e) => e.props,
        $attrs: (e) => e.attrs,
        $slots: (e) => e.slots,
        $refs: (e) => e.refs,
        $parent: (e) => li(e.parent),
        $root: (e) => li(e.root),
        $host: (e) => e.ce,
        $emit: (e) => e.emit,
        $options: (e) => ki(e),
        $forceUpdate: (e) =>
            e.f ||
            (e.f = () => {
                xn(e.update);
            }),
        $nextTick: (e) => e.n || (e.n = In.bind(e.proxy)),
        $watch: (e) => ls.bind(e),
    }),
    di = (e, n) => e !== t && !e.__isScriptSetup && u(e, n),
    hi = {
        get({ _: e }, n) {
            if ("__v_skip" === n) return !0;
            const { ctx: r, setupState: i, data: s, props: a, accessCache: o, type: c, appContext: l } = e;
            let d;
            if ("$" !== n[0]) {
                const c = o[n];
                if (void 0 !== c)
                    switch (c) {
                        case 1:
                            return i[n];
                        case 2:
                            return s[n];
                        case 4:
                            return r[n];
                        case 3:
                            return a[n];
                    }
                else {
                    if (di(i, n)) return (o[n] = 1), i[n];
                    if (s !== t && u(s, n)) return (o[n] = 2), s[n];
                    if ((d = e.propsOptions[0]) && u(d, n)) return (o[n] = 3), a[n];
                    if (r !== t && u(r, n)) return (o[n] = 4), r[n];
                    gi && (o[n] = 0);
                }
            }
            const h = ui[n];
            let m, p;
            return h
                ? ("$attrs" === n && tt(e.attrs, 0, ""), h(e))
                : (m = c.__cssModules) && (m = m[n])
                  ? m
                  : r !== t && u(r, n)
                    ? ((o[n] = 4), r[n])
                    : ((p = l.config.globalProperties), u(p, n) ? p[n] : void 0);
        },
        set({ _: e }, n, r) {
            const { data: i, setupState: s, ctx: a } = e;
            return di(s, n)
                ? ((s[n] = r), !0)
                : i !== t && u(i, n)
                  ? ((i[n] = r), !0)
                  : !u(e.props, n) && ("$" !== n[0] || !(n.slice(1) in e)) && ((a[n] = r), !0);
        },
        has({ _: { data: e, setupState: n, accessCache: r, ctx: i, appContext: s, propsOptions: a } }, o) {
            let c;
            return (
                !!r[o] ||
                (e !== t && u(e, o)) ||
                di(n, o) ||
                ((c = a[0]) && u(c, o)) ||
                u(i, o) ||
                u(ui, o) ||
                u(s.config.globalProperties, o)
            );
        },
        defineProperty(e, t, n) {
            return (
                null != n.get ? (e._.accessCache[t] = 0) : u(n, "value") && this.set(e, t, n.value, null),
                Reflect.defineProperty(e, t, n)
            );
        },
    },
    mi = o({}, hi, {
        get(e, t) {
            if (t !== Symbol.unscopables) return hi.get(e, t, e);
        },
        has: (e, t) => "_" !== t[0] && !H(t),
    });
function pi() {
    const e = aa();
    return e.setupContext || (e.setupContext = wa(e));
}
function fi(e) {
    return d(e) ? e.reduce((e, t) => ((e[t] = null), e), {}) : e;
}
let gi = !0;
function bi(e) {
    const t = ki(e),
        n = e.proxy,
        i = e.ctx;
    (gi = !1), t.beforeCreate && yi(t.beforeCreate, e, "bc");
    const {
        data: s,
        computed: a,
        methods: o,
        watch: c,
        provide: l,
        inject: u,
        created: h,
        beforeMount: m,
        mounted: p,
        beforeUpdate: f,
        updated: b,
        activated: y,
        deactivated: k,
        beforeDestroy: T,
        beforeUnmount: _,
        destroyed: v,
        unmounted: S,
        render: E,
        renderTracked: C,
        renderTriggered: I,
        errorCaptured: x,
        serverPrefetch: A,
        expose: P,
        inheritAttrs: O,
        components: N,
        directives: R,
        filters: M,
    } = t;
    if (
        (u &&
            (function (e, t) {
                d(e) && (e = Si(e));
                for (const n in e) {
                    const r = e[n];
                    let i;
                    (i = w(r) ? ("default" in r ? Ri(r.from || n, r.default, !0) : Ri(r.from || n)) : Ri(r)),
                        Gt(i)
                            ? Object.defineProperty(t, n, {
                                  enumerable: !0,
                                  configurable: !0,
                                  get: () => i.value,
                                  set: (e) => (i.value = e),
                              })
                            : (t[n] = i);
                }
            })(u, i, null),
        o)
    )
        for (const r in o) {
            const e = o[r];
            g(e) && (i[r] = e.bind(n));
        }
    if (s) {
        const t = s.call(n, n);
        w(t) && (e.data = Dt(t));
    }
    if (((gi = !0), a))
        for (const d in a) {
            const e = a[d],
                t = g(e) ? e.bind(n, n) : g(e.get) ? e.get.bind(n, n) : r,
                s = !g(e) && g(e.set) ? e.set.bind(n) : r,
                o = _a({ get: t, set: s });
            Object.defineProperty(i, d, {
                enumerable: !0,
                configurable: !0,
                get: () => o.value,
                set: (e) => (o.value = e),
            });
        }
    if (c) for (const r in c) wi(c[r], i, n, r);
    if (l) {
        const e = g(l) ? l.call(n) : l;
        Reflect.ownKeys(e).forEach((t) => {
            Ni(t, e[t]);
        });
    }
    function D(e, t) {
        d(t) ? t.forEach((t) => e(t.bind(n))) : t && e(t.bind(n));
    }
    if (
        (h && yi(h, e, "c"),
        D($r, m),
        D(Vr, p),
        D(Wr, f),
        D(jr, b),
        D(Rr, y),
        D(Mr, k),
        D(Yr, x),
        D(Kr, C),
        D(Gr, I),
        D(Hr, _),
        D(qr, S),
        D(Xr, A),
        d(P))
    )
        if (P.length) {
            const t = e.exposed || (e.exposed = {});
            P.forEach((e) => {
                Object.defineProperty(t, e, { get: () => n[e], set: (t) => (n[e] = t) });
            });
        } else e.exposed || (e.exposed = {});
    E && e.render === r && (e.render = E),
        null != O && (e.inheritAttrs = O),
        N && (e.components = N),
        R && (e.directives = R),
        A && gr(e);
}
function yi(e, t, n) {
    yn(d(e) ? e.map((e) => e.bind(t.proxy)) : e.bind(t.proxy), t, n);
}
function wi(e, t, n, r) {
    let i = r.includes(".") ? us(n, r) : () => n[r];
    if (b(e)) {
        const n = t[e];
        g(n) && os(i, n);
    } else if (g(e)) os(i, e.bind(n));
    else if (w(e))
        if (d(e)) e.forEach((e) => wi(e, t, n, r));
        else {
            const r = g(e.handler) ? e.handler.bind(n) : t[e.handler];
            g(r) && os(i, r, e);
        }
}
function ki(e) {
    const t = e.type,
        { mixins: n, extends: r } = t,
        {
            mixins: i,
            optionsCache: s,
            config: { optionMergeStrategies: a },
        } = e.appContext,
        o = s.get(t);
    let c;
    return (
        o
            ? (c = o)
            : i.length || n || r
              ? ((c = {}), i.length && i.forEach((e) => Ti(c, e, a, !0)), Ti(c, t, a))
              : (c = t),
        w(t) && s.set(t, c),
        c
    );
}
function Ti(e, t, n, r = !1) {
    const { mixins: i, extends: s } = t;
    s && Ti(e, s, n, !0), i && i.forEach((t) => Ti(e, t, n, !0));
    for (const a in t)
        if (r && "expose" === a);
        else {
            const r = _i[a] || (n && n[a]);
            e[a] = r ? r(e[a], t[a]) : t[a];
        }
    return e;
}
const _i = {
    data: vi,
    props: Ii,
    emits: Ii,
    methods: Ci,
    computed: Ci,
    beforeCreate: Ei,
    created: Ei,
    beforeMount: Ei,
    mounted: Ei,
    beforeUpdate: Ei,
    updated: Ei,
    beforeDestroy: Ei,
    beforeUnmount: Ei,
    destroyed: Ei,
    unmounted: Ei,
    activated: Ei,
    deactivated: Ei,
    errorCaptured: Ei,
    serverPrefetch: Ei,
    components: Ci,
    directives: Ci,
    watch: function (e, t) {
        if (!e) return t;
        if (!t) return e;
        const n = o(Object.create(null), e);
        for (const r in t) n[r] = Ei(e[r], t[r]);
        return n;
    },
    provide: vi,
    inject: function (e, t) {
        return Ci(Si(e), Si(t));
    },
};
function vi(e, t) {
    return t
        ? e
            ? function () {
                  return o(g(e) ? e.call(this, this) : e, g(t) ? t.call(this, this) : t);
              }
            : t
        : e;
}
function Si(e) {
    if (d(e)) {
        const t = {};
        for (let n = 0; n < e.length; n++) t[e[n]] = e[n];
        return t;
    }
    return e;
}
function Ei(e, t) {
    return e ? [...new Set([].concat(e, t))] : t;
}
function Ci(e, t) {
    return e ? o(Object.create(null), e, t) : t;
}
function Ii(e, t) {
    return e ? (d(e) && d(t) ? [...new Set([...e, ...t])] : o(Object.create(null), fi(e), fi(null != t ? t : {}))) : t;
}
function xi() {
    return {
        app: null,
        config: {
            isNativeTag: i,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {},
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap(),
    };
}
let Ai = 0;
function Pi(e, t) {
    return function (n, r = null) {
        g(n) || (n = o({}, n)), null == r || w(r) || (r = null);
        const i = xi(),
            s = new WeakSet(),
            a = [];
        let c = !1;
        const l = (i.app = {
            _uid: Ai++,
            _component: n,
            _props: r,
            _container: null,
            _context: i,
            _instance: null,
            version: Ea,
            get config() {
                return i.config;
            },
            set config(e) {},
            use: (e, ...t) => (
                s.has(e) || (e && g(e.install) ? (s.add(e), e.install(l, ...t)) : g(e) && (s.add(e), e(l, ...t))), l
            ),
            mixin: (e) => (i.mixins.includes(e) || i.mixins.push(e), l),
            component: (e, t) => (t ? ((i.components[e] = t), l) : i.components[e]),
            directive: (e, t) => (t ? ((i.directives[e] = t), l) : i.directives[e]),
            mount(s, a, o) {
                if (!c) {
                    const u = l._ceVNode || qs(n, r);
                    return (
                        (u.appContext = i),
                        !0 === o ? (o = "svg") : !1 === o && (o = void 0),
                        a && t ? t(u, s) : e(u, s, o),
                        (c = !0),
                        (l._container = s),
                        (s.__vue_app__ = l),
                        ka(u.component)
                    );
                }
            },
            onUnmount(e) {
                a.push(e);
            },
            unmount() {
                c && (yn(a, l._instance, 16), e(null, l._container), delete l._container.__vue_app__);
            },
            provide: (e, t) => ((i.provides[e] = t), l),
            runWithContext(e) {
                const t = Oi;
                Oi = l;
                try {
                    return e();
                } finally {
                    Oi = t;
                }
            },
        });
        return l;
    };
}
let Oi = null;
function Ni(e, t) {
    if (sa) {
        let n = sa.provides;
        const r = sa.parent && sa.parent.provides;
        r === n && (n = sa.provides = Object.create(r)), (n[e] = t);
    } else;
}
function Ri(e, t, n = !1) {
    const r = sa || Ln;
    if (r || Oi) {
        let i = Oi
            ? Oi._context.provides
            : r
              ? null == r.parent || r.ce
                  ? r.vnode.appContext && r.vnode.appContext.provides
                  : r.parent.provides
              : void 0;
        if (i && e in i) return i[e];
        if (arguments.length > 1) return n && g(t) ? t.call(r && r.proxy) : t;
    }
}
const Mi = {},
    Di = () => Object.create(Mi),
    Fi = (e) => Object.getPrototypeOf(e) === Mi;
function Li(e, n, r, i) {
    const [s, a] = e.propsOptions;
    let o,
        c = !1;
    if (n)
        for (let t in n) {
            if (C(t)) continue;
            const l = n[t];
            let d;
            s && u(s, (d = P(t)))
                ? a && a.includes(d)
                    ? ((o || (o = {}))[d] = l)
                    : (r[d] = l)
                : ps(e.emitsOptions, t) || (t in i && l === i[t]) || ((i[t] = l), (c = !0));
        }
    if (a) {
        const n = jt(r),
            i = o || t;
        for (let t = 0; t < a.length; t++) {
            const o = a[t];
            r[o] = Bi(s, n, o, i[o], e, !u(i, o));
        }
    }
    return c;
}
function Bi(e, t, n, r, i, s) {
    const a = e[n];
    if (null != a) {
        const e = u(a, "default");
        if (e && void 0 === r) {
            const e = a.default;
            if (a.type !== Function && !a.skipFactory && g(e)) {
                const { propsDefaults: s } = i;
                if (n in s) r = s[n];
                else {
                    const a = la(i);
                    (r = s[n] = e.call(null, t)), a();
                }
            } else r = e;
            i.ce && i.ce._setProp(n, r);
        }
        a[0] && (s && !e ? (r = !1) : !a[1] || ("" !== r && r !== N(n)) || (r = !0));
    }
    return r;
}
const zi = new WeakMap();
function Ui(e, r, i = !1) {
    const s = i ? zi : r.propsCache,
        a = s.get(e);
    if (a) return a;
    const c = e.props,
        l = {},
        h = [];
    let m = !1;
    if (!g(e)) {
        const t = (e) => {
            m = !0;
            const [t, n] = Ui(e, r, !0);
            o(l, t), n && h.push(...n);
        };
        !i && r.mixins.length && r.mixins.forEach(t), e.extends && t(e.extends), e.mixins && e.mixins.forEach(t);
    }
    if (!c && !m) return w(e) && s.set(e, n), n;
    if (d(c))
        for (let n = 0; n < c.length; n++) {
            const e = P(c[n]);
            $i(e) && (l[e] = t);
        }
    else if (c)
        for (const t in c) {
            const e = P(t);
            if ($i(e)) {
                const n = c[t],
                    r = (l[e] = d(n) || g(n) ? { type: n } : o({}, n)),
                    i = r.type;
                let s = !1,
                    a = !0;
                if (d(i))
                    for (let e = 0; e < i.length; ++e) {
                        const t = i[e],
                            n = g(t) && t.name;
                        if ("Boolean" === n) {
                            s = !0;
                            break;
                        }
                        "String" === n && (a = !1);
                    }
                else s = g(i) && "Boolean" === i.name;
                (r[0] = s), (r[1] = a), (s || u(r, "default")) && h.push(e);
            }
        }
    const p = [l, h];
    return w(e) && s.set(e, p), p;
}
function $i(e) {
    return "$" !== e[0] && !C(e);
}
const Vi = (e) => "_" === e[0] || "$stable" === e,
    Wi = (e) => (d(e) ? e.map(Qs) : [Qs(e)]),
    ji = (e, t, n) => {
        if (t._n) return t;
        const r = Un((...e) => Wi(t(...e)), n);
        return (r._c = !1), r;
    },
    Hi = (e, t, n) => {
        const r = e._ctx;
        for (const i in e) {
            if (Vi(i)) continue;
            const n = e[i];
            if (g(n)) t[i] = ji(0, n, r);
            else if (null != n) {
                const e = Wi(n);
                t[i] = () => e;
            }
        }
    },
    qi = (e, t) => {
        const n = Wi(t);
        e.slots.default = () => n;
    },
    Xi = (e, t, n) => {
        for (const r in t) (!n && Vi(r)) || (e[r] = t[r]);
    },
    Gi = Cs;
function Ki(e) {
    return Qi(e);
}
function Yi(e) {
    return Qi(e, _r);
}
function Qi(e, i) {
    $().__VUE__ = !0;
    const {
            insert: s,
            remove: a,
            patchProp: o,
            createElement: c,
            createText: l,
            createComment: h,
            setText: m,
            setElementText: p,
            parentNode: f,
            nextSibling: g,
            setScopeId: b = r,
            insertStaticContent: y,
        } = e,
        w = (e, t, n, r = null, i = null, s = null, a = void 0, o = null, c = !!t.dynamicChildren) => {
            if (e === t) return;
            e && !Vs(e, t) && ((r = Y(e)), H(e, i, s, !0), (e = null)),
                -2 === t.patchFlag && ((c = !1), (t.dynamicChildren = null));
            const { type: l, ref: u, shapeFlag: d } = t;
            switch (l) {
                case As:
                    k(e, t, n, r);
                    break;
                case Ps:
                    T(e, t, n, r);
                    break;
                case Os:
                    null == e && _(t, n, r, a);
                    break;
                case xs:
                    R(e, t, n, r, i, s, a, o, c);
                    break;
                default:
                    1 & d
                        ? v(e, t, n, r, i, s, a, o, c)
                        : 6 & d
                          ? M(e, t, n, r, i, s, a, o, c)
                          : (64 & d || 128 & d) && l.process(e, t, n, r, i, s, a, o, c, Z);
            }
            null != u && i
                ? br(u, e && e.ref, s, t || e, !t)
                : null == u && e && null != e.ref && br(e.ref, null, s, e, !0);
        },
        k = (e, t, n, r) => {
            if (null == e) s((t.el = l(t.children)), n, r);
            else {
                const n = (t.el = e.el);
                t.children !== e.children && m(n, t.children);
            }
        },
        T = (e, t, n, r) => {
            null == e ? s((t.el = h(t.children || "")), n, r) : (t.el = e.el);
        },
        _ = (e, t, n, r) => {
            [e.el, e.anchor] = y(e.children, t, n, r, e.el, e.anchor);
        },
        v = (e, t, n, r, i, s, a, o, c) => {
            "svg" === t.type ? (a = "svg") : "math" === t.type && (a = "mathml"),
                null == e ? S(t, n, r, i, s, a, o, c) : x(e, t, i, s, a, o, c);
        },
        S = (e, t, n, r, i, a, l, u) => {
            let d, h;
            const { props: m, shapeFlag: f, transition: g, dirs: b } = e;
            if (
                ((d = e.el = c(e.type, a, m && m.is, m)),
                8 & f ? p(d, e.children) : 16 & f && I(e.children, d, null, r, i, Ji(e, a), l, u),
                b && Vn(e, null, r, "created"),
                E(d, e, e.scopeId, l, r),
                m)
            ) {
                for (const e in m) "value" === e || C(e) || o(d, e, null, m[e], a, r);
                "value" in m && o(d, "value", null, m.value, a), (h = m.onVnodeBeforeMount) && ta(h, r, e);
            }
            b && Vn(e, null, r, "beforeMount");
            const y = es(i, g);
            y && g.beforeEnter(d),
                s(d, t, n),
                ((h = m && m.onVnodeMounted) || y || b) &&
                    Gi(() => {
                        h && ta(h, r, e), y && g.enter(d), b && Vn(e, null, r, "mounted");
                    }, i);
        },
        E = (e, t, n, r, i) => {
            if ((n && b(e, n), r)) for (let s = 0; s < r.length; s++) b(e, r[s]);
            if (i) {
                let n = i.subTree;
                if (t === n || (ks(n.type) && (n.ssContent === t || n.ssFallback === t))) {
                    const t = i.vnode;
                    E(e, t, t.scopeId, t.slotScopeIds, i.parent);
                }
            }
        },
        I = (e, t, n, r, i, s, a, o, c = 0) => {
            for (let l = c; l < e.length; l++) {
                const c = (e[l] = o ? Js(e[l]) : Qs(e[l]));
                w(null, c, t, n, r, i, s, a, o);
            }
        },
        x = (e, n, r, i, s, a, c) => {
            const l = (n.el = e.el);
            let { patchFlag: u, dynamicChildren: d, dirs: h } = n;
            u |= 16 & e.patchFlag;
            const m = e.props || t,
                f = n.props || t;
            let g;
            if (
                (r && Zi(r, !1),
                (g = f.onVnodeBeforeUpdate) && ta(g, r, n, e),
                h && Vn(n, e, r, "beforeUpdate"),
                r && Zi(r, !0),
                ((m.innerHTML && null == f.innerHTML) || (m.textContent && null == f.textContent)) && p(l, ""),
                d ? A(e.dynamicChildren, d, l, r, i, Ji(n, s), a) : c || U(e, n, l, null, r, i, Ji(n, s), a, !1),
                u > 0)
            ) {
                if (16 & u) O(l, m, f, r, s);
                else if (
                    (2 & u && m.class !== f.class && o(l, "class", null, f.class, s),
                    4 & u && o(l, "style", m.style, f.style, s),
                    8 & u)
                ) {
                    const e = n.dynamicProps;
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t],
                            i = m[n],
                            a = f[n];
                        (a === i && "value" !== n) || o(l, n, i, a, s, r);
                    }
                }
                1 & u && e.children !== n.children && p(l, n.children);
            } else c || null != d || O(l, m, f, r, s);
            ((g = f.onVnodeUpdated) || h) &&
                Gi(() => {
                    g && ta(g, r, n, e), h && Vn(n, e, r, "updated");
                }, i);
        },
        A = (e, t, n, r, i, s, a) => {
            for (let o = 0; o < t.length; o++) {
                const c = e[o],
                    l = t[o],
                    u = c.el && (c.type === xs || !Vs(c, l) || 198 & c.shapeFlag) ? f(c.el) : n;
                w(c, l, u, null, r, i, s, a, !0);
            }
        },
        O = (e, n, r, i, s) => {
            if (n !== r) {
                if (n !== t) for (const t in n) C(t) || t in r || o(e, t, n[t], null, s, i);
                for (const t in r) {
                    if (C(t)) continue;
                    const a = r[t],
                        c = n[t];
                    a !== c && "value" !== t && o(e, t, c, a, s, i);
                }
                "value" in r && o(e, "value", n.value, r.value, s);
            }
        },
        R = (e, t, n, r, i, a, o, c, u) => {
            const d = (t.el = e ? e.el : l("")),
                h = (t.anchor = e ? e.anchor : l(""));
            let { patchFlag: m, dynamicChildren: p, slotScopeIds: f } = t;
            f && (c = c ? c.concat(f) : f),
                null == e
                    ? (s(d, n, r), s(h, n, r), I(t.children || [], n, h, i, a, o, c, u))
                    : m > 0 && 64 & m && p && e.dynamicChildren
                      ? (A(e.dynamicChildren, p, n, i, a, o, c),
                        (null != t.key || (i && t === i.subTree)) && ts(e, t, !0))
                      : U(e, t, n, h, i, a, o, c, u);
        },
        M = (e, t, n, r, i, s, a, o, c) => {
            (t.slotScopeIds = o),
                null == e ? (512 & t.shapeFlag ? i.ctx.activate(t, n, r, a, c) : D(t, n, r, i, s, a, c)) : L(e, t, c);
        },
        D = (e, t, n, r, i, s, a) => {
            const o = (e.component = ia(e, r, i));
            if ((Pr(e) && (o.ctx.renderer = Z), fa(o, !1, a), o.asyncDep)) {
                if ((i && i.registerDep(o, B, a), !e.el)) {
                    const e = (o.subTree = qs(Ps));
                    T(null, e, t, n);
                }
            } else B(o, e, t, n, i, s, a);
        },
        L = (e, t, n) => {
            const r = (t.component = e.component);
            if (
                (function (e, t, n) {
                    const { props: r, children: i, component: s } = e,
                        { props: a, children: o, patchFlag: c } = t,
                        l = s.emitsOptions;
                    if (t.dirs || t.transition) return !0;
                    if (!(n && c >= 0))
                        return !((!i && !o) || (o && o.$stable)) || (r !== a && (r ? !a || ys(r, a, l) : !!a));
                    if (1024 & c) return !0;
                    if (16 & c) return r ? ys(r, a, l) : !!a;
                    if (8 & c) {
                        const e = t.dynamicProps;
                        for (let t = 0; t < e.length; t++) {
                            const n = e[t];
                            if (a[n] !== r[n] && !ps(l, n)) return !0;
                        }
                    }
                    return !1;
                })(e, t, n)
            ) {
                if (r.asyncDep && !r.asyncResolved) return void z(r, t, n);
                (r.next = t), r.update();
            } else (t.el = e.el), (r.vnode = t);
        },
        B = (e, t, n, r, i, s, a) => {
            const o = () => {
                if (e.isMounted) {
                    let { next: t, bu: n, u: r, parent: c, vnode: l } = e;
                    {
                        const n = ns(e);
                        if (n)
                            return (
                                t && ((t.el = l.el), z(e, t, a)),
                                void n.asyncDep.then(() => {
                                    e.isUnmounted || o();
                                })
                            );
                    }
                    let u,
                        d = t;
                    Zi(e, !1),
                        t ? ((t.el = l.el), z(e, t, a)) : (t = l),
                        n && F(n),
                        (u = t.props && t.props.onVnodeBeforeUpdate) && ta(u, c, t, l),
                        Zi(e, !0);
                    const h = fs(e),
                        m = e.subTree;
                    (e.subTree = h),
                        w(m, h, f(m.el), Y(m), e, i, s),
                        (t.el = h.el),
                        null === d && ws(e, h.el),
                        r && Gi(r, i),
                        (u = t.props && t.props.onVnodeUpdated) && Gi(() => ta(u, c, t, l), i);
                } else {
                    let a;
                    const { el: o, props: c } = t,
                        { bm: l, m: u, parent: d, root: h, type: m } = e,
                        p = xr(t);
                    if (
                        (Zi(e, !1), l && F(l), !p && (a = c && c.onVnodeBeforeMount) && ta(a, d, t), Zi(e, !0), o && te)
                    ) {
                        const t = () => {
                            (e.subTree = fs(e)), te(o, e.subTree, e, i, null);
                        };
                        p && m.__asyncHydrate ? m.__asyncHydrate(o, e, t) : t();
                    } else {
                        h.ce && !1 !== h.ce._def.shadowRoot && h.ce._injectChildStyle(m);
                        const a = (e.subTree = fs(e));
                        w(null, a, n, r, e, i, s), (t.el = a.el);
                    }
                    if ((u && Gi(u, i), !p && (a = c && c.onVnodeMounted))) {
                        const e = t;
                        Gi(() => ta(a, d, e), i);
                    }
                    (256 & t.shapeFlag || (d && xr(d.vnode) && 256 & d.vnode.shapeFlag)) && e.a && Gi(e.a, i),
                        (e.isMounted = !0),
                        (t = n = r = null);
                }
            };
            e.scope.on();
            const c = (e.effect = new Ae(o));
            e.scope.off();
            const l = (e.update = c.run.bind(c)),
                u = (e.job = c.runIfDirty.bind(c));
            (u.i = e), (u.id = e.uid), (c.scheduler = () => xn(u)), Zi(e, !0), l();
        },
        z = (e, n, r) => {
            n.component = e;
            const i = e.vnode.props;
            (e.vnode = n),
                (e.next = null),
                (function (e, t, n, r) {
                    const {
                            props: i,
                            attrs: s,
                            vnode: { patchFlag: a },
                        } = e,
                        o = jt(i),
                        [c] = e.propsOptions;
                    let l = !1;
                    if (!(r || a > 0) || 16 & a) {
                        let r;
                        Li(e, t, i, s) && (l = !0);
                        for (const s in o)
                            (t && (u(t, s) || ((r = N(s)) !== s && u(t, r)))) ||
                                (c
                                    ? !n || (void 0 === n[s] && void 0 === n[r]) || (i[s] = Bi(c, o, s, void 0, e, !0))
                                    : delete i[s]);
                        if (s !== o) for (const e in s) (t && u(t, e)) || (delete s[e], (l = !0));
                    } else if (8 & a) {
                        const n = e.vnode.dynamicProps;
                        for (let r = 0; r < n.length; r++) {
                            let a = n[r];
                            if (ps(e.emitsOptions, a)) continue;
                            const d = t[a];
                            if (c)
                                if (u(s, a)) d !== s[a] && ((s[a] = d), (l = !0));
                                else {
                                    const t = P(a);
                                    i[t] = Bi(c, o, t, d, e, !1);
                                }
                            else d !== s[a] && ((s[a] = d), (l = !0));
                        }
                    }
                    l && nt(e.attrs, "set", "");
                })(e, n.props, i, r),
                ((e, n, r) => {
                    const { vnode: i, slots: s } = e;
                    let a = !0,
                        o = t;
                    if (32 & i.shapeFlag) {
                        const e = n._;
                        e ? (r && 1 === e ? (a = !1) : Xi(s, n, r)) : ((a = !n.$stable), Hi(n, s)), (o = n);
                    } else n && (qi(e, n), (o = { default: 1 }));
                    if (a) for (const t in s) Vi(t) || null != o[t] || delete s[t];
                })(e, n.children, r),
                je(),
                On(e),
                He();
        },
        U = (e, t, n, r, i, s, a, o, c = !1) => {
            const l = e && e.children,
                u = e ? e.shapeFlag : 0,
                d = t.children,
                { patchFlag: h, shapeFlag: m } = t;
            if (h > 0) {
                if (128 & h) return void W(l, d, n, r, i, s, a, o, c);
                if (256 & h) return void V(l, d, n, r, i, s, a, o, c);
            }
            8 & m
                ? (16 & u && K(l, i, s), d !== l && p(n, d))
                : 16 & u
                  ? 16 & m
                      ? W(l, d, n, r, i, s, a, o, c)
                      : K(l, i, s, !0)
                  : (8 & u && p(n, ""), 16 & m && I(d, n, r, i, s, a, o, c));
        },
        V = (e, t, r, i, s, a, o, c, l) => {
            t = t || n;
            const u = (e = e || n).length,
                d = t.length,
                h = Math.min(u, d);
            let m;
            for (m = 0; m < h; m++) {
                const n = (t[m] = l ? Js(t[m]) : Qs(t[m]));
                w(e[m], n, r, null, s, a, o, c, l);
            }
            u > d ? K(e, s, a, !0, !1, h) : I(t, r, i, s, a, o, c, l, h);
        },
        W = (e, t, r, i, s, a, o, c, l) => {
            let u = 0;
            const d = t.length;
            let h = e.length - 1,
                m = d - 1;
            for (; u <= h && u <= m; ) {
                const n = e[u],
                    i = (t[u] = l ? Js(t[u]) : Qs(t[u]));
                if (!Vs(n, i)) break;
                w(n, i, r, null, s, a, o, c, l), u++;
            }
            for (; u <= h && u <= m; ) {
                const n = e[h],
                    i = (t[m] = l ? Js(t[m]) : Qs(t[m]));
                if (!Vs(n, i)) break;
                w(n, i, r, null, s, a, o, c, l), h--, m--;
            }
            if (u > h) {
                if (u <= m) {
                    const e = m + 1,
                        n = e < d ? t[e].el : i;
                    for (; u <= m; ) w(null, (t[u] = l ? Js(t[u]) : Qs(t[u])), r, n, s, a, o, c, l), u++;
                }
            } else if (u > m) for (; u <= h; ) H(e[u], s, a, !0), u++;
            else {
                const p = u,
                    f = u,
                    g = new Map();
                for (u = f; u <= m; u++) {
                    const e = (t[u] = l ? Js(t[u]) : Qs(t[u]));
                    null != e.key && g.set(e.key, u);
                }
                let b,
                    y = 0;
                const k = m - f + 1;
                let T = !1,
                    _ = 0;
                const v = new Array(k);
                for (u = 0; u < k; u++) v[u] = 0;
                for (u = p; u <= h; u++) {
                    const n = e[u];
                    if (y >= k) {
                        H(n, s, a, !0);
                        continue;
                    }
                    let i;
                    if (null != n.key) i = g.get(n.key);
                    else
                        for (b = f; b <= m; b++)
                            if (0 === v[b - f] && Vs(n, t[b])) {
                                i = b;
                                break;
                            }
                    void 0 === i
                        ? H(n, s, a, !0)
                        : ((v[i - f] = u + 1), i >= _ ? (_ = i) : (T = !0), w(n, t[i], r, null, s, a, o, c, l), y++);
                }
                const S = T
                    ? (function (e) {
                          const t = e.slice(),
                              n = [0];
                          let r, i, s, a, o;
                          const c = e.length;
                          for (r = 0; r < c; r++) {
                              const c = e[r];
                              if (0 !== c) {
                                  if (((i = n[n.length - 1]), e[i] < c)) {
                                      (t[r] = i), n.push(r);
                                      continue;
                                  }
                                  for (s = 0, a = n.length - 1; s < a; )
                                      (o = (s + a) >> 1), e[n[o]] < c ? (s = o + 1) : (a = o);
                                  c < e[n[s]] && (s > 0 && (t[r] = n[s - 1]), (n[s] = r));
                              }
                          }
                          (s = n.length), (a = n[s - 1]);
                          for (; s-- > 0; ) (n[s] = a), (a = t[a]);
                          return n;
                      })(v)
                    : n;
                for (b = S.length - 1, u = k - 1; u >= 0; u--) {
                    const e = f + u,
                        n = t[e],
                        h = e + 1 < d ? t[e + 1].el : i;
                    0 === v[u] ? w(null, n, r, h, s, a, o, c, l) : T && (b < 0 || u !== S[b] ? j(n, r, h, 2) : b--);
                }
            }
        },
        j = (e, t, n, r, i = null) => {
            const { el: o, type: c, transition: l, children: u, shapeFlag: d } = e;
            if (6 & d) return void j(e.component.subTree, t, n, r);
            if (128 & d) return void e.suspense.move(t, n, r);
            if (64 & d) return void c.move(e, t, n, Z);
            if (c === xs) {
                s(o, t, n);
                for (let e = 0; e < u.length; e++) j(u[e], t, n, r);
                return void s(e.anchor, t, n);
            }
            if (c === Os)
                return void (({ el: e, anchor: t }, n, r) => {
                    let i;
                    for (; e && e !== t; ) (i = g(e)), s(e, n, r), (e = i);
                    s(t, n, r);
                })(e, t, n);
            if (2 !== r && 1 & d && l)
                if (0 === r) l.beforeEnter(o), s(o, t, n), Gi(() => l.enter(o), i);
                else {
                    const { leave: r, delayLeave: i, afterLeave: c } = l,
                        u = () => {
                            e.ctx.isUnmounted ? a(o) : s(o, t, n);
                        },
                        d = () => {
                            r(o, () => {
                                u(), c && c();
                            });
                        };
                    i ? i(o, u, d) : d();
                }
            else s(o, t, n);
        },
        H = (e, t, n, r = !1, i = !1) => {
            const {
                type: s,
                props: a,
                ref: o,
                children: c,
                dynamicChildren: l,
                shapeFlag: u,
                patchFlag: d,
                dirs: h,
                cacheIndex: m,
            } = e;
            if (
                (-2 === d && (i = !1),
                null != o && (je(), br(o, null, n, e, !0), He()),
                null != m && (t.renderCache[m] = void 0),
                256 & u)
            )
                return void t.ctx.deactivate(e);
            const p = 1 & u && h,
                f = !xr(e);
            let g;
            if ((f && (g = a && a.onVnodeBeforeUnmount) && ta(g, t, e), 6 & u)) G(e.component, n, r);
            else {
                if (128 & u) return void e.suspense.unmount(n, r);
                p && Vn(e, null, t, "beforeUnmount"),
                    64 & u
                        ? e.type.remove(e, t, n, Z, r)
                        : l && !l.hasOnce && (s !== xs || (d > 0 && 64 & d))
                          ? K(l, t, n, !1, !0)
                          : ((s === xs && 384 & d) || (!i && 16 & u)) && K(c, t, n),
                    r && q(e);
            }
            ((f && (g = a && a.onVnodeUnmounted)) || p) &&
                Gi(() => {
                    g && ta(g, t, e), p && Vn(e, null, t, "unmounted");
                }, n);
        },
        q = (e) => {
            const { type: t, el: n, anchor: r, transition: i } = e;
            if (t === xs) return void X(n, r);
            if (t === Os)
                return void (({ el: e, anchor: t }) => {
                    let n;
                    for (; e && e !== t; ) (n = g(e)), a(e), (e = n);
                    a(t);
                })(e);
            const s = () => {
                a(n), i && !i.persisted && i.afterLeave && i.afterLeave();
            };
            if (1 & e.shapeFlag && i && !i.persisted) {
                const { leave: t, delayLeave: r } = i,
                    a = () => t(n, s);
                r ? r(e.el, s, a) : a();
            } else s();
        },
        X = (e, t) => {
            let n;
            for (; e !== t; ) (n = g(e)), a(e), (e = n);
            a(t);
        },
        G = (e, t, n) => {
            const {
                bum: r,
                scope: i,
                job: s,
                subTree: a,
                um: o,
                m: c,
                a: l,
                parent: u,
                slots: { __: h },
            } = e;
            rs(c),
                rs(l),
                r && F(r),
                u &&
                    d(h) &&
                    h.forEach((e) => {
                        u.renderCache[e] = void 0;
                    }),
                i.stop(),
                s && ((s.flags |= 8), H(a, e, t, n)),
                o && Gi(o, t),
                Gi(() => {
                    e.isUnmounted = !0;
                }, t),
                t &&
                    t.pendingBranch &&
                    !t.isUnmounted &&
                    e.asyncDep &&
                    !e.asyncResolved &&
                    e.suspenseId === t.pendingId &&
                    (t.deps--, 0 === t.deps && t.resolve());
        },
        K = (e, t, n, r = !1, i = !1, s = 0) => {
            for (let a = s; a < e.length; a++) H(e[a], t, n, r, i);
        },
        Y = (e) => {
            if (6 & e.shapeFlag) return Y(e.component.subTree);
            if (128 & e.shapeFlag) return e.suspense.next();
            const t = g(e.anchor || e.el),
                n = t && t[Wn];
            return n ? g(n) : t;
        };
    let Q = !1;
    const J = (e, t, n) => {
            null == e ? t._vnode && H(t._vnode, null, null, !0) : w(t._vnode || null, e, t, null, null, null, n),
                (t._vnode = e),
                Q || ((Q = !0), On(), Nn(), (Q = !1));
        },
        Z = { p: w, um: H, m: j, r: q, mt: D, mc: I, pc: U, pbc: A, n: Y, o: e };
    let ee, te;
    return i && ([ee, te] = i(Z)), { render: J, hydrate: ee, createApp: Pi(J, ee) };
}
function Ji({ type: e, props: t }, n) {
    return ("svg" === n && "foreignObject" === e) ||
        ("mathml" === n && "annotation-xml" === e && t && t.encoding && t.encoding.includes("html"))
        ? void 0
        : n;
}
function Zi({ effect: e, job: t }, n) {
    n ? ((e.flags |= 32), (t.flags |= 4)) : ((e.flags &= -33), (t.flags &= -5));
}
function es(e, t) {
    return (!e || (e && !e.pendingBranch)) && t && !t.persisted;
}
function ts(e, t, n = !1) {
    const r = e.children,
        i = t.children;
    if (d(r) && d(i))
        for (let s = 0; s < r.length; s++) {
            const e = r[s];
            let t = i[s];
            1 & t.shapeFlag &&
                !t.dynamicChildren &&
                ((t.patchFlag <= 0 || 32 === t.patchFlag) && ((t = i[s] = Js(i[s])), (t.el = e.el)),
                n || -2 === t.patchFlag || ts(e, t)),
                t.type === As && (t.el = e.el),
                t.type !== Ps || t.el || (t.el = e.el);
        }
}
function ns(e) {
    const t = e.subTree.component;
    if (t) return t.asyncDep && !t.asyncResolved ? t : ns(t);
}
function rs(e) {
    if (e) for (let t = 0; t < e.length; t++) e[t].flags |= 8;
}
const is = Symbol.for("v-scx"),
    ss = () => Ri(is);
function as(e, t) {
    return cs(e, null, { flush: "sync" });
}
function os(e, t, n) {
    return cs(e, t, n);
}
function cs(e, n, i = t) {
    const { immediate: s, deep: a, flush: l, once: u } = i,
        h = o({}, i),
        m = (n && s) || (!n && "post" !== l);
    let p;
    if (pa)
        if ("sync" === l) {
            const e = ss();
            p = e.__watcherHandles || (e.__watcherHandles = []);
        } else if (!m) {
            const e = () => {};
            return (e.stop = r), (e.resume = r), (e.pause = r), e;
        }
    const f = sa;
    h.call = (e, t, n) => yn(e, f, t, n);
    let b = !1;
    "post" === l
        ? (h.scheduler = (e) => {
              Gi(e, f && f.suspense);
          })
        : "sync" !== l &&
          ((b = !0),
          (h.scheduler = (e, t) => {
              t ? e() : xn(e);
          })),
        (h.augmentJob = (e) => {
            n && (e.flags |= 4), b && ((e.flags |= 2), f && ((e.id = f.uid), (e.i = f)));
        });
    const y = (function (e, n, i = t) {
        const { immediate: s, deep: a, once: o, scheduler: l, augmentJob: u, call: h } = i,
            m = (e) => (a ? e : Vt(e) || !1 === a || 0 === a ? pn(e, 1) : pn(e));
        let p,
            f,
            b,
            y,
            w = !1,
            k = !1;
        if (
            (Gt(e)
                ? ((f = () => e.value), (w = Vt(e)))
                : Ut(e)
                  ? ((f = () => m(e)), (w = !0))
                  : d(e)
                    ? ((k = !0),
                      (w = e.some((e) => Ut(e) || Vt(e))),
                      (f = () => e.map((e) => (Gt(e) ? e.value : Ut(e) ? m(e) : g(e) ? (h ? h(e, 2) : e()) : void 0))))
                    : (f = g(e)
                          ? n
                              ? h
                                  ? () => h(e, 2)
                                  : e
                              : () => {
                                    if (b) {
                                        je();
                                        try {
                                            b();
                                        } finally {
                                            He();
                                        }
                                    }
                                    const t = hn;
                                    hn = p;
                                    try {
                                        return h ? h(e, 3, [y]) : e(y);
                                    } finally {
                                        hn = t;
                                    }
                                }
                          : r),
            n && a)
        ) {
            const e = f,
                t = !0 === a ? 1 / 0 : a;
            f = () => pn(e(), t);
        }
        const T = Ie(),
            _ = () => {
                p.stop(), T && T.active && c(T.effects, p);
            };
        if (o && n) {
            const e = n;
            n = (...t) => {
                e(...t), _();
            };
        }
        let v = k ? new Array(e.length).fill(un) : un;
        const S = (e) => {
            if (1 & p.flags && (p.dirty || e))
                if (n) {
                    const e = p.run();
                    if (a || w || (k ? e.some((e, t) => D(e, v[t])) : D(e, v))) {
                        b && b();
                        const t = hn;
                        hn = p;
                        try {
                            const t = [e, v === un ? void 0 : k && v[0] === un ? [] : v, y];
                            (v = e), h ? h(n, 3, t) : n(...t);
                        } finally {
                            hn = t;
                        }
                    }
                } else p.run();
        };
        return (
            u && u(S),
            (p = new Ae(f)),
            (p.scheduler = l ? () => l(S, !1) : S),
            (y = (e) => mn(e, !1, p)),
            (b = p.onStop =
                () => {
                    const e = dn.get(p);
                    if (e) {
                        if (h) h(e, 4);
                        else for (const t of e) t();
                        dn.delete(p);
                    }
                }),
            n ? (s ? S(!0) : (v = p.run())) : l ? l(S.bind(null, !0), !0) : p.run(),
            (_.pause = p.pause.bind(p)),
            (_.resume = p.resume.bind(p)),
            (_.stop = _),
            _
        );
    })(e, n, h);
    return pa && (p ? p.push(y) : m && y()), y;
}
function ls(e, t, n) {
    const r = this.proxy,
        i = b(e) ? (e.includes(".") ? us(r, e) : () => r[e]) : e.bind(r, r);
    let s;
    g(t) ? (s = t) : ((s = t.handler), (n = t));
    const a = la(this),
        o = cs(i, s.bind(r), n);
    return a(), o;
}
function us(e, t) {
    const n = t.split(".");
    return () => {
        let t = e;
        for (let e = 0; e < n.length && t; e++) t = t[n[e]];
        return t;
    };
}
const ds = (e, t) =>
    "modelValue" === t || "model-value" === t
        ? e.modelModifiers
        : e[`${t}Modifiers`] || e[`${P(t)}Modifiers`] || e[`${N(t)}Modifiers`];
function hs(e, n, ...r) {
    if (e.isUnmounted) return;
    const i = e.vnode.props || t;
    let s = r;
    const a = n.startsWith("update:"),
        o = a && ds(i, n.slice(7));
    let c;
    o && (o.trim && (s = r.map((e) => (b(e) ? e.trim() : e))), o.number && (s = r.map(B)));
    let l = i[(c = M(n))] || i[(c = M(P(n)))];
    !l && a && (l = i[(c = M(N(n)))]), l && yn(l, e, 6, s);
    const u = i[c + "Once"];
    if (u) {
        if (e.emitted) {
            if (e.emitted[c]) return;
        } else e.emitted = {};
        (e.emitted[c] = !0), yn(u, e, 6, s);
    }
}
function ms(e, t, n = !1) {
    const r = t.emitsCache,
        i = r.get(e);
    if (void 0 !== i) return i;
    const s = e.emits;
    let a = {},
        c = !1;
    if (!g(e)) {
        const r = (e) => {
            const n = ms(e, t, !0);
            n && ((c = !0), o(a, n));
        };
        !n && t.mixins.length && t.mixins.forEach(r), e.extends && r(e.extends), e.mixins && e.mixins.forEach(r);
    }
    return s || c
        ? (d(s) ? s.forEach((e) => (a[e] = null)) : o(a, s), w(e) && r.set(e, a), a)
        : (w(e) && r.set(e, null), null);
}
function ps(e, t) {
    return (
        !(!e || !s(t)) &&
        ((t = t.slice(2).replace(/Once$/, "")), u(e, t[0].toLowerCase() + t.slice(1)) || u(e, N(t)) || u(e, t))
    );
}
function fs(e) {
    const {
            type: t,
            vnode: n,
            proxy: r,
            withProxy: i,
            propsOptions: [s],
            slots: o,
            attrs: c,
            emit: l,
            render: u,
            renderCache: d,
            props: h,
            data: m,
            setupState: p,
            ctx: f,
            inheritAttrs: g,
        } = e,
        b = zn(e);
    let y, w;
    try {
        if (4 & n.shapeFlag) {
            const e = i || r,
                t = e;
            (y = Qs(u.call(t, e, d, h, p, m, f))), (w = c);
        } else {
            const e = t;
            0, (y = Qs(e.length > 1 ? e(h, { attrs: c, slots: o, emit: l }) : e(h, null))), (w = t.props ? c : gs(c));
        }
    } catch (T) {
        (Ns.length = 0), wn(T, e, 1), (y = qs(Ps));
    }
    let k = y;
    if (w && !1 !== g) {
        const e = Object.keys(w),
            { shapeFlag: t } = k;
        e.length && 7 & t && (s && e.some(a) && (w = bs(w, s)), (k = Gs(k, w, !1, !0)));
    }
    return (
        n.dirs && ((k = Gs(k, null, !1, !0)), (k.dirs = k.dirs ? k.dirs.concat(n.dirs) : n.dirs)),
        n.transition && mr(k, n.transition),
        (y = k),
        zn(b),
        y
    );
}
const gs = (e) => {
        let t;
        for (const n in e) ("class" === n || "style" === n || s(n)) && ((t || (t = {}))[n] = e[n]);
        return t;
    },
    bs = (e, t) => {
        const n = {};
        for (const r in e) (a(r) && r.slice(9) in t) || (n[r] = e[r]);
        return n;
    };
function ys(e, t, n) {
    const r = Object.keys(t);
    if (r.length !== Object.keys(e).length) return !0;
    for (let i = 0; i < r.length; i++) {
        const s = r[i];
        if (t[s] !== e[s] && !ps(n, s)) return !0;
    }
    return !1;
}
function ws({ vnode: e, parent: t }, n) {
    for (; t; ) {
        const r = t.subTree;
        if ((r.suspense && r.suspense.activeBranch === e && (r.el = e.el), r !== e)) break;
        ((e = t.vnode).el = n), (t = t.parent);
    }
}
const ks = (e) => e.__isSuspense;
let Ts = 0;
const _s = {
    name: "Suspense",
    __isSuspense: !0,
    process(e, t, n, r, i, s, a, o, c, l) {
        if (null == e)
            !(function (e, t, n, r, i, s, a, o, c) {
                const {
                        p: l,
                        o: { createElement: u },
                    } = c,
                    d = u("div"),
                    h = (e.suspense = Ss(e, i, r, t, d, n, s, a, o, c));
                l(null, (h.pendingBranch = e.ssContent), d, null, r, h, s, a),
                    h.deps > 0
                        ? (vs(e, "onPending"),
                          vs(e, "onFallback"),
                          l(null, e.ssFallback, t, n, r, null, s, a),
                          Is(h, e.ssFallback))
                        : h.resolve(!1, !0);
            })(t, n, r, i, s, a, o, c, l);
        else {
            if (s && s.deps > 0 && !e.suspense.isInFallback)
                return (t.suspense = e.suspense), (t.suspense.vnode = t), void (t.el = e.el);
            !(function (e, t, n, r, i, s, a, o, { p: c, um: l, o: { createElement: u } }) {
                const d = (t.suspense = e.suspense);
                (d.vnode = t), (t.el = e.el);
                const h = t.ssContent,
                    m = t.ssFallback,
                    { activeBranch: p, pendingBranch: f, isInFallback: g, isHydrating: b } = d;
                if (f)
                    (d.pendingBranch = h),
                        Vs(h, f)
                            ? (c(f, h, d.hiddenContainer, null, i, d, s, a, o),
                              d.deps <= 0 ? d.resolve() : g && (b || (c(p, m, n, r, i, null, s, a, o), Is(d, m))))
                            : ((d.pendingId = Ts++),
                              b ? ((d.isHydrating = !1), (d.activeBranch = f)) : l(f, i, d),
                              (d.deps = 0),
                              (d.effects.length = 0),
                              (d.hiddenContainer = u("div")),
                              g
                                  ? (c(null, h, d.hiddenContainer, null, i, d, s, a, o),
                                    d.deps <= 0 ? d.resolve() : (c(p, m, n, r, i, null, s, a, o), Is(d, m)))
                                  : p && Vs(h, p)
                                    ? (c(p, h, n, r, i, d, s, a, o), d.resolve(!0))
                                    : (c(null, h, d.hiddenContainer, null, i, d, s, a, o), d.deps <= 0 && d.resolve()));
                else if (p && Vs(h, p)) c(p, h, n, r, i, d, s, a, o), Is(d, h);
                else if (
                    (vs(t, "onPending"),
                    (d.pendingBranch = h),
                    512 & h.shapeFlag ? (d.pendingId = h.component.suspenseId) : (d.pendingId = Ts++),
                    c(null, h, d.hiddenContainer, null, i, d, s, a, o),
                    d.deps <= 0)
                )
                    d.resolve();
                else {
                    const { timeout: e, pendingId: t } = d;
                    e > 0
                        ? setTimeout(() => {
                              d.pendingId === t && d.fallback(m);
                          }, e)
                        : 0 === e && d.fallback(m);
                }
            })(e, t, n, r, i, a, o, c, l);
        }
    },
    hydrate: function (e, t, n, r, i, s, a, o, c) {
        const l = (t.suspense = Ss(t, r, n, e.parentNode, document.createElement("div"), null, i, s, a, o, !0)),
            u = c(e, (l.pendingBranch = t.ssContent), n, l, s, a);
        0 === l.deps && l.resolve(!1, !0);
        return u;
    },
    normalize: function (e) {
        const { shapeFlag: t, children: n } = e,
            r = 32 & t;
        (e.ssContent = Es(r ? n.default : n)), (e.ssFallback = r ? Es(n.fallback) : qs(Ps));
    },
};
function vs(e, t) {
    const n = e.props && e.props[t];
    g(n) && n();
}
function Ss(e, t, n, r, i, s, a, o, c, l, u = !1) {
    const {
        p: d,
        m: h,
        um: m,
        n: p,
        o: { parentNode: f, remove: g },
    } = l;
    let b;
    const y = (function (e) {
        const t = e.props && e.props.suspensible;
        return null != t && !1 !== t;
    })(e);
    y && t && t.pendingBranch && ((b = t.pendingId), t.deps++);
    const w = e.props ? z(e.props.timeout) : void 0,
        k = s,
        T = {
            vnode: e,
            parent: t,
            parentComponent: n,
            namespace: a,
            container: r,
            hiddenContainer: i,
            deps: 0,
            pendingId: Ts++,
            timeout: "number" == typeof w ? w : -1,
            activeBranch: null,
            pendingBranch: null,
            isInFallback: !u,
            isHydrating: u,
            isUnmounted: !1,
            effects: [],
            resolve(e = !1, n = !1) {
                const {
                    vnode: r,
                    activeBranch: i,
                    pendingBranch: a,
                    pendingId: o,
                    effects: c,
                    parentComponent: l,
                    container: u,
                } = T;
                let d = !1;
                T.isHydrating
                    ? (T.isHydrating = !1)
                    : e ||
                      ((d = i && a.transition && "out-in" === a.transition.mode),
                      d &&
                          (i.transition.afterLeave = () => {
                              o === T.pendingId && (h(a, u, s === k ? p(i) : s, 0), Pn(c));
                          }),
                      i && (f(i.el) === u && (s = p(i)), m(i, l, T, !0)),
                      d || h(a, u, s, 0)),
                    Is(T, a),
                    (T.pendingBranch = null),
                    (T.isInFallback = !1);
                let g = T.parent,
                    w = !1;
                for (; g; ) {
                    if (g.pendingBranch) {
                        g.effects.push(...c), (w = !0);
                        break;
                    }
                    g = g.parent;
                }
                w || d || Pn(c),
                    (T.effects = []),
                    y && t && t.pendingBranch && b === t.pendingId && (t.deps--, 0 !== t.deps || n || t.resolve()),
                    vs(r, "onResolve");
            },
            fallback(e) {
                if (!T.pendingBranch) return;
                const { vnode: t, activeBranch: n, parentComponent: r, container: i, namespace: s } = T;
                vs(t, "onFallback");
                const a = p(n),
                    l = () => {
                        T.isInFallback && (d(null, e, i, a, r, null, s, o, c), Is(T, e));
                    },
                    u = e.transition && "out-in" === e.transition.mode;
                u && (n.transition.afterLeave = l), (T.isInFallback = !0), m(n, r, null, !0), u || l();
            },
            move(e, t, n) {
                T.activeBranch && h(T.activeBranch, e, t, n), (T.container = e);
            },
            next: () => T.activeBranch && p(T.activeBranch),
            registerDep(e, t, n) {
                const r = !!T.pendingBranch;
                r && T.deps++;
                const i = e.vnode.el;
                e.asyncDep
                    .catch((t) => {
                        wn(t, e, 0);
                    })
                    .then((s) => {
                        if (e.isUnmounted || T.isUnmounted || T.pendingId !== e.suspenseId) return;
                        e.asyncResolved = !0;
                        const { vnode: o } = e;
                        ga(e, s, !1), i && (o.el = i);
                        const c = !i && e.subTree.el;
                        t(e, o, f(i || e.subTree.el), i ? null : p(e.subTree), T, a, n),
                            c && g(c),
                            ws(e, o.el),
                            r && 0 === --T.deps && T.resolve();
                    });
            },
            unmount(e, t) {
                (T.isUnmounted = !0),
                    T.activeBranch && m(T.activeBranch, n, e, t),
                    T.pendingBranch && m(T.pendingBranch, n, e, t);
            },
        };
    return T;
}
function Es(e) {
    let t;
    if (g(e)) {
        const n = Fs && e._c;
        n && ((e._d = !1), Ms()), (e = e()), n && ((e._d = !0), (t = Rs), Ds());
    }
    if (d(e)) {
        const t = (function (e) {
            let t;
            for (let n = 0; n < e.length; n++) {
                const r = e[n];
                if (!$s(r)) return;
                if (r.type !== Ps || "v-if" === r.children) {
                    if (t) return;
                    t = r;
                }
            }
            return t;
        })(e);
        e = t;
    }
    return (e = Qs(e)), t && !e.dynamicChildren && (e.dynamicChildren = t.filter((t) => t !== e)), e;
}
function Cs(e, t) {
    t && t.pendingBranch ? (d(e) ? t.effects.push(...e) : t.effects.push(e)) : Pn(e);
}
function Is(e, t) {
    e.activeBranch = t;
    const { vnode: n, parentComponent: r } = e;
    let i = t.el;
    for (; !i && t.component; ) i = (t = t.component.subTree).el;
    (n.el = i), r && r.subTree === n && ((r.vnode.el = i), ws(r, i));
}
const xs = Symbol.for("v-fgt"),
    As = Symbol.for("v-txt"),
    Ps = Symbol.for("v-cmt"),
    Os = Symbol.for("v-stc"),
    Ns = [];
let Rs = null;
function Ms(e = !1) {
    Ns.push((Rs = e ? null : []));
}
function Ds() {
    Ns.pop(), (Rs = Ns[Ns.length - 1] || null);
}
let Fs = 1;
function Ls(e, t = !1) {
    (Fs += e), e < 0 && Rs && t && (Rs.hasOnce = !0);
}
function Bs(e) {
    return (e.dynamicChildren = Fs > 0 ? Rs || n : null), Ds(), Fs > 0 && Rs && Rs.push(e), e;
}
function zs(e, t, n, r, i, s) {
    return Bs(Hs(e, t, n, r, i, s, !0));
}
function Us(e, t, n, r, i) {
    return Bs(qs(e, t, n, r, i, !0));
}
function $s(e) {
    return !!e && !0 === e.__v_isVNode;
}
function Vs(e, t) {
    return e.type === t.type && e.key === t.key;
}
const Ws = ({ key: e }) => (null != e ? e : null),
    js = ({ ref: e, ref_key: t, ref_for: n }) => (
        "number" == typeof e && (e = "" + e),
        null != e ? (b(e) || Gt(e) || g(e) ? { i: Ln, r: e, k: t, f: !!n } : e) : null
    );
function Hs(e, t = null, n = null, r = 0, i = null, s = e === xs ? 0 : 1, a = !1, o = !1) {
    const c = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && Ws(t),
        ref: t && js(t),
        scopeId: Bn,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: r,
        dynamicProps: i,
        dynamicChildren: null,
        appContext: null,
        ctx: Ln,
    };
    return (
        o ? (Zs(c, n), 128 & s && e.normalize(c)) : n && (c.shapeFlag |= b(n) ? 8 : 16),
        Fs > 0 && !a && Rs && (c.patchFlag > 0 || 6 & s) && 32 !== c.patchFlag && Rs.push(c),
        c
    );
}
const qs = function (e, t = null, n = null, r = 0, i = null, s = !1) {
    (e && e !== Zr) || (e = Ps);
    if ($s(e)) {
        const r = Gs(e, t, !0);
        return (
            n && Zs(r, n),
            Fs > 0 && !s && Rs && (6 & r.shapeFlag ? (Rs[Rs.indexOf(e)] = r) : Rs.push(r)),
            (r.patchFlag = -2),
            r
        );
    }
    (a = e), g(a) && "__vccOpts" in a && (e = e.__vccOpts);
    var a;
    if (t) {
        t = Xs(t);
        let { class: e, style: n } = t;
        e && !b(e) && (t.class = Z(e)), w(n) && (Wt(n) && !d(n) && (n = o({}, n)), (t.style = G(n)));
    }
    const c = b(e) ? 1 : ks(e) ? 128 : jn(e) ? 64 : w(e) ? 4 : g(e) ? 2 : 0;
    return Hs(e, t, n, r, i, c, s, !0);
};
function Xs(e) {
    return e ? (Wt(e) || Fi(e) ? o({}, e) : e) : null;
}
function Gs(e, t, n = !1, r = !1) {
    const { props: i, ref: s, patchFlag: a, children: o, transition: c } = e,
        l = t ? ea(i || {}, t) : i,
        u = {
            __v_isVNode: !0,
            __v_skip: !0,
            type: e.type,
            props: l,
            key: l && Ws(l),
            ref: t && t.ref ? (n && s ? (d(s) ? s.concat(js(t)) : [s, js(t)]) : js(t)) : s,
            scopeId: e.scopeId,
            slotScopeIds: e.slotScopeIds,
            children: o,
            target: e.target,
            targetStart: e.targetStart,
            targetAnchor: e.targetAnchor,
            staticCount: e.staticCount,
            shapeFlag: e.shapeFlag,
            patchFlag: t && e.type !== xs ? (-1 === a ? 16 : 16 | a) : a,
            dynamicProps: e.dynamicProps,
            dynamicChildren: e.dynamicChildren,
            appContext: e.appContext,
            dirs: e.dirs,
            transition: c,
            component: e.component,
            suspense: e.suspense,
            ssContent: e.ssContent && Gs(e.ssContent),
            ssFallback: e.ssFallback && Gs(e.ssFallback),
            el: e.el,
            anchor: e.anchor,
            ctx: e.ctx,
            ce: e.ce,
        };
    return c && r && mr(u, c.clone(u)), u;
}
function Ks(e = " ", t = 0) {
    return qs(As, null, e, t);
}
function Ys(e = "", t = !1) {
    return t ? (Ms(), Us(Ps, null, e)) : qs(Ps, null, e);
}
function Qs(e) {
    return null == e || "boolean" == typeof e
        ? qs(Ps)
        : d(e)
          ? qs(xs, null, e.slice())
          : $s(e)
            ? Js(e)
            : qs(As, null, String(e));
}
function Js(e) {
    return (null === e.el && -1 !== e.patchFlag) || e.memo ? e : Gs(e);
}
function Zs(e, t) {
    let n = 0;
    const { shapeFlag: r } = e;
    if (null == t) t = null;
    else if (d(t)) n = 16;
    else if ("object" == typeof t) {
        if (65 & r) {
            const n = t.default;
            return void (n && (n._c && (n._d = !1), Zs(e, n()), n._c && (n._d = !0)));
        }
        {
            n = 32;
            const r = t._;
            r || Fi(t)
                ? 3 === r && Ln && (1 === Ln.slots._ ? (t._ = 1) : ((t._ = 2), (e.patchFlag |= 1024)))
                : (t._ctx = Ln);
        }
    } else
        g(t)
            ? ((t = { default: t, _ctx: Ln }), (n = 32))
            : ((t = String(t)), 64 & r ? ((n = 16), (t = [Ks(t)])) : (n = 8));
    (e.children = t), (e.shapeFlag |= n);
}
function ea(...e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        for (const e in r)
            if ("class" === e) t.class !== r.class && (t.class = Z([t.class, r.class]));
            else if ("style" === e) t.style = G([t.style, r.style]);
            else if (s(e)) {
                const n = t[e],
                    i = r[e];
                !i || n === i || (d(n) && n.includes(i)) || (t[e] = n ? [].concat(n, i) : i);
            } else "" !== e && (t[e] = r[e]);
    }
    return t;
}
function ta(e, t, n, r = null) {
    yn(e, t, 7, [n, r]);
}
const na = xi();
let ra = 0;
function ia(e, n, r) {
    const i = e.type,
        s = (n ? n.appContext : e.appContext) || na,
        a = {
            uid: ra++,
            vnode: e,
            type: i,
            parent: n,
            appContext: s,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            job: null,
            scope: new Ce(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: n ? n.provides : Object.create(s.provides),
            ids: n ? n.ids : ["", 0, 0],
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: Ui(i, s),
            emitsOptions: ms(i, s),
            emit: null,
            emitted: null,
            propsDefaults: t,
            inheritAttrs: i.inheritAttrs,
            ctx: t,
            data: t,
            props: t,
            attrs: t,
            slots: t,
            refs: t,
            setupState: t,
            setupContext: null,
            suspense: r,
            suspenseId: r ? r.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null,
        };
    return (a.ctx = { _: a }), (a.root = n ? n.root : a), (a.emit = hs.bind(null, a)), e.ce && e.ce(a), a;
}
let sa = null;
const aa = () => sa || Ln;
let oa, ca;
{
    const e = $(),
        t = (t, n) => {
            let r;
            return (
                (r = e[t]) || (r = e[t] = []),
                r.push(n),
                (e) => {
                    r.length > 1 ? r.forEach((t) => t(e)) : r[0](e);
                }
            );
        };
    (oa = t("__VUE_INSTANCE_SETTERS__", (e) => (sa = e))), (ca = t("__VUE_SSR_SETTERS__", (e) => (pa = e)));
}
const la = (e) => {
        const t = sa;
        return (
            oa(e),
            e.scope.on(),
            () => {
                e.scope.off(), oa(t);
            }
        );
    },
    ua = () => {
        sa && sa.scope.off(), oa(null);
    };
function da(e) {
    return 4 & e.vnode.shapeFlag;
}
let ha,
    ma,
    pa = !1;
function fa(e, t = !1, n = !1) {
    t && ca(t);
    const { props: r, children: i } = e.vnode,
        s = da(e);
    !(function (e, t, n, r = !1) {
        const i = {},
            s = Di();
        (e.propsDefaults = Object.create(null)), Li(e, t, i, s);
        for (const a in e.propsOptions[0]) a in i || (i[a] = void 0);
        n ? (e.props = r ? i : Ft(i)) : e.type.props ? (e.props = i) : (e.props = s), (e.attrs = s);
    })(e, r, s, t),
        ((e, t, n) => {
            const r = (e.slots = Di());
            if (32 & e.vnode.shapeFlag) {
                const e = t.__;
                e && L(r, "__", e, !0);
                const i = t._;
                i ? (Xi(r, t, n), n && L(r, "_", i, !0)) : Hi(t, r);
            } else t && qi(e, t);
        })(e, i, n || t);
    const a = s
        ? (function (e, t) {
              const n = e.type;
              (e.accessCache = Object.create(null)), (e.proxy = new Proxy(e.ctx, hi));
              const { setup: r } = n;
              if (r) {
                  je();
                  const n = (e.setupContext = r.length > 1 ? wa(e) : null),
                      i = la(e),
                      s = bn(r, e, 0, [e.props, n]),
                      a = k(s);
                  if ((He(), i(), (!a && !e.sp) || xr(e) || gr(e), a)) {
                      if ((s.then(ua, ua), t))
                          return s
                              .then((n) => {
                                  ga(e, n, t);
                              })
                              .catch((t) => {
                                  wn(t, e, 0);
                              });
                      e.asyncDep = s;
                  } else ga(e, s, t);
              } else ba(e, t);
          })(e, t)
        : void 0;
    return t && ca(!1), a;
}
function ga(e, t, n) {
    g(t) ? (e.type.__ssrInlineRender ? (e.ssrRender = t) : (e.render = t)) : w(t) && (e.setupState = tn(t)), ba(e, n);
}
function ba(e, t, n) {
    const i = e.type;
    if (!e.render) {
        if (!t && ha && !i.render) {
            const t = i.template || ki(e).template;
            if (t) {
                const { isCustomElement: n, compilerOptions: r } = e.appContext.config,
                    { delimiters: s, compilerOptions: a } = i,
                    c = o(o({ isCustomElement: n, delimiters: s }, r), a);
                i.render = ha(t, c);
            }
        }
        (e.render = i.render || r), ma && ma(e);
    }
    {
        const t = la(e);
        je();
        try {
            bi(e);
        } finally {
            He(), t();
        }
    }
}
const ya = { get: (e, t) => (tt(e, 0, ""), e[t]) };
function wa(e) {
    const t = (t) => {
        e.exposed = t || {};
    };
    return { attrs: new Proxy(e.attrs, ya), slots: e.slots, emit: e.emit, expose: t };
}
function ka(e) {
    return e.exposed
        ? e.exposeProxy ||
              (e.exposeProxy = new Proxy(tn(Ht(e.exposed)), {
                  get: (t, n) => (n in t ? t[n] : n in ui ? ui[n](e) : void 0),
                  has: (e, t) => t in e || t in ui,
              }))
        : e.proxy;
}
function Ta(e, t = !0) {
    return g(e) ? e.displayName || e.name : e.name || (t && e.__name);
}
const _a = (e, t) => {
    const n = (function (e, t, n = !1) {
        let r, i;
        return g(e) ? (r = e) : ((r = e.get), (i = e.set)), new ln(r, i, n);
    })(e, 0, pa);
    return n;
};
function va(e, t, n) {
    const r = arguments.length;
    return 2 === r
        ? w(t) && !d(t)
            ? $s(t)
                ? qs(e, null, [t])
                : qs(e, t)
            : qs(e, null, t)
        : (r > 3 ? (n = Array.prototype.slice.call(arguments, 2)) : 3 === r && $s(n) && (n = [n]), qs(e, t, n));
}
function Sa(e, t) {
    const n = e.memo;
    if (n.length != t.length) return !1;
    for (let r = 0; r < n.length; r++) if (D(n[r], t[r])) return !1;
    return Fs > 0 && Rs && Rs.push(e), !0;
}
const Ea = "3.5.17",
    Ca = r,
    Ia = gn,
    xa = Dn,
    Aa = function e(t, n) {
        var r, i;
        if (((Dn = t), Dn)) (Dn.enabled = !0), Fn.forEach(({ event: e, args: t }) => Dn.emit(e, ...t)), (Fn = []);
        else if (
            "undefined" != typeof window &&
            window.HTMLElement &&
            !(null == (i = null == (r = window.navigator) ? void 0 : r.userAgent) ? void 0 : i.includes("jsdom"))
        ) {
            (n.__VUE_DEVTOOLS_HOOK_REPLAY__ = n.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((t) => {
                e(t, n);
            }),
                setTimeout(() => {
                    Dn || ((n.__VUE_DEVTOOLS_HOOK_REPLAY__ = null), (Fn = []));
                }, 3e3);
        } else Fn = [];
    },
    Pa = {
        createComponentInstance: ia,
        setupComponent: fa,
        renderComponentRoot: fs,
        setCurrentRenderingInstance: zn,
        isVNode: $s,
        normalizeVNode: Qs,
        getComponentPublicInstance: ka,
        ensureValidVNode: oi,
        pushWarningContext: function (e) {
            fn.push(e);
        },
        popWarningContext: function () {
            fn.pop();
        },
    };
let Oa;
const Na = "undefined" != typeof window && window.trustedTypes;
if (Na)
    try {
        Oa = Na.createPolicy("vue", { createHTML: (e) => e });
    } catch (ez) {}
const Ra = Oa ? (e) => Oa.createHTML(e) : (e) => e,
    Ma = "undefined" != typeof document ? document : null,
    Da = Ma && Ma.createElement("template"),
    Fa = {
        insert: (e, t, n) => {
            t.insertBefore(e, n || null);
        },
        remove: (e) => {
            const t = e.parentNode;
            t && t.removeChild(e);
        },
        createElement: (e, t, n, r) => {
            const i =
                "svg" === t
                    ? Ma.createElementNS("http://www.w3.org/2000/svg", e)
                    : "mathml" === t
                      ? Ma.createElementNS("http://www.w3.org/1998/Math/MathML", e)
                      : n
                        ? Ma.createElement(e, { is: n })
                        : Ma.createElement(e);
            return "select" === e && r && null != r.multiple && i.setAttribute("multiple", r.multiple), i;
        },
        createText: (e) => Ma.createTextNode(e),
        createComment: (e) => Ma.createComment(e),
        setText: (e, t) => {
            e.nodeValue = t;
        },
        setElementText: (e, t) => {
            e.textContent = t;
        },
        parentNode: (e) => e.parentNode,
        nextSibling: (e) => e.nextSibling,
        querySelector: (e) => Ma.querySelector(e),
        setScopeId(e, t) {
            e.setAttribute(t, "");
        },
        insertStaticContent(e, t, n, r, i, s) {
            const a = n ? n.previousSibling : t.lastChild;
            if (i && (i === s || i.nextSibling))
                for (; t.insertBefore(i.cloneNode(!0), n), i !== s && (i = i.nextSibling); );
            else {
                Da.innerHTML = Ra("svg" === r ? `<svg>${e}</svg>` : "mathml" === r ? `<math>${e}</math>` : e);
                const i = Da.content;
                if ("svg" === r || "mathml" === r) {
                    const e = i.firstChild;
                    for (; e.firstChild; ) i.appendChild(e.firstChild);
                    i.removeChild(e);
                }
                t.insertBefore(i, n);
            }
            return [a ? a.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild];
        },
    },
    La = "transition",
    Ba = "animation",
    za = Symbol("_vtc"),
    Ua = {
        name: String,
        type: String,
        css: { type: Boolean, default: !0 },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String,
    },
    $a = o({}, sr, Ua),
    Va = ((e) => ((e.displayName = "Transition"), (e.props = $a), e))((e, { slots: t }) => va(cr, Ha(e), t)),
    Wa = (e, t = []) => {
        d(e) ? e.forEach((e) => e(...t)) : e && e(...t);
    },
    ja = (e) => !!e && (d(e) ? e.some((e) => e.length > 1) : e.length > 1);
function Ha(e) {
    const t = {};
    for (const o in e) o in Ua || (t[o] = e[o]);
    if (!1 === e.css) return t;
    const {
            name: n = "v",
            type: r,
            duration: i,
            enterFromClass: s = `${n}-enter-from`,
            enterActiveClass: a = `${n}-enter-active`,
            enterToClass: c = `${n}-enter-to`,
            appearFromClass: l = s,
            appearActiveClass: u = a,
            appearToClass: d = c,
            leaveFromClass: h = `${n}-leave-from`,
            leaveActiveClass: m = `${n}-leave-active`,
            leaveToClass: p = `${n}-leave-to`,
        } = e,
        f = (function (e) {
            if (null == e) return null;
            if (w(e)) return [qa(e.enter), qa(e.leave)];
            {
                const t = qa(e);
                return [t, t];
            }
        })(i),
        g = f && f[0],
        b = f && f[1],
        {
            onBeforeEnter: y,
            onEnter: k,
            onEnterCancelled: T,
            onLeave: _,
            onLeaveCancelled: v,
            onBeforeAppear: S = y,
            onAppear: E = k,
            onAppearCancelled: C = T,
        } = t,
        I = (e, t, n, r) => {
            (e._enterCancelled = r), Ga(e, t ? d : c), Ga(e, t ? u : a), n && n();
        },
        x = (e, t) => {
            (e._isLeaving = !1), Ga(e, h), Ga(e, p), Ga(e, m), t && t();
        },
        A = (e) => (t, n) => {
            const i = e ? E : k,
                a = () => I(t, e, n);
            Wa(i, [t, a]),
                Ka(() => {
                    Ga(t, e ? l : s), Xa(t, e ? d : c), ja(i) || Qa(t, r, g, a);
                });
        };
    return o(t, {
        onBeforeEnter(e) {
            Wa(y, [e]), Xa(e, s), Xa(e, a);
        },
        onBeforeAppear(e) {
            Wa(S, [e]), Xa(e, l), Xa(e, u);
        },
        onEnter: A(!1),
        onAppear: A(!0),
        onLeave(e, t) {
            e._isLeaving = !0;
            const n = () => x(e, t);
            Xa(e, h),
                e._enterCancelled ? (Xa(e, m), to()) : (to(), Xa(e, m)),
                Ka(() => {
                    e._isLeaving && (Ga(e, h), Xa(e, p), ja(_) || Qa(e, r, b, n));
                }),
                Wa(_, [e, n]);
        },
        onEnterCancelled(e) {
            I(e, !1, void 0, !0), Wa(T, [e]);
        },
        onAppearCancelled(e) {
            I(e, !0, void 0, !0), Wa(C, [e]);
        },
        onLeaveCancelled(e) {
            x(e), Wa(v, [e]);
        },
    });
}
function qa(e) {
    return z(e);
}
function Xa(e, t) {
    t.split(/\s+/).forEach((t) => t && e.classList.add(t)), (e[za] || (e[za] = new Set())).add(t);
}
function Ga(e, t) {
    t.split(/\s+/).forEach((t) => t && e.classList.remove(t));
    const n = e[za];
    n && (n.delete(t), n.size || (e[za] = void 0));
}
function Ka(e) {
    requestAnimationFrame(() => {
        requestAnimationFrame(e);
    });
}
let Ya = 0;
function Qa(e, t, n, r) {
    const i = (e._endId = ++Ya),
        s = () => {
            i === e._endId && r();
        };
    if (null != n) return setTimeout(s, n);
    const { type: a, timeout: o, propCount: c } = Ja(e, t);
    if (!a) return r();
    const l = a + "end";
    let u = 0;
    const d = () => {
            e.removeEventListener(l, h), s();
        },
        h = (t) => {
            t.target === e && ++u >= c && d();
        };
    setTimeout(() => {
        u < c && d();
    }, o + 1),
        e.addEventListener(l, h);
}
function Ja(e, t) {
    const n = window.getComputedStyle(e),
        r = (e) => (n[e] || "").split(", "),
        i = r(`${La}Delay`),
        s = r(`${La}Duration`),
        a = Za(i, s),
        o = r(`${Ba}Delay`),
        c = r(`${Ba}Duration`),
        l = Za(o, c);
    let u = null,
        d = 0,
        h = 0;
    t === La
        ? a > 0 && ((u = La), (d = a), (h = s.length))
        : t === Ba
          ? l > 0 && ((u = Ba), (d = l), (h = c.length))
          : ((d = Math.max(a, l)),
            (u = d > 0 ? (a > l ? La : Ba) : null),
            (h = u ? (u === La ? s.length : c.length) : 0));
    return {
        type: u,
        timeout: d,
        propCount: h,
        hasTransform: u === La && /\b(transform|all)(,|$)/.test(r(`${La}Property`).toString()),
    };
}
function Za(e, t) {
    for (; e.length < t.length; ) e = e.concat(e);
    return Math.max(...t.map((t, n) => eo(t) + eo(e[n])));
}
function eo(e) {
    return "auto" === e ? 0 : 1e3 * Number(e.slice(0, -1).replace(",", "."));
}
function to() {
    return document.body.offsetHeight;
}
const no = Symbol("_vod"),
    ro = Symbol("_vsh"),
    io = {
        beforeMount(e, { value: t }, { transition: n }) {
            (e[no] = "none" === e.style.display ? "" : e.style.display), n && t ? n.beforeEnter(e) : so(e, t);
        },
        mounted(e, { value: t }, { transition: n }) {
            n && t && n.enter(e);
        },
        updated(e, { value: t, oldValue: n }, { transition: r }) {
            !t != !n &&
                (r
                    ? t
                        ? (r.beforeEnter(e), so(e, !0), r.enter(e))
                        : r.leave(e, () => {
                              so(e, !1);
                          })
                    : so(e, t));
        },
        beforeUnmount(e, { value: t }) {
            so(e, t);
        },
    };
function so(e, t) {
    (e.style.display = t ? e[no] : "none"), (e[ro] = !t);
}
const ao = Symbol("");
function oo(e, t) {
    if (128 & e.shapeFlag) {
        const n = e.suspense;
        (e = n.activeBranch),
            n.pendingBranch &&
                !n.isHydrating &&
                n.effects.push(() => {
                    oo(n.activeBranch, t);
                });
    }
    for (; e.component; ) e = e.component.subTree;
    if (1 & e.shapeFlag && e.el) co(e.el, t);
    else if (e.type === xs) e.children.forEach((e) => oo(e, t));
    else if (e.type === Os) {
        let { el: n, anchor: r } = e;
        for (; n && (co(n, t), n !== r); ) n = n.nextSibling;
    }
}
function co(e, t) {
    if (1 === e.nodeType) {
        const n = e.style;
        let r = "";
        for (const e in t) n.setProperty(`--${e}`, t[e]), (r += `--${e}: ${t[e]};`);
        n[ao] = r;
    }
}
const lo = /(^|;)\s*display\s*:/;
const uo = /\s*!important$/;
function ho(e, t, n) {
    if (d(n)) n.forEach((n) => ho(e, t, n));
    else if ((null == n && (n = ""), t.startsWith("--"))) e.setProperty(t, n);
    else {
        const r = (function (e, t) {
            const n = po[t];
            if (n) return n;
            let r = P(t);
            if ("filter" !== r && r in e) return (po[t] = r);
            r = R(r);
            for (let i = 0; i < mo.length; i++) {
                const n = mo[i] + r;
                if (n in e) return (po[t] = n);
            }
            return t;
        })(e, t);
        uo.test(n) ? e.setProperty(N(r), n.replace(uo, ""), "important") : (e[r] = n);
    }
}
const mo = ["Webkit", "Moz", "ms"],
    po = {};
const fo = "http://www.w3.org/1999/xlink";
function go(e, t, n, r, i, s = ae(t)) {
    r && t.startsWith("xlink:")
        ? null == n
            ? e.removeAttributeNS(fo, t.slice(6, t.length))
            : e.setAttributeNS(fo, t, n)
        : null == n || (s && !ce(n))
          ? e.removeAttribute(t)
          : e.setAttribute(t, s ? "" : y(n) ? String(n) : n);
}
function bo(e, t, n, r, i) {
    if ("innerHTML" === t || "textContent" === t) return void (null != n && (e[t] = "innerHTML" === t ? Ra(n) : n));
    const s = e.tagName;
    if ("value" === t && "PROGRESS" !== s && !s.includes("-")) {
        const r = "OPTION" === s ? e.getAttribute("value") || "" : e.value,
            i = null == n ? ("checkbox" === e.type ? "on" : "") : String(n);
        return (r === i && "_value" in e) || (e.value = i), null == n && e.removeAttribute(t), void (e._value = n);
    }
    let a = !1;
    if ("" === n || null == n) {
        const r = typeof e[t];
        "boolean" === r
            ? (n = ce(n))
            : null == n && "string" === r
              ? ((n = ""), (a = !0))
              : "number" === r && ((n = 0), (a = !0));
    }
    try {
        e[t] = n;
    } catch (ez) {}
    a && e.removeAttribute(i || t);
}
function yo(e, t, n, r) {
    e.addEventListener(t, n, r);
}
const wo = Symbol("_vei");
function ko(e, t, n, r, i = null) {
    const s = e[wo] || (e[wo] = {}),
        a = s[t];
    if (r && a) a.value = r;
    else {
        const [n, o] = (function (e) {
            let t;
            if (To.test(e)) {
                let n;
                for (t = {}; (n = e.match(To)); )
                    (e = e.slice(0, e.length - n[0].length)), (t[n[0].toLowerCase()] = !0);
            }
            const n = ":" === e[2] ? e.slice(3) : N(e.slice(2));
            return [n, t];
        })(t);
        if (r) {
            const a = (s[t] = (function (e, t) {
                const n = (e) => {
                    if (e._vts) {
                        if (e._vts <= n.attached) return;
                    } else e._vts = Date.now();
                    yn(
                        (function (e, t) {
                            if (d(t)) {
                                const n = e.stopImmediatePropagation;
                                return (
                                    (e.stopImmediatePropagation = () => {
                                        n.call(e), (e._stopped = !0);
                                    }),
                                    t.map((e) => (t) => !t._stopped && e && e(t))
                                );
                            }
                            return t;
                        })(e, n.value),
                        t,
                        5,
                        [e]
                    );
                };
                return (n.value = e), (n.attached = So()), n;
            })(r, i));
            yo(e, n, a, o);
        } else
            a &&
                (!(function (e, t, n, r) {
                    e.removeEventListener(t, n, r);
                })(e, n, a, o),
                (s[t] = void 0));
    }
}
const To = /(?:Once|Passive|Capture)$/;
let _o = 0;
const vo = Promise.resolve(),
    So = () => _o || (vo.then(() => (_o = 0)), (_o = Date.now()));
const Eo = (e) => 111 === e.charCodeAt(0) && 110 === e.charCodeAt(1) && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123;
const Co = {};
function Io(e, t, n) {
    const r = fr(e, t);
    S(r) && o(r, t);
    class i extends Ao {
        constructor(e) {
            super(r, e, n);
        }
    }
    return (i.def = r), i;
}
const xo = "undefined" != typeof HTMLElement ? HTMLElement : class {};
class Ao extends xo {
    constructor(e, t = {}, n = dc) {
        super(),
            (this._def = e),
            (this._props = t),
            (this._createApp = n),
            (this._isVueCE = !0),
            (this._instance = null),
            (this._app = null),
            (this._nonce = this._def.nonce),
            (this._connected = !1),
            (this._resolved = !1),
            (this._numberProps = null),
            (this._styleChildren = new WeakSet()),
            (this._ob = null),
            this.shadowRoot && n !== dc
                ? (this._root = this.shadowRoot)
                : !1 !== e.shadowRoot
                  ? (this.attachShadow({ mode: "open" }), (this._root = this.shadowRoot))
                  : (this._root = this);
    }
    connectedCallback() {
        if (!this.isConnected) return;
        this.shadowRoot || this._resolved || this._parseSlots(), (this._connected = !0);
        let e = this;
        for (; (e = e && (e.parentNode || e.host)); )
            if (e instanceof Ao) {
                this._parent = e;
                break;
            }
        this._instance ||
            (this._resolved
                ? this._mount(this._def)
                : e && e._pendingResolve
                  ? (this._pendingResolve = e._pendingResolve.then(() => {
                        (this._pendingResolve = void 0), this._resolveDef();
                    }))
                  : this._resolveDef());
    }
    _setParent(e = this._parent) {
        e && ((this._instance.parent = e._instance), this._inheritParentContext(e));
    }
    _inheritParentContext(e = this._parent) {
        e && this._app && Object.setPrototypeOf(this._app._context.provides, e._instance.provides);
    }
    disconnectedCallback() {
        (this._connected = !1),
            In(() => {
                this._connected ||
                    (this._ob && (this._ob.disconnect(), (this._ob = null)),
                    this._app && this._app.unmount(),
                    this._instance && (this._instance.ce = void 0),
                    (this._app = this._instance = null));
            });
    }
    _resolveDef() {
        if (this._pendingResolve) return;
        for (let n = 0; n < this.attributes.length; n++) this._setAttr(this.attributes[n].name);
        (this._ob = new MutationObserver((e) => {
            for (const t of e) this._setAttr(t.attributeName);
        })),
            this._ob.observe(this, { attributes: !0 });
        const e = (e, t = !1) => {
                (this._resolved = !0), (this._pendingResolve = void 0);
                const { props: n, styles: r } = e;
                let i;
                if (n && !d(n))
                    for (const s in n) {
                        const e = n[s];
                        (e === Number || (e && e.type === Number)) &&
                            (s in this._props && (this._props[s] = z(this._props[s])),
                            ((i || (i = Object.create(null)))[P(s)] = !0));
                    }
                (this._numberProps = i), this._resolveProps(e), this.shadowRoot && this._applyStyles(r), this._mount(e);
            },
            t = this._def.__asyncLoader;
        t
            ? (this._pendingResolve = t().then((t) => {
                  (t.configureApp = this._def.configureApp), e((this._def = t), !0);
              }))
            : e(this._def);
    }
    _mount(e) {
        (this._app = this._createApp(e)),
            this._inheritParentContext(),
            e.configureApp && e.configureApp(this._app),
            (this._app._ceVNode = this._createVNode()),
            this._app.mount(this._root);
        const t = this._instance && this._instance.exposed;
        if (t) for (const n in t) u(this, n) || Object.defineProperty(this, n, { get: () => Zt(t[n]) });
    }
    _resolveProps(e) {
        const { props: t } = e,
            n = d(t) ? t : Object.keys(t || {});
        for (const r of Object.keys(this)) "_" !== r[0] && n.includes(r) && this._setProp(r, this[r]);
        for (const r of n.map(P))
            Object.defineProperty(this, r, {
                get() {
                    return this._getProp(r);
                },
                set(e) {
                    this._setProp(r, e, !0, !0);
                },
            });
    }
    _setAttr(e) {
        if (e.startsWith("data-v-")) return;
        const t = this.hasAttribute(e);
        let n = t ? this.getAttribute(e) : Co;
        const r = P(e);
        t && this._numberProps && this._numberProps[r] && (n = z(n)), this._setProp(r, n, !1, !0);
    }
    _getProp(e) {
        return this._props[e];
    }
    _setProp(e, t, n = !0, r = !1) {
        if (
            t !== this._props[e] &&
            (t === Co
                ? delete this._props[e]
                : ((this._props[e] = t), "key" === e && this._app && (this._app._ceVNode.key = t)),
            r && this._instance && this._update(),
            n)
        ) {
            const n = this._ob;
            n && n.disconnect(),
                !0 === t
                    ? this.setAttribute(N(e), "")
                    : "string" == typeof t || "number" == typeof t
                      ? this.setAttribute(N(e), t + "")
                      : t || this.removeAttribute(N(e)),
                n && n.observe(this, { attributes: !0 });
        }
    }
    _update() {
        const e = this._createVNode();
        this._app && (e.appContext = this._app._context), uc(e, this._root);
    }
    _createVNode() {
        const e = {};
        this.shadowRoot || (e.onVnodeMounted = e.onVnodeUpdated = this._renderSlots.bind(this));
        const t = qs(this._def, o(e, this._props));
        return (
            this._instance ||
                (t.ce = (e) => {
                    (this._instance = e), (e.ce = this), (e.isCE = !0);
                    const t = (e, t) => {
                        this.dispatchEvent(new CustomEvent(e, S(t[0]) ? o({ detail: t }, t[0]) : { detail: t }));
                    };
                    (e.emit = (e, ...n) => {
                        t(e, n), N(e) !== e && t(N(e), n);
                    }),
                        this._setParent();
                }),
            t
        );
    }
    _applyStyles(e, t) {
        if (!e) return;
        if (t) {
            if (t === this._def || this._styleChildren.has(t)) return;
            this._styleChildren.add(t);
        }
        const n = this._nonce;
        for (let r = e.length - 1; r >= 0; r--) {
            const t = document.createElement("style");
            n && t.setAttribute("nonce", n), (t.textContent = e[r]), this.shadowRoot.prepend(t);
        }
    }
    _parseSlots() {
        const e = (this._slots = {});
        let t;
        for (; (t = this.firstChild); ) {
            const n = (1 === t.nodeType && t.getAttribute("slot")) || "default";
            (e[n] || (e[n] = [])).push(t), this.removeChild(t);
        }
    }
    _renderSlots() {
        const e = (this._teleportTarget || this).querySelectorAll("slot"),
            t = this._instance.type.__scopeId;
        for (let n = 0; n < e.length; n++) {
            const r = e[n],
                i = r.getAttribute("name") || "default",
                s = this._slots[i],
                a = r.parentNode;
            if (s)
                for (const e of s) {
                    if (t && 1 === e.nodeType) {
                        const n = t + "-s",
                            r = document.createTreeWalker(e, 1);
                        let i;
                        for (e.setAttribute(n, ""); (i = r.nextNode()); ) i.setAttribute(n, "");
                    }
                    a.insertBefore(e, r);
                }
            else for (; r.firstChild; ) a.insertBefore(r.firstChild, r);
            a.removeChild(r);
        }
    }
    _injectChildStyle(e) {
        this._applyStyles(e.styles, e);
    }
    _removeChildStyle(e) {}
}
function Po(e) {
    const t = aa(),
        n = t && t.ce;
    return n || null;
}
const Oo = new WeakMap(),
    No = new WeakMap(),
    Ro = Symbol("_moveCb"),
    Mo = Symbol("_enterCb"),
    Do = ((e) => (delete e.props.mode, e))({
        name: "TransitionGroup",
        props: o({}, $a, { tag: String, moveClass: String }),
        setup(e, { slots: t }) {
            const n = aa(),
                r = rr();
            let i, s;
            return (
                jr(() => {
                    if (!i.length) return;
                    const t = e.moveClass || `${e.name || "v"}-move`;
                    if (
                        !(function (e, t, n) {
                            const r = e.cloneNode(),
                                i = e[za];
                            i &&
                                i.forEach((e) => {
                                    e.split(/\s+/).forEach((e) => e && r.classList.remove(e));
                                });
                            n.split(/\s+/).forEach((e) => e && r.classList.add(e)), (r.style.display = "none");
                            const s = 1 === t.nodeType ? t : t.parentNode;
                            s.appendChild(r);
                            const { hasTransform: a } = Ja(r);
                            return s.removeChild(r), a;
                        })(i[0].el, n.vnode.el, t)
                    )
                        return void (i = []);
                    i.forEach(Lo), i.forEach(Bo);
                    const r = i.filter(zo);
                    to(),
                        r.forEach((e) => {
                            const n = e.el,
                                r = n.style;
                            Xa(n, t), (r.transform = r.webkitTransform = r.transitionDuration = "");
                            const i = (n[Ro] = (e) => {
                                (e && e.target !== n) ||
                                    (e && !/transform$/.test(e.propertyName)) ||
                                    (n.removeEventListener("transitionend", i), (n[Ro] = null), Ga(n, t));
                            });
                            n.addEventListener("transitionend", i);
                        }),
                        (i = []);
                }),
                () => {
                    const a = jt(e),
                        o = Ha(a);
                    let c = a.tag || xs;
                    if (((i = []), s))
                        for (let e = 0; e < s.length; e++) {
                            const t = s[e];
                            t.el &&
                                t.el instanceof Element &&
                                (i.push(t), mr(t, ur(t, o, r, n)), Oo.set(t, t.el.getBoundingClientRect()));
                        }
                    s = t.default ? pr(t.default()) : [];
                    for (let e = 0; e < s.length; e++) {
                        const t = s[e];
                        null != t.key && mr(t, ur(t, o, r, n));
                    }
                    return qs(c, null, s);
                }
            );
        },
    }),
    Fo = Do;
function Lo(e) {
    const t = e.el;
    t[Ro] && t[Ro](), t[Mo] && t[Mo]();
}
function Bo(e) {
    No.set(e, e.el.getBoundingClientRect());
}
function zo(e) {
    const t = Oo.get(e),
        n = No.get(e),
        r = t.left - n.left,
        i = t.top - n.top;
    if (r || i) {
        const t = e.el.style;
        return (t.transform = t.webkitTransform = `translate(${r}px,${i}px)`), (t.transitionDuration = "0s"), e;
    }
}
const Uo = (e) => {
    const t = e.props["onUpdate:modelValue"] || !1;
    return d(t) ? (e) => F(t, e) : t;
};
function $o(e) {
    e.target.composing = !0;
}
function Vo(e) {
    const t = e.target;
    t.composing && ((t.composing = !1), t.dispatchEvent(new Event("input")));
}
const Wo = Symbol("_assign"),
    jo = {
        created(e, { modifiers: { lazy: t, trim: n, number: r } }, i) {
            e[Wo] = Uo(i);
            const s = r || (i.props && "number" === i.props.type);
            yo(e, t ? "change" : "input", (t) => {
                if (t.target.composing) return;
                let r = e.value;
                n && (r = r.trim()), s && (r = B(r)), e[Wo](r);
            }),
                n &&
                    yo(e, "change", () => {
                        e.value = e.value.trim();
                    }),
                t || (yo(e, "compositionstart", $o), yo(e, "compositionend", Vo), yo(e, "change", Vo));
        },
        mounted(e, { value: t }) {
            e.value = null == t ? "" : t;
        },
        beforeUpdate(e, { value: t, oldValue: n, modifiers: { lazy: r, trim: i, number: s } }, a) {
            if (((e[Wo] = Uo(a)), e.composing)) return;
            const o = null == t ? "" : t;
            if (((!s && "number" !== e.type) || /^0\d/.test(e.value) ? e.value : B(e.value)) !== o) {
                if (document.activeElement === e && "range" !== e.type) {
                    if (r && t === n) return;
                    if (i && e.value.trim() === o) return;
                }
                e.value = o;
            }
        },
    },
    Ho = {
        deep: !0,
        created(e, t, n) {
            (e[Wo] = Uo(n)),
                yo(e, "change", () => {
                    const t = e._modelValue,
                        n = Yo(e),
                        r = e.checked,
                        i = e[Wo];
                    if (d(t)) {
                        const e = ye(t, n),
                            s = -1 !== e;
                        if (r && !s) i(t.concat(n));
                        else if (!r && s) {
                            const n = [...t];
                            n.splice(e, 1), i(n);
                        }
                    } else if (m(t)) {
                        const e = new Set(t);
                        r ? e.add(n) : e.delete(n), i(e);
                    } else i(Qo(e, r));
                });
        },
        mounted: qo,
        beforeUpdate(e, t, n) {
            (e[Wo] = Uo(n)), qo(e, t, n);
        },
    };
function qo(e, { value: t, oldValue: n }, r) {
    let i;
    if (((e._modelValue = t), d(t))) i = ye(t, r.props.value) > -1;
    else if (m(t)) i = t.has(r.props.value);
    else {
        if (t === n) return;
        i = be(t, Qo(e, !0));
    }
    e.checked !== i && (e.checked = i);
}
const Xo = {
        created(e, { value: t }, n) {
            (e.checked = be(t, n.props.value)),
                (e[Wo] = Uo(n)),
                yo(e, "change", () => {
                    e[Wo](Yo(e));
                });
        },
        beforeUpdate(e, { value: t, oldValue: n }, r) {
            (e[Wo] = Uo(r)), t !== n && (e.checked = be(t, r.props.value));
        },
    },
    Go = {
        deep: !0,
        created(e, { value: t, modifiers: { number: n } }, r) {
            const i = m(t);
            yo(e, "change", () => {
                const t = Array.prototype.filter.call(e.options, (e) => e.selected).map((e) => (n ? B(Yo(e)) : Yo(e)));
                e[Wo](e.multiple ? (i ? new Set(t) : t) : t[0]),
                    (e._assigning = !0),
                    In(() => {
                        e._assigning = !1;
                    });
            }),
                (e[Wo] = Uo(r));
        },
        mounted(e, { value: t }) {
            Ko(e, t);
        },
        beforeUpdate(e, t, n) {
            e[Wo] = Uo(n);
        },
        updated(e, { value: t }) {
            e._assigning || Ko(e, t);
        },
    };
function Ko(e, t) {
    const n = e.multiple,
        r = d(t);
    if (!n || r || m(t)) {
        for (let i = 0, s = e.options.length; i < s; i++) {
            const s = e.options[i],
                a = Yo(s);
            if (n)
                if (r) {
                    const e = typeof a;
                    s.selected =
                        "string" === e || "number" === e ? t.some((e) => String(e) === String(a)) : ye(t, a) > -1;
                } else s.selected = t.has(a);
            else if (be(Yo(s), t)) return void (e.selectedIndex !== i && (e.selectedIndex = i));
        }
        n || -1 === e.selectedIndex || (e.selectedIndex = -1);
    }
}
function Yo(e) {
    return "_value" in e ? e._value : e.value;
}
function Qo(e, t) {
    const n = t ? "_trueValue" : "_falseValue";
    return n in e ? e[n] : t;
}
const Jo = {
    created(e, t, n) {
        ec(e, t, n, null, "created");
    },
    mounted(e, t, n) {
        ec(e, t, n, null, "mounted");
    },
    beforeUpdate(e, t, n, r) {
        ec(e, t, n, r, "beforeUpdate");
    },
    updated(e, t, n, r) {
        ec(e, t, n, r, "updated");
    },
};
function Zo(e, t) {
    switch (e) {
        case "SELECT":
            return Go;
        case "TEXTAREA":
            return jo;
        default:
            switch (t) {
                case "checkbox":
                    return Ho;
                case "radio":
                    return Xo;
                default:
                    return jo;
            }
    }
}
function ec(e, t, n, r, i) {
    const s = Zo(e.tagName, n.props && n.props.type)[i];
    s && s(e, t, n, r);
}
const tc = ["ctrl", "shift", "alt", "meta"],
    nc = {
        stop: (e) => e.stopPropagation(),
        prevent: (e) => e.preventDefault(),
        self: (e) => e.target !== e.currentTarget,
        ctrl: (e) => !e.ctrlKey,
        shift: (e) => !e.shiftKey,
        alt: (e) => !e.altKey,
        meta: (e) => !e.metaKey,
        left: (e) => "button" in e && 0 !== e.button,
        middle: (e) => "button" in e && 1 !== e.button,
        right: (e) => "button" in e && 2 !== e.button,
        exact: (e, t) => tc.some((n) => e[`${n}Key`] && !t.includes(n)),
    },
    rc = (e, t) => {
        const n = e._withMods || (e._withMods = {}),
            r = t.join(".");
        return (
            n[r] ||
            (n[r] = (n, ...r) => {
                for (let e = 0; e < t.length; e++) {
                    const r = nc[t[e]];
                    if (r && r(n, t)) return;
                }
                return e(n, ...r);
            })
        );
    },
    ic = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace",
    },
    sc = o(
        {
            patchProp: (e, t, n, r, i, o) => {
                const c = "svg" === i;
                "class" === t
                    ? (function (e, t, n) {
                          const r = e[za];
                          r && (t = (t ? [t, ...r] : [...r]).join(" ")),
                              null == t
                                  ? e.removeAttribute("class")
                                  : n
                                    ? e.setAttribute("class", t)
                                    : (e.className = t);
                      })(e, r, c)
                    : "style" === t
                      ? (function (e, t, n) {
                            const r = e.style,
                                i = b(n);
                            let s = !1;
                            if (n && !i) {
                                if (t)
                                    if (b(t))
                                        for (const e of t.split(";")) {
                                            const t = e.slice(0, e.indexOf(":")).trim();
                                            null == n[t] && ho(r, t, "");
                                        }
                                    else for (const e in t) null == n[e] && ho(r, e, "");
                                for (const e in n) "display" === e && (s = !0), ho(r, e, n[e]);
                            } else if (i) {
                                if (t !== n) {
                                    const e = r[ao];
                                    e && (n += ";" + e), (r.cssText = n), (s = lo.test(n));
                                }
                            } else t && e.removeAttribute("style");
                            no in e && ((e[no] = s ? r.display : ""), e[ro] && (r.display = "none"));
                        })(e, n, r)
                      : s(t)
                        ? a(t) || ko(e, t, 0, r, o)
                        : (
                                "." === t[0]
                                    ? ((t = t.slice(1)), 1)
                                    : "^" === t[0]
                                      ? ((t = t.slice(1)), 0)
                                      : (function (e, t, n, r) {
                                            if (r)
                                                return (
                                                    "innerHTML" === t ||
                                                    "textContent" === t ||
                                                    !!(t in e && Eo(t) && g(n))
                                                );
                                            if (
                                                "spellcheck" === t ||
                                                "draggable" === t ||
                                                "translate" === t ||
                                                "autocorrect" === t
                                            )
                                                return !1;
                                            if ("form" === t) return !1;
                                            if ("list" === t && "INPUT" === e.tagName) return !1;
                                            if ("type" === t && "TEXTAREA" === e.tagName) return !1;
                                            if ("width" === t || "height" === t) {
                                                const t = e.tagName;
                                                if ("IMG" === t || "VIDEO" === t || "CANVAS" === t || "SOURCE" === t)
                                                    return !1;
                                            }
                                            if (Eo(t) && b(n)) return !1;
                                            return t in e;
                                        })(e, t, r, c)
                            )
                          ? (bo(e, t, r),
                            e.tagName.includes("-") ||
                                ("value" !== t && "checked" !== t && "selected" !== t) ||
                                go(e, t, r, c, 0, "value" !== t))
                          : !e._isVueCE || (!/[A-Z]/.test(t) && b(r))
                            ? ("true-value" === t ? (e._trueValue = r) : "false-value" === t && (e._falseValue = r),
                              go(e, t, r, c))
                            : bo(e, P(t), r, 0, t);
            },
        },
        Fa
    );
let ac,
    oc = !1;
function cc() {
    return ac || (ac = Ki(sc));
}
function lc() {
    return (ac = oc ? ac : Yi(sc)), (oc = !0), ac;
}
const uc = (...e) => {
        cc().render(...e);
    },
    dc = (...e) => {
        const t = cc().createApp(...e),
            { mount: n } = t;
        return (
            (t.mount = (e) => {
                const r = pc(e);
                if (!r) return;
                const i = t._component;
                g(i) || i.render || i.template || (i.template = r.innerHTML), 1 === r.nodeType && (r.textContent = "");
                const s = n(r, !1, mc(r));
                return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), s;
            }),
            t
        );
    },
    hc = (...e) => {
        const t = lc().createApp(...e),
            { mount: n } = t;
        return (
            (t.mount = (e) => {
                const t = pc(e);
                if (t) return n(t, !0, mc(t));
            }),
            t
        );
    };
function mc(e) {
    return e instanceof SVGElement
        ? "svg"
        : "function" == typeof MathMLElement && e instanceof MathMLElement
          ? "mathml"
          : void 0;
}
function pc(e) {
    if (b(e)) {
        return document.querySelector(e);
    }
    return e;
}
let fc = !1;
const gc = Object.freeze(
    Object.defineProperty(
        {
            __proto__: null,
            BaseTransition: cr,
            BaseTransitionPropsValidators: sr,
            Comment: Ps,
            DeprecationTypes: null,
            EffectScope: Ce,
            ErrorCodes: {
                SETUP_FUNCTION: 0,
                0: "SETUP_FUNCTION",
                RENDER_FUNCTION: 1,
                1: "RENDER_FUNCTION",
                NATIVE_EVENT_HANDLER: 5,
                5: "NATIVE_EVENT_HANDLER",
                COMPONENT_EVENT_HANDLER: 6,
                6: "COMPONENT_EVENT_HANDLER",
                VNODE_HOOK: 7,
                7: "VNODE_HOOK",
                DIRECTIVE_HOOK: 8,
                8: "DIRECTIVE_HOOK",
                TRANSITION_HOOK: 9,
                9: "TRANSITION_HOOK",
                APP_ERROR_HANDLER: 10,
                10: "APP_ERROR_HANDLER",
                APP_WARN_HANDLER: 11,
                11: "APP_WARN_HANDLER",
                FUNCTION_REF: 12,
                12: "FUNCTION_REF",
                ASYNC_COMPONENT_LOADER: 13,
                13: "ASYNC_COMPONENT_LOADER",
                SCHEDULER: 14,
                14: "SCHEDULER",
                COMPONENT_UPDATE: 15,
                15: "COMPONENT_UPDATE",
                APP_UNMOUNT_CLEANUP: 16,
                16: "APP_UNMOUNT_CLEANUP",
            },
            ErrorTypeStrings: Ia,
            Fragment: xs,
            KeepAlive: Or,
            ReactiveEffect: Ae,
            Static: Os,
            Suspense: _s,
            Teleport: Jn,
            Text: As,
            TrackOpTypes: { GET: "get", HAS: "has", ITERATE: "iterate" },
            Transition: Va,
            TransitionGroup: Fo,
            TriggerOpTypes: { SET: "set", ADD: "add", DELETE: "delete", CLEAR: "clear" },
            VueElement: Ao,
            assertNumber: function (e, t) {},
            callWithAsyncErrorHandling: yn,
            callWithErrorHandling: bn,
            camelize: P,
            capitalize: R,
            cloneVNode: Gs,
            compatUtils: null,
            computed: _a,
            createApp: dc,
            createBlock: Us,
            createCommentVNode: Ys,
            createElementBlock: zs,
            createElementVNode: Hs,
            createHydrationRenderer: Yi,
            createPropsRestProxy: function (e, t) {
                const n = {};
                for (const r in e) t.includes(r) || Object.defineProperty(n, r, { enumerable: !0, get: () => e[r] });
                return n;
            },
            createRenderer: Ki,
            createSSRApp: hc,
            createSlots: si,
            createStaticVNode: function (e, t) {
                const n = qs(Os, null, e);
                return (n.staticCount = t), n;
            },
            createTextVNode: Ks,
            createVNode: qs,
            customRef: rn,
            defineAsyncComponent: function (e) {
                g(e) && (e = { loader: e });
                const {
                    loader: t,
                    loadingComponent: n,
                    errorComponent: r,
                    delay: i = 200,
                    hydrate: s,
                    timeout: a,
                    suspensible: o = !0,
                    onError: c,
                } = e;
                let l,
                    u = null,
                    d = 0;
                const h = () => {
                    let e;
                    return (
                        u ||
                        (e = u =
                            t()
                                .catch((e) => {
                                    if (((e = e instanceof Error ? e : new Error(String(e))), c))
                                        return new Promise((t, n) => {
                                            c(
                                                e,
                                                () => t((d++, (u = null), h())),
                                                () => n(e),
                                                d + 1
                                            );
                                        });
                                    throw e;
                                })
                                .then((t) =>
                                    e !== u && u
                                        ? u
                                        : (t && (t.__esModule || "Module" === t[Symbol.toStringTag]) && (t = t.default),
                                          (l = t),
                                          t)
                                ))
                    );
                };
                return fr({
                    name: "AsyncComponentWrapper",
                    __asyncLoader: h,
                    __asyncHydrate(e, t, n) {
                        const r = s
                            ? () => {
                                  const r = s(
                                      () => {
                                          n();
                                      },
                                      (t) =>
                                          (function (e, t) {
                                              if (Tr(e) && "[" === e.data) {
                                                  let n = 1,
                                                      r = e.nextSibling;
                                                  for (; r; ) {
                                                      if (1 === r.nodeType) {
                                                          if (!1 === t(r)) break;
                                                      } else if (Tr(r))
                                                          if ("]" === r.data) {
                                                              if (0 === --n) break;
                                                          } else "[" === r.data && n++;
                                                      r = r.nextSibling;
                                                  }
                                              } else t(e);
                                          })(e, t)
                                  );
                                  r && (t.bum || (t.bum = [])).push(r), (t.u || (t.u = [])).push(() => !0);
                              }
                            : n;
                        l ? r() : h().then(() => !t.isUnmounted && r());
                    },
                    get __asyncResolved() {
                        return l;
                    },
                    setup() {
                        const e = sa;
                        if ((gr(e), l)) return () => Ar(l, e);
                        const t = (t) => {
                            (u = null), wn(t, e, 13, !r);
                        };
                        if ((o && e.suspense) || pa)
                            return h()
                                .then((t) => () => Ar(t, e))
                                .catch((e) => (t(e), () => (r ? qs(r, { error: e }) : null)));
                        const s = Kt(!1),
                            c = Kt(),
                            d = Kt(!!i);
                        return (
                            i &&
                                setTimeout(() => {
                                    d.value = !1;
                                }, i),
                            null != a &&
                                setTimeout(() => {
                                    if (!s.value && !c.value) {
                                        const e = new Error(`Async component timed out after ${a}ms.`);
                                        t(e), (c.value = e);
                                    }
                                }, a),
                            h()
                                .then(() => {
                                    (s.value = !0), e.parent && Pr(e.parent.vnode) && e.parent.update();
                                })
                                .catch((e) => {
                                    t(e), (c.value = e);
                                }),
                            () =>
                                s.value && l
                                    ? Ar(l, e)
                                    : c.value && r
                                      ? qs(r, { error: c.value })
                                      : n && !d.value
                                        ? qs(n)
                                        : void 0
                        );
                    },
                });
            },
            defineComponent: fr,
            defineCustomElement: Io,
            defineEmits: function () {
                return null;
            },
            defineExpose: function (e) {},
            defineModel: function () {},
            defineOptions: function (e) {},
            defineProps: function () {
                return null;
            },
            defineSSRCustomElement: (e, t) => Io(e, t, hc),
            defineSlots: function () {
                return null;
            },
            devtools: xa,
            effect: function (e, t) {
                e.effect instanceof Ae && (e = e.effect.fn);
                const n = new Ae(e);
                t && o(n, t);
                try {
                    n.run();
                } catch (i) {
                    throw (n.stop(), i);
                }
                const r = n.run.bind(n);
                return (r.effect = n), r;
            },
            effectScope: function (e) {
                return new Ce(e);
            },
            getCurrentInstance: aa,
            getCurrentScope: Ie,
            getCurrentWatcher: function () {
                return hn;
            },
            getTransitionRawChildren: pr,
            guardReactiveProps: Xs,
            h: va,
            handleError: wn,
            hasInjectionContext: function () {
                return !!(sa || Ln || Oi);
            },
            hydrate: (...e) => {
                lc().hydrate(...e);
            },
            hydrateOnIdle:
                (e = 1e4) =>
                (t) => {
                    const n = Cr(t, { timeout: e });
                    return () => Ir(n);
                },
            hydrateOnInteraction:
                (e = []) =>
                (t, n) => {
                    b(e) && (e = [e]);
                    let r = !1;
                    const i = (e) => {
                            r || ((r = !0), s(), t(), e.target.dispatchEvent(new e.constructor(e.type, e)));
                        },
                        s = () => {
                            n((t) => {
                                for (const n of e) t.removeEventListener(n, i);
                            });
                        };
                    return (
                        n((t) => {
                            for (const n of e) t.addEventListener(n, i, { once: !0 });
                        }),
                        s
                    );
                },
            hydrateOnMediaQuery: (e) => (t) => {
                if (e) {
                    const n = matchMedia(e);
                    if (!n.matches)
                        return n.addEventListener("change", t, { once: !0 }), () => n.removeEventListener("change", t);
                    t();
                }
            },
            hydrateOnVisible: (e) => (t, n) => {
                const r = new IntersectionObserver((e) => {
                    for (const n of e)
                        if (n.isIntersecting) {
                            r.disconnect(), t();
                            break;
                        }
                }, e);
                return (
                    n((e) => {
                        if (e instanceof Element)
                            return (function (e) {
                                const { top: t, left: n, bottom: r, right: i } = e.getBoundingClientRect(),
                                    { innerHeight: s, innerWidth: a } = window;
                                return ((t > 0 && t < s) || (r > 0 && r < s)) && ((n > 0 && n < a) || (i > 0 && i < a));
                            })(e)
                                ? (t(), r.disconnect(), !1)
                                : void r.observe(e);
                    }),
                    () => r.disconnect()
                );
            },
            initCustomFormatter: function () {},
            initDirectivesForSSR: () => {
                fc ||
                    ((fc = !0),
                    (jo.getSSRProps = ({ value: e }) => ({ value: e })),
                    (Xo.getSSRProps = ({ value: e }, t) => {
                        if (t.props && be(t.props.value, e)) return { checked: !0 };
                    }),
                    (Ho.getSSRProps = ({ value: e }, t) => {
                        if (d(e)) {
                            if (t.props && ye(e, t.props.value) > -1) return { checked: !0 };
                        } else if (m(e)) {
                            if (t.props && e.has(t.props.value)) return { checked: !0 };
                        } else if (e) return { checked: !0 };
                    }),
                    (Jo.getSSRProps = (e, t) => {
                        if ("string" != typeof t.type) return;
                        const n = Zo(t.type.toUpperCase(), t.props && t.props.type);
                        return n.getSSRProps ? n.getSSRProps(e, t) : void 0;
                    }),
                    (io.getSSRProps = ({ value: e }) => {
                        if (!e) return { style: { display: "none" } };
                    }));
            },
            inject: Ri,
            isMemoSame: Sa,
            isProxy: Wt,
            isReactive: Ut,
            isReadonly: $t,
            isRef: Gt,
            isRuntimeOnly: () => !ha,
            isShallow: Vt,
            isVNode: $s,
            markRaw: Ht,
            mergeDefaults: function (e, t) {
                const n = fi(e);
                for (const r in t) {
                    if (r.startsWith("__skip")) continue;
                    let e = n[r];
                    e
                        ? d(e) || g(e)
                            ? (e = n[r] = { type: e, default: t[r] })
                            : (e.default = t[r])
                        : null === e && (e = n[r] = { default: t[r] }),
                        e && t[`__skip_${r}`] && (e.skipFactory = !0);
                }
                return n;
            },
            mergeModels: function (e, t) {
                return e && t ? (d(e) && d(t) ? e.concat(t) : o({}, fi(e), fi(t))) : e || t;
            },
            mergeProps: ea,
            nextTick: In,
            normalizeClass: Z,
            normalizeProps: ee,
            normalizeStyle: G,
            onActivated: Rr,
            onBeforeMount: $r,
            onBeforeUnmount: Hr,
            onBeforeUpdate: Wr,
            onDeactivated: Mr,
            onErrorCaptured: Yr,
            onMounted: Vr,
            onRenderTracked: Kr,
            onRenderTriggered: Gr,
            onScopeDispose: function (e, t = !1) {
                Se && Se.cleanups.push(e);
            },
            onServerPrefetch: Xr,
            onUnmounted: qr,
            onUpdated: jr,
            onWatcherCleanup: mn,
            openBlock: Ms,
            popScopeId: function () {
                Bn = null;
            },
            provide: Ni,
            proxyRefs: tn,
            pushScopeId: function (e) {
                Bn = e;
            },
            queuePostFlushCb: Pn,
            reactive: Dt,
            readonly: Lt,
            ref: Kt,
            registerRuntimeCompiler: function (e) {
                (ha = e),
                    (ma = (e) => {
                        e.render._rc && (e.withProxy = new Proxy(e.ctx, mi));
                    });
            },
            render: uc,
            renderList: ii,
            renderSlot: ai,
            resolveComponent: Jr,
            resolveDirective: ti,
            resolveDynamicComponent: ei,
            resolveFilter: null,
            resolveTransitionHooks: ur,
            setBlockTracking: Ls,
            setDevtoolsHook: Aa,
            setTransitionHooks: mr,
            shallowReactive: Ft,
            shallowReadonly: Bt,
            shallowRef: Yt,
            ssrContextKey: is,
            ssrUtils: Pa,
            stop: function (e) {
                e.effect.stop();
            },
            toDisplayString: ke,
            toHandlerKey: M,
            toHandlers: ci,
            toRaw: jt,
            toRef: function (e, t, n) {
                return Gt(e) ? e : g(e) ? new on(e) : w(e) && arguments.length > 1 ? cn(e, t, n) : Kt(e);
            },
            toRefs: sn,
            toValue: function (e) {
                return g(e) ? e() : Zt(e);
            },
            transformVNodeArgs: function (e) {},
            triggerRef: function (e) {
                e.dep && e.dep.trigger();
            },
            unref: Zt,
            useAttrs: function () {
                return pi().attrs;
            },
            useCssModule: function (e = "$style") {
                {
                    const n = aa();
                    if (!n) return t;
                    const r = n.type.__cssModules;
                    if (!r) return t;
                    const i = r[e];
                    return i || t;
                }
            },
            useCssVars: function (e) {
                const t = aa();
                if (!t) return;
                const n = (t.ut = (n = e(t.proxy)) => {
                        Array.from(document.querySelectorAll(`[data-v-owner="${t.uid}"]`)).forEach((e) => co(e, n));
                    }),
                    i = () => {
                        const r = e(t.proxy);
                        t.ce ? co(t.ce, r) : oo(t.subTree, r), n(r);
                    };
                Wr(() => {
                    Pn(i);
                }),
                    Vr(() => {
                        os(i, r, { flush: "post" });
                        const e = new MutationObserver(i);
                        e.observe(t.subTree.el.parentNode, { childList: !0 }), qr(() => e.disconnect());
                    });
            },
            useHost: Po,
            useId: function () {
                const e = aa();
                return e ? (e.appContext.config.idPrefix || "v") + "-" + e.ids[0] + e.ids[1]++ : "";
            },
            useModel: function (e, n, r = t) {
                const i = aa(),
                    s = P(n),
                    a = N(n),
                    o = ds(e, s),
                    c = rn((o, c) => {
                        let l,
                            u,
                            d = t;
                        return (
                            as(() => {
                                const t = e[s];
                                D(l, t) && ((l = t), c());
                            }),
                            {
                                get: () => (o(), r.get ? r.get(l) : l),
                                set(e) {
                                    const o = r.set ? r.set(e) : e;
                                    if (!(D(o, l) || (d !== t && D(e, d)))) return;
                                    const h = i.vnode.props;
                                    (h &&
                                        (n in h || s in h || a in h) &&
                                        (`onUpdate:${n}` in h || `onUpdate:${s}` in h || `onUpdate:${a}` in h)) ||
                                        ((l = e), c()),
                                        i.emit(`update:${n}`, o),
                                        D(e, o) && D(e, d) && !D(o, u) && c(),
                                        (d = e),
                                        (u = o);
                                },
                            }
                        );
                    });
                return (
                    (c[Symbol.iterator] = () => {
                        let e = 0;
                        return { next: () => (e < 2 ? { value: e++ ? o || t : c, done: !1 } : { done: !0 }) };
                    }),
                    c
                );
            },
            useSSRContext: ss,
            useShadowRoot: function () {
                const e = Po();
                return e && e.shadowRoot;
            },
            useSlots: function () {
                return pi().slots;
            },
            useTemplateRef: function (e) {
                const n = aa(),
                    r = Yt(null);
                if (n) {
                    const i = n.refs === t ? (n.refs = {}) : n.refs;
                    Object.defineProperty(i, e, { enumerable: !0, get: () => r.value, set: (e) => (r.value = e) });
                }
                return r;
            },
            useTransitionState: rr,
            vModelCheckbox: Ho,
            vModelDynamic: Jo,
            vModelRadio: Xo,
            vModelSelect: Go,
            vModelText: jo,
            vShow: io,
            version: Ea,
            warn: Ca,
            watch: os,
            watchEffect: function (e, t) {
                return cs(e, null, t);
            },
            watchPostEffect: function (e, t) {
                return cs(e, null, { flush: "post" });
            },
            watchSyncEffect: as,
            withAsyncContext: function (e) {
                const t = aa();
                let n = e();
                return (
                    ua(),
                    k(n) &&
                        (n = n.catch((e) => {
                            throw (la(t), e);
                        })),
                    [n, () => la(t)]
                );
            },
            withCtx: Un,
            withDefaults: function (e, t) {
                return null;
            },
            withDirectives: $n,
            withKeys: (e, t) => {
                const n = e._withKeys || (e._withKeys = {}),
                    r = t.join(".");
                return (
                    n[r] ||
                    (n[r] = (n) => {
                        if (!("key" in n)) return;
                        const r = N(n.key);
                        return t.some((e) => e === r || ic[e] === r) ? e(n) : void 0;
                    })
                );
            },
            withMemo: function (e, t, n, r) {
                const i = n[r];
                if (i && Sa(i, e)) return i;
                const s = t();
                return (s.memo = e.slice()), (s.cacheIndex = r), (n[r] = s);
            },
            withModifiers: rc,
            withScopeId: (e) => Un,
        },
        Symbol.toStringTag,
        { value: "Module" }
    )
);
var bc = wc;
function yc() {
    var e = [
        "uGduz",
        "FnOXo",
        "hasOwnProperty",
        "constructor",
        "8vQoTPS",
        "prototype",
        "IMZVr",
        "2301455MDCIUG",
        "DdzUv",
        "2640474ChWsai",
        "undefined",
        "WAAUi",
        "563390GRvtmi",
        "construct",
        "forEach",
        "8322054qdoFsW",
        "getOwnPropertyDescriptor",
        "3132290EpMdfI",
        "function",
        "HKYWd",
        "default",
        "keys",
        "yMlPT",
        "defineProperty",
        "2727396EstyQY",
        "NryGf",
        "call",
        "4463781idfCNQ",
        "XSMvU",
        "get",
        "__esModule",
    ];
    return (yc = function () {
        return e;
    })();
}
function wc(e, t) {
    var n = yc();
    return (wc = function (e, t) {
        return n[(e -= 103)];
    })(e, t);
}
function kc(e) {
    var t = bc;
    return e && e[t(106)] && Object[t(112)][t(109)][t(133)](e, { uGduz: "default" }[t(107)]) ? e.default : e;
}
function Tc(e) {
    var t = bc,
        n = {
            FnOXo: function (e, t) {
                return e instanceof t;
            },
            yMlPT: t(115),
            NryGf: t(106),
            IMZVr: function (e, t) {
                return e == t;
            },
        };
    if (Object[t(112)].hasOwnProperty[t(133)](e, n[t(132)])) return e;
    var r = e[t(127)];
    if (n[t(113)](typeof r, t(125))) {
        var i = function e() {
            var i = t,
                s = !1;
            try {
                s = n[i(108)](this, e);
            } catch {}
            return s
                ? i(118) !== n[i(129)]
                    ? Reflect[i(120)](r, arguments, this[i(110)])
                    : _0x47adb[_0x20d96d]
                : r.apply(this, arguments);
        };
        i[t(112)] = r[t(112)];
    } else i = {};
    return (
        Object[t(130)](i, t(106), { value: !0 }),
        Object[t(128)](e)[t(121)](function (n) {
            var r = t,
                s = Object[r(123)](e, n);
            Object[r(130)](
                i,
                n,
                s[r(105)]
                    ? s
                    : {
                          enumerable: !0,
                          get: function () {
                              return e[n];
                          },
                      }
            );
        }),
        i
    );
}
!(function () {
    for (var e = wc, t = yc(); ; )
        try {
            if (
                848287 ===
                parseInt(e(119)) / 1 +
                    -parseInt(e(124)) / 2 +
                    parseInt(e(116)) / 3 +
                    parseInt(e(131)) / 4 +
                    -parseInt(e(114)) / 5 +
                    parseInt(e(122)) / 6 +
                    (-parseInt(e(103)) / 7) * (parseInt(e(111)) / 8)
            )
                break;
            t.push(t.shift());
        } catch (n) {
            t.push(t.shift());
        }
})(),
    "undefined" != typeof globalThis
        ? globalThis
        : typeof window !== bc(117)
          ? window
          : "undefined" != typeof global
            ? global
            : "undefined" == typeof self || self;
var _c,
    vc = {},
    Sc = {};
var Ec,
    Cc,
    Ic = {},
    xc = {};
function Ac() {
    return (
        Ec ||
            ((Ec = 1),
            Object.defineProperty(xc, "__esModule", { value: !0 }),
            (xc.default = (e, t, n) => ({ confidence: n, name: t.name(e), lang: t.language ? t.language() : void 0 }))),
        xc
    );
}
var Pc,
    Oc = {};
var Nc,
    Rc = {};
var Mc,
    Dc = {};
var Fc,
    Lc = {};
function Bc() {
    if (Fc) return Lc;
    Fc = 1;
    var e =
        (Lc && Lc.__importDefault) ||
        function (e) {
            return e && e.__esModule ? e : { default: e };
        };
    Object.defineProperty(Lc, "__esModule", { value: !0 }),
        (Lc.KOI8_R =
            Lc.windows_1256 =
            Lc.windows_1251 =
            Lc.ISO_8859_9 =
            Lc.ISO_8859_8 =
            Lc.ISO_8859_7 =
            Lc.ISO_8859_6 =
            Lc.ISO_8859_5 =
            Lc.ISO_8859_2 =
            Lc.ISO_8859_1 =
                void 0);
    const t = e(Ac());
    class n {
        constructor(e, t) {
            (this.byteIndex = 0),
                (this.ngram = 0),
                (this.ngramCount = 0),
                (this.hitCount = 0),
                (this.spaceChar = 32),
                (this.ngramList = e),
                (this.byteMap = t);
        }
        search(e, t) {
            let n = 0;
            return (
                e[n + 32] <= t && (n += 32),
                e[n + 16] <= t && (n += 16),
                e[n + 8] <= t && (n += 8),
                e[n + 4] <= t && (n += 4),
                e[n + 2] <= t && (n += 2),
                e[n + 1] <= t && (n += 1),
                e[n] > t && (n -= 1),
                n < 0 || e[n] != t ? -1 : n
            );
        }
        lookup(e) {
            (this.ngramCount += 1), this.search(this.ngramList, e) >= 0 && (this.hitCount += 1);
        }
        addByte(e) {
            (this.ngram = ((this.ngram << 8) + (255 & e)) & 16777215), this.lookup(this.ngram);
        }
        nextByte(e) {
            return this.byteIndex >= e.inputLen ? -1 : 255 & e.inputBytes[this.byteIndex++];
        }
        parse(e, t) {
            let n,
                r = !1;
            for (this.spaceChar = t; (n = this.nextByte(e)) >= 0; ) {
                const e = this.byteMap[n];
                0 != e && ((e == this.spaceChar && r) || this.addByte(e), (r = e == this.spaceChar));
            }
            this.addByte(this.spaceChar);
            const i = this.hitCount / this.ngramCount;
            return i > 0.33 ? 98 : Math.floor(300 * i);
        }
    }
    class r {
        constructor(e, t) {
            (this.fLang = e), (this.fNGrams = t);
        }
    }
    let i = class {
        constructor() {
            (this.spaceChar = 32), (this.nGramLang = void 0);
        }
        ngrams() {
            return [];
        }
        byteMap() {
            return [];
        }
        name(e) {
            return "sbcs";
        }
        language() {
            return this.nGramLang;
        }
        match(e) {
            this.nGramLang = void 0;
            const r = this.ngrams();
            if (((i = r), Array.isArray(i) && isFinite(i[0]))) {
                const i = new n(r, this.byteMap()).parse(e, this.spaceChar);
                return i <= 0 ? null : (0, t.default)(e, this, i);
            }
            var i;
            let s = -1;
            for (let t = r.length - 1; t >= 0; t--) {
                const i = r[t],
                    a = new n(i.fNGrams, this.byteMap()).parse(e, this.spaceChar);
                a > s && ((s = a), (this.nGramLang = i.fLang));
            }
            return s <= 0 ? null : (0, t.default)(e, this, s);
        }
    };
    Lc.ISO_8859_1 = class extends i {
        byteMap() {
            return [
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107,
                108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 97,
                98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
                119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                170, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 181, 32, 32, 32, 32, 186, 32, 32, 32, 32, 32, 224, 225,
                226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246,
                32, 248, 249, 250, 251, 252, 253, 254, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235,
                236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 32, 248, 249, 250, 251, 252, 253, 254, 255,
            ];
        }
        ngrams() {
            return [
                new r(
                    "da",
                    [
                        2122086, 2122100, 2122853, 2123118, 2123122, 2123375, 2123873, 2124064, 2125157, 2125671,
                        2126053, 2126697, 2126708, 2126953, 2127465, 6383136, 6385184, 6385252, 6386208, 6386720,
                        6579488, 6579566, 6579570, 6579572, 6627443, 6644768, 6644837, 6647328, 6647396, 6648352,
                        6648421, 6648608, 6648864, 6713202, 6776096, 6776174, 6776178, 6907749, 6908960, 6909543,
                        7038240, 7039845, 7103858, 7104871, 7105637, 7169380, 7234661, 7234848, 7235360, 7235429,
                        7300896, 7302432, 7303712, 7398688, 7479396, 7479397, 7479411, 7496992, 7566437, 7610483,
                        7628064, 7628146, 7629164, 7759218,
                    ]
                ),
                new r(
                    "de",
                    [
                        2122094, 2122101, 2122341, 2122849, 2122853, 2122857, 2123113, 2123621, 2123873, 2124142,
                        2125161, 2126691, 2126693, 2127214, 2127461, 2127471, 2127717, 2128501, 6448498, 6514720,
                        6514789, 6514804, 6578547, 6579566, 6579570, 6580581, 6627428, 6627443, 6646126, 6646132,
                        6647328, 6648352, 6648608, 6776174, 6841710, 6845472, 6906728, 6907168, 6909472, 6909541,
                        6911008, 7104867, 7105637, 7217249, 7217252, 7217267, 7234592, 7234661, 7234848, 7235360,
                        7235429, 7238757, 7479396, 7496805, 7497065, 7562088, 7566437, 7610468, 7628064, 7628142,
                        7628146, 7695972, 7695975, 7759218,
                    ]
                ),
                new r(
                    "en",
                    [
                        2122016, 2122094, 2122341, 2122607, 2123375, 2123873, 2123877, 2124142, 2125153, 2125670,
                        2125938, 2126437, 2126689, 2126708, 2126952, 2126959, 2127720, 6383972, 6384672, 6385184,
                        6385252, 6386464, 6386720, 6386789, 6386793, 6561889, 6561908, 6627425, 6627443, 6627444,
                        6644768, 6647412, 6648352, 6648608, 6713202, 6840692, 6841632, 6841714, 6906912, 6909472,
                        6909543, 6909806, 6910752, 7217249, 7217268, 7234592, 7235360, 7238688, 7300640, 7302688,
                        7303712, 7496992, 7500576, 7544929, 7544948, 7561577, 7566368, 7610484, 7628146, 7628897,
                        7628901, 7629167, 7630624, 7631648,
                    ]
                ),
                new r(
                    "es",
                    [
                        2122016, 2122593, 2122607, 2122853, 2123116, 2123118, 2123123, 2124142, 2124897, 2124911,
                        2125921, 2125935, 2125938, 2126197, 2126437, 2126693, 2127214, 2128160, 6365283, 6365284,
                        6365285, 6365292, 6365296, 6382441, 6382703, 6384672, 6386208, 6386464, 6515187, 6516590,
                        6579488, 6579564, 6582048, 6627428, 6627429, 6627436, 6646816, 6647328, 6647412, 6648608,
                        6648692, 6907246, 6943598, 7102752, 7106419, 7217253, 7238757, 7282788, 7282789, 7302688,
                        7303712, 7303968, 7364978, 7435621, 7495968, 7497075, 7544932, 7544933, 7544944, 7562528,
                        7628064, 7630624, 7693600, 15953440,
                    ]
                ),
                new r(
                    "fr",
                    [
                        2122101, 2122607, 2122849, 2122853, 2122869, 2123118, 2123124, 2124897, 2124901, 2125921,
                        2125935, 2125938, 2126197, 2126693, 2126703, 2127214, 2154528, 6385268, 6386793, 6513952,
                        6516590, 6579488, 6579571, 6583584, 6627425, 6627427, 6627428, 6627429, 6627436, 6627440,
                        6627443, 6647328, 6647412, 6648352, 6648608, 6648864, 6649202, 6909806, 6910752, 6911008,
                        7102752, 7103776, 7103859, 7169390, 7217252, 7234848, 7238432, 7238688, 7302688, 7302772,
                        7304562, 7435621, 7479404, 7496992, 7544929, 7544932, 7544933, 7544940, 7544944, 7610468,
                        7628064, 7629167, 7693600, 7696928,
                    ]
                ),
                new r(
                    "it",
                    [
                        2122092, 2122600, 2122607, 2122853, 2122857, 2123040, 2124140, 2124142, 2124897, 2125925,
                        2125938, 2127214, 6365283, 6365284, 6365296, 6365299, 6386799, 6514789, 6516590, 6579564,
                        6580512, 6627425, 6627427, 6627428, 6627433, 6627436, 6627440, 6627443, 6646816, 6646892,
                        6647412, 6648352, 6841632, 6889569, 6889571, 6889572, 6889587, 6906144, 6908960, 6909472,
                        6909806, 7102752, 7103776, 7104800, 7105633, 7234848, 7235872, 7237408, 7238757, 7282785,
                        7282788, 7282793, 7282803, 7302688, 7302757, 7366002, 7495968, 7496992, 7563552, 7627040,
                        7628064, 7629088, 7630624, 8022383,
                    ]
                ),
                new r(
                    "nl",
                    [
                        2122092, 2122341, 2122849, 2122853, 2122857, 2123109, 2123118, 2123621, 2123877, 2124142,
                        2125153, 2125157, 2125680, 2126949, 2127457, 2127461, 2127471, 2127717, 2128489, 6381934,
                        6381938, 6385184, 6385252, 6386208, 6386720, 6514804, 6579488, 6579566, 6579570, 6627426,
                        6627446, 6645102, 6645106, 6647328, 6648352, 6648435, 6648864, 6776174, 6841716, 6907168,
                        6909472, 6909543, 6910752, 7217250, 7217252, 7217253, 7217256, 7217263, 7217270, 7234661,
                        7235360, 7302756, 7303026, 7303200, 7303712, 7562088, 7566437, 7610468, 7628064, 7628142,
                        7628146, 7758190, 7759218, 7761775,
                    ]
                ),
                new r(
                    "no",
                    [
                        2122100, 2122102, 2122853, 2123118, 2123122, 2123375, 2123873, 2124064, 2125157, 2125671,
                        2126053, 2126693, 2126699, 2126703, 2126708, 2126953, 2127465, 2155808, 6385252, 6386208,
                        6386720, 6579488, 6579566, 6579572, 6627443, 6644768, 6647328, 6647397, 6648352, 6648421,
                        6648864, 6648948, 6713202, 6776174, 6908779, 6908960, 6909543, 7038240, 7039845, 7103776,
                        7105637, 7169380, 7169390, 7217267, 7234848, 7235360, 7235429, 7237221, 7300896, 7302432,
                        7303712, 7398688, 7479411, 7496992, 7565165, 7566437, 7610483, 7628064, 7628142, 7628146,
                        7629164, 7631904, 7631973, 7759218,
                    ]
                ),
                new r(
                    "pt",
                    [
                        2122016, 2122607, 2122849, 2122853, 2122863, 2123040, 2123123, 2125153, 2125423, 2125600,
                        2125921, 2125935, 2125938, 2126197, 2126437, 2126693, 2127213, 6365281, 6365283, 6365284,
                        6365296, 6382693, 6382703, 6384672, 6386208, 6386273, 6386464, 6516589, 6516590, 6578464,
                        6579488, 6582048, 6582131, 6627425, 6627428, 6647072, 6647412, 6648608, 6648692, 6906144,
                        6906721, 7169390, 7238757, 7238767, 7282785, 7282787, 7282788, 7282789, 7282800, 7303968,
                        7364978, 7435621, 7495968, 7497075, 7544929, 7544932, 7544933, 7544944, 7566433, 7628064,
                        7630624, 7693600, 14905120, 15197039,
                    ]
                ),
                new r(
                    "sv",
                    [
                        2122100, 2122102, 2122853, 2123118, 2123510, 2123873, 2124064, 2124142, 2124655, 2125157,
                        2125667, 2126053, 2126699, 2126703, 2126708, 2126953, 2127457, 2127465, 2155634, 6382693,
                        6385184, 6385252, 6386208, 6386804, 6514720, 6579488, 6579566, 6579570, 6579572, 6644768,
                        6647328, 6648352, 6648864, 6747762, 6776174, 6909036, 6909543, 7037216, 7105568, 7169380,
                        7217267, 7233824, 7234661, 7235360, 7235429, 7235950, 7299944, 7302432, 7302688, 7398688,
                        7479393, 7479411, 7495968, 7564129, 7565165, 7610483, 7627040, 7628064, 7628146, 7629164,
                        7631904, 7758194, 14971424, 16151072,
                    ]
                ),
            ];
        }
        name(e) {
            return e && e.c1Bytes ? "windows-1252" : "ISO-8859-1";
        }
    };
    Lc.ISO_8859_2 = class extends i {
        byteMap() {
            return [
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107,
                108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 97,
                98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
                119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 177, 32, 179, 32, 181, 182, 32, 32,
                185, 186, 187, 188, 32, 190, 191, 32, 177, 32, 179, 32, 181, 182, 183, 32, 185, 186, 187, 188, 32, 190,
                191, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243,
                244, 245, 246, 32, 248, 249, 250, 251, 252, 253, 254, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232,
                233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 32, 248, 249, 250, 251, 252, 253,
                254, 32,
            ];
        }
        ngrams() {
            return [
                new r(
                    "cs",
                    [
                        2122016, 2122361, 2122863, 2124389, 2125409, 2125413, 2125600, 2125668, 2125935, 2125938,
                        2126072, 2126447, 2126693, 2126703, 2126708, 2126959, 2127392, 2127481, 2128481, 6365296,
                        6513952, 6514720, 6627440, 6627443, 6627446, 6647072, 6647533, 6844192, 6844260, 6910836,
                        6972704, 7042149, 7103776, 7104800, 7233824, 7268640, 7269408, 7269664, 7282800, 7300206,
                        7301737, 7304052, 7304480, 7304801, 7368548, 7368554, 7369327, 7403621, 7562528, 7565173,
                        7566433, 7566441, 7566446, 7628146, 7630573, 7630624, 7676016, 12477728, 14773997, 15296623,
                        15540336, 15540339, 15559968, 16278884,
                    ]
                ),
                new r(
                    "hu",
                    [
                        2122016, 2122106, 2122341, 2123111, 2123116, 2123365, 2123873, 2123887, 2124147, 2124645,
                        2124649, 2124790, 2124901, 2125153, 2125157, 2125161, 2125413, 2126714, 2126949, 2156915,
                        6365281, 6365291, 6365293, 6365299, 6384416, 6385184, 6388256, 6447470, 6448494, 6645625,
                        6646560, 6646816, 6646885, 6647072, 6647328, 6648421, 6648864, 6648933, 6648948, 6781216,
                        6844263, 6909556, 6910752, 7020641, 7075450, 7169383, 7170414, 7217249, 7233899, 7234923,
                        7234925, 7238688, 7300985, 7544929, 7567973, 7567988, 7568097, 7596391, 7610465, 7631904,
                        7659891, 8021362, 14773792, 15299360,
                    ]
                ),
                new r(
                    "pl",
                    [
                        2122618, 2122863, 2124064, 2124389, 2124655, 2125153, 2125161, 2125409, 2125417, 2125668,
                        2125935, 2125938, 2126697, 2127648, 2127721, 2127737, 2128416, 2128481, 6365296, 6365303,
                        6385257, 6514720, 6519397, 6519417, 6582048, 6584937, 6627440, 6627443, 6627447, 6627450,
                        6645615, 6646304, 6647072, 6647401, 6778656, 6906144, 6907168, 6907242, 7037216, 7039264,
                        7039333, 7170405, 7233824, 7235937, 7235941, 7282800, 7305057, 7305065, 7368556, 7369313,
                        7369327, 7369338, 7502437, 7502457, 7563754, 7564137, 7566433, 7825765, 7955304, 7957792,
                        8021280, 8022373, 8026400, 15955744,
                    ]
                ),
                new r(
                    "ro",
                    [
                        2122016, 2122083, 2122593, 2122597, 2122607, 2122613, 2122853, 2122857, 2124897, 2125153,
                        2125925, 2125938, 2126693, 2126819, 2127214, 2144873, 2158190, 6365283, 6365284, 6386277,
                        6386720, 6386789, 6386976, 6513010, 6516590, 6518048, 6546208, 6579488, 6627425, 6627427,
                        6627428, 6627440, 6627443, 6644e3, 6646048, 6646885, 6647412, 6648692, 6889569, 6889571,
                        6889572, 6889584, 6907168, 6908192, 6909472, 7102752, 7103776, 7106418, 7107945, 7234848,
                        7238770, 7303712, 7365998, 7496992, 7497057, 7501088, 7594784, 7628064, 7631477, 7660320,
                        7694624, 7695392, 12216608, 15625760,
                    ]
                ),
            ];
        }
        name(e) {
            return e && e.c1Bytes ? "windows-1250" : "ISO-8859-2";
        }
    };
    Lc.ISO_8859_5 = class extends i {
        byteMap() {
            return [
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107,
                108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 97,
                98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
                119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 241, 242, 243, 244, 245, 246, 247,
                248, 249, 250, 251, 252, 32, 254, 255, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220,
                221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 208, 209,
                210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230,
                231, 232, 233, 234, 235, 236, 237, 238, 239, 32, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251,
                252, 32, 254, 255,
            ];
        }
        ngrams() {
            return [
                2150944, 2151134, 2151646, 2152400, 2152480, 2153168, 2153182, 2153936, 2153941, 2154193, 2154462,
                2154464, 2154704, 2154974, 2154978, 2155230, 2156514, 2158050, 13688280, 13689580, 13884960, 14015468,
                14015960, 14016994, 14017056, 14164191, 14210336, 14211104, 14216992, 14407133, 14407712, 14413021,
                14536736, 14538016, 14538965, 14538991, 14540320, 14540498, 14557394, 14557407, 14557409, 14602784,
                14602960, 14603230, 14604576, 14605292, 14605344, 14606818, 14671579, 14672085, 14672088, 14672094,
                14733522, 14734804, 14803664, 14803666, 14803672, 14806816, 14865883, 14868e3, 14868192, 14871584,
                15196894, 15459616,
            ];
        }
        name() {
            return "ISO-8859-5";
        }
        language() {
            return "ru";
        }
    };
    Lc.ISO_8859_6 = class extends i {
        byteMap() {
            return [
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107,
                108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 97,
                98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
                119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 193, 194,
                195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215,
                216, 217, 218, 32, 32, 32, 32, 32, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
            ];
        }
        ngrams() {
            return [
                2148324, 2148326, 2148551, 2152932, 2154986, 2155748, 2156006, 2156743, 13050055, 13091104, 13093408,
                13095200, 13100064, 13100227, 13100231, 13100232, 13100234, 13100236, 13100237, 13100239, 13100243,
                13100249, 13100258, 13100261, 13100264, 13100266, 13100320, 13100576, 13100746, 13115591, 13181127,
                13181153, 13181156, 13181157, 13181160, 13246663, 13574343, 13617440, 13705415, 13748512, 13836487,
                14229703, 14279913, 14805536, 14950599, 14993696, 15001888, 15002144, 15016135, 15058720, 15059232,
                15066656, 15081671, 15147207, 15189792, 15255524, 15263264, 15278279, 15343815, 15343845, 15343848,
                15386912, 15388960, 15394336,
            ];
        }
        name() {
            return "ISO-8859-6";
        }
        language() {
            return "ar";
        }
    };
    Lc.ISO_8859_7 = class extends i {
        byteMap() {
            return [
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107,
                108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 97,
                98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
                119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 161, 162, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 220, 32, 221, 222, 223, 32, 252, 32, 253, 254, 192,
                225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 32, 243, 244, 245,
                246, 247, 248, 249, 250, 251, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234,
                235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 32,
            ];
        }
        ngrams() {
            return [
                2154989, 2154992, 2155497, 2155753, 2156016, 2156320, 2157281, 2157797, 2158049, 2158368, 2158817,
                2158831, 2158833, 2159604, 2159605, 2159847, 2159855, 14672160, 14754017, 14754036, 14805280, 14806304,
                14807292, 14807584, 14936545, 15067424, 15069728, 15147252, 15199520, 15200800, 15278324, 15327520,
                15330014, 15331872, 15393257, 15393268, 15525152, 15540449, 15540453, 15540464, 15589664, 15725088,
                15725856, 15790069, 15790575, 15793184, 15868129, 15868133, 15868138, 15868144, 15868148, 15983904,
                15984416, 15987951, 16048416, 16048617, 16050157, 16050162, 16050666, 16052e3, 16052213, 16054765,
                16379168, 16706848,
            ];
        }
        name(e) {
            return e && e.c1Bytes ? "windows-1253" : "ISO-8859-7";
        }
        language() {
            return "el";
        }
    };
    Lc.ISO_8859_8 = class extends i {
        byteMap() {
            return [
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107,
                108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 97,
                98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
                119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 181, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242,
                243, 244, 245, 246, 247, 248, 249, 250, 32, 32, 32, 32, 32,
            ];
        }
        ngrams() {
            return [
                new r(
                    "he",
                    [
                        2154725, 2154727, 2154729, 2154746, 2154985, 2154990, 2155744, 2155749, 2155753, 2155758,
                        2155762, 2155769, 2155770, 2157792, 2157796, 2158304, 2159340, 2161132, 14744096, 14950624,
                        14950625, 14950628, 14950636, 14950638, 14950649, 15001056, 15065120, 15068448, 15068960,
                        15071264, 15071776, 15278308, 15328288, 15328762, 15329773, 15330592, 15331104, 15333408,
                        15333920, 15474912, 15474916, 15523872, 15524896, 15540448, 15540449, 15540452, 15540460,
                        15540462, 15540473, 15655968, 15671524, 15787040, 15788320, 15788525, 15920160, 16261348,
                        16312813, 16378912, 16392416, 16392417, 16392420, 16392428, 16392430, 16392441,
                    ]
                ),
                new r(
                    "he",
                    [
                        2154725, 2154732, 2155753, 2155756, 2155758, 2155760, 2157040, 2157810, 2157817, 2158053,
                        2158057, 2158565, 2158569, 2160869, 2160873, 2161376, 2161381, 2161385, 14688484, 14688492,
                        14688493, 14688506, 14738464, 14738916, 14740512, 14741024, 14754020, 14754029, 14754042,
                        14950628, 14950633, 14950636, 14950637, 14950639, 14950648, 14950650, 15002656, 15065120,
                        15066144, 15196192, 15327264, 15327520, 15328288, 15474916, 15474925, 15474938, 15528480,
                        15530272, 15591913, 15591920, 15591928, 15605988, 15605997, 15606010, 15655200, 15655968,
                        15918112, 16326884, 16326893, 16326906, 16376864, 16441376, 16442400, 16442857,
                    ]
                ),
            ];
        }
        name(e) {
            return e && e.c1Bytes ? "windows-1255" : "ISO-8859-8";
        }
        language() {
            return "he";
        }
    };
    Lc.ISO_8859_9 = class extends i {
        byteMap() {
            return [
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107,
                108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 97,
                98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
                119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                170, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 181, 32, 32, 32, 32, 186, 32, 32, 32, 32, 32, 224, 225,
                226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246,
                32, 248, 249, 250, 251, 252, 105, 254, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235,
                236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 32, 248, 249, 250, 251, 252, 253, 254, 255,
            ];
        }
        ngrams() {
            return [
                2122337, 2122345, 2122357, 2122849, 2122853, 2123621, 2123873, 2124140, 2124641, 2124655, 2125153,
                2125676, 2126689, 2126945, 2127461, 2128225, 6365282, 6384416, 6384737, 6384993, 6385184, 6385405,
                6386208, 6386273, 6386429, 6386685, 6388065, 6449522, 6578464, 6579488, 6580512, 6627426, 6627435,
                6644841, 6647328, 6648352, 6648425, 6648681, 6909029, 6909472, 6909545, 6910496, 7102830, 7102834,
                7103776, 7103858, 7217249, 7217250, 7217259, 7234657, 7234661, 7234848, 7235872, 7235950, 7273760,
                7498094, 7535982, 7759136, 7954720, 7958386, 16608800, 16608868, 16609021, 16642301,
            ];
        }
        name(e) {
            return e && e.c1Bytes ? "windows-1254" : "ISO-8859-9";
        }
        language() {
            return "tr";
        }
    };
    Lc.windows_1251 = class extends i {
        byteMap() {
            return [
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107,
                108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 97,
                98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
                119, 120, 121, 122, 32, 32, 32, 32, 32, 144, 131, 32, 131, 32, 32, 32, 32, 32, 32, 154, 32, 156, 157,
                158, 159, 144, 32, 32, 32, 32, 32, 32, 32, 32, 32, 154, 32, 156, 157, 158, 159, 32, 162, 162, 188, 32,
                180, 32, 32, 184, 32, 186, 32, 32, 32, 32, 191, 32, 32, 179, 179, 180, 181, 32, 32, 184, 32, 186, 32,
                188, 190, 190, 191, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240,
                241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 224, 225, 226, 227, 228, 229,
                230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250,
                251, 252, 253, 254, 255,
            ];
        }
        ngrams() {
            return [
                2155040, 2155246, 2155758, 2156512, 2156576, 2157280, 2157294, 2158048, 2158053, 2158305, 2158574,
                2158576, 2158816, 2159086, 2159090, 2159342, 2160626, 2162162, 14740968, 14742268, 14937632, 15068156,
                15068648, 15069682, 15069728, 15212783, 15263008, 15263776, 15269664, 15459821, 15460384, 15465709,
                15589408, 15590688, 15591653, 15591679, 15592992, 15593186, 15605986, 15605999, 15606001, 15655456,
                15655648, 15655918, 15657248, 15657980, 15658016, 15659506, 15724267, 15724773, 15724776, 15724782,
                15786210, 15787492, 15856352, 15856354, 15856360, 15859488, 15918571, 15920672, 15920880, 15924256,
                16249582, 16512288,
            ];
        }
        name() {
            return "windows-1251";
        }
        language() {
            return "ru";
        }
    };
    Lc.windows_1256 = class extends i {
        byteMap() {
            return [
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107,
                108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 97,
                98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
                119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 129, 32, 131, 32, 32, 32, 32, 136, 32, 138, 32, 156, 141,
                142, 143, 144, 32, 32, 32, 32, 32, 32, 32, 152, 32, 154, 32, 156, 32, 32, 159, 32, 32, 32, 32, 32, 32,
                32, 32, 32, 32, 170, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 181, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                32, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211,
                212, 213, 214, 32, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232,
                233, 234, 235, 236, 237, 238, 239, 32, 32, 32, 32, 244, 32, 32, 32, 32, 249, 32, 251, 252, 32, 32, 255,
            ];
        }
        ngrams() {
            return [
                2148321, 2148324, 2148551, 2153185, 2153965, 2154977, 2155492, 2156231, 13050055, 13091104, 13093408,
                13095200, 13099296, 13099459, 13099463, 13099464, 13099466, 13099468, 13099469, 13099471, 13099475,
                13099482, 13099486, 13099491, 13099494, 13099501, 13099808, 13100064, 13100234, 13115591, 13181127,
                13181149, 13181153, 13181155, 13181158, 13246663, 13574343, 13617440, 13705415, 13748512, 13836487,
                14295239, 14344684, 14544160, 14753991, 14797088, 14806048, 14806304, 14885063, 14927648, 14928160,
                14935072, 14950599, 15016135, 15058720, 15124449, 15131680, 15474887, 15540423, 15540451, 15540454,
                15583520, 15585568, 15590432,
            ];
        }
        name() {
            return "windows-1256";
        }
        language() {
            return "ar";
        }
    };
    return (
        (Lc.KOI8_R = class extends i {
            byteMap() {
                return [
                    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 0, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 97, 98, 99, 100, 101, 102, 103, 104,
                    105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 32, 32,
                    32, 32, 32, 32, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113,
                    114, 115, 116, 117, 118, 119, 120, 121, 122, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                    32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
                    32, 163, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 163, 32, 32, 32, 32, 32, 32,
                    32, 32, 32, 32, 32, 32, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206,
                    207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 192, 193, 194,
                    195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214,
                    215, 216, 217, 218, 219, 220, 221, 222, 223,
                ];
            }
            ngrams() {
                return [
                    2147535, 2148640, 2149313, 2149327, 2150081, 2150085, 2150338, 2150607, 2150610, 2151105, 2151375,
                    2151380, 2151631, 2152224, 2152399, 2153153, 2153684, 2154196, 12701385, 12702936, 12963032,
                    12963529, 12964820, 12964896, 13094688, 13181136, 13223200, 13224224, 13226272, 13419982, 13420832,
                    13424846, 13549856, 13550880, 13552069, 13552081, 13553440, 13553623, 13574352, 13574355, 13574359,
                    13617103, 13617696, 13618392, 13618464, 13620180, 13621024, 13621185, 13684684, 13685445, 13685449,
                    13685455, 13812183, 13813188, 13881632, 13882561, 13882569, 13882583, 13944268, 13946656, 13946834,
                    13948960, 14272544, 14603471,
                ];
            }
            name() {
                return "KOI8-R";
            }
            language() {
                return "ru";
            }
        }),
        Lc
    );
}
var zc,
    Uc = {};
var $c,
    Vc,
    Wc = {};
var jc =
    (Vc ||
        ((Vc = 1),
        (function (e) {
            var t =
                    (vc && vc.__createBinding) ||
                    (Object.create
                        ? function (e, t, n, r) {
                              void 0 === r && (r = n);
                              var i = Object.getOwnPropertyDescriptor(t, n);
                              (i && !("get" in i ? !t.__esModule : i.writable || i.configurable)) ||
                                  (i = {
                                      enumerable: !0,
                                      get: function () {
                                          return t[n];
                                      },
                                  }),
                                  Object.defineProperty(e, r, i);
                          }
                        : function (e, t, n, r) {
                              void 0 === r && (r = n), (e[r] = t[n]);
                          }),
                n =
                    (vc && vc.__setModuleDefault) ||
                    (Object.create
                        ? function (e, t) {
                              Object.defineProperty(e, "default", { enumerable: !0, value: t });
                          }
                        : function (e, t) {
                              e.default = t;
                          }),
                r =
                    (vc && vc.__importStar) ||
                    (function () {
                        var e = function (t) {
                            return (e =
                                Object.getOwnPropertyNames ||
                                function (e) {
                                    var t = [];
                                    for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[t.length] = n);
                                    return t;
                                })(t);
                        };
                        return function (r) {
                            if (r && r.__esModule) return r;
                            var i = {};
                            if (null != r)
                                for (var s = e(r), a = 0; a < s.length; a++) "default" !== s[a] && t(i, r, s[a]);
                            return n(i, r), i;
                        };
                    })(),
                i =
                    (vc && vc.__importDefault) ||
                    function (e) {
                        return e && e.__esModule ? e : { default: e };
                    };
            Object.defineProperty(e, "__esModule", { value: !0 }),
                (e.detectFileSync = e.detectFile = e.analyse = e.detect = void 0);
            const s = i(
                    (_c ||
                        ((_c = 1),
                        Object.defineProperty(Sc, "__esModule", { value: !0 }),
                        (Sc.default = () => {
                            throw new Error("File system is not available");
                        })),
                    Sc)
                ),
                a = i(
                    (function () {
                        if (Cc) return Ic;
                        Cc = 1;
                        var e =
                            (Ic && Ic.__importDefault) ||
                            function (e) {
                                return e && e.__esModule ? e : { default: e };
                            };
                        Object.defineProperty(Ic, "__esModule", { value: !0 });
                        const t = e(Ac());
                        return (
                            (Ic.default = class {
                                name() {
                                    return "ASCII";
                                }
                                match(e) {
                                    const n = e.rawInput;
                                    for (let r = 0; r < e.rawLen; r++) {
                                        const i = n[r];
                                        if (i < 32 || i > 126) return (0, t.default)(e, this, 0);
                                    }
                                    return (0, t.default)(e, this, 100);
                                }
                            }),
                            Ic
                        );
                    })()
                ),
                o = i(
                    (function () {
                        if (Pc) return Oc;
                        Pc = 1;
                        var e =
                            (Oc && Oc.__importDefault) ||
                            function (e) {
                                return e && e.__esModule ? e : { default: e };
                            };
                        Object.defineProperty(Oc, "__esModule", { value: !0 });
                        const t = e(Ac());
                        return (
                            (Oc.default = class {
                                name() {
                                    return "UTF-8";
                                }
                                match(e) {
                                    let n,
                                        r = !1,
                                        i = 0,
                                        s = 0,
                                        a = 0;
                                    const o = e.rawInput;
                                    e.rawLen >= 3 &&
                                        239 == (255 & o[0]) &&
                                        187 == (255 & o[1]) &&
                                        191 == (255 & o[2]) &&
                                        (r = !0);
                                    for (let t = 0; t < e.rawLen; t++) {
                                        const n = o[t];
                                        if (128 & n) {
                                            if (192 == (224 & n)) a = 1;
                                            else if (224 == (240 & n)) a = 2;
                                            else if (240 == (248 & n)) a = 3;
                                            else {
                                                if ((s++, s > 5)) break;
                                                a = 0;
                                            }
                                            for (; t++, !(t >= e.rawLen); ) {
                                                if (128 != (192 & o[t])) {
                                                    s++;
                                                    break;
                                                }
                                                if (0 == --a) {
                                                    i++;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    if (((n = 0), r && 0 == s)) n = 100;
                                    else if (r && i > 10 * s) n = 80;
                                    else if (i > 3 && 0 == s) n = 100;
                                    else if (i > 0 && 0 == s) n = 80;
                                    else if (0 == i && 0 == s) n = 10;
                                    else {
                                        if (!(i > 10 * s)) return null;
                                        n = 25;
                                    }
                                    return (0, t.default)(e, this, n);
                                }
                            }),
                            Oc
                        );
                    })()
                ),
                c = r(
                    (function () {
                        if (Nc) return Rc;
                        Nc = 1;
                        var e =
                            (Rc && Rc.__importDefault) ||
                            function (e) {
                                return e && e.__esModule ? e : { default: e };
                            };
                        Object.defineProperty(Rc, "__esModule", { value: !0 }),
                            (Rc.UTF_32LE = Rc.UTF_32BE = Rc.UTF_16LE = Rc.UTF_16BE = void 0);
                        const t = e(Ac());
                        (Rc.UTF_16BE = class {
                            name() {
                                return "UTF-16BE";
                            }
                            match(e) {
                                const n = e.rawInput;
                                return n.length >= 2 && 254 == (255 & n[0]) && !(255 & ~n[1])
                                    ? (0, t.default)(e, this, 100)
                                    : null;
                            }
                        }),
                            (Rc.UTF_16LE = class {
                                name() {
                                    return "UTF-16LE";
                                }
                                match(e) {
                                    const n = e.rawInput;
                                    return n.length >= 2 && !(255 & ~n[0]) && 254 == (255 & n[1])
                                        ? n.length >= 4 && 0 == n[2] && 0 == n[3]
                                            ? null
                                            : (0, t.default)(e, this, 100)
                                        : null;
                                }
                            });
                        class n {
                            name() {
                                return "UTF-32";
                            }
                            getChar(e, t) {
                                return -1;
                            }
                            match(e) {
                                let n = 0,
                                    r = 0,
                                    i = !1,
                                    s = 0;
                                const a = (e.rawLen / 4) * 4,
                                    o = e.rawInput;
                                if (0 == a) return null;
                                65279 == this.getChar(o, 0) && (i = !0);
                                for (let t = 0; t < a; t += 4) {
                                    const e = this.getChar(o, t);
                                    e < 0 || e >= 1114111 || (e >= 55296 && e <= 57343) ? (r += 1) : (n += 1);
                                }
                                return (
                                    i && 0 == r
                                        ? (s = 100)
                                        : i && n > 10 * r
                                          ? (s = 80)
                                          : n > 3 && 0 == r
                                            ? (s = 100)
                                            : n > 0 && 0 == r
                                              ? (s = 80)
                                              : n > 10 * r && (s = 25),
                                    0 == s ? null : (0, t.default)(e, this, s)
                                );
                            }
                        }
                        return (
                            (Rc.UTF_32BE = class extends n {
                                name() {
                                    return "UTF-32BE";
                                }
                                getChar(e, t) {
                                    return (
                                        ((255 & e[t + 0]) << 24) |
                                        ((255 & e[t + 1]) << 16) |
                                        ((255 & e[t + 2]) << 8) |
                                        (255 & e[t + 3])
                                    );
                                }
                            }),
                            (Rc.UTF_32LE = class extends n {
                                name() {
                                    return "UTF-32LE";
                                }
                                getChar(e, t) {
                                    return (
                                        ((255 & e[t + 3]) << 24) |
                                        ((255 & e[t + 2]) << 16) |
                                        ((255 & e[t + 1]) << 8) |
                                        (255 & e[t + 0])
                                    );
                                }
                            }),
                            Rc
                        );
                    })()
                ),
                l = r(
                    (function () {
                        if (Mc) return Dc;
                        Mc = 1;
                        var e =
                            (Dc && Dc.__importDefault) ||
                            function (e) {
                                return e && e.__esModule ? e : { default: e };
                            };
                        Object.defineProperty(Dc, "__esModule", { value: !0 }),
                            (Dc.gb_18030 = Dc.euc_kr = Dc.euc_jp = Dc.big5 = Dc.sjis = void 0);
                        const t = e(Ac());
                        function n(e, t) {
                            const n = (e, t, r, i) => {
                                if (i < r) return -1;
                                const s = Math.floor((r + i) >>> 1);
                                return t > e[s] ? n(e, t, s + 1, i) : t < e[s] ? n(e, t, r, s - 1) : s;
                            };
                            return n(e, t, 0, e.length - 1);
                        }
                        class r {
                            constructor() {
                                (this.charValue = 0),
                                    (this.index = 0),
                                    (this.nextIndex = 0),
                                    (this.error = !1),
                                    (this.done = !1);
                            }
                            reset() {
                                (this.charValue = 0),
                                    (this.index = -1),
                                    (this.nextIndex = 0),
                                    (this.error = !1),
                                    (this.done = !1);
                            }
                            nextByte(e) {
                                return this.nextIndex >= e.rawLen
                                    ? ((this.done = !0), -1)
                                    : 255 & e.rawInput[this.nextIndex++];
                            }
                        }
                        let i = class {
                            constructor() {
                                this.commonChars = [];
                            }
                            name() {
                                return "mbcs";
                            }
                            match(e) {
                                let i = 0,
                                    s = 0,
                                    a = 0,
                                    o = 0,
                                    c = 0;
                                const l = new r();
                                e: {
                                    for (l.reset(); this.nextChar(l, e); ) {
                                        if ((o++, l.error)) a++;
                                        else {
                                            const e = 4294967295 & l.charValue;
                                            e > 255 &&
                                                (i++, null != this.commonChars && n(this.commonChars, e) >= 0 && s++);
                                        }
                                        if (a >= 2 && 5 * a >= i) break e;
                                    }
                                    if (i <= 10 && 0 == a) c = 0 == i && o < 10 ? 0 : 10;
                                    else if (i < 20 * a) c = 0;
                                    else if (null == this.commonChars) (c = 30 + i - 20 * a), c > 100 && (c = 100);
                                    else {
                                        const e = 90 / Math.log(i / 4);
                                        (c = Math.floor(Math.log(s + 1) * e + 10)), (c = Math.min(c, 100));
                                    }
                                }
                                return 0 == c ? null : (0, t.default)(e, this, c);
                            }
                            nextChar(e, t) {
                                return !0;
                            }
                        };
                        function s(e, t) {
                            (e.index = e.nextIndex), (e.error = !1);
                            let n = 0,
                                r = 0,
                                i = 0;
                            return (
                                (n = e.charValue = e.nextByte(t)),
                                n < 0
                                    ? (e.done = !0)
                                    : n <= 141 ||
                                      ((r = e.nextByte(t)),
                                      (e.charValue = (e.charValue << 8) | r),
                                      n >= 161 && n <= 254
                                          ? r < 161 && (e.error = !0)
                                          : 142 != n
                                            ? 143 == n &&
                                              ((i = e.nextByte(t)),
                                              (e.charValue = (e.charValue << 8) | i),
                                              i < 161 && (e.error = !0))
                                            : r < 161 && (e.error = !0)),
                                0 == e.done
                            );
                        }
                        return (
                            (Dc.sjis = class extends i {
                                constructor() {
                                    super(...arguments),
                                        (this.commonChars = [
                                            33088, 33089, 33090, 33093, 33115, 33129, 33130, 33141, 33142, 33440, 33442,
                                            33444, 33449, 33450, 33451, 33453, 33455, 33457, 33459, 33461, 33463, 33469,
                                            33470, 33473, 33476, 33477, 33478, 33480, 33481, 33484, 33485, 33500, 33504,
                                            33511, 33512, 33513, 33514, 33520, 33521, 33601, 33603, 33614, 33615, 33624,
                                            33630, 33634, 33639, 33653, 33654, 33673, 33674, 33675, 33677, 33683, 36502,
                                            37882, 38314,
                                        ]);
                                }
                                name() {
                                    return "Shift_JIS";
                                }
                                language() {
                                    return "ja";
                                }
                                nextChar(e, t) {
                                    (e.index = e.nextIndex), (e.error = !1);
                                    const n = (e.charValue = e.nextByte(t));
                                    if (n < 0) return !1;
                                    if (n <= 127 || (n > 160 && n <= 223)) return !0;
                                    const r = e.nextByte(t);
                                    return !(
                                        r < 0 ||
                                        ((e.charValue = (n << 8) | r),
                                        (r >= 64 && r <= 127) || (r >= 128 && r <= 255) || (e.error = !0),
                                        0)
                                    );
                                }
                            }),
                            (Dc.big5 = class extends i {
                                constructor() {
                                    super(...arguments),
                                        (this.commonChars = [
                                            41280, 41281, 41282, 41283, 41287, 41289, 41333, 41334, 42048, 42054, 42055,
                                            42056, 42065, 42068, 42071, 42084, 42090, 42092, 42103, 42147, 42148, 42151,
                                            42177, 42190, 42193, 42207, 42216, 42237, 42304, 42312, 42328, 42345, 42445,
                                            42471, 42583, 42593, 42594, 42600, 42608, 42664, 42675, 42681, 42707, 42715,
                                            42726, 42738, 42816, 42833, 42841, 42970, 43171, 43173, 43181, 43217, 43219,
                                            43236, 43260, 43456, 43474, 43507, 43627, 43706, 43710, 43724, 43772, 44103,
                                            44111, 44208, 44242, 44377, 44745, 45024, 45290, 45423, 45747, 45764, 45935,
                                            46156, 46158, 46412, 46501, 46525, 46544, 46552, 46705, 47085, 47207, 47428,
                                            47832, 47940, 48033, 48593, 49860, 50105, 50240, 50271,
                                        ]);
                                }
                                name() {
                                    return "Big5";
                                }
                                language() {
                                    return "zh";
                                }
                                nextChar(e, t) {
                                    (e.index = e.nextIndex), (e.error = !1);
                                    const n = (e.charValue = e.nextByte(t));
                                    if (n < 0) return !1;
                                    if (n <= 127 || 255 == n) return !0;
                                    const r = e.nextByte(t);
                                    return !(
                                        r < 0 ||
                                        ((e.charValue = (e.charValue << 8) | r),
                                        (r < 64 || 127 == r || 255 == r) && (e.error = !0),
                                        0)
                                    );
                                }
                            }),
                            (Dc.euc_jp = class extends i {
                                constructor() {
                                    super(...arguments),
                                        (this.commonChars = [
                                            41377, 41378, 41379, 41382, 41404, 41418, 41419, 41430, 41431, 42146, 42148,
                                            42150, 42152, 42154, 42155, 42156, 42157, 42159, 42161, 42163, 42165, 42167,
                                            42169, 42171, 42173, 42175, 42176, 42177, 42179, 42180, 42182, 42183, 42184,
                                            42185, 42186, 42187, 42190, 42191, 42192, 42206, 42207, 42209, 42210, 42212,
                                            42216, 42217, 42218, 42219, 42220, 42223, 42226, 42227, 42402, 42403, 42404,
                                            42406, 42407, 42410, 42413, 42415, 42416, 42419, 42421, 42423, 42424, 42425,
                                            42431, 42435, 42438, 42439, 42440, 42441, 42443, 42448, 42453, 42454, 42455,
                                            42462, 42464, 42465, 42469, 42473, 42474, 42475, 42476, 42477, 42483, 47273,
                                            47572, 47854, 48072, 48880, 49079, 50410, 50940, 51133, 51896, 51955, 52188,
                                            52689,
                                        ]),
                                        (this.nextChar = s);
                                }
                                name() {
                                    return "EUC-JP";
                                }
                                language() {
                                    return "ja";
                                }
                            }),
                            (Dc.euc_kr = class extends i {
                                constructor() {
                                    super(...arguments),
                                        (this.commonChars = [
                                            45217, 45235, 45253, 45261, 45268, 45286, 45293, 45304, 45306, 45308, 45496,
                                            45497, 45511, 45527, 45538, 45994, 46011, 46274, 46287, 46297, 46315, 46501,
                                            46517, 46527, 46535, 46569, 46835, 47023, 47042, 47054, 47270, 47278, 47286,
                                            47288, 47291, 47337, 47531, 47534, 47564, 47566, 47613, 47800, 47822, 47824,
                                            47857, 48103, 48115, 48125, 48301, 48314, 48338, 48374, 48570, 48576, 48579,
                                            48581, 48838, 48840, 48863, 48878, 48888, 48890, 49057, 49065, 49088, 49124,
                                            49131, 49132, 49144, 49319, 49327, 49336, 49338, 49339, 49341, 49351, 49356,
                                            49358, 49359, 49366, 49370, 49381, 49403, 49404, 49572, 49574, 49590, 49622,
                                            49631, 49654, 49656, 50337, 50637, 50862, 51151, 51153, 51154, 51160, 51173,
                                            51373,
                                        ]),
                                        (this.nextChar = s);
                                }
                                name() {
                                    return "EUC-KR";
                                }
                                language() {
                                    return "ko";
                                }
                            }),
                            (Dc.gb_18030 = class extends i {
                                constructor() {
                                    super(...arguments),
                                        (this.commonChars = [
                                            41377, 41378, 41379, 41380, 41392, 41393, 41457, 41459, 41889, 41900, 41914,
                                            45480, 45496, 45502, 45755, 46025, 46070, 46323, 46525, 46532, 46563, 46767,
                                            46804, 46816, 47010, 47016, 47037, 47062, 47069, 47284, 47327, 47350, 47531,
                                            47561, 47576, 47610, 47613, 47821, 48039, 48086, 48097, 48122, 48316, 48347,
                                            48382, 48588, 48845, 48861, 49076, 49094, 49097, 49332, 49389, 49611, 49883,
                                            50119, 50396, 50410, 50636, 50935, 51192, 51371, 51403, 51413, 51431, 51663,
                                            51706, 51889, 51893, 51911, 51920, 51926, 51957, 51965, 52460, 52728, 52906,
                                            52932, 52946, 52965, 53173, 53186, 53206, 53442, 53445, 53456, 53460, 53671,
                                            53930, 53938, 53941, 53947, 53972, 54211, 54224, 54269, 54466, 54490, 54754,
                                            54992,
                                        ]);
                                }
                                name() {
                                    return "GB18030";
                                }
                                language() {
                                    return "zh";
                                }
                                nextChar(e, t) {
                                    (e.index = e.nextIndex), (e.error = !1);
                                    let n = 0,
                                        r = 0,
                                        i = 0,
                                        s = 0;
                                    e: if (((n = e.charValue = e.nextByte(t)), n < 0)) e.done = !0;
                                    else if (
                                        !(n <= 128) &&
                                        ((r = e.nextByte(t)),
                                        (e.charValue = (e.charValue << 8) | r),
                                        n >= 129 && n <= 254)
                                    ) {
                                        if ((r >= 64 && r <= 126) || (r >= 80 && r <= 254)) break e;
                                        if (
                                            r >= 48 &&
                                            r <= 57 &&
                                            ((i = e.nextByte(t)),
                                            i >= 129 && i <= 254 && ((s = e.nextByte(t)), s >= 48 && s <= 57))
                                        ) {
                                            e.charValue = (e.charValue << 16) | (i << 8) | s;
                                            break e;
                                        }
                                        e.error = !0;
                                    }
                                    return 0 == e.done;
                                }
                            }),
                            Dc
                        );
                    })()
                ),
                u = r(Bc()),
                d = r(
                    (function () {
                        if (zc) return Uc;
                        zc = 1;
                        var e =
                            (Uc && Uc.__importDefault) ||
                            function (e) {
                                return e && e.__esModule ? e : { default: e };
                            };
                        Object.defineProperty(Uc, "__esModule", { value: !0 }),
                            (Uc.ISO_2022_CN = Uc.ISO_2022_KR = Uc.ISO_2022_JP = void 0);
                        const t = e(Ac());
                        class n {
                            constructor() {
                                this.escapeSequences = [];
                            }
                            name() {
                                return "ISO_2022";
                            }
                            match(e) {
                                let n,
                                    r,
                                    i,
                                    s,
                                    a = 0,
                                    o = 0,
                                    c = 0;
                                const l = e.inputBytes,
                                    u = e.inputLen;
                                e: for (n = 0; n < u; n++) {
                                    if (27 == l[n]) {
                                        t: for (i = 0; i < this.escapeSequences.length; i++) {
                                            const e = this.escapeSequences[i];
                                            if (!(u - n < e.length)) {
                                                for (r = 1; r < e.length; r++) if (e[r] != l[n + r]) continue t;
                                                a++, (n += e.length - 1);
                                                continue e;
                                            }
                                        }
                                        o++;
                                    }
                                    (14 != l[n] && 15 != l[n]) || c++;
                                }
                                return 0 == a
                                    ? null
                                    : ((s = (100 * a - 100 * o) / (a + o)),
                                      a + c < 5 && (s -= 10 * (5 - (a + c))),
                                      s <= 0 ? null : (0, t.default)(e, this, s));
                            }
                        }
                        return (
                            (Uc.ISO_2022_JP = class extends n {
                                constructor() {
                                    super(...arguments),
                                        (this.escapeSequences = [
                                            [27, 36, 40, 67],
                                            [27, 36, 40, 68],
                                            [27, 36, 64],
                                            [27, 36, 65],
                                            [27, 36, 66],
                                            [27, 38, 64],
                                            [27, 40, 66],
                                            [27, 40, 72],
                                            [27, 40, 73],
                                            [27, 40, 74],
                                            [27, 46, 65],
                                            [27, 46, 70],
                                        ]);
                                }
                                name() {
                                    return "ISO-2022-JP";
                                }
                                language() {
                                    return "ja";
                                }
                            }),
                            (Uc.ISO_2022_KR = class extends n {
                                constructor() {
                                    super(...arguments), (this.escapeSequences = [[27, 36, 41, 67]]);
                                }
                                name() {
                                    return "ISO-2022-KR";
                                }
                                language() {
                                    return "kr";
                                }
                            }),
                            (Uc.ISO_2022_CN = class extends n {
                                constructor() {
                                    super(...arguments),
                                        (this.escapeSequences = [
                                            [27, 36, 41, 65],
                                            [27, 36, 41, 71],
                                            [27, 36, 42, 72],
                                            [27, 36, 41, 69],
                                            [27, 36, 43, 73],
                                            [27, 36, 43, 74],
                                            [27, 36, 43, 75],
                                            [27, 36, 43, 76],
                                            [27, 36, 43, 77],
                                            [27, 78],
                                            [27, 79],
                                        ]);
                                }
                                name() {
                                    return "ISO-2022-CN";
                                }
                                language() {
                                    return "zh";
                                }
                            }),
                            Uc
                        );
                    })()
                ),
                h =
                    ($c ||
                        (($c = 1),
                        Object.defineProperty(Wc, "__esModule", { value: !0 }),
                        (Wc.isByteArray = void 0),
                        (Wc.isByteArray = (e) =>
                            null != e && "object" == typeof e && isFinite(e.length) && e.length >= 0)),
                    Wc),
                m = [
                    new o.default(),
                    new c.UTF_16BE(),
                    new c.UTF_16LE(),
                    new c.UTF_32BE(),
                    new c.UTF_32LE(),
                    new l.sjis(),
                    new l.big5(),
                    new l.euc_jp(),
                    new l.euc_kr(),
                    new l.gb_18030(),
                    new d.ISO_2022_JP(),
                    new d.ISO_2022_KR(),
                    new d.ISO_2022_CN(),
                    new u.ISO_8859_1(),
                    new u.ISO_8859_2(),
                    new u.ISO_8859_5(),
                    new u.ISO_8859_6(),
                    new u.ISO_8859_7(),
                    new u.ISO_8859_8(),
                    new u.ISO_8859_9(),
                    new u.windows_1251(),
                    new u.windows_1256(),
                    new u.KOI8_R(),
                    new a.default(),
                ];
            (e.detect = (t) => {
                const n = (0, e.analyse)(t);
                return n.length > 0 ? n[0].name : null;
            }),
                (e.analyse = (e) => {
                    if (!(0, h.isByteArray)(e))
                        throw new Error("Input must be a byte array, e.g. Buffer or Uint8Array");
                    const t = [];
                    for (let i = 0; i < 256; i++) t[i] = 0;
                    for (let i = e.length - 1; i >= 0; i--) t[255 & e[i]]++;
                    let n = !1;
                    for (let i = 128; i <= 159; i += 1)
                        if (0 !== t[i]) {
                            n = !0;
                            break;
                        }
                    const r = {
                        byteStats: t,
                        c1Bytes: n,
                        rawInput: e,
                        rawLen: e.length,
                        inputBytes: e,
                        inputLen: e.length,
                    };
                    return m
                        .map((e) => e.match(r))
                        .filter((e) => !!e)
                        .sort((e, t) => t.confidence - e.confidence);
                }),
                (e.detectFile = (t, n = {}) =>
                    new Promise((r, i) => {
                        let a;
                        const o = (0, s.default)(),
                            c = (t, n) => {
                                a && o.closeSync(a), t ? i(t) : r((0, e.detect)(n));
                            };
                        if (n && n.sampleSize) {
                            a = o.openSync(t, "r");
                            const e = Buffer.allocUnsafe(n.sampleSize);
                            return void o.read(a, e, 0, n.sampleSize, n.offset, (t) => {
                                c(t, e);
                            });
                        }
                        o.readFile(t, c);
                    })),
                (e.detectFileSync = (t, n = {}) => {
                    const r = (0, s.default)();
                    if (n && n.sampleSize) {
                        const i = r.openSync(t, "r"),
                            s = Buffer.allocUnsafe(n.sampleSize);
                        return r.readSync(i, s, 0, n.sampleSize, n.offset), r.closeSync(i), (0, e.detect)(s);
                    }
                    return (0, e.detect)(r.readFileSync(t));
                }),
                (e.default = {
                    analyse: e.analyse,
                    detect: e.detect,
                    detectFileSync: e.detectFileSync,
                    detectFile: e.detectFile,
                });
        })(vc)),
    vc);
const Hc = kc(jc);
class qc extends Error {
    constructor() {
        super("End-Of-Stream"), (this.name = "EndOfStreamError");
    }
}
let Xc = class extends Error {
    constructor(e = "The operation was aborted") {
        super(e), (this.name = "AbortError");
    }
};
class Gc {
    constructor() {
        (this.endOfStream = !1), (this.interrupted = !1), (this.peekQueue = []);
    }
    async peek(e, t = !1) {
        const n = await this.read(e, t);
        return this.peekQueue.push(e.subarray(0, n)), n;
    }
    async read(e, t = !1) {
        if (0 === e.length) return 0;
        let n = this.readFromPeekBuffer(e);
        if ((this.endOfStream || (n += await this.readRemainderFromStream(e.subarray(n), t)), 0 === n && !t))
            throw new qc();
        return n;
    }
    readFromPeekBuffer(e) {
        let t = e.length,
            n = 0;
        for (; this.peekQueue.length > 0 && t > 0; ) {
            const r = this.peekQueue.pop();
            if (!r) throw new Error("peekData should be defined");
            const i = Math.min(r.length, t);
            e.set(r.subarray(0, i), n), (n += i), (t -= i), i < r.length && this.peekQueue.push(r.subarray(i));
        }
        return n;
    }
    async readRemainderFromStream(e, t) {
        let n = 0;
        for (; n < e.length && !this.endOfStream; ) {
            if (this.interrupted) throw new Xc();
            const r = await this.readFromStream(e.subarray(n), t);
            if (0 === r) break;
            n += r;
        }
        if (!t && n < e.length) throw new qc();
        return n;
    }
}
class Kc extends Gc {
    constructor(e) {
        super(), (this.reader = e);
    }
    async abort() {
        return this.close();
    }
    async close() {
        this.reader.releaseLock();
    }
}
class Yc extends Kc {
    async readFromStream(e, t) {
        if (0 === e.length) return 0;
        const n = await this.reader.read(new Uint8Array(e.length), { min: t ? void 0 : e.length });
        return n.done && (this.endOfStream = n.done), n.value ? (e.set(n.value), n.value.length) : 0;
    }
}
class Qc extends Gc {
    constructor(e) {
        super(), (this.reader = e), (this.buffer = null);
    }
    writeChunk(e, t) {
        const n = Math.min(t.length, e.length);
        return e.set(t.subarray(0, n)), n < t.length ? (this.buffer = t.subarray(n)) : (this.buffer = null), n;
    }
    async readFromStream(e, t) {
        if (0 === e.length) return 0;
        let n = 0;
        for (this.buffer && (n += this.writeChunk(e, this.buffer)); n < e.length && !this.endOfStream; ) {
            const t = await this.reader.read();
            if (t.done) {
                this.endOfStream = !0;
                break;
            }
            t.value && (n += this.writeChunk(e.subarray(n), t.value));
        }
        if (!t && 0 === n && this.endOfStream) throw new qc();
        return n;
    }
    abort() {
        return (this.interrupted = !0), this.reader.cancel();
    }
    async close() {
        await this.abort(), this.reader.releaseLock();
    }
}
class Jc {
    constructor(e) {
        (this.numBuffer = new Uint8Array(8)),
            (this.position = 0),
            (this.onClose = e?.onClose),
            e?.abortSignal &&
                e.abortSignal.addEventListener("abort", () => {
                    this.abort();
                });
    }
    async readToken(e, t = this.position) {
        const n = new Uint8Array(e.len);
        if ((await this.readBuffer(n, { position: t })) < e.len) throw new qc();
        return e.get(n, 0);
    }
    async peekToken(e, t = this.position) {
        const n = new Uint8Array(e.len);
        if ((await this.peekBuffer(n, { position: t })) < e.len) throw new qc();
        return e.get(n, 0);
    }
    async readNumber(e) {
        if ((await this.readBuffer(this.numBuffer, { length: e.len })) < e.len) throw new qc();
        return e.get(this.numBuffer, 0);
    }
    async peekNumber(e) {
        if ((await this.peekBuffer(this.numBuffer, { length: e.len })) < e.len) throw new qc();
        return e.get(this.numBuffer, 0);
    }
    async ignore(e) {
        if (void 0 !== this.fileInfo.size) {
            const t = this.fileInfo.size - this.position;
            if (e > t) return (this.position += t), t;
        }
        return (this.position += e), e;
    }
    async close() {
        await this.abort(), await this.onClose?.();
    }
    normalizeOptions(e, t) {
        if (!this.supportsRandomAccess() && t && void 0 !== t.position && t.position < this.position)
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        return { mayBeLess: !1, offset: 0, length: e.length, position: this.position, ...t };
    }
    abort() {
        return Promise.resolve();
    }
}
class Zc extends Jc {
    constructor(e, t) {
        super(t), (this.streamReader = e), (this.fileInfo = t?.fileInfo ?? {});
    }
    async readBuffer(e, t) {
        const n = this.normalizeOptions(e, t),
            r = n.position - this.position;
        if (r > 0) return await this.ignore(r), this.readBuffer(e, t);
        if (r < 0) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        if (0 === n.length) return 0;
        const i = await this.streamReader.read(e.subarray(0, n.length), n.mayBeLess);
        if (((this.position += i), (!t || !t.mayBeLess) && i < n.length)) throw new qc();
        return i;
    }
    async peekBuffer(e, t) {
        const n = this.normalizeOptions(e, t);
        let r = 0;
        if (n.position) {
            const t = n.position - this.position;
            if (t > 0) {
                const i = new Uint8Array(n.length + t);
                return (r = await this.peekBuffer(i, { mayBeLess: n.mayBeLess })), e.set(i.subarray(t)), r - t;
            }
            if (t < 0) throw new Error("Cannot peek from a negative offset in a stream");
        }
        if (n.length > 0) {
            try {
                r = await this.streamReader.peek(e.subarray(0, n.length), n.mayBeLess);
            } catch (i) {
                if (t?.mayBeLess && i instanceof qc) return 0;
                throw i;
            }
            if (!n.mayBeLess && r < n.length) throw new qc();
        }
        return r;
    }
    async ignore(e) {
        const t = Math.min(256e3, e),
            n = new Uint8Array(t);
        let r = 0;
        for (; r < e; ) {
            const i = e - r,
                s = await this.readBuffer(n, { length: Math.min(t, i) });
            if (s < 0) return s;
            r += s;
        }
        return r;
    }
    abort() {
        return this.streamReader.abort();
    }
    async close() {
        return this.streamReader.close();
    }
    supportsRandomAccess() {
        return !1;
    }
}
class el extends Jc {
    constructor(e, t) {
        super(t), (this.uint8Array = e), (this.fileInfo = { ...(t?.fileInfo ?? {}), size: e.length });
    }
    async readBuffer(e, t) {
        t?.position && (this.position = t.position);
        const n = await this.peekBuffer(e, t);
        return (this.position += n), n;
    }
    async peekBuffer(e, t) {
        const n = this.normalizeOptions(e, t),
            r = Math.min(this.uint8Array.length - n.position, n.length);
        if (!n.mayBeLess && r < n.length) throw new qc();
        return e.set(this.uint8Array.subarray(n.position, n.position + r)), r;
    }
    close() {
        return super.close();
    }
    supportsRandomAccess() {
        return !0;
    }
    setPosition(e) {
        this.position = e;
    }
}
function tl(e, t) {
    const n = (function (e) {
            try {
                const t = e.getReader({ mode: "byob" });
                return t instanceof ReadableStreamDefaultReader ? new Qc(t) : new Yc(t);
            } catch (t) {
                if (t instanceof TypeError) return new Qc(e.getReader());
                throw t;
            }
        })(e),
        r = t ?? {},
        i = r.onClose;
    return (
        (r.onClose = async () => {
            if ((await n.close(), i)) return i();
        }),
        new Zc(n, r)
    );
}
function nl(e, t) {
    return new el(e, t);
}
var rl,
    il = {};
var sl =
    (rl ||
        ((rl = 1),
        (il.read = function (e, t, n, r, i) {
            var s,
                a,
                o = 8 * i - r - 1,
                c = (1 << o) - 1,
                l = c >> 1,
                u = -7,
                d = n ? i - 1 : 0,
                h = n ? -1 : 1,
                m = e[t + d];
            for (d += h, s = m & ((1 << -u) - 1), m >>= -u, u += o; u > 0; s = 256 * s + e[t + d], d += h, u -= 8);
            for (a = s & ((1 << -u) - 1), s >>= -u, u += r; u > 0; a = 256 * a + e[t + d], d += h, u -= 8);
            if (0 === s) s = 1 - l;
            else {
                if (s === c) return a ? NaN : (1 / 0) * (m ? -1 : 1);
                (a += Math.pow(2, r)), (s -= l);
            }
            return (m ? -1 : 1) * a * Math.pow(2, s - r);
        }),
        (il.write = function (e, t, n, r, i, s) {
            var a,
                o,
                c,
                l = 8 * s - i - 1,
                u = (1 << l) - 1,
                d = u >> 1,
                h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                m = r ? 0 : s - 1,
                p = r ? 1 : -1,
                f = t < 0 || (0 === t && 1 / t < 0) ? 1 : 0;
            for (
                t = Math.abs(t),
                    isNaN(t) || t === 1 / 0
                        ? ((o = isNaN(t) ? 1 : 0), (a = u))
                        : ((a = Math.floor(Math.log(t) / Math.LN2)),
                          t * (c = Math.pow(2, -a)) < 1 && (a--, (c *= 2)),
                          (t += a + d >= 1 ? h / c : h * Math.pow(2, 1 - d)) * c >= 2 && (a++, (c /= 2)),
                          a + d >= u
                              ? ((o = 0), (a = u))
                              : a + d >= 1
                                ? ((o = (t * c - 1) * Math.pow(2, i)), (a += d))
                                : ((o = t * Math.pow(2, d - 1) * Math.pow(2, i)), (a = 0)));
                i >= 8;
                e[n + m] = 255 & o, m += p, o /= 256, i -= 8
            );
            for (a = (a << i) | o, l += i; l > 0; e[n + m] = 255 & a, m += p, a /= 256, l -= 8);
            e[n + m - p] |= 128 * f;
        })),
    il);
function al(e) {
    return new DataView(e.buffer, e.byteOffset);
}
const ol = { len: 1, get: (e, t) => al(e).getUint8(t), put: (e, t, n) => (al(e).setUint8(t, n), t + 1) },
    cl = { len: 2, get: (e, t) => al(e).getUint16(t, !0), put: (e, t, n) => (al(e).setUint16(t, n, !0), t + 2) },
    ll = { len: 2, get: (e, t) => al(e).getUint16(t), put: (e, t, n) => (al(e).setUint16(t, n), t + 2) },
    ul = {
        len: 3,
        get(e, t) {
            const n = al(e);
            return n.getUint8(t) + (n.getUint16(t + 1, !0) << 8);
        },
        put(e, t, n) {
            const r = al(e);
            return r.setUint8(t, 255 & n), r.setUint16(t + 1, n >> 8, !0), t + 3;
        },
    },
    dl = {
        len: 3,
        get(e, t) {
            const n = al(e);
            return (n.getUint16(t) << 8) + n.getUint8(t + 2);
        },
        put(e, t, n) {
            const r = al(e);
            return r.setUint16(t, n >> 8), r.setUint8(t + 2, 255 & n), t + 3;
        },
    },
    hl = { len: 4, get: (e, t) => al(e).getUint32(t, !0), put: (e, t, n) => (al(e).setUint32(t, n, !0), t + 4) },
    ml = { len: 4, get: (e, t) => al(e).getUint32(t), put: (e, t, n) => (al(e).setUint32(t, n), t + 4) },
    pl = { len: 1, get: (e, t) => al(e).getInt8(t), put: (e, t, n) => (al(e).setInt8(t, n), t + 1) },
    fl = { len: 2, get: (e, t) => al(e).getInt16(t), put: (e, t, n) => (al(e).setInt16(t, n), t + 2) },
    gl = { len: 2, get: (e, t) => al(e).getInt16(t, !0), put: (e, t, n) => (al(e).setInt16(t, n, !0), t + 2) },
    bl = {
        len: 3,
        get(e, t) {
            const n = ul.get(e, t);
            return n > 8388607 ? n - 16777216 : n;
        },
        put(e, t, n) {
            const r = al(e);
            return r.setUint8(t, 255 & n), r.setUint16(t + 1, n >> 8, !0), t + 3;
        },
    },
    yl = {
        len: 3,
        get(e, t) {
            const n = dl.get(e, t);
            return n > 8388607 ? n - 16777216 : n;
        },
        put(e, t, n) {
            const r = al(e);
            return r.setUint16(t, n >> 8), r.setUint8(t + 2, 255 & n), t + 3;
        },
    },
    wl = { len: 4, get: (e, t) => al(e).getInt32(t), put: (e, t, n) => (al(e).setInt32(t, n), t + 4) },
    kl = { len: 4, get: (e, t) => al(e).getInt32(t, !0), put: (e, t, n) => (al(e).setInt32(t, n, !0), t + 4) },
    Tl = { len: 8, get: (e, t) => al(e).getBigUint64(t, !0), put: (e, t, n) => (al(e).setBigUint64(t, n, !0), t + 8) },
    _l = { len: 8, get: (e, t) => al(e).getBigInt64(t, !0), put: (e, t, n) => (al(e).setBigInt64(t, n, !0), t + 8) },
    vl = { len: 8, get: (e, t) => al(e).getBigUint64(t), put: (e, t, n) => (al(e).setBigUint64(t, n), t + 8) },
    Sl = { len: 8, get: (e, t) => al(e).getBigInt64(t), put: (e, t, n) => (al(e).setBigInt64(t, n), t + 8) },
    El = {
        len: 2,
        get(e, t) {
            return sl.read(e, t, !1, 10, this.len);
        },
        put(e, t, n) {
            return sl.write(e, n, t, !1, 10, this.len), t + this.len;
        },
    },
    Cl = {
        len: 2,
        get(e, t) {
            return sl.read(e, t, !0, 10, this.len);
        },
        put(e, t, n) {
            return sl.write(e, n, t, !0, 10, this.len), t + this.len;
        },
    },
    Il = { len: 4, get: (e, t) => al(e).getFloat32(t), put: (e, t, n) => (al(e).setFloat32(t, n), t + 4) },
    xl = { len: 4, get: (e, t) => al(e).getFloat32(t, !0), put: (e, t, n) => (al(e).setFloat32(t, n, !0), t + 4) },
    Al = { len: 8, get: (e, t) => al(e).getFloat64(t), put: (e, t, n) => (al(e).setFloat64(t, n), t + 8) },
    Pl = { len: 8, get: (e, t) => al(e).getFloat64(t, !0), put: (e, t, n) => (al(e).setFloat64(t, n, !0), t + 8) },
    Ol = {
        len: 10,
        get(e, t) {
            return sl.read(e, t, !1, 63, this.len);
        },
        put(e, t, n) {
            return sl.write(e, n, t, !1, 63, this.len), t + this.len;
        },
    },
    Nl = {
        len: 10,
        get(e, t) {
            return sl.read(e, t, !0, 63, this.len);
        },
        put(e, t, n) {
            return sl.write(e, n, t, !0, 63, this.len), t + this.len;
        },
    };
class Rl {
    constructor(e) {
        this.len = e;
    }
    get(e, t) {
        return e.subarray(t, t + this.len);
    }
}
class Ml {
    constructor(e, t) {
        if (((this.len = e), t && "windows-1252" === t.toLowerCase())) this.decoder = Ml.decodeWindows1252;
        else {
            const e = new TextDecoder(t);
            this.decoder = (t) => e.decode(t);
        }
    }
    get(e, t = 0) {
        const n = e.subarray(t, t + this.len);
        return this.decoder(n);
    }
    static decodeWindows1252(e) {
        let t = "";
        for (let n = 0; n < e.length; n++) {
            const r = e[n];
            t += r < 128 || r >= 160 ? String.fromCharCode(r) : Ml.win1252Map[r - 128];
        }
        return t;
    }
}
Ml.win1252Map = "";
const Dl = Object.freeze(
    Object.defineProperty(
        {
            __proto__: null,
            AnsiStringType: class extends Ml {
                constructor(e) {
                    super(e, "windows-1252");
                }
            },
            Float16_BE: El,
            Float16_LE: Cl,
            Float32_BE: Il,
            Float32_LE: xl,
            Float64_BE: Al,
            Float64_LE: Pl,
            Float80_BE: Ol,
            Float80_LE: Nl,
            INT16_BE: fl,
            INT16_LE: gl,
            INT24_BE: yl,
            INT24_LE: bl,
            INT32_BE: wl,
            INT32_LE: kl,
            INT64_BE: Sl,
            INT64_LE: _l,
            INT8: pl,
            IgnoreType: class {
                constructor(e) {
                    this.len = e;
                }
                get(e, t) {}
            },
            StringType: Ml,
            UINT16_BE: ll,
            UINT16_LE: cl,
            UINT24_BE: dl,
            UINT24_LE: ul,
            UINT32_BE: ml,
            UINT32_LE: hl,
            UINT64_BE: vl,
            UINT64_LE: Tl,
            UINT8: ol,
            Uint8ArrayType: Rl,
        },
        Symbol.toStringTag,
        { value: "Module" }
    )
);
var Fl = Uint8Array,
    Ll = Uint16Array,
    Bl = Int32Array,
    zl = new Fl([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
    Ul = new Fl([
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0,
    ]),
    $l = new Fl([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
    Vl = function (e, t) {
        for (var n = new Ll(31), r = 0; r < 31; ++r) n[r] = t += 1 << e[r - 1];
        var i = new Bl(n[30]);
        for (r = 1; r < 30; ++r) for (var s = n[r]; s < n[r + 1]; ++s) i[s] = ((s - n[r]) << 5) | r;
        return { b: n, r: i };
    },
    Wl = Vl(zl, 2),
    jl = Wl.b,
    Hl = Wl.r;
(jl[28] = 258), (Hl[258] = 28);
for (var ql = Vl(Ul, 0).b, Xl = new Ll(32768), Gl = 0; Gl < 32768; ++Gl) {
    var Kl = ((43690 & Gl) >> 1) | ((21845 & Gl) << 1);
    (Kl = ((61680 & (Kl = ((52428 & Kl) >> 2) | ((13107 & Kl) << 2))) >> 4) | ((3855 & Kl) << 4)),
        (Xl[Gl] = (((65280 & Kl) >> 8) | ((255 & Kl) << 8)) >> 1);
}
var Yl = function (e, t, n) {
        for (var r = e.length, i = 0, s = new Ll(t); i < r; ++i) e[i] && ++s[e[i] - 1];
        var a,
            o = new Ll(t);
        for (i = 1; i < t; ++i) o[i] = (o[i - 1] + s[i - 1]) << 1;
        if (n) {
            a = new Ll(1 << t);
            var c = 15 - t;
            for (i = 0; i < r; ++i)
                if (e[i])
                    for (
                        var l = (i << 4) | e[i], u = t - e[i], d = o[e[i] - 1]++ << u, h = d | ((1 << u) - 1);
                        d <= h;
                        ++d
                    )
                        a[Xl[d] >> c] = l;
        } else for (a = new Ll(r), i = 0; i < r; ++i) e[i] && (a[i] = Xl[o[e[i] - 1]++] >> (15 - e[i]));
        return a;
    },
    Ql = new Fl(288);
for (Gl = 0; Gl < 144; ++Gl) Ql[Gl] = 8;
for (Gl = 144; Gl < 256; ++Gl) Ql[Gl] = 9;
for (Gl = 256; Gl < 280; ++Gl) Ql[Gl] = 7;
for (Gl = 280; Gl < 288; ++Gl) Ql[Gl] = 8;
var Jl = new Fl(32);
for (Gl = 0; Gl < 32; ++Gl) Jl[Gl] = 5;
var Zl = Yl(Ql, 9, 1),
    eu = Yl(Jl, 5, 1),
    tu = function (e) {
        for (var t = e[0], n = 1; n < e.length; ++n) e[n] > t && (t = e[n]);
        return t;
    },
    nu = function (e, t, n) {
        var r = (t / 8) | 0;
        return ((e[r] | (e[r + 1] << 8)) >> (7 & t)) & n;
    },
    ru = function (e, t) {
        var n = (t / 8) | 0;
        return (e[n] | (e[n + 1] << 8) | (e[n + 2] << 16)) >> (7 & t);
    },
    iu = function (e) {
        return ((e + 7) / 8) | 0;
    },
    su = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data",
    ],
    au = function (e, t, n) {
        var r = new Error(t || su[e]);
        if (((r.code = e), Error.captureStackTrace && Error.captureStackTrace(r, au), !n)) throw r;
        return r;
    },
    ou = function (e, t, n, r) {
        var i = e.length;
        if (!i || (t.f && !t.l)) return n || new Fl(0);
        var s = !n,
            a = s || 2 != t.i,
            o = t.i;
        s && (n = new Fl(3 * i));
        var c = function (e) {
                var t = n.length;
                if (e > t) {
                    var r = new Fl(Math.max(2 * t, e));
                    r.set(n), (n = r);
                }
            },
            l = t.f || 0,
            u = t.p || 0,
            d = t.b || 0,
            h = t.l,
            m = t.d,
            p = t.m,
            f = t.n,
            g = 8 * i;
        do {
            if (!h) {
                l = nu(e, u, 1);
                var b = nu(e, u + 1, 3);
                if (((u += 3), !b)) {
                    var y = e[(A = iu(u) + 4) - 4] | (e[A - 3] << 8),
                        w = A + y;
                    if (w > i) {
                        o && au(0);
                        break;
                    }
                    a && c(d + y), n.set(e.subarray(A, w), d), (t.b = d += y), (t.p = u = 8 * w), (t.f = l);
                    continue;
                }
                if (1 == b) (h = Zl), (m = eu), (p = 9), (f = 5);
                else if (2 == b) {
                    var k = nu(e, u, 31) + 257,
                        T = nu(e, u + 10, 15) + 4,
                        _ = k + nu(e, u + 5, 31) + 1;
                    u += 14;
                    for (var v = new Fl(_), S = new Fl(19), E = 0; E < T; ++E) S[$l[E]] = nu(e, u + 3 * E, 7);
                    u += 3 * T;
                    var C = tu(S),
                        I = (1 << C) - 1,
                        x = Yl(S, C, 1);
                    for (E = 0; E < _; ) {
                        var A,
                            P = x[nu(e, u, I)];
                        if (((u += 15 & P), (A = P >> 4) < 16)) v[E++] = A;
                        else {
                            var O = 0,
                                N = 0;
                            for (
                                16 == A
                                    ? ((N = 3 + nu(e, u, 3)), (u += 2), (O = v[E - 1]))
                                    : 17 == A
                                      ? ((N = 3 + nu(e, u, 7)), (u += 3))
                                      : 18 == A && ((N = 11 + nu(e, u, 127)), (u += 7));
                                N--;

                            )
                                v[E++] = O;
                        }
                    }
                    var R = v.subarray(0, k),
                        M = v.subarray(k);
                    (p = tu(R)), (f = tu(M)), (h = Yl(R, p, 1)), (m = Yl(M, f, 1));
                } else au(1);
                if (u > g) {
                    o && au(0);
                    break;
                }
            }
            a && c(d + 131072);
            for (var D = (1 << p) - 1, F = (1 << f) - 1, L = u; ; L = u) {
                var B = (O = h[ru(e, u) & D]) >> 4;
                if ((u += 15 & O) > g) {
                    o && au(0);
                    break;
                }
                if ((O || au(2), B < 256)) n[d++] = B;
                else {
                    if (256 == B) {
                        (L = u), (h = null);
                        break;
                    }
                    var z = B - 254;
                    if (B > 264) {
                        var U = zl[(E = B - 257)];
                        (z = nu(e, u, (1 << U) - 1) + jl[E]), (u += U);
                    }
                    var $ = m[ru(e, u) & F],
                        V = $ >> 4;
                    $ || au(3), (u += 15 & $);
                    M = ql[V];
                    if (V > 3) {
                        U = Ul[V];
                        (M += ru(e, u) & ((1 << U) - 1)), (u += U);
                    }
                    if (u > g) {
                        o && au(0);
                        break;
                    }
                    a && c(d + 131072);
                    var W = d + z;
                    if (d < M) {
                        var j = 0 - M,
                            H = Math.min(M, W);
                        for (j + d < 0 && au(3); d < H; ++d) n[d] = r[j + d];
                    }
                    for (; d < W; ++d) n[d] = n[d - M];
                }
            }
            (t.l = h), (t.p = L), (t.b = d), (t.f = l), h && ((l = 1), (t.m = p), (t.d = m), (t.n = f));
        } while (!l);
        return d != n.length && s
            ? (function (e, t, n) {
                  return (null == n || n > e.length) && (n = e.length), new Fl(e.subarray(t, n));
              })(n, 0, d)
            : n.subarray(0, d);
    },
    cu = new Fl(0);
function lu(e, t) {
    var n,
        r,
        i = (function (e) {
            (31 == e[0] && 139 == e[1] && 8 == e[2]) || au(6, "invalid gzip data");
            var t = e[3],
                n = 10;
            4 & t && (n += 2 + (e[10] | (e[11] << 8)));
            for (var r = ((t >> 3) & 1) + ((t >> 4) & 1); r > 0; r -= !e[n++]);
            return n + (2 & t);
        })(e);
    return (
        i + 8 > e.length && au(6, "invalid gzip data"),
        ou(
            e.subarray(i, -8),
            { i: 2 },
            new Fl(((r = (n = e).length), (n[r - 4] | (n[r - 3] << 8) | (n[r - 2] << 16) | (n[r - 1] << 24)) >>> 0)),
            t
        )
    );
}
function uu(e, t) {
    return ou(
        e.subarray(
            ((8 != (15 & (n = e)[0]) || n[0] >> 4 > 7 || ((n[0] << 8) | n[1]) % 31) && au(6, "invalid zlib data"),
            1 == ((n[1] >> 5) & 1) &&
                au(6, "invalid zlib data: " + (32 & n[1] ? "need" : "unexpected") + " dictionary"),
            2 + ((n[1] >> 3) & 4)),
            -4
        ),
        { i: 2 },
        t,
        t
    );
    var n;
}
function du(e, t) {
    return 31 == e[0] && 139 == e[1] && 8 == e[2]
        ? lu(e, t)
        : 8 != (15 & e[0]) || e[0] >> 4 > 7 || ((e[0] << 8) | e[1]) % 31
          ? (function (e, t) {
                return ou(e, { i: 2 }, t, t);
            })(e, t)
          : uu(e, t);
}
var hu = "undefined" != typeof TextDecoder && new TextDecoder();
try {
    hu.decode(cu, { stream: !0 });
} catch (ez) {}
var mu,
    pu,
    fu,
    gu,
    bu,
    yu = { exports: {} };
function wu() {
    if (pu) return mu;
    pu = 1;
    var e = 1e3,
        t = 60 * e,
        n = 60 * t,
        r = 24 * n,
        i = 7 * r,
        s = 365.25 * r;
    function a(e, t, n, r) {
        var i = t >= 1.5 * n;
        return Math.round(e / n) + " " + r + (i ? "s" : "");
    }
    return (mu = function (o, c) {
        c = c || {};
        var l = typeof o;
        if ("string" === l && o.length > 0)
            return (function (a) {
                if ((a = String(a)).length > 100) return;
                var o =
                    /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
                        a
                    );
                if (!o) return;
                var c = parseFloat(o[1]);
                switch ((o[2] || "ms").toLowerCase()) {
                    case "years":
                    case "year":
                    case "yrs":
                    case "yr":
                    case "y":
                        return c * s;
                    case "weeks":
                    case "week":
                    case "w":
                        return c * i;
                    case "days":
                    case "day":
                    case "d":
                        return c * r;
                    case "hours":
                    case "hour":
                    case "hrs":
                    case "hr":
                    case "h":
                        return c * n;
                    case "minutes":
                    case "minute":
                    case "mins":
                    case "min":
                    case "m":
                        return c * t;
                    case "seconds":
                    case "second":
                    case "secs":
                    case "sec":
                    case "s":
                        return c * e;
                    case "milliseconds":
                    case "millisecond":
                    case "msecs":
                    case "msec":
                    case "ms":
                        return c;
                    default:
                        return;
                }
            })(o);
        if ("number" === l && isFinite(o))
            return c.long
                ? (function (i) {
                      var s = Math.abs(i);
                      if (s >= r) return a(i, s, r, "day");
                      if (s >= n) return a(i, s, n, "hour");
                      if (s >= t) return a(i, s, t, "minute");
                      if (s >= e) return a(i, s, e, "second");
                      return i + " ms";
                  })(o)
                : (function (i) {
                      var s = Math.abs(i);
                      if (s >= r) return Math.round(i / r) + "d";
                      if (s >= n) return Math.round(i / n) + "h";
                      if (s >= t) return Math.round(i / t) + "m";
                      if (s >= e) return Math.round(i / e) + "s";
                      return i + "ms";
                  })(o);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(o));
    });
}
var ku =
    (bu ||
        ((bu = 1),
        (function (e, t) {
            var n = {};
            (t.formatArgs = function (t) {
                if (
                    ((t[0] =
                        (this.useColors ? "%c" : "") +
                        this.namespace +
                        (this.useColors ? " %c" : " ") +
                        t[0] +
                        (this.useColors ? "%c " : " ") +
                        "+" +
                        e.exports.humanize(this.diff)),
                    !this.useColors)
                )
                    return;
                const n = "color: " + this.color;
                t.splice(1, 0, n, "color: inherit");
                let r = 0,
                    i = 0;
                t[0].replace(/%[a-zA-Z%]/g, (e) => {
                    "%%" !== e && (r++, "%c" === e && (i = r));
                }),
                    t.splice(i, 0, n);
            }),
                (t.save = function (e) {
                    try {
                        e ? t.storage.setItem("debug", e) : t.storage.removeItem("debug");
                    } catch (n) {}
                }),
                (t.load = function () {
                    let e;
                    try {
                        e = t.storage.getItem("debug") || t.storage.getItem("DEBUG");
                    } catch (r) {}
                    return !e && "undefined" != typeof process && "env" in process && (e = n.DEBUG), e;
                }),
                (t.useColors = function () {
                    if (
                        "undefined" != typeof window &&
                        window.process &&
                        ("renderer" === window.process.type || window.process.__nwjs)
                    )
                        return !0;
                    if (
                        "undefined" != typeof navigator &&
                        navigator.userAgent &&
                        navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
                    )
                        return !1;
                    let e;
                    return (
                        ("undefined" != typeof document &&
                            document.documentElement &&
                            document.documentElement.style &&
                            document.documentElement.style.WebkitAppearance) ||
                        ("undefined" != typeof window &&
                            window.console &&
                            (window.console.firebug || (window.console.exception && window.console.table))) ||
                        ("undefined" != typeof navigator &&
                            navigator.userAgent &&
                            (e = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
                            parseInt(e[1], 10) >= 31) ||
                        ("undefined" != typeof navigator &&
                            navigator.userAgent &&
                            navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
                    );
                }),
                (t.storage = (function () {
                    try {
                        return localStorage;
                    } catch (e) {}
                })()),
                (t.destroy = (() => {
                    let e = !1;
                    return () => {
                        e || (e = !0);
                    };
                })()),
                (t.colors = [
                    "#0000CC",
                    "#0000FF",
                    "#0033CC",
                    "#0033FF",
                    "#0066CC",
                    "#0066FF",
                    "#0099CC",
                    "#0099FF",
                    "#00CC00",
                    "#00CC33",
                    "#00CC66",
                    "#00CC99",
                    "#00CCCC",
                    "#00CCFF",
                    "#3300CC",
                    "#3300FF",
                    "#3333CC",
                    "#3333FF",
                    "#3366CC",
                    "#3366FF",
                    "#3399CC",
                    "#3399FF",
                    "#33CC00",
                    "#33CC33",
                    "#33CC66",
                    "#33CC99",
                    "#33CCCC",
                    "#33CCFF",
                    "#6600CC",
                    "#6600FF",
                    "#6633CC",
                    "#6633FF",
                    "#66CC00",
                    "#66CC33",
                    "#9900CC",
                    "#9900FF",
                    "#9933CC",
                    "#9933FF",
                    "#99CC00",
                    "#99CC33",
                    "#CC0000",
                    "#CC0033",
                    "#CC0066",
                    "#CC0099",
                    "#CC00CC",
                    "#CC00FF",
                    "#CC3300",
                    "#CC3333",
                    "#CC3366",
                    "#CC3399",
                    "#CC33CC",
                    "#CC33FF",
                    "#CC6600",
                    "#CC6633",
                    "#CC9900",
                    "#CC9933",
                    "#CCCC00",
                    "#CCCC33",
                    "#FF0000",
                    "#FF0033",
                    "#FF0066",
                    "#FF0099",
                    "#FF00CC",
                    "#FF00FF",
                    "#FF3300",
                    "#FF3333",
                    "#FF3366",
                    "#FF3399",
                    "#FF33CC",
                    "#FF33FF",
                    "#FF6600",
                    "#FF6633",
                    "#FF9900",
                    "#FF9933",
                    "#FFCC00",
                    "#FFCC33",
                ]),
                (t.log = console.debug || console.log || (() => {})),
                (e.exports = (gu ||
                    ((gu = 1),
                    (fu = function (e) {
                        function t(e) {
                            let r,
                                i,
                                s,
                                a = null;
                            function o(...e) {
                                if (!o.enabled) return;
                                const n = o,
                                    i = Number(new Date()),
                                    s = i - (r || i);
                                (n.diff = s),
                                    (n.prev = r),
                                    (n.curr = i),
                                    (r = i),
                                    (e[0] = t.coerce(e[0])),
                                    "string" != typeof e[0] && e.unshift("%O");
                                let a = 0;
                                (e[0] = e[0].replace(/%([a-zA-Z%])/g, (r, i) => {
                                    if ("%%" === r) return "%";
                                    a++;
                                    const s = t.formatters[i];
                                    if ("function" == typeof s) {
                                        const t = e[a];
                                        (r = s.call(n, t)), e.splice(a, 1), a--;
                                    }
                                    return r;
                                })),
                                    t.formatArgs.call(n, e),
                                    (n.log || t.log).apply(n, e);
                            }
                            return (
                                (o.namespace = e),
                                (o.useColors = t.useColors()),
                                (o.color = t.selectColor(e)),
                                (o.extend = n),
                                (o.destroy = t.destroy),
                                Object.defineProperty(o, "enabled", {
                                    enumerable: !0,
                                    configurable: !1,
                                    get: () =>
                                        null !== a
                                            ? a
                                            : (i !== t.namespaces && ((i = t.namespaces), (s = t.enabled(e))), s),
                                    set: (e) => {
                                        a = e;
                                    },
                                }),
                                "function" == typeof t.init && t.init(o),
                                o
                            );
                        }
                        function n(e, n) {
                            const r = t(this.namespace + (void 0 === n ? ":" : n) + e);
                            return (r.log = this.log), r;
                        }
                        function r(e, t) {
                            let n = 0,
                                r = 0,
                                i = -1,
                                s = 0;
                            for (; n < e.length; )
                                if (r < t.length && (t[r] === e[n] || "*" === t[r]))
                                    "*" === t[r] ? ((i = r), (s = n), r++) : (n++, r++);
                                else {
                                    if (-1 === i) return !1;
                                    (r = i + 1), s++, (n = s);
                                }
                            for (; r < t.length && "*" === t[r]; ) r++;
                            return r === t.length;
                        }
                        return (
                            (t.debug = t),
                            (t.default = t),
                            (t.coerce = function (e) {
                                return e instanceof Error ? e.stack || e.message : e;
                            }),
                            (t.disable = function () {
                                const e = [...t.names, ...t.skips.map((e) => "-" + e)].join(",");
                                return t.enable(""), e;
                            }),
                            (t.enable = function (e) {
                                t.save(e), (t.namespaces = e), (t.names = []), (t.skips = []);
                                const n = ("string" == typeof e ? e : "")
                                    .trim()
                                    .replace(/\s+/g, ",")
                                    .split(",")
                                    .filter(Boolean);
                                for (const r of n) "-" === r[0] ? t.skips.push(r.slice(1)) : t.names.push(r);
                            }),
                            (t.enabled = function (e) {
                                for (const n of t.skips) if (r(e, n)) return !1;
                                for (const n of t.names) if (r(e, n)) return !0;
                                return !1;
                            }),
                            (t.humanize = wu()),
                            (t.destroy = function () {}),
                            Object.keys(e).forEach((n) => {
                                t[n] = e[n];
                            }),
                            (t.names = []),
                            (t.skips = []),
                            (t.formatters = {}),
                            (t.selectColor = function (e) {
                                let n = 0;
                                for (let t = 0; t < e.length; t++) (n = (n << 5) - n + e.charCodeAt(t)), (n |= 0);
                                return t.colors[Math.abs(n) % t.colors.length];
                            }),
                            t.enable(t.load()),
                            t
                        );
                    })),
                fu)(t));
            const { formatters: r } = e.exports;
            r.j = function (e) {
                try {
                    return JSON.stringify(e);
                } catch (t) {
                    return "[UnexpectedJSONParseError]: " + t.message;
                }
            };
        })(yu, yu.exports)),
    yu.exports);
const Tu = kc(ku),
    _u = 67324752,
    vu = 134695760,
    Su = 33639248,
    Eu = 101010256,
    Cu = {
        get: (e) => (
            cl.get(e, 6), { signature: hl.get(e, 0), compressedSize: hl.get(e, 8), uncompressedSize: hl.get(e, 12) }
        ),
        len: 16,
    },
    Iu = {
        get(e) {
            const t = cl.get(e, 6);
            return {
                signature: hl.get(e, 0),
                minVersion: cl.get(e, 4),
                dataDescriptor: !!(8 & t),
                compressedMethod: cl.get(e, 8),
                compressedSize: hl.get(e, 18),
                uncompressedSize: hl.get(e, 22),
                filenameLength: cl.get(e, 26),
                extraFieldLength: cl.get(e, 28),
                filename: null,
            };
        },
        len: 30,
    },
    xu = {
        get: (e) => ({
            signature: hl.get(e, 0),
            nrOfThisDisk: cl.get(e, 4),
            nrOfThisDiskWithTheStart: cl.get(e, 6),
            nrOfEntriesOnThisDisk: cl.get(e, 8),
            nrOfEntriesOfSize: cl.get(e, 10),
            sizeOfCd: hl.get(e, 12),
            offsetOfStartOfCd: hl.get(e, 16),
            zipFileCommentLength: cl.get(e, 20),
        }),
        len: 22,
    },
    Au = {
        get(e) {
            const t = cl.get(e, 8);
            return {
                signature: hl.get(e, 0),
                minVersion: cl.get(e, 6),
                dataDescriptor: !!(8 & t),
                compressedMethod: cl.get(e, 10),
                compressedSize: hl.get(e, 20),
                uncompressedSize: hl.get(e, 24),
                filenameLength: cl.get(e, 28),
                extraFieldLength: cl.get(e, 30),
                fileCommentLength: cl.get(e, 32),
                relativeOffsetOfLocalHeader: hl.get(e, 42),
                filename: null,
            };
        },
        len: 46,
    };
function Pu(e) {
    const t = new Uint8Array(hl.len);
    return hl.put(t, 0, e), t;
}
const Ou = Tu("tokenizer:inflate"),
    Nu = 262144,
    Ru = Pu(vu),
    Mu = Pu(Eu);
class Du {
    constructor(e) {
        (this.tokenizer = e), (this.syncBuffer = new Uint8Array(Nu));
    }
    async isZip() {
        return (await this.peekSignature()) === _u;
    }
    peekSignature() {
        return this.tokenizer.peekToken(hl);
    }
    async findEndOfCentralDirectoryLocator() {
        const e = this.tokenizer,
            t = Math.min(16384, e.fileInfo.size),
            n = this.syncBuffer.subarray(0, t);
        await this.tokenizer.readBuffer(n, { position: e.fileInfo.size - t });
        for (let r = n.length - 4; r >= 0; r--)
            if (n[r] === Mu[0] && n[r + 1] === Mu[1] && n[r + 2] === Mu[2] && n[r + 3] === Mu[3])
                return e.fileInfo.size - t + r;
        return -1;
    }
    async readCentralDirectory() {
        if (!this.tokenizer.supportsRandomAccess())
            return void Ou("Cannot reading central-directory without random-read support");
        Ou("Reading central-directory...");
        const e = this.tokenizer.position,
            t = await this.findEndOfCentralDirectoryLocator();
        if (t > 0) {
            Ou("Central-directory 32-bit signature found");
            const n = await this.tokenizer.readToken(xu, t),
                r = [];
            this.tokenizer.setPosition(n.offsetOfStartOfCd);
            for (let e = 0; e < n.nrOfEntriesOfSize; ++e) {
                const t = await this.tokenizer.readToken(Au);
                if (t.signature !== Su) throw new Error("Expected Central-File-Header signature");
                (t.filename = await this.tokenizer.readToken(new Ml(t.filenameLength, "utf-8"))),
                    await this.tokenizer.ignore(t.extraFieldLength),
                    await this.tokenizer.ignore(t.fileCommentLength),
                    r.push(t),
                    Ou(`Add central-directory file-entry: n=${e + 1}/${r.length}: filename=${r[e].filename}`);
            }
            return this.tokenizer.setPosition(e), r;
        }
        this.tokenizer.setPosition(e);
    }
    async unzip(e) {
        const t = await this.readCentralDirectory();
        if (t) return this.iterateOverCentralDirectory(t, e);
        let n = !1;
        do {
            const t = await this.readLocalFileHeader();
            if (!t) break;
            const r = e(t);
            let i;
            if (
                ((n = !!r.stop),
                await this.tokenizer.ignore(t.extraFieldLength),
                t.dataDescriptor && 0 === t.compressedSize)
            ) {
                const e = [];
                let n = Nu;
                Ou("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
                let i = -1;
                for (; i < 0 && n === Nu; ) {
                    (n = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: !0 })),
                        (i = Fu(this.syncBuffer.subarray(0, n), Ru));
                    const t = i >= 0 ? i : n;
                    if (r.handler) {
                        const n = new Uint8Array(t);
                        await this.tokenizer.readBuffer(n), e.push(n);
                    } else await this.tokenizer.ignore(t);
                }
                Ou(`Found data-descriptor-signature at pos=${this.tokenizer.position}`),
                    r.handler && (await this.inflate(t, Lu(e), r.handler));
            } else
                r.handler
                    ? (Ou(`Reading compressed-file-data: ${t.compressedSize} bytes`),
                      (i = new Uint8Array(t.compressedSize)),
                      await this.tokenizer.readBuffer(i),
                      await this.inflate(t, i, r.handler))
                    : (Ou(`Ignoring compressed-file-data: ${t.compressedSize} bytes`),
                      await this.tokenizer.ignore(t.compressedSize));
            if ((Ou(`Reading data-descriptor at pos=${this.tokenizer.position}`), t.dataDescriptor)) {
                if (134695760 !== (await this.tokenizer.readToken(Cu)).signature)
                    throw new Error(
                        "Expected data-descriptor-signature at position " + (this.tokenizer.position - Cu.len)
                    );
            }
        } while (!n);
    }
    async iterateOverCentralDirectory(e, t) {
        for (const n of e) {
            const e = t(n);
            if (e.handler) {
                this.tokenizer.setPosition(n.relativeOffsetOfLocalHeader);
                const t = await this.readLocalFileHeader();
                if (t) {
                    await this.tokenizer.ignore(t.extraFieldLength);
                    const r = new Uint8Array(n.compressedSize);
                    await this.tokenizer.readBuffer(r), await this.inflate(t, r, e.handler);
                }
            }
            if (e.stop) break;
        }
    }
    inflate(e, t, n) {
        if (0 === e.compressedMethod) return n(t);
        Ou(`Decompress filename=${e.filename}, compressed-size=${t.length}`);
        return n(du(t));
    }
    async readLocalFileHeader() {
        const e = await this.tokenizer.peekToken(hl);
        if (e === _u) {
            const e = await this.tokenizer.readToken(Iu);
            return (e.filename = await this.tokenizer.readToken(new Ml(e.filenameLength, "utf-8"))), e;
        }
        if (e === Su) return !1;
        if (3759263696 === e) throw new Error("Encrypted ZIP");
        throw new Error("Unexpected signature");
    }
}
function Fu(e, t) {
    const n = e.length,
        r = t.length;
    if (r > n) return -1;
    for (let i = 0; i <= n - r; i++) {
        let n = !0;
        for (let s = 0; s < r; s++)
            if (e[i + s] !== t[s]) {
                n = !1;
                break;
            }
        if (n) return i;
    }
    return -1;
}
function Lu(e) {
    const t = e.reduce((e, t) => e + t.length, 0),
        n = new Uint8Array(t);
    let r = 0;
    for (const i of e) n.set(i, r), (r += i.length);
    return n;
}
const Bu = Object.prototype.toString;
function zu(e, t, n) {
    return !!e && (e.constructor === t || Bu.call(e) === n);
}
function Uu(e) {
    return zu(e, Uint8Array, "[object Uint8Array]");
}
function $u(e) {
    return (
        Uu(e) ||
        (function (e) {
            return zu(e, ArrayBuffer, "[object ArrayBuffer]");
        })(e)
    );
}
const Vu = { utf8: new globalThis.TextDecoder("utf8") };
function Wu(e, t = "utf8") {
    return (
        (function (e) {
            if (!$u(e)) throw new TypeError(`Expected \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof e}\``);
        })(e),
        (Vu[t] ??= new globalThis.TextDecoder(t)),
        Vu[t].decode(e)
    );
}
function ju(e) {
    if ("string" != typeof e) throw new TypeError(`Expected \`string\`, got \`${typeof e}\``);
}
const Hu = new globalThis.TextEncoder();
const qu = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Xu(e) {
    !(function (e) {
        if (!Uu(e)) throw new TypeError(`Expected \`Uint8Array\`, got \`${typeof e}\``);
    })(e);
    let t = "";
    for (let n = 0; n < e.length; n++) t += qu[e[n]];
    return t;
}
const Gu = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
};
function Ku(e) {
    if ((ju(e), e.length % 2 != 0)) throw new Error("Invalid Hex string length.");
    const t = e.length / 2,
        n = new Uint8Array(t);
    for (let r = 0; r < t; r++) {
        const t = Gu[e[2 * r]],
            i = Gu[e[2 * r + 1]];
        if (void 0 === t || void 0 === i) throw new Error("Invalid Hex character encountered at position " + 2 * r);
        n[r] = (t << 4) | i;
    }
    return n;
}
function Yu(e) {
    const { byteLength: t } = e;
    return 6 === t
        ? e.getUint16(0) * 2 ** 32 + e.getUint32(2)
        : 5 === t
          ? e.getUint8(0) * 2 ** 32 + e.getUint32(1)
          : 4 === t
            ? e.getUint32(0)
            : 3 === t
              ? 65536 * e.getUint8(0) + e.getUint16(1)
              : 2 === t
                ? e.getUint16(0)
                : 1 === t
                  ? e.getUint8(0)
                  : void 0;
}
const Qu = { get: (e, t) => (127 & e[t + 3]) | (e[t + 2] << 7) | (e[t + 1] << 14) | (e[t] << 21), len: 4 },
    Ju = 4100;
async function Zu(e, t) {
    return new nd(t).fromBuffer(e);
}
function ed(e) {
    switch ((e = e.toLowerCase())) {
        case "application/epub+zip":
            return { ext: "epub", mime: e };
        case "application/vnd.oasis.opendocument.text":
            return { ext: "odt", mime: e };
        case "application/vnd.oasis.opendocument.text-template":
            return { ext: "ott", mime: e };
        case "application/vnd.oasis.opendocument.spreadsheet":
            return { ext: "ods", mime: e };
        case "application/vnd.oasis.opendocument.spreadsheet-template":
            return { ext: "ots", mime: e };
        case "application/vnd.oasis.opendocument.presentation":
            return { ext: "odp", mime: e };
        case "application/vnd.oasis.opendocument.presentation-template":
            return { ext: "otp", mime: e };
        case "application/vnd.oasis.opendocument.graphics":
            return { ext: "odg", mime: e };
        case "application/vnd.oasis.opendocument.graphics-template":
            return { ext: "otg", mime: e };
        case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
            return { ext: "ppsx", mime: e };
        case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
            return { ext: "xlsx", mime: e };
        case "application/vnd.ms-excel.sheet.macroenabled":
            return { ext: "xlsm", mime: "application/vnd.ms-excel.sheet.macroenabled.12" };
        case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
            return { ext: "xltx", mime: e };
        case "application/vnd.ms-excel.template.macroenabled":
            return { ext: "xltm", mime: "application/vnd.ms-excel.template.macroenabled.12" };
        case "application/vnd.ms-powerpoint.slideshow.macroenabled":
            return { ext: "ppsm", mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12" };
        case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
            return { ext: "docx", mime: e };
        case "application/vnd.ms-word.document.macroenabled":
            return { ext: "docm", mime: "application/vnd.ms-word.document.macroenabled.12" };
        case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
            return { ext: "dotx", mime: e };
        case "application/vnd.ms-word.template.macroenabledtemplate":
            return { ext: "dotm", mime: "application/vnd.ms-word.template.macroenabled.12" };
        case "application/vnd.openxmlformats-officedocument.presentationml.template":
            return { ext: "potx", mime: e };
        case "application/vnd.ms-powerpoint.template.macroenabled":
            return { ext: "potm", mime: "application/vnd.ms-powerpoint.template.macroenabled.12" };
        case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
            return { ext: "pptx", mime: e };
        case "application/vnd.ms-powerpoint.presentation.macroenabled":
            return { ext: "pptm", mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12" };
        case "application/vnd.ms-visio.drawing":
            return { ext: "vsdx", mime: "application/vnd.visio" };
        case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
            return { ext: "3mf", mime: "model/3mf" };
    }
}
function td(e, t, n) {
    n = { offset: 0, ...n };
    for (const [r, i] of t.entries())
        if (n.mask) {
            if (i !== (n.mask[r] & e[r + n.offset])) return !1;
        } else if (i !== e[r + n.offset]) return !1;
    return !0;
}
class nd {
    constructor(e) {
        (this.options = { mpegOffsetTolerance: 0, ...e }),
            (this.detectors = [
                ...(e?.customDetectors ?? []),
                { id: "core", detect: this.detectConfident },
                { id: "core.imprecise", detect: this.detectImprecise },
            ]),
            (this.tokenizerOptions = { abortSignal: e?.signal });
    }
    async fromTokenizer(e) {
        const t = e.position;
        for (const n of this.detectors) {
            const r = await n.detect(e);
            if (r) return r;
            if (t !== e.position) return;
        }
    }
    async fromBuffer(e) {
        if (!(e instanceof Uint8Array || e instanceof ArrayBuffer))
            throw new TypeError(
                `Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof e}\``
            );
        const t = e instanceof Uint8Array ? e : new Uint8Array(e);
        if (t?.length > 1) return this.fromTokenizer(nl(t, this.tokenizerOptions));
    }
    async fromBlob(e) {
        return this.fromStream(e.stream());
    }
    async fromStream(e) {
        const t = await tl(e, this.tokenizerOptions);
        try {
            return await this.fromTokenizer(t);
        } finally {
            await t.close();
        }
    }
    async toDetectionStream(e, t) {
        const { sampleSize: n = Ju } = t;
        let r, i;
        const s = e.getReader({ mode: "byob" });
        try {
            const { value: e, done: t } = await s.read(new Uint8Array(n));
            if (((i = e), !t && e))
                try {
                    r = await this.fromBuffer(e.subarray(0, n));
                } catch (c) {
                    if (!(c instanceof qc)) throw c;
                    r = void 0;
                }
            i = e;
        } finally {
            s.releaseLock();
        }
        const a = new TransformStream({
                async start(e) {
                    e.enqueue(i);
                },
                transform(e, t) {
                    t.enqueue(e);
                },
            }),
            o = e.pipeThrough(a);
        return (o.fileType = r), o;
    }
    check(e, t) {
        return td(this.buffer, e, t);
    }
    checkString(e, t) {
        return this.check(((n = e), [...n].map((e) => e.charCodeAt(0))), t);
        var n;
    }
    detectConfident = async (e) => {
        if (
            ((this.buffer = new Uint8Array(Ju)),
            void 0 === e.fileInfo.size && (e.fileInfo.size = Number.MAX_SAFE_INTEGER),
            (this.tokenizer = e),
            await e.peekBuffer(this.buffer, { length: 12, mayBeLess: !0 }),
            this.check([66, 77]))
        )
            return { ext: "bmp", mime: "image/bmp" };
        if (this.check([11, 119])) return { ext: "ac3", mime: "audio/vnd.dolby.dd-raw" };
        if (this.check([120, 1])) return { ext: "dmg", mime: "application/x-apple-diskimage" };
        if (this.check([77, 90])) return { ext: "exe", mime: "application/x-msdownload" };
        if (this.check([37, 33]))
            return (
                await e.peekBuffer(this.buffer, { length: 24, mayBeLess: !0 }),
                this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })
                    ? { ext: "eps", mime: "application/eps" }
                    : { ext: "ps", mime: "application/postscript" }
            );
        if (this.check([31, 160]) || this.check([31, 157])) return { ext: "Z", mime: "application/x-compress" };
        if (this.check([199, 113])) return { ext: "cpio", mime: "application/x-cpio" };
        if (this.check([96, 234])) return { ext: "arj", mime: "application/x-arj" };
        if (this.check([239, 187, 191])) return this.tokenizer.ignore(3), this.detectConfident(e);
        if (this.check([71, 73, 70])) return { ext: "gif", mime: "image/gif" };
        if (this.check([73, 73, 188])) return { ext: "jxr", mime: "image/vnd.ms-photo" };
        if (this.check([31, 139, 8])) return { ext: "gz", mime: "application/gzip" };
        if (this.check([66, 90, 104])) return { ext: "bz2", mime: "application/x-bzip2" };
        if (this.checkString("ID3")) {
            await e.ignore(6);
            const t = await e.readToken(Qu);
            return e.position + t > e.fileInfo.size
                ? { ext: "mp3", mime: "audio/mpeg" }
                : (await e.ignore(t), this.fromTokenizer(e));
        }
        if (this.checkString("MP+")) return { ext: "mpc", mime: "audio/x-musepack" };
        if ((67 === this.buffer[0] || 70 === this.buffer[0]) && this.check([87, 83], { offset: 1 }))
            return { ext: "swf", mime: "application/x-shockwave-flash" };
        if (this.check([255, 216, 255]))
            return this.check([247], { offset: 3 })
                ? { ext: "jls", mime: "image/jls" }
                : { ext: "jpg", mime: "image/jpeg" };
        if (this.check([79, 98, 106, 1])) return { ext: "avro", mime: "application/avro" };
        if (this.checkString("FLIF")) return { ext: "flif", mime: "image/flif" };
        if (this.checkString("8BPS")) return { ext: "psd", mime: "image/vnd.adobe.photoshop" };
        if (this.checkString("MPCK")) return { ext: "mpc", mime: "audio/x-musepack" };
        if (this.checkString("FORM")) return { ext: "aif", mime: "audio/aiff" };
        if (this.checkString("icns", { offset: 0 })) return { ext: "icns", mime: "image/icns" };
        if (this.check([80, 75, 3, 4])) {
            let n;
            return (
                await new Du(e).unzip((e) => {
                    switch (e.filename) {
                        case "META-INF/mozilla.rsa":
                            return (n = { ext: "xpi", mime: "application/x-xpinstall" }), { stop: !0 };
                        case "META-INF/MANIFEST.MF":
                            return (n = { ext: "jar", mime: "application/java-archive" }), { stop: !0 };
                        case "mimetype":
                            return {
                                async handler(e) {
                                    const t = new TextDecoder("utf-8").decode(e).trim();
                                    n = ed(t);
                                },
                                stop: !0,
                            };
                        case "[Content_Types].xml":
                            return {
                                async handler(e) {
                                    let t = new TextDecoder("utf-8").decode(e);
                                    const r = t.indexOf('.main+xml"');
                                    if (-1 === r) {
                                        const e = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                                        t.includes(`ContentType="${e}"`) && (n = ed(e));
                                    } else {
                                        t = t.slice(0, Math.max(0, r));
                                        const e = t.lastIndexOf('"'),
                                            i = t.slice(Math.max(0, e + 1));
                                        n = ed(i);
                                    }
                                },
                                stop: !0,
                            };
                        default:
                            return /classes\d*\.dex/.test(e.filename)
                                ? ((n = { ext: "apk", mime: "application/vnd.android.package-archive" }), { stop: !0 })
                                : {};
                    }
                }),
                n ?? { ext: "zip", mime: "application/zip" }
            );
        }
        if (this.checkString("OggS")) {
            await e.ignore(28);
            const r = new Uint8Array(8);
            return (
                await e.readBuffer(r),
                td(r, [79, 112, 117, 115, 72, 101, 97, 100])
                    ? { ext: "opus", mime: "audio/ogg; codecs=opus" }
                    : td(r, [128, 116, 104, 101, 111, 114, 97])
                      ? { ext: "ogv", mime: "video/ogg" }
                      : td(r, [1, 118, 105, 100, 101, 111, 0])
                        ? { ext: "ogm", mime: "video/ogg" }
                        : td(r, [127, 70, 76, 65, 67])
                          ? { ext: "oga", mime: "audio/ogg" }
                          : td(r, [83, 112, 101, 101, 120, 32, 32])
                            ? { ext: "spx", mime: "audio/ogg" }
                            : td(r, [1, 118, 111, 114, 98, 105, 115])
                              ? { ext: "ogg", mime: "audio/ogg" }
                              : { ext: "ogx", mime: "application/ogg" }
            );
        }
        if (
            this.check([80, 75]) &&
            (3 === this.buffer[2] || 5 === this.buffer[2] || 7 === this.buffer[2]) &&
            (4 === this.buffer[3] || 6 === this.buffer[3] || 8 === this.buffer[3])
        )
            return { ext: "zip", mime: "application/zip" };
        if (this.checkString("MThd")) return { ext: "mid", mime: "audio/midi" };
        if (
            this.checkString("wOFF") &&
            (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))
        )
            return { ext: "woff", mime: "font/woff" };
        if (
            this.checkString("wOF2") &&
            (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))
        )
            return { ext: "woff2", mime: "font/woff2" };
        if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212]))
            return { ext: "pcap", mime: "application/vnd.tcpdump.pcap" };
        if (this.checkString("DSD ")) return { ext: "dsf", mime: "audio/x-dsf" };
        if (this.checkString("LZIP")) return { ext: "lz", mime: "application/x-lzip" };
        if (this.checkString("fLaC")) return { ext: "flac", mime: "audio/flac" };
        if (this.check([66, 80, 71, 251])) return { ext: "bpg", mime: "image/bpg" };
        if (this.checkString("wvpk")) return { ext: "wv", mime: "audio/wavpack" };
        if (this.checkString("%PDF")) return { ext: "pdf", mime: "application/pdf" };
        if (this.check([0, 97, 115, 109])) return { ext: "wasm", mime: "application/wasm" };
        if (this.check([73, 73])) {
            const i = await this.readTiffHeader(!1);
            if (i) return i;
        }
        if (this.check([77, 77])) {
            const s = await this.readTiffHeader(!0);
            if (s) return s;
        }
        if (this.checkString("MAC ")) return { ext: "ape", mime: "audio/ape" };
        if (this.check([26, 69, 223, 163])) {
            async function a() {
                const t = await e.peekNumber(ol);
                let n = 128,
                    r = 0;
                for (; 0 === (t & n) && 0 !== n; ) ++r, (n >>= 1);
                const i = new Uint8Array(r + 1);
                return await e.readBuffer(i), i;
            }
            async function o() {
                const e = await a(),
                    t = await a();
                t[0] ^= 128 >> (t.length - 1);
                const n = Math.min(6, t.length),
                    r = new DataView(e.buffer),
                    i = new DataView(t.buffer, t.length - n, n);
                return { id: Yu(r), len: Yu(i) };
            }
            async function c(t) {
                for (; t > 0; ) {
                    const n = await o();
                    if (17026 === n.id) {
                        return (await e.readToken(new Ml(n.len))).replaceAll(/\00.*$/g, "");
                    }
                    await e.ignore(n.len), --t;
                }
            }
            const l = await o();
            switch (await c(l.len)) {
                case "webm":
                    return { ext: "webm", mime: "video/webm" };
                case "matroska":
                    return { ext: "mkv", mime: "video/matroska" };
                default:
                    return;
            }
        }
        if (this.checkString("SQLi")) return { ext: "sqlite", mime: "application/x-sqlite3" };
        if (this.check([78, 69, 83, 26])) return { ext: "nes", mime: "application/x-nintendo-nes-rom" };
        if (this.checkString("Cr24")) return { ext: "crx", mime: "application/x-google-chrome-extension" };
        if (this.checkString("MSCF") || this.checkString("ISc("))
            return { ext: "cab", mime: "application/vnd.ms-cab-compressed" };
        if (this.check([237, 171, 238, 219])) return { ext: "rpm", mime: "application/x-rpm" };
        if (this.check([197, 208, 211, 198])) return { ext: "eps", mime: "application/eps" };
        if (this.check([40, 181, 47, 253])) return { ext: "zst", mime: "application/zstd" };
        if (this.check([127, 69, 76, 70])) return { ext: "elf", mime: "application/x-elf" };
        if (this.check([33, 66, 68, 78])) return { ext: "pst", mime: "application/vnd.ms-outlook" };
        if (this.checkString("PAR1") || this.checkString("PARE"))
            return { ext: "parquet", mime: "application/vnd.apache.parquet" };
        if (this.checkString("ttcf")) return { ext: "ttc", mime: "font/collection" };
        if (this.check([207, 250, 237, 254])) return { ext: "macho", mime: "application/x-mach-binary" };
        if (this.check([4, 34, 77, 24])) return { ext: "lz4", mime: "application/x-lz4" };
        if (this.check([79, 84, 84, 79, 0])) return { ext: "otf", mime: "font/otf" };
        if (this.checkString("#!AMR")) return { ext: "amr", mime: "audio/amr" };
        if (this.checkString("{\\rtf")) return { ext: "rtf", mime: "application/rtf" };
        if (this.check([70, 76, 86, 1])) return { ext: "flv", mime: "video/x-flv" };
        if (this.checkString("IMPM")) return { ext: "it", mime: "audio/x-it" };
        if (
            this.checkString("-lh0-", { offset: 2 }) ||
            this.checkString("-lh1-", { offset: 2 }) ||
            this.checkString("-lh2-", { offset: 2 }) ||
            this.checkString("-lh3-", { offset: 2 }) ||
            this.checkString("-lh4-", { offset: 2 }) ||
            this.checkString("-lh5-", { offset: 2 }) ||
            this.checkString("-lh6-", { offset: 2 }) ||
            this.checkString("-lh7-", { offset: 2 }) ||
            this.checkString("-lzs-", { offset: 2 }) ||
            this.checkString("-lz4-", { offset: 2 }) ||
            this.checkString("-lz5-", { offset: 2 }) ||
            this.checkString("-lhd-", { offset: 2 })
        )
            return { ext: "lzh", mime: "application/x-lzh-compressed" };
        if (this.check([0, 0, 1, 186])) {
            if (this.check([33], { offset: 4, mask: [241] })) return { ext: "mpg", mime: "video/MP1S" };
            if (this.check([68], { offset: 4, mask: [196] })) return { ext: "mpg", mime: "video/MP2P" };
        }
        if (this.checkString("ITSF")) return { ext: "chm", mime: "application/vnd.ms-htmlhelp" };
        if (this.check([202, 254, 186, 190])) return { ext: "class", mime: "application/java-vm" };
        if (this.checkString(".RMF")) return { ext: "rm", mime: "application/vnd.rn-realmedia" };
        if (this.checkString("DRACO")) return { ext: "drc", mime: "application/vnd.google.draco" };
        if (this.check([253, 55, 122, 88, 90, 0])) return { ext: "xz", mime: "application/x-xz" };
        if (this.checkString("<?xml ")) return { ext: "xml", mime: "application/xml" };
        if (this.check([55, 122, 188, 175, 39, 28])) return { ext: "7z", mime: "application/x-7z-compressed" };
        if (this.check([82, 97, 114, 33, 26, 7]) && (0 === this.buffer[6] || 1 === this.buffer[6]))
            return { ext: "rar", mime: "application/x-rar-compressed" };
        if (this.checkString("solid ")) return { ext: "stl", mime: "model/stl" };
        if (this.checkString("AC")) {
            const u = new Ml(4, "latin1").get(this.buffer, 2);
            if (u.match("^d*") && u >= 1e3 && u <= 1050) return { ext: "dwg", mime: "image/vnd.dwg" };
        }
        if (this.checkString("070707")) return { ext: "cpio", mime: "application/x-cpio" };
        if (this.checkString("BLENDER")) return { ext: "blend", mime: "application/x-blender" };
        if (this.checkString("!<arch>")) {
            await e.ignore(8);
            return "debian-binary" === (await e.readToken(new Ml(13, "ascii")))
                ? { ext: "deb", mime: "application/x-deb" }
                : { ext: "ar", mime: "application/x-unix-archive" };
        }
        if (this.checkString("WEBVTT") && ["\n", "\r", "\t", " ", "\0"].some((e) => this.checkString(e, { offset: 6 })))
            return { ext: "vtt", mime: "text/vtt" };
        if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
            async function d() {
                return { length: await e.readToken(wl), type: await e.readToken(new Ml(4, "latin1")) };
            }
            await e.ignore(8);
            do {
                const h = await d();
                if (h.length < 0) return;
                switch (h.type) {
                    case "IDAT":
                        return { ext: "png", mime: "image/png" };
                    case "acTL":
                        return { ext: "apng", mime: "image/apng" };
                    default:
                        await e.ignore(h.length + 4);
                }
            } while (e.position + 8 < e.fileInfo.size);
            return { ext: "png", mime: "image/png" };
        }
        if (this.check([65, 82, 82, 79, 87, 49, 0, 0]))
            return { ext: "arrow", mime: "application/vnd.apache.arrow.file" };
        if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) return { ext: "glb", mime: "model/gltf-binary" };
        if (
            this.check([102, 114, 101, 101], { offset: 4 }) ||
            this.check([109, 100, 97, 116], { offset: 4 }) ||
            this.check([109, 111, 111, 118], { offset: 4 }) ||
            this.check([119, 105, 100, 101], { offset: 4 })
        )
            return { ext: "mov", mime: "video/quicktime" };
        if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) return { ext: "orf", mime: "image/x-olympus-orf" };
        if (this.checkString("gimp xcf ")) return { ext: "xcf", mime: "image/x-xcf" };
        if (this.checkString("ftyp", { offset: 4 }) && 96 & this.buffer[8]) {
            const m = new Ml(4, "latin1").get(this.buffer, 8).replace("\0", " ").trim();
            switch (m) {
                case "avif":
                case "avis":
                    return { ext: "avif", mime: "image/avif" };
                case "mif1":
                    return { ext: "heic", mime: "image/heif" };
                case "msf1":
                    return { ext: "heic", mime: "image/heif-sequence" };
                case "heic":
                case "heix":
                    return { ext: "heic", mime: "image/heic" };
                case "hevc":
                case "hevx":
                    return { ext: "heic", mime: "image/heic-sequence" };
                case "qt":
                    return { ext: "mov", mime: "video/quicktime" };
                case "M4V":
                case "M4VH":
                case "M4VP":
                    return { ext: "m4v", mime: "video/x-m4v" };
                case "M4P":
                    return { ext: "m4p", mime: "video/mp4" };
                case "M4B":
                    return { ext: "m4b", mime: "audio/mp4" };
                case "M4A":
                    return { ext: "m4a", mime: "audio/x-m4a" };
                case "F4V":
                    return { ext: "f4v", mime: "video/mp4" };
                case "F4P":
                    return { ext: "f4p", mime: "video/mp4" };
                case "F4A":
                    return { ext: "f4a", mime: "audio/mp4" };
                case "F4B":
                    return { ext: "f4b", mime: "audio/mp4" };
                case "crx":
                    return { ext: "cr3", mime: "image/x-canon-cr3" };
                default:
                    return m.startsWith("3g")
                        ? m.startsWith("3g2")
                            ? { ext: "3g2", mime: "video/3gpp2" }
                            : { ext: "3gp", mime: "video/3gpp" }
                        : { ext: "mp4", mime: "video/mp4" };
            }
        }
        if (this.check([82, 73, 70, 70])) {
            if (this.checkString("WEBP", { offset: 8 })) return { ext: "webp", mime: "image/webp" };
            if (this.check([65, 86, 73], { offset: 8 })) return { ext: "avi", mime: "video/vnd.avi" };
            if (this.check([87, 65, 86, 69], { offset: 8 })) return { ext: "wav", mime: "audio/wav" };
            if (this.check([81, 76, 67, 77], { offset: 8 })) return { ext: "qcp", mime: "audio/qcelp" };
        }
        if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216]))
            return { ext: "rw2", mime: "image/x-panasonic-rw2" };
        if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
            async function p() {
                const t = new Uint8Array(16);
                return await e.readBuffer(t), { id: t, size: Number(await e.readToken(Tl)) };
            }
            for (await e.ignore(30); e.position + 24 < e.fileInfo.size; ) {
                const f = await p();
                let g = f.size - 24;
                if (td(f.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
                    const b = new Uint8Array(16);
                    if (
                        ((g -= await e.readBuffer(b)),
                        td(b, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
                    )
                        return { ext: "asf", mime: "audio/x-ms-asf" };
                    if (td(b, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
                        return { ext: "asf", mime: "video/x-ms-asf" };
                    break;
                }
                await e.ignore(g);
            }
            return { ext: "asf", mime: "application/vnd.ms-asf" };
        }
        if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) return { ext: "ktx", mime: "image/ktx" };
        if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 }))
            return { ext: "mie", mime: "application/x-mie" };
        if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 }))
            return { ext: "shp", mime: "application/x-esri-shape" };
        if (this.check([255, 79, 255, 81])) return { ext: "j2c", mime: "image/j2c" };
        if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
            await e.ignore(20);
            switch (await e.readToken(new Ml(4, "ascii"))) {
                case "jp2 ":
                    return { ext: "jp2", mime: "image/jp2" };
                case "jpx ":
                    return { ext: "jpx", mime: "image/jpx" };
                case "jpm ":
                    return { ext: "jpm", mime: "image/jpm" };
                case "mjp2":
                    return { ext: "mj2", mime: "image/mj2" };
                default:
                    return;
            }
        }
        if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10]))
            return { ext: "jxl", mime: "image/jxl" };
        if (this.check([254, 255]))
            return this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })
                ? { ext: "xml", mime: "application/xml" }
                : void 0;
        if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) return { ext: "cfb", mime: "application/x-cfb" };
        if (
            (await e.peekBuffer(this.buffer, { length: Math.min(256, e.fileInfo.size), mayBeLess: !0 }),
            this.check([97, 99, 115, 112], { offset: 36 }))
        )
            return { ext: "icc", mime: "application/vnd.iccprofile" };
        if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 }))
            return { ext: "ace", mime: "application/x-ace-compressed" };
        if (this.checkString("BEGIN:")) {
            if (this.checkString("VCARD", { offset: 6 })) return { ext: "vcf", mime: "text/vcard" };
            if (this.checkString("VCALENDAR", { offset: 6 })) return { ext: "ics", mime: "text/calendar" };
        }
        if (this.checkString("FUJIFILMCCD-RAW")) return { ext: "raf", mime: "image/x-fujifilm-raf" };
        if (this.checkString("Extended Module:")) return { ext: "xm", mime: "audio/x-xm" };
        if (this.checkString("Creative Voice File")) return { ext: "voc", mime: "audio/x-voc" };
        if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
            const y = new DataView(this.buffer.buffer).getUint32(12, !0);
            if (y > 12 && this.buffer.length >= y + 16)
                try {
                    const w = new TextDecoder().decode(this.buffer.subarray(16, y + 16));
                    if (JSON.parse(w).files) return { ext: "asar", mime: "application/x-asar" };
                } catch {}
        }
        return this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])
            ? { ext: "mxf", mime: "application/mxf" }
            : this.checkString("SCRM", { offset: 44 })
              ? { ext: "s3m", mime: "audio/x-s3m" }
              : (this.check([71]) && this.check([71], { offset: 188 })) ||
                  (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 }))
                ? { ext: "mts", mime: "video/mp2t" }
                : this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })
                  ? { ext: "mobi", mime: "application/x-mobipocket-ebook" }
                  : this.check([68, 73, 67, 77], { offset: 128 })
                    ? { ext: "dcm", mime: "application/dicom" }
                    : this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])
                      ? { ext: "lnk", mime: "application/x.ms.shortcut" }
                      : this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])
                        ? { ext: "alias", mime: "application/x.apple.alias" }
                        : this.checkString("Kaydara FBX Binary  \0")
                          ? { ext: "fbx", mime: "application/x.autodesk.fbx" }
                          : this.check([76, 80], { offset: 34 }) &&
                              (this.check([0, 0, 1], { offset: 8 }) ||
                                  this.check([1, 0, 2], { offset: 8 }) ||
                                  this.check([2, 0, 2], { offset: 8 }))
                            ? { ext: "eot", mime: "application/vnd.ms-fontobject" }
                            : this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])
                              ? { ext: "indd", mime: "application/x-indesign" }
                              : (await e.peekBuffer(this.buffer, {
                                    length: Math.min(512, e.fileInfo.size),
                                    mayBeLess: !0,
                                }),
                                (this.checkString("ustar", { offset: 257 }) &&
                                    (this.checkString("\0", { offset: 262 }) ||
                                        this.checkString(" ", { offset: 262 }))) ||
                                (this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) &&
                                    (function (e, t = 0) {
                                        const n = Number.parseInt(new Ml(6).get(e, 148).replace(/\0.*$/, "").trim(), 8);
                                        if (Number.isNaN(n)) return !1;
                                        let r = 256;
                                        for (let i = t; i < t + 148; i++) r += e[i];
                                        for (let i = t + 156; i < t + 512; i++) r += e[i];
                                        return n === r;
                                    })(this.buffer))
                                    ? { ext: "tar", mime: "application/x-tar" }
                                    : this.check([255, 254])
                                      ? this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })
                                          ? { ext: "xml", mime: "application/xml" }
                                          : this.check(
                                                  [
                                                      255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112,
                                                      0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0,
                                                  ],
                                                  { offset: 2 }
                                              )
                                            ? { ext: "skp", mime: "application/vnd.sketchup.skp" }
                                            : void 0
                                      : this.checkString("-----BEGIN PGP MESSAGE-----")
                                        ? { ext: "pgp", mime: "application/pgp-encrypted" }
                                        : void 0);
    };
    detectImprecise = async (e) => {
        if (
            ((this.buffer = new Uint8Array(Ju)),
            await e.peekBuffer(this.buffer, { length: Math.min(8, e.fileInfo.size), mayBeLess: !0 }),
            this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179]))
        )
            return { ext: "mpg", mime: "video/mpeg" };
        if (this.check([0, 1, 0, 0, 0])) return { ext: "ttf", mime: "font/ttf" };
        if (this.check([0, 0, 1, 0])) return { ext: "ico", mime: "image/x-icon" };
        if (this.check([0, 0, 2, 0])) return { ext: "cur", mime: "image/x-icon" };
        if (
            (await e.peekBuffer(this.buffer, {
                length: Math.min(2 + this.options.mpegOffsetTolerance, e.fileInfo.size),
                mayBeLess: !0,
            }),
            this.buffer.length >= 2 + this.options.mpegOffsetTolerance)
        )
            for (let t = 0; t <= this.options.mpegOffsetTolerance; ++t) {
                const e = this.scanMpeg(t);
                if (e) return e;
            }
    };
    async readTiffTag(e) {
        const t = await this.tokenizer.readToken(e ? ll : cl);
        switch ((this.tokenizer.ignore(10), t)) {
            case 50341:
                return { ext: "arw", mime: "image/x-sony-arw" };
            case 50706:
                return { ext: "dng", mime: "image/x-adobe-dng" };
        }
    }
    async readTiffIFD(e) {
        const t = await this.tokenizer.readToken(e ? ll : cl);
        for (let n = 0; n < t; ++n) {
            const t = await this.readTiffTag(e);
            if (t) return t;
        }
    }
    async readTiffHeader(e) {
        const t = (e ? ll : cl).get(this.buffer, 2),
            n = (e ? ml : hl).get(this.buffer, 4);
        if (42 === t) {
            if (n >= 6) {
                if (this.checkString("CR", { offset: 8 })) return { ext: "cr2", mime: "image/x-canon-cr2" };
                if (n >= 8) {
                    const t = (e ? ll : cl).get(this.buffer, 8),
                        n = (e ? ll : cl).get(this.buffer, 10);
                    if ((28 === t && 254 === n) || (31 === t && 11 === n))
                        return { ext: "nef", mime: "image/x-nikon-nef" };
                }
            }
            await this.tokenizer.ignore(n);
            return (await this.readTiffIFD(e)) ?? { ext: "tif", mime: "image/tiff" };
        }
        if (43 === t) return { ext: "tif", mime: "image/tiff" };
    }
    scanMpeg(e) {
        if (this.check([255, 224], { offset: e, mask: [255, 224] })) {
            if (this.check([16], { offset: e + 1, mask: [22] }))
                return this.check([8], { offset: e + 1, mask: [8] }), { ext: "aac", mime: "audio/aac" };
            if (this.check([2], { offset: e + 1, mask: [6] })) return { ext: "mp3", mime: "audio/mpeg" };
            if (this.check([4], { offset: e + 1, mask: [6] })) return { ext: "mp2", mime: "audio/mpeg" };
            if (this.check([6], { offset: e + 1, mask: [6] })) return { ext: "mp1", mime: "audio/mpeg" };
        }
    }
}
new Set([
    "jpg",
    "png",
    "apng",
    "gif",
    "webp",
    "flif",
    "xcf",
    "cr2",
    "cr3",
    "orf",
    "arw",
    "dng",
    "nef",
    "rw2",
    "raf",
    "tif",
    "bmp",
    "icns",
    "jxr",
    "psd",
    "indd",
    "zip",
    "tar",
    "rar",
    "gz",
    "bz2",
    "7z",
    "dmg",
    "mp4",
    "mid",
    "mkv",
    "webm",
    "mov",
    "avi",
    "mpg",
    "mp2",
    "mp3",
    "m4a",
    "oga",
    "ogg",
    "ogv",
    "opus",
    "flac",
    "wav",
    "spx",
    "amr",
    "pdf",
    "epub",
    "elf",
    "macho",
    "exe",
    "swf",
    "rtf",
    "wasm",
    "woff",
    "woff2",
    "eot",
    "ttf",
    "otf",
    "ttc",
    "ico",
    "flv",
    "ps",
    "xz",
    "sqlite",
    "nes",
    "crx",
    "xpi",
    "cab",
    "deb",
    "ar",
    "rpm",
    "Z",
    "lz",
    "cfb",
    "mxf",
    "mts",
    "blend",
    "bpg",
    "docx",
    "pptx",
    "xlsx",
    "3gp",
    "3g2",
    "j2c",
    "jp2",
    "jpm",
    "jpx",
    "mj2",
    "aif",
    "qcp",
    "odt",
    "ods",
    "odp",
    "xml",
    "mobi",
    "heic",
    "cur",
    "ktx",
    "ape",
    "wv",
    "dcm",
    "ics",
    "glb",
    "pcap",
    "dsf",
    "lnk",
    "alias",
    "voc",
    "ac3",
    "m4v",
    "m4p",
    "m4b",
    "f4v",
    "f4p",
    "f4b",
    "f4a",
    "mie",
    "asf",
    "ogm",
    "ogx",
    "mpc",
    "arrow",
    "shp",
    "aac",
    "mp1",
    "it",
    "s3m",
    "xm",
    "skp",
    "avif",
    "eps",
    "lzh",
    "pgp",
    "asar",
    "stl",
    "chm",
    "3mf",
    "zst",
    "jxl",
    "vcf",
    "jls",
    "pst",
    "dwg",
    "parquet",
    "class",
    "arj",
    "cpio",
    "ace",
    "avro",
    "icc",
    "fbx",
    "vsdx",
    "vtt",
    "apk",
    "drc",
    "lz4",
    "potx",
    "xltx",
    "dotx",
    "xltm",
    "ott",
    "ots",
    "otp",
    "odg",
    "otg",
    "xlsm",
    "docm",
    "dotm",
    "potm",
    "pptm",
    "jar",
    "rm",
    "ppsm",
    "ppsx",
]),
    new Set([
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp",
        "image/flif",
        "image/x-xcf",
        "image/x-canon-cr2",
        "image/x-canon-cr3",
        "image/tiff",
        "image/bmp",
        "image/vnd.ms-photo",
        "image/vnd.adobe.photoshop",
        "application/x-indesign",
        "application/epub+zip",
        "application/x-xpinstall",
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
        "application/vnd.oasis.opendocument.text",
        "application/vnd.oasis.opendocument.spreadsheet",
        "application/vnd.oasis.opendocument.presentation",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
        "application/zip",
        "application/x-tar",
        "application/x-rar-compressed",
        "application/gzip",
        "application/x-bzip2",
        "application/x-7z-compressed",
        "application/x-apple-diskimage",
        "application/vnd.apache.arrow.file",
        "video/mp4",
        "audio/midi",
        "video/matroska",
        "video/webm",
        "video/quicktime",
        "video/vnd.avi",
        "audio/wav",
        "audio/qcelp",
        "audio/x-ms-asf",
        "video/x-ms-asf",
        "application/vnd.ms-asf",
        "video/mpeg",
        "video/3gpp",
        "audio/mpeg",
        "audio/mp4",
        "video/ogg",
        "audio/ogg",
        "audio/ogg; codecs=opus",
        "application/ogg",
        "audio/flac",
        "audio/ape",
        "audio/wavpack",
        "audio/amr",
        "application/pdf",
        "application/x-elf",
        "application/x-mach-binary",
        "application/x-msdownload",
        "application/x-shockwave-flash",
        "application/rtf",
        "application/wasm",
        "font/woff",
        "font/woff2",
        "application/vnd.ms-fontobject",
        "font/ttf",
        "font/otf",
        "font/collection",
        "image/x-icon",
        "video/x-flv",
        "application/postscript",
        "application/eps",
        "application/x-xz",
        "application/x-sqlite3",
        "application/x-nintendo-nes-rom",
        "application/x-google-chrome-extension",
        "application/vnd.ms-cab-compressed",
        "application/x-deb",
        "application/x-unix-archive",
        "application/x-rpm",
        "application/x-compress",
        "application/x-lzip",
        "application/x-cfb",
        "application/x-mie",
        "application/mxf",
        "video/mp2t",
        "application/x-blender",
        "image/bpg",
        "image/j2c",
        "image/jp2",
        "image/jpx",
        "image/jpm",
        "image/mj2",
        "audio/aiff",
        "application/xml",
        "application/x-mobipocket-ebook",
        "image/heif",
        "image/heif-sequence",
        "image/heic",
        "image/heic-sequence",
        "image/icns",
        "image/ktx",
        "application/dicom",
        "audio/x-musepack",
        "text/calendar",
        "text/vcard",
        "text/vtt",
        "model/gltf-binary",
        "application/vnd.tcpdump.pcap",
        "audio/x-dsf",
        "application/x.ms.shortcut",
        "application/x.apple.alias",
        "audio/x-voc",
        "audio/vnd.dolby.dd-raw",
        "audio/x-m4a",
        "image/apng",
        "image/x-olympus-orf",
        "image/x-sony-arw",
        "image/x-adobe-dng",
        "image/x-nikon-nef",
        "image/x-panasonic-rw2",
        "image/x-fujifilm-raf",
        "video/x-m4v",
        "video/3gpp2",
        "application/x-esri-shape",
        "audio/aac",
        "audio/x-it",
        "audio/x-s3m",
        "audio/x-xm",
        "video/MP1S",
        "video/MP2P",
        "application/vnd.sketchup.skp",
        "image/avif",
        "application/x-lzh-compressed",
        "application/pgp-encrypted",
        "application/x-asar",
        "model/stl",
        "application/vnd.ms-htmlhelp",
        "model/3mf",
        "image/jxl",
        "application/zstd",
        "image/jls",
        "application/vnd.ms-outlook",
        "image/vnd.dwg",
        "application/vnd.apache.parquet",
        "application/java-vm",
        "application/x-arj",
        "application/x-cpio",
        "application/x-ace-compressed",
        "application/avro",
        "application/vnd.iccprofile",
        "application/x.autodesk.fbx",
        "application/vnd.visio",
        "application/vnd.android.package-archive",
        "application/vnd.google.draco",
        "application/x-lz4",
        "application/vnd.openxmlformats-officedocument.presentationml.template",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
        "application/vnd.ms-excel.template.macroenabled.12",
        "application/vnd.oasis.opendocument.text-template",
        "application/vnd.oasis.opendocument.spreadsheet-template",
        "application/vnd.oasis.opendocument.presentation-template",
        "application/vnd.oasis.opendocument.graphics",
        "application/vnd.oasis.opendocument.graphics-template",
        "application/vnd.ms-excel.sheet.macroenabled.12",
        "application/vnd.ms-word.document.macroenabled.12",
        "application/vnd.ms-word.template.macroenabled.12",
        "application/vnd.ms-powerpoint.template.macroenabled.12",
        "application/vnd.ms-powerpoint.presentation.macroenabled.12",
        "application/java-archive",
        "application/vnd.rn-realmedia",
    ]);
var rd,
    id = {};
var sd = (function () {
    if (rd) return id;
    rd = 1;
    var e =
            /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g,
        t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/,
        n = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/,
        r = /\\([\u000b\u0020-\u00ff])/g,
        i = /([\\"])/g,
        s = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    function a(e) {
        var r = String(e);
        if (n.test(r)) return r;
        if (r.length > 0 && !t.test(r)) throw new TypeError("invalid parameter value");
        return '"' + r.replace(i, "\\$1") + '"';
    }
    function o(e) {
        (this.parameters = Object.create(null)), (this.type = e);
    }
    return (
        (id.format = function (e) {
            if (!e || "object" != typeof e) throw new TypeError("argument obj is required");
            var t = e.parameters,
                r = e.type;
            if (!r || !s.test(r)) throw new TypeError("invalid type");
            var i = r;
            if (t && "object" == typeof t)
                for (var o, c = Object.keys(t).sort(), l = 0; l < c.length; l++) {
                    if (((o = c[l]), !n.test(o))) throw new TypeError("invalid parameter name");
                    i += "; " + o + "=" + a(t[o]);
                }
            return i;
        }),
        (id.parse = function (t) {
            if (!t) throw new TypeError("argument string is required");
            var n =
                "object" == typeof t
                    ? (function (e) {
                          var t;
                          "function" == typeof e.getHeader
                              ? (t = e.getHeader("content-type"))
                              : "object" == typeof e.headers && (t = e.headers && e.headers["content-type"]);
                          if ("string" != typeof t) throw new TypeError("content-type header is missing from object");
                          return t;
                      })(t)
                    : t;
            if ("string" != typeof n) throw new TypeError("argument string is required to be a string");
            var i = n.indexOf(";"),
                a = -1 !== i ? n.slice(0, i).trim() : n.trim();
            if (!s.test(a)) throw new TypeError("invalid media type");
            var c = new o(a.toLowerCase());
            if (-1 !== i) {
                var l, u, d;
                for (e.lastIndex = i; (u = e.exec(n)); ) {
                    if (u.index !== i) throw new TypeError("invalid parameter format");
                    (i += u[0].length),
                        (l = u[1].toLowerCase()),
                        34 === (d = u[2]).charCodeAt(0) &&
                            -1 !== (d = d.slice(1, -1)).indexOf("\\") &&
                            (d = d.replace(r, "$1")),
                        (c.parameters[l] = d);
                }
                if (i !== n.length) throw new TypeError("invalid parameter format");
            }
            return c;
        }),
        id
    );
})();
const ad = kc(sd);
var od,
    cd = {};
var ld = (function () {
    if (od) return cd;
    od = 1;
    var e = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/,
        t = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/,
        n = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
    function r(e, t, n) {
        (this.type = e), (this.subtype = t), (this.suffix = n);
    }
    return (
        (cd.format = function (n) {
            if (!n || "object" != typeof n) throw new TypeError("argument obj is required");
            var r = n.subtype,
                i = n.suffix,
                s = n.type;
            if (!s || !t.test(s)) throw new TypeError("invalid type");
            if (!r || !e.test(r)) throw new TypeError("invalid subtype");
            var a = s + "/" + r;
            if (i) {
                if (!t.test(i)) throw new TypeError("invalid suffix");
                a += "+" + i;
            }
            return a;
        }),
        (cd.parse = function (e) {
            if (!e) throw new TypeError("argument string is required");
            if ("string" != typeof e) throw new TypeError("argument string is required to be a string");
            var t = n.exec(e.toLowerCase());
            if (!t) throw new TypeError("invalid media type");
            var i,
                s = t[1],
                a = t[2],
                o = a.lastIndexOf("+");
            -1 !== o && ((i = a.substr(o + 1)), (a = a.substr(0, o)));
            return new r(s, a, i);
        }),
        (cd.test = function (e) {
            if (!e) throw new TypeError("argument string is required");
            if ("string" != typeof e) throw new TypeError("argument string is required to be a string");
            return n.test(e.toLowerCase());
        }),
        cd
    );
})();
const ud = { 10: "shot", 20: "scene", 30: "track", 40: "part", 50: "album", 60: "edition", 70: "collection" },
    dd = 1,
    hd = 2,
    md = 3,
    pd = 4,
    fd = 17,
    gd = 18,
    bd = 32,
    yd = {
        [dd]: "video",
        [hd]: "audio",
        [md]: "complex",
        [pd]: "logo",
        [fd]: "subtitle",
        [gd]: "button",
        [bd]: "control",
    },
    wd = (e) =>
        class extends Error {
            constructor(t) {
                super(t), (this.name = e);
            }
        };
class kd extends wd("CouldNotDetermineFileTypeError") {}
class Td extends wd("UnsupportedFileTypeError") {}
class _d extends wd("UnexpectedFileContentError") {
    constructor(e, t) {
        super(t), (this.fileType = e);
    }
    toString() {
        return `${this.name} (FileType: ${this.fileType}): ${this.message}`;
    }
}
class vd extends wd("FieldDecodingError") {}
class Sd extends wd("InternalParserError") {}
const Ed = (e) =>
    class extends _d {
        constructor(t) {
            super(e, t);
        }
    };
function Cd(e, t, n) {
    return !!(e[t] & (1 << n));
}
function Id(e, t, n, r) {
    let i = t;
    if ("utf-16le" === r) {
        for (; 0 !== e[i] || 0 !== e[i + 1]; ) {
            if (i >= n) return n;
            i += 2;
        }
        return i;
    }
    for (; 0 !== e[i]; ) {
        if (i >= n) return n;
        i++;
    }
    return i;
}
function xd(e) {
    const t = e.indexOf("\0");
    return -1 === t ? e : e.substr(0, t);
}
function Ad(e, t) {
    if (255 === e[0] && 254 === e[1]) return Ad(e.subarray(2), t);
    if ("utf-16le" === t && 254 === e[0] && 255 === e[1]) {
        if (1 & e.length) throw new vd("Expected even number of octets for 16-bit unicode string");
        return Ad(
            (function (e) {
                const t = e.length;
                if (1 & t) throw new vd("Buffer length must be even");
                for (let n = 0; n < t; n += 2) {
                    const t = e[n];
                    (e[n] = e[n + 1]), (e[n + 1] = t);
                }
                return e;
            })(e),
            t
        );
    }
    return new Ml(e.length, t).get(e, 0);
}
function Pd(e) {
    return (e = (e = e.replace(/^\x00+/g, "")).replace(/\x00+$/g, ""));
}
function Od(e, t, n, r) {
    const i = n % 8;
    let s = e[t + ~~(n / 8)];
    s &= 255 >> i;
    const a = 8 - i,
        o = r - a;
    return o < 0 ? (s >>= 8 - i - r) : o > 0 && ((s <<= o), (s |= Od(e, t, n + a, o))), s;
}
function Nd(e, t, n) {
    return 1 === Od(e, t, n, 1);
}
const Rd = {
        0: "Other",
        1: "32x32 pixels 'file icon' (PNG only)",
        2: "Other file icon",
        3: "Cover (front)",
        4: "Cover (back)",
        5: "Leaflet page",
        6: "Media (e.g. label side of CD)",
        7: "Lead artist/lead performer/soloist",
        8: "Artist/performer",
        9: "Conductor",
        10: "Band/Orchestra",
        11: "Composer",
        12: "Lyricist/text writer",
        13: "Recording Location",
        14: "During recording",
        15: "During performance",
        16: "Movie/video screen capture",
        17: "A bright coloured fish",
        18: "Illustration",
        19: "Band/artist logotype",
        20: "Publisher/Studio logotype",
    },
    Md = 1,
    Dd = 2,
    Fd = { get: (e, t) => (127 & e[t + 3]) | (e[t + 2] << 7) | (e[t + 1] << 14) | (e[t] << 21), len: 4 },
    Ld = {
        len: 10,
        get: (e, t) => ({
            fileIdentifier: new Ml(3, "ascii").get(e, t),
            version: { major: pl.get(e, t + 3), revision: pl.get(e, t + 4) },
            flags: {
                unsynchronisation: Cd(e, t + 5, 7),
                isExtendedHeader: Cd(e, t + 5, 6),
                expIndicator: Cd(e, t + 5, 5),
                footer: Cd(e, t + 5, 4),
            },
            size: Fd.get(e, t + 6),
        }),
    },
    Bd = {
        len: 10,
        get: (e, t) => ({
            size: ml.get(e, t),
            extendedFlags: ll.get(e, t + 4),
            sizeOfPadding: ml.get(e, t + 6),
            crcDataPresent: Cd(e, t + 4, 31),
        }),
    },
    zd = (e, t) => {
        switch (e[t]) {
            case 0:
                return { encoding: "latin1" };
            case 1:
                return { encoding: "utf-16le", bom: !0 };
            case 2:
                return { encoding: "utf-16le", bom: !1 };
            default:
                return { encoding: "utf8", bom: !1 };
        }
    },
    Ud = 4,
    $d = (e, t) => ({ encoding: zd(e, t), language: new Ml(3, "latin1").get(e, t + 1) }),
    Vd = 6,
    Wd = (e, t) => {
        const n = $d(e, t);
        return {
            encoding: n.encoding,
            language: n.language,
            timeStampFormat: ol.get(e, t + 4),
            contentType: ol.get(e, t + 5),
        };
    },
    jd = { multiple: !1 },
    Hd = {
        year: jd,
        track: jd,
        disk: jd,
        title: jd,
        artist: jd,
        artists: { multiple: !0, unique: !0 },
        albumartist: jd,
        album: jd,
        date: jd,
        originaldate: jd,
        originalyear: jd,
        releasedate: jd,
        comment: { multiple: !0, unique: !1 },
        genre: { multiple: !0, unique: !0 },
        picture: { multiple: !0, unique: !0 },
        composer: { multiple: !0, unique: !0 },
        lyrics: { multiple: !0, unique: !1 },
        albumsort: { multiple: !1, unique: !0 },
        titlesort: { multiple: !1, unique: !0 },
        work: { multiple: !1, unique: !0 },
        artistsort: { multiple: !1, unique: !0 },
        albumartistsort: { multiple: !1, unique: !0 },
        composersort: { multiple: !1, unique: !0 },
        lyricist: { multiple: !0, unique: !0 },
        writer: { multiple: !0, unique: !0 },
        conductor: { multiple: !0, unique: !0 },
        remixer: { multiple: !0, unique: !0 },
        arranger: { multiple: !0, unique: !0 },
        engineer: { multiple: !0, unique: !0 },
        producer: { multiple: !0, unique: !0 },
        technician: { multiple: !0, unique: !0 },
        djmixer: { multiple: !0, unique: !0 },
        mixer: { multiple: !0, unique: !0 },
        label: { multiple: !0, unique: !0 },
        grouping: jd,
        subtitle: { multiple: !0 },
        discsubtitle: jd,
        totaltracks: jd,
        totaldiscs: jd,
        compilation: jd,
        rating: { multiple: !0 },
        bpm: jd,
        mood: jd,
        media: jd,
        catalognumber: { multiple: !0, unique: !0 },
        tvShow: jd,
        tvShowSort: jd,
        tvSeason: jd,
        tvEpisode: jd,
        tvEpisodeId: jd,
        tvNetwork: jd,
        podcast: jd,
        podcasturl: jd,
        releasestatus: jd,
        releasetype: { multiple: !0 },
        releasecountry: jd,
        script: jd,
        language: jd,
        copyright: jd,
        license: jd,
        encodedby: jd,
        encodersettings: jd,
        gapless: jd,
        barcode: jd,
        isrc: { multiple: !0 },
        asin: jd,
        musicbrainz_recordingid: jd,
        musicbrainz_trackid: jd,
        musicbrainz_albumid: jd,
        musicbrainz_artistid: { multiple: !0 },
        musicbrainz_albumartistid: { multiple: !0 },
        musicbrainz_releasegroupid: jd,
        musicbrainz_workid: jd,
        musicbrainz_trmid: jd,
        musicbrainz_discid: jd,
        acoustid_id: jd,
        acoustid_fingerprint: jd,
        musicip_puid: jd,
        musicip_fingerprint: jd,
        website: jd,
        "performer:instrument": { multiple: !0, unique: !0 },
        averageLevel: jd,
        peakLevel: jd,
        notes: { multiple: !0, unique: !1 },
        key: jd,
        originalalbum: jd,
        originalartist: jd,
        discogs_artist_id: { multiple: !0, unique: !0 },
        discogs_release_id: jd,
        discogs_label_id: jd,
        discogs_master_release_id: jd,
        discogs_votes: jd,
        discogs_rating: jd,
        replaygain_track_peak: jd,
        replaygain_track_gain: jd,
        replaygain_album_peak: jd,
        replaygain_album_gain: jd,
        replaygain_track_minmax: jd,
        replaygain_album_minmax: jd,
        replaygain_undo: jd,
        description: { multiple: !0 },
        longDescription: jd,
        category: { multiple: !0 },
        hdVideo: jd,
        keywords: { multiple: !0 },
        movement: jd,
        movementIndex: jd,
        movementTotal: jd,
        podcastId: jd,
        showMovement: jd,
        stik: jd,
    };
class qd {
    static toIntOrNull(e) {
        const t = Number.parseInt(e, 10);
        return Number.isNaN(t) ? null : t;
    }
    static normalizeTrack(e) {
        const t = e.toString().split("/");
        return { no: Number.parseInt(t[0], 10) || null, of: Number.parseInt(t[1], 10) || null };
    }
    constructor(e, t) {
        (this.tagTypes = e), (this.tagMap = t);
    }
    mapGenericTag(e, t) {
        (e = { id: e.id, value: e.value }), this.postMap(e, t);
        const n = this.getCommonName(e.id);
        return n ? { id: n, value: e.value } : null;
    }
    getCommonName(e) {
        return this.tagMap[e];
    }
    postMap(e, t) {}
}
qd.maxRatingScore = 1;
const Xd = {
    title: "title",
    artist: "artist",
    album: "album",
    year: "year",
    comment: "comment",
    track: "track",
    genre: "genre",
};
class Gd extends qd {
    constructor() {
        super(["ID3v1"], Xd);
    }
}
class Kd extends qd {
    constructor(e, t) {
        const n = {};
        for (const r of Object.keys(t)) n[r.toUpperCase()] = t[r];
        super(e, n);
    }
    getCommonName(e) {
        return this.tagMap[e.toUpperCase()];
    }
}
const Yd = {
    TIT2: "title",
    TPE1: "artist",
    "TXXX:Artists": "artists",
    TPE2: "albumartist",
    TALB: "album",
    TDRV: "date",
    TORY: "originalyear",
    TPOS: "disk",
    TCON: "genre",
    APIC: "picture",
    TCOM: "composer",
    USLT: "lyrics",
    TSOA: "albumsort",
    TSOT: "titlesort",
    TOAL: "originalalbum",
    TSOP: "artistsort",
    TSO2: "albumartistsort",
    TSOC: "composersort",
    TEXT: "lyricist",
    "TXXX:Writer": "writer",
    TPE3: "conductor",
    TPE4: "remixer",
    "IPLS:arranger": "arranger",
    "IPLS:engineer": "engineer",
    "IPLS:producer": "producer",
    "IPLS:DJ-mix": "djmixer",
    "IPLS:mix": "mixer",
    TPUB: "label",
    TIT1: "grouping",
    TIT3: "subtitle",
    TRCK: "track",
    TCMP: "compilation",
    POPM: "rating",
    TBPM: "bpm",
    TMED: "media",
    "TXXX:CATALOGNUMBER": "catalognumber",
    "TXXX:MusicBrainz Album Status": "releasestatus",
    "TXXX:MusicBrainz Album Type": "releasetype",
    "TXXX:MusicBrainz Album Release Country": "releasecountry",
    "TXXX:RELEASECOUNTRY": "releasecountry",
    "TXXX:SCRIPT": "script",
    TLAN: "language",
    TCOP: "copyright",
    WCOP: "license",
    TENC: "encodedby",
    TSSE: "encodersettings",
    "TXXX:BARCODE": "barcode",
    "TXXX:ISRC": "isrc",
    TSRC: "isrc",
    "TXXX:ASIN": "asin",
    "TXXX:originalyear": "originalyear",
    "UFID:http://musicbrainz.org": "musicbrainz_recordingid",
    "TXXX:MusicBrainz Release Track Id": "musicbrainz_trackid",
    "TXXX:MusicBrainz Album Id": "musicbrainz_albumid",
    "TXXX:MusicBrainz Artist Id": "musicbrainz_artistid",
    "TXXX:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
    "TXXX:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
    "TXXX:MusicBrainz Work Id": "musicbrainz_workid",
    "TXXX:MusicBrainz TRM Id": "musicbrainz_trmid",
    "TXXX:MusicBrainz Disc Id": "musicbrainz_discid",
    "TXXX:ACOUSTID_ID": "acoustid_id",
    "TXXX:Acoustid Id": "acoustid_id",
    "TXXX:Acoustid Fingerprint": "acoustid_fingerprint",
    "TXXX:MusicIP PUID": "musicip_puid",
    "TXXX:MusicMagic Fingerprint": "musicip_fingerprint",
    WOAR: "website",
    TDRC: "date",
    TYER: "year",
    TDOR: "originaldate",
    "TIPL:arranger": "arranger",
    "TIPL:engineer": "engineer",
    "TIPL:producer": "producer",
    "TIPL:DJ-mix": "djmixer",
    "TIPL:mix": "mixer",
    TMOO: "mood",
    SYLT: "lyrics",
    TSST: "discsubtitle",
    TKEY: "key",
    COMM: "comment",
    TOPE: "originalartist",
    "PRIV:AverageLevel": "averageLevel",
    "PRIV:PeakLevel": "peakLevel",
    "TXXX:DISCOGS_ARTIST_ID": "discogs_artist_id",
    "TXXX:DISCOGS_ARTISTS": "artists",
    "TXXX:DISCOGS_ARTIST_NAME": "artists",
    "TXXX:DISCOGS_ALBUM_ARTISTS": "albumartist",
    "TXXX:DISCOGS_CATALOG": "catalognumber",
    "TXXX:DISCOGS_COUNTRY": "releasecountry",
    "TXXX:DISCOGS_DATE": "originaldate",
    "TXXX:DISCOGS_LABEL": "label",
    "TXXX:DISCOGS_LABEL_ID": "discogs_label_id",
    "TXXX:DISCOGS_MASTER_RELEASE_ID": "discogs_master_release_id",
    "TXXX:DISCOGS_RATING": "discogs_rating",
    "TXXX:DISCOGS_RELEASED": "date",
    "TXXX:DISCOGS_RELEASE_ID": "discogs_release_id",
    "TXXX:DISCOGS_VOTES": "discogs_votes",
    "TXXX:CATALOGID": "catalognumber",
    "TXXX:STYLE": "genre",
    "TXXX:REPLAYGAIN_TRACK_PEAK": "replaygain_track_peak",
    "TXXX:REPLAYGAIN_TRACK_GAIN": "replaygain_track_gain",
    "TXXX:REPLAYGAIN_ALBUM_PEAK": "replaygain_album_peak",
    "TXXX:REPLAYGAIN_ALBUM_GAIN": "replaygain_album_gain",
    "TXXX:MP3GAIN_MINMAX": "replaygain_track_minmax",
    "TXXX:MP3GAIN_ALBUM_MINMAX": "replaygain_album_minmax",
    "TXXX:MP3GAIN_UNDO": "replaygain_undo",
    MVNM: "movement",
    MVIN: "movementIndex",
    PCST: "podcast",
    TCAT: "category",
    TDES: "description",
    TDRL: "releasedate",
    TGID: "podcastId",
    TKWD: "keywords",
    WFED: "podcasturl",
    GRP1: "grouping",
};
class Qd extends Kd {
    static toRating(e) {
        return { source: e.email, rating: e.rating > 0 ? ((e.rating - 1) / 254) * qd.maxRatingScore : void 0 };
    }
    constructor() {
        super(["ID3v2.3", "ID3v2.4"], Yd);
    }
    postMap(e, t) {
        switch (e.id) {
            case "UFID":
                {
                    const t = e.value;
                    "http://musicbrainz.org" === t.owner_identifier &&
                        ((e.id += `:${t.owner_identifier}`), (e.value = Ad(t.identifier, "latin1")));
                }
                break;
            case "PRIV":
                {
                    const n = e.value;
                    switch (n.owner_identifier) {
                        case "AverageLevel":
                        case "PeakValue":
                            (e.id += `:${n.owner_identifier}`),
                                (e.value = 4 === n.data.length ? hl.get(n.data, 0) : null),
                                null === e.value && t.addWarning("Failed to parse PRIV:PeakValue");
                            break;
                        default:
                            t.addWarning(`Unknown PRIV owner-identifier: ${n.data}`);
                    }
                }
                break;
            case "POPM":
                e.value = Qd.toRating(e.value);
        }
    }
}
const Jd = {
    Title: "title",
    Author: "artist",
    "WM/AlbumArtist": "albumartist",
    "WM/AlbumTitle": "album",
    "WM/Year": "date",
    "WM/OriginalReleaseTime": "originaldate",
    "WM/OriginalReleaseYear": "originalyear",
    Description: "comment",
    "WM/TrackNumber": "track",
    "WM/PartOfSet": "disk",
    "WM/Genre": "genre",
    "WM/Composer": "composer",
    "WM/Lyrics": "lyrics",
    "WM/AlbumSortOrder": "albumsort",
    "WM/TitleSortOrder": "titlesort",
    "WM/ArtistSortOrder": "artistsort",
    "WM/AlbumArtistSortOrder": "albumartistsort",
    "WM/ComposerSortOrder": "composersort",
    "WM/Writer": "lyricist",
    "WM/Conductor": "conductor",
    "WM/ModifiedBy": "remixer",
    "WM/Engineer": "engineer",
    "WM/Producer": "producer",
    "WM/DJMixer": "djmixer",
    "WM/Mixer": "mixer",
    "WM/Publisher": "label",
    "WM/ContentGroupDescription": "grouping",
    "WM/SubTitle": "subtitle",
    "WM/SetSubTitle": "discsubtitle",
    "WM/IsCompilation": "compilation",
    "WM/SharedUserRating": "rating",
    "WM/BeatsPerMinute": "bpm",
    "WM/Mood": "mood",
    "WM/Media": "media",
    "WM/CatalogNo": "catalognumber",
    "MusicBrainz/Album Status": "releasestatus",
    "MusicBrainz/Album Type": "releasetype",
    "MusicBrainz/Album Release Country": "releasecountry",
    "WM/Script": "script",
    "WM/Language": "language",
    Copyright: "copyright",
    LICENSE: "license",
    "WM/EncodedBy": "encodedby",
    "WM/EncodingSettings": "encodersettings",
    "WM/Barcode": "barcode",
    "WM/ISRC": "isrc",
    "MusicBrainz/Track Id": "musicbrainz_recordingid",
    "MusicBrainz/Release Track Id": "musicbrainz_trackid",
    "MusicBrainz/Album Id": "musicbrainz_albumid",
    "MusicBrainz/Artist Id": "musicbrainz_artistid",
    "MusicBrainz/Album Artist Id": "musicbrainz_albumartistid",
    "MusicBrainz/Release Group Id": "musicbrainz_releasegroupid",
    "MusicBrainz/Work Id": "musicbrainz_workid",
    "MusicBrainz/TRM Id": "musicbrainz_trmid",
    "MusicBrainz/Disc Id": "musicbrainz_discid",
    "Acoustid/Id": "acoustid_id",
    "Acoustid/Fingerprint": "acoustid_fingerprint",
    "MusicIP/PUID": "musicip_puid",
    "WM/ARTISTS": "artists",
    "WM/InitialKey": "key",
    ASIN: "asin",
    "WM/Work": "work",
    "WM/AuthorURL": "website",
    "WM/Picture": "picture",
};
class Zd extends qd {
    static toRating(e) {
        return { rating: Number.parseFloat(e + 1) / 5 };
    }
    constructor() {
        super(["asf"], Jd);
    }
    postMap(e) {
        switch (e.id) {
            case "WM/SharedUserRating": {
                const t = e.id.split(":");
                (e.value = Zd.toRating(e.value)), (e.id = t[0]);
                break;
            }
        }
    }
}
const eh = {
    TT2: "title",
    TP1: "artist",
    TP2: "albumartist",
    TAL: "album",
    TYE: "year",
    COM: "comment",
    TRK: "track",
    TPA: "disk",
    TCO: "genre",
    PIC: "picture",
    TCM: "composer",
    TOR: "originaldate",
    TOT: "originalalbum",
    TXT: "lyricist",
    TP3: "conductor",
    TPB: "label",
    TT1: "grouping",
    TT3: "subtitle",
    TLA: "language",
    TCR: "copyright",
    WCP: "license",
    TEN: "encodedby",
    TSS: "encodersettings",
    WAR: "website",
    PCS: "podcast",
    TCP: "compilation",
    TDR: "date",
    TS2: "albumartistsort",
    TSA: "albumsort",
    TSC: "composersort",
    TSP: "artistsort",
    TST: "titlesort",
    WFD: "podcasturl",
    TBP: "bpm",
};
class th extends Kd {
    constructor() {
        super(["ID3v2.2"], eh);
    }
}
const nh = {
    Title: "title",
    Artist: "artist",
    Artists: "artists",
    "Album Artist": "albumartist",
    Album: "album",
    Year: "date",
    Originalyear: "originalyear",
    Originaldate: "originaldate",
    Releasedate: "releasedate",
    Comment: "comment",
    Track: "track",
    Disc: "disk",
    DISCNUMBER: "disk",
    Genre: "genre",
    "Cover Art (Front)": "picture",
    "Cover Art (Back)": "picture",
    Composer: "composer",
    Lyrics: "lyrics",
    ALBUMSORT: "albumsort",
    TITLESORT: "titlesort",
    WORK: "work",
    ARTISTSORT: "artistsort",
    ALBUMARTISTSORT: "albumartistsort",
    COMPOSERSORT: "composersort",
    Lyricist: "lyricist",
    Writer: "writer",
    Conductor: "conductor",
    MixArtist: "remixer",
    Arranger: "arranger",
    Engineer: "engineer",
    Producer: "producer",
    DJMixer: "djmixer",
    Mixer: "mixer",
    Label: "label",
    Grouping: "grouping",
    Subtitle: "subtitle",
    DiscSubtitle: "discsubtitle",
    Compilation: "compilation",
    BPM: "bpm",
    Mood: "mood",
    Media: "media",
    CatalogNumber: "catalognumber",
    MUSICBRAINZ_ALBUMSTATUS: "releasestatus",
    MUSICBRAINZ_ALBUMTYPE: "releasetype",
    RELEASECOUNTRY: "releasecountry",
    Script: "script",
    Language: "language",
    Copyright: "copyright",
    LICENSE: "license",
    EncodedBy: "encodedby",
    EncoderSettings: "encodersettings",
    Barcode: "barcode",
    ISRC: "isrc",
    ASIN: "asin",
    musicbrainz_trackid: "musicbrainz_recordingid",
    musicbrainz_releasetrackid: "musicbrainz_trackid",
    MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
    MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
    MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
    MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
    MUSICBRAINZ_WORKID: "musicbrainz_workid",
    MUSICBRAINZ_TRMID: "musicbrainz_trmid",
    MUSICBRAINZ_DISCID: "musicbrainz_discid",
    Acoustid_Id: "acoustid_id",
    ACOUSTID_FINGERPRINT: "acoustid_fingerprint",
    MUSICIP_PUID: "musicip_puid",
    Weblink: "website",
    REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
    REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
    MP3GAIN_MINMAX: "replaygain_track_minmax",
    MP3GAIN_UNDO: "replaygain_undo",
};
class rh extends Kd {
    constructor() {
        super(["APEv2"], nh);
    }
}
const ih = {
    "nam": "title",
    "ART": "artist",
    aART: "albumartist",
    "----:com.apple.iTunes:Band": "albumartist",
    "alb": "album",
    "day": "date",
    "cmt": "comment",
    "com": "comment",
    trkn: "track",
    disk: "disk",
    "gen": "genre",
    covr: "picture",
    "wrt": "composer",
    "lyr": "lyrics",
    soal: "albumsort",
    sonm: "titlesort",
    soar: "artistsort",
    soaa: "albumartistsort",
    soco: "composersort",
    "----:com.apple.iTunes:LYRICIST": "lyricist",
    "----:com.apple.iTunes:CONDUCTOR": "conductor",
    "----:com.apple.iTunes:REMIXER": "remixer",
    "----:com.apple.iTunes:ENGINEER": "engineer",
    "----:com.apple.iTunes:PRODUCER": "producer",
    "----:com.apple.iTunes:DJMIXER": "djmixer",
    "----:com.apple.iTunes:MIXER": "mixer",
    "----:com.apple.iTunes:LABEL": "label",
    "grp": "grouping",
    "----:com.apple.iTunes:SUBTITLE": "subtitle",
    "----:com.apple.iTunes:DISCSUBTITLE": "discsubtitle",
    cpil: "compilation",
    tmpo: "bpm",
    "----:com.apple.iTunes:MOOD": "mood",
    "----:com.apple.iTunes:MEDIA": "media",
    "----:com.apple.iTunes:CATALOGNUMBER": "catalognumber",
    tvsh: "tvShow",
    tvsn: "tvSeason",
    tves: "tvEpisode",
    sosn: "tvShowSort",
    tven: "tvEpisodeId",
    tvnn: "tvNetwork",
    pcst: "podcast",
    purl: "podcasturl",
    "----:com.apple.iTunes:MusicBrainz Album Status": "releasestatus",
    "----:com.apple.iTunes:MusicBrainz Album Type": "releasetype",
    "----:com.apple.iTunes:MusicBrainz Album Release Country": "releasecountry",
    "----:com.apple.iTunes:SCRIPT": "script",
    "----:com.apple.iTunes:LANGUAGE": "language",
    cprt: "copyright",
    "cpy": "copyright",
    "----:com.apple.iTunes:LICENSE": "license",
    "too": "encodedby",
    pgap: "gapless",
    "----:com.apple.iTunes:BARCODE": "barcode",
    "----:com.apple.iTunes:ISRC": "isrc",
    "----:com.apple.iTunes:ASIN": "asin",
    "----:com.apple.iTunes:NOTES": "comment",
    "----:com.apple.iTunes:MusicBrainz Track Id": "musicbrainz_recordingid",
    "----:com.apple.iTunes:MusicBrainz Release Track Id": "musicbrainz_trackid",
    "----:com.apple.iTunes:MusicBrainz Album Id": "musicbrainz_albumid",
    "----:com.apple.iTunes:MusicBrainz Artist Id": "musicbrainz_artistid",
    "----:com.apple.iTunes:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
    "----:com.apple.iTunes:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
    "----:com.apple.iTunes:MusicBrainz Work Id": "musicbrainz_workid",
    "----:com.apple.iTunes:MusicBrainz TRM Id": "musicbrainz_trmid",
    "----:com.apple.iTunes:MusicBrainz Disc Id": "musicbrainz_discid",
    "----:com.apple.iTunes:Acoustid Id": "acoustid_id",
    "----:com.apple.iTunes:Acoustid Fingerprint": "acoustid_fingerprint",
    "----:com.apple.iTunes:MusicIP PUID": "musicip_puid",
    "----:com.apple.iTunes:fingerprint": "musicip_fingerprint",
    "----:com.apple.iTunes:replaygain_track_gain": "replaygain_track_gain",
    "----:com.apple.iTunes:replaygain_track_peak": "replaygain_track_peak",
    "----:com.apple.iTunes:replaygain_album_gain": "replaygain_album_gain",
    "----:com.apple.iTunes:replaygain_album_peak": "replaygain_album_peak",
    "----:com.apple.iTunes:replaygain_track_minmax": "replaygain_track_minmax",
    "----:com.apple.iTunes:replaygain_album_minmax": "replaygain_album_minmax",
    "----:com.apple.iTunes:replaygain_undo": "replaygain_undo",
    gnre: "genre",
    "----:com.apple.iTunes:ALBUMARTISTSORT": "albumartistsort",
    "----:com.apple.iTunes:ARTISTS": "artists",
    "----:com.apple.iTunes:ORIGINALDATE": "originaldate",
    "----:com.apple.iTunes:ORIGINALYEAR": "originalyear",
    "----:com.apple.iTunes:RELEASEDATE": "releasedate",
    desc: "description",
    ldes: "longDescription",
    "mvn": "movement",
    "mvi": "movementIndex",
    "mvc": "movementTotal",
    "wrk": "work",
    catg: "category",
    egid: "podcastId",
    hdvd: "hdVideo",
    keyw: "keywords",
    shwm: "showMovement",
    stik: "stik",
    rate: "rating",
};
class sh extends Kd {
    constructor() {
        super(["iTunes"], ih);
    }
    postMap(e, t) {
        if ("rate" === e.id) e.value = { source: void 0, rating: Number.parseFloat(e.value) / 100 };
    }
}
const ah = {
    TITLE: "title",
    ARTIST: "artist",
    ARTISTS: "artists",
    ALBUMARTIST: "albumartist",
    "ALBUM ARTIST": "albumartist",
    ALBUM: "album",
    DATE: "date",
    ORIGINALDATE: "originaldate",
    ORIGINALYEAR: "originalyear",
    RELEASEDATE: "releasedate",
    COMMENT: "comment",
    TRACKNUMBER: "track",
    DISCNUMBER: "disk",
    GENRE: "genre",
    METADATA_BLOCK_PICTURE: "picture",
    COMPOSER: "composer",
    LYRICS: "lyrics",
    ALBUMSORT: "albumsort",
    TITLESORT: "titlesort",
    WORK: "work",
    ARTISTSORT: "artistsort",
    ALBUMARTISTSORT: "albumartistsort",
    COMPOSERSORT: "composersort",
    LYRICIST: "lyricist",
    WRITER: "writer",
    CONDUCTOR: "conductor",
    REMIXER: "remixer",
    ARRANGER: "arranger",
    ENGINEER: "engineer",
    PRODUCER: "producer",
    DJMIXER: "djmixer",
    MIXER: "mixer",
    LABEL: "label",
    GROUPING: "grouping",
    SUBTITLE: "subtitle",
    DISCSUBTITLE: "discsubtitle",
    TRACKTOTAL: "totaltracks",
    DISCTOTAL: "totaldiscs",
    COMPILATION: "compilation",
    RATING: "rating",
    BPM: "bpm",
    KEY: "key",
    MOOD: "mood",
    MEDIA: "media",
    CATALOGNUMBER: "catalognumber",
    RELEASESTATUS: "releasestatus",
    RELEASETYPE: "releasetype",
    RELEASECOUNTRY: "releasecountry",
    SCRIPT: "script",
    LANGUAGE: "language",
    COPYRIGHT: "copyright",
    LICENSE: "license",
    ENCODEDBY: "encodedby",
    ENCODERSETTINGS: "encodersettings",
    BARCODE: "barcode",
    ISRC: "isrc",
    ASIN: "asin",
    MUSICBRAINZ_TRACKID: "musicbrainz_recordingid",
    MUSICBRAINZ_RELEASETRACKID: "musicbrainz_trackid",
    MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
    MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
    MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
    MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
    MUSICBRAINZ_WORKID: "musicbrainz_workid",
    MUSICBRAINZ_TRMID: "musicbrainz_trmid",
    MUSICBRAINZ_DISCID: "musicbrainz_discid",
    ACOUSTID_ID: "acoustid_id",
    ACOUSTID_ID_FINGERPRINT: "acoustid_fingerprint",
    MUSICIP_PUID: "musicip_puid",
    WEBSITE: "website",
    NOTES: "notes",
    TOTALTRACKS: "totaltracks",
    TOTALDISCS: "totaldiscs",
    DISCOGS_ARTIST_ID: "discogs_artist_id",
    DISCOGS_ARTISTS: "artists",
    DISCOGS_ARTIST_NAME: "artists",
    DISCOGS_ALBUM_ARTISTS: "albumartist",
    DISCOGS_CATALOG: "catalognumber",
    DISCOGS_COUNTRY: "releasecountry",
    DISCOGS_DATE: "originaldate",
    DISCOGS_LABEL: "label",
    DISCOGS_LABEL_ID: "discogs_label_id",
    DISCOGS_MASTER_RELEASE_ID: "discogs_master_release_id",
    DISCOGS_RATING: "discogs_rating",
    DISCOGS_RELEASED: "date",
    DISCOGS_RELEASE_ID: "discogs_release_id",
    DISCOGS_VOTES: "discogs_votes",
    CATALOGID: "catalognumber",
    STYLE: "genre",
    REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
    REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
    REPLAYGAIN_ALBUM_GAIN: "replaygain_album_gain",
    REPLAYGAIN_ALBUM_PEAK: "replaygain_album_peak",
    REPLAYGAIN_MINMAX: "replaygain_track_minmax",
    REPLAYGAIN_ALBUM_MINMAX: "replaygain_album_minmax",
    REPLAYGAIN_UNDO: "replaygain_undo",
};
class oh extends qd {
    static toRating(e, t, n) {
        return { source: e ? e.toLowerCase() : void 0, rating: (Number.parseFloat(t) / n) * qd.maxRatingScore };
    }
    constructor() {
        super(["vorbis"], ah);
    }
    postMap(e) {
        if ("RATING" === e.id) e.value = oh.toRating(void 0, e.value, 100);
        else if (0 === e.id.indexOf("RATING:")) {
            const t = e.id.split(":");
            (e.value = oh.toRating(t[1], e.value, 1)), (e.id = t[0]);
        }
    }
}
const ch = {
    IART: "artist",
    ICRD: "date",
    INAM: "title",
    TITL: "title",
    IPRD: "album",
    ITRK: "track",
    IPRT: "track",
    COMM: "comment",
    ICMT: "comment",
    ICNT: "releasecountry",
    GNRE: "genre",
    IWRI: "writer",
    RATE: "rating",
    YEAR: "year",
    ISFT: "encodedby",
    CODE: "encodedby",
    TURL: "website",
    IGNR: "genre",
    IENG: "engineer",
    ITCH: "technician",
    IMED: "media",
    IRPD: "album",
};
class lh extends qd {
    constructor() {
        super(["exif"], ch);
    }
}
const uh = {
    "segment:title": "title",
    "album:ARTIST": "albumartist",
    "album:ARTISTSORT": "albumartistsort",
    "album:TITLE": "album",
    "album:DATE_RECORDED": "originaldate",
    "album:DATE_RELEASED": "releasedate",
    "album:PART_NUMBER": "disk",
    "album:TOTAL_PARTS": "totaltracks",
    "track:ARTIST": "artist",
    "track:ARTISTSORT": "artistsort",
    "track:TITLE": "title",
    "track:PART_NUMBER": "track",
    "track:MUSICBRAINZ_TRACKID": "musicbrainz_recordingid",
    "track:MUSICBRAINZ_ALBUMID": "musicbrainz_albumid",
    "track:MUSICBRAINZ_ARTISTID": "musicbrainz_artistid",
    "track:PUBLISHER": "label",
    "track:GENRE": "genre",
    "track:ENCODER": "encodedby",
    "track:ENCODER_OPTIONS": "encodersettings",
    "edition:TOTAL_PARTS": "totaldiscs",
    picture: "picture",
};
class dh extends Kd {
    constructor() {
        super(["matroska"], uh);
    }
}
const hh = { NAME: "title", AUTH: "artist", "(c) ": "copyright", ANNO: "comment" };
class mh extends qd {
    constructor() {
        super(["AIFF"], hh);
    }
}
class ph {
    constructor() {
        (this.tagMappers = {}),
            [
                new Gd(),
                new th(),
                new Qd(),
                new sh(),
                new sh(),
                new oh(),
                new rh(),
                new Zd(),
                new lh(),
                new dh(),
                new mh(),
            ].forEach((e) => {
                this.registerTagMapper(e);
            });
    }
    mapTag(e, t, n) {
        if (this.tagMappers[e]) return this.tagMappers[e].mapGenericTag(t, n);
        throw new Sd(`No generic tag mapper defined for tag-format: ${e}`);
    }
    registerTagMapper(e) {
        for (const t of e.tagTypes) this.tagMappers[t] = e;
    }
}
const fh = Tu("music-metadata:collector"),
    gh = ["matroska", "APEv2", "vorbis", "ID3v2.4", "ID3v2.3", "ID3v2.2", "exif", "asf", "iTunes", "AIFF", "ID3v1"];
class bh {
    constructor(e) {
        (this.format = { tagTypes: [], trackInfo: [] }),
            (this.native = {}),
            (this.common = {
                track: { no: null, of: null },
                disk: { no: null, of: null },
                movementIndex: { no: null, of: null },
            }),
            (this.quality = { warnings: [] }),
            (this.commonOrigin = {}),
            (this.originPriority = {}),
            (this.tagMapper = new ph()),
            (this.opts = e);
        let t = 1;
        for (const n of gh) this.originPriority[n] = t++;
        (this.originPriority.artificial = 500), (this.originPriority.id3v1 = 600);
    }
    hasAny() {
        return Object.keys(this.native).length > 0;
    }
    addStreamInfo(e) {
        fh(`streamInfo: type=${e.type ? yd[e.type] : "?"}, codec=${e.codecName}`), this.format.trackInfo.push(e);
    }
    setFormat(e, t) {
        fh(`format: ${e} = ${t}`),
            (this.format[e] = t),
            this.opts?.observer && this.opts.observer({ metadata: this, tag: { type: "format", id: e, value: t } });
    }
    setAudioOnly() {
        this.setFormat("hasAudio", !0), this.setFormat("hasVideo", !1);
    }
    async addTag(e, t, n) {
        fh(`tag ${e}.${t} = ${n}`),
            this.native[e] || (this.format.tagTypes.push(e), (this.native[e] = [])),
            this.native[e].push({ id: t, value: n }),
            await this.toCommon(e, t, n);
    }
    addWarning(e) {
        this.quality.warnings.push({ message: e });
    }
    async postMap(e, t) {
        switch (t.id) {
            case "artist":
                if (this.commonOrigin.artist === this.originPriority[e])
                    return this.postMap("artificial", { id: "artists", value: t.value });
                this.common.artists || this.setGenericTag("artificial", { id: "artists", value: t.value });
                break;
            case "artists":
                if (
                    !(
                        (this.common.artist && this.commonOrigin.artist !== this.originPriority.artificial) ||
                        (this.common.artists && -1 !== this.common.artists.indexOf(t.value))
                    )
                ) {
                    const e = (function (e) {
                            if (e.length > 2) return `${e.slice(0, e.length - 1).join(", ")} & ${e[e.length - 1]}`;
                            return e.join(" & ");
                        })((this.common.artists || []).concat([t.value])),
                        n = { id: "artist", value: e };
                    this.setGenericTag("artificial", n);
                }
                break;
            case "picture":
                return this.postFixPicture(t.value).then((n) => {
                    null !== n && ((t.value = n), this.setGenericTag(e, t));
                });
            case "totaltracks":
                return void (this.common.track.of = qd.toIntOrNull(t.value));
            case "totaldiscs":
                return void (this.common.disk.of = qd.toIntOrNull(t.value));
            case "movementTotal":
                return void (this.common.movementIndex.of = qd.toIntOrNull(t.value));
            case "track":
            case "disk":
            case "movementIndex": {
                const e = this.common[t.id].of;
                return (
                    (this.common[t.id] = qd.normalizeTrack(t.value)),
                    void (this.common[t.id].of = null != e ? e : this.common[t.id].of)
                );
            }
            case "bpm":
            case "year":
            case "originalyear":
                t.value = Number.parseInt(t.value, 10);
                break;
            case "date": {
                const e = Number.parseInt(t.value.substr(0, 4), 10);
                Number.isNaN(e) || (this.common.year = e);
                break;
            }
            case "discogs_label_id":
            case "discogs_release_id":
            case "discogs_master_release_id":
            case "discogs_artist_id":
            case "discogs_votes":
                t.value = "string" == typeof t.value ? Number.parseInt(t.value, 10) : t.value;
                break;
            case "replaygain_track_gain":
            case "replaygain_track_peak":
            case "replaygain_album_gain":
            case "replaygain_album_peak":
                t.value = (function (e) {
                    const t = e.split(" ").map((e) => e.trim().toLowerCase());
                    if (t.length >= 1) {
                        const e = Number.parseFloat(t[0]);
                        return 2 === t.length && "db" === t[1]
                            ? { dB: e, ratio: ((r = e), 10 ** (r / 10)) }
                            : { dB: ((n = e), 10 * Math.log10(n)), ratio: e };
                    }
                    var n, r;
                })(t.value);
                break;
            case "replaygain_track_minmax":
                t.value = t.value.split(",").map((e) => Number.parseInt(e, 10));
                break;
            case "replaygain_undo": {
                const e = t.value.split(",").map((e) => Number.parseInt(e, 10));
                t.value = { leftChannel: e[0], rightChannel: e[1] };
                break;
            }
            case "gapless":
            case "compilation":
            case "podcast":
            case "showMovement":
                t.value = "1" === t.value || 1 === t.value;
                break;
            case "isrc": {
                const e = this.common[t.id];
                if (e && -1 !== e.indexOf(t.value)) return;
                break;
            }
            case "comment":
                "string" == typeof t.value && (t.value = { text: t.value }),
                    "iTunPGAP" === t.value.descriptor &&
                        this.setGenericTag(e, { id: "gapless", value: "1" === t.value.text });
                break;
            case "lyrics":
                "string" == typeof t.value &&
                    (t.value = (function (e) {
                        const t = e.split("\n"),
                            n = [],
                            r = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
                        for (const i of t) {
                            const e = i.match(r);
                            if (e) {
                                const t = Number.parseInt(e[1], 10),
                                    s = Number.parseInt(e[2], 10),
                                    a = e[3];
                                let o;
                                o = 3 === a.length ? Number.parseInt(a, 10) : 10 * Number.parseInt(a, 10);
                                const c = 1e3 * (60 * t + s) + o,
                                    l = i.replace(r, "").trim();
                                n.push({ timestamp: c, text: l });
                            }
                        }
                        return { contentType: Md, timeStampFormat: Dd, syncText: n };
                    })(t.value));
        }
        null !== t.value && this.setGenericTag(e, t);
    }
    toCommonMetadata() {
        return { format: this.format, native: this.native, quality: this.quality, common: this.common };
    }
    async postFixPicture(e) {
        if (e.data && e.data.length > 0) {
            if (!e.format) {
                const t = await Zu(Uint8Array.from(e.data));
                if (!t) return null;
                e.format = t.mime;
            }
            if (((e.format = e.format.toLocaleLowerCase()), "image/jpg" === e.format)) e.format = "image/jpeg";
            return e;
        }
        return this.addWarning("Empty picture tag found"), null;
    }
    async toCommon(e, t, n) {
        const r = { id: t, value: n },
            i = this.tagMapper.mapTag(e, r, this);
        i && (await this.postMap(e, i));
    }
    setGenericTag(e, t) {
        fh(`common.${t.id} = ${t.value}`);
        const n = this.commonOrigin[t.id] || 1e3,
            r = this.originPriority[e];
        if (((i = t.id), Hd[i] && !Hd[i].multiple)) {
            if (!(r <= n)) return fh(`Ignore native tag (singleton): ${e}.${t.id} = ${t.value}`);
            (this.common[t.id] = t.value), (this.commonOrigin[t.id] = r);
        } else if (r === n)
            !(function (e) {
                return !Hd[e].multiple || Hd[e].unique || !1;
            })(t.id) || -1 === this.common[t.id].indexOf(t.value)
                ? this.common[t.id].push(t.value)
                : fh(`Ignore duplicate value: ${e}.${t.id} = ${t.value}`);
        else {
            if (!(r < n)) return fh(`Ignore native tag (list): ${e}.${t.id} = ${t.value}`);
            (this.common[t.id] = [t.value]), (this.commonOrigin[t.id] = r);
        }
        var i;
        this.opts?.observer &&
            this.opts.observer({ metadata: this, tag: { type: "common", id: t.id, value: t.value } });
    }
}
function yh() {
    const e = [
        "fulfilled",
        "endsWith",
        "vite:preloadError",
        "2753460fmIKhz",
        "tHRzW",
        "732310kBBRPj",
        "kwBvO",
        "script",
        "nKtWJ",
        "getElementsByTagName",
        "qWhVC",
        "resolve",
        "flUwp",
        "gxrXk",
        "1881392AlqMfE",
        "error",
        "znppt",
        "lOfGa",
        "createElement",
        "234802gJOQSs",
        "stylesheet",
        ".css",
        "22635mAhCwS",
        "12oyOweT",
        "kOQTx",
        "JwZbM",
        "getAttribute",
        "Ivgka",
        "mMjmq",
        "hQcVf",
        "dispatchEvent",
        "then",
        "WGlan",
        "nonce",
        "gzfDZ",
        "reason",
        "link",
        "NCLMe",
        "DUiDO",
        "120AKKouB",
        "Efnfh",
        "head",
        "2MgcBdt",
        "YWJWA",
        "modulepreload",
        "gJUpe",
        "addEventListener",
        "payload",
        "iWXnI",
        "defaultPrevented",
        "TIMiV",
        "yOsPb",
        "href",
        "vMqVL",
        "rejected",
        "UvvWs",
        "map",
        "load",
        "9APbloW",
        "QjFSx",
        "rel",
        "XGIOF",
        "crossOrigin",
        "qaTvi",
        "Unable to preload CSS for ",
        "YCMTn",
        "setAttribute",
        "querySelector",
        "oLFaF",
        "RIYfW",
        "11RRBQrH",
        "984347EOLHQY",
        "wLkFb",
        "ZWZry",
        'link[href="',
        "vHYNi",
        "9361332TeYQIB",
        "length",
    ];
    return (yh = function () {
        return e;
    })();
}
const wh = kh;
function kh(e, t) {
    const n = yh();
    return (kh = function (e, t) {
        return n[(e -= 140)];
    })(e, t);
}
!(function () {
    const e = kh,
        t = yh();
    for (;;)
        try {
            if (
                155502 ===
                (-parseInt(e(177)) / 1) * (parseInt(e(154)) / 2) +
                    (parseInt(e(157)) / 3) * (parseInt(e(174)) / 4) +
                    (-parseInt(e(140)) / 5) * (-parseInt(e(158)) / 6) +
                    parseInt(e(206)) / 7 +
                    (-parseInt(e(149)) / 8) * (-parseInt(e(193)) / 9) +
                    parseInt(e(216)) / 10 +
                    (-parseInt(e(205)) / 11) * (parseInt(e(211)) / 12)
            )
                break;
            t.push(t.shift());
        } catch (n) {
            t.push(t.shift());
        }
})();
const Th = wh(179),
    _h = function (e, t) {
        return new URL(e, t).href;
    },
    vh = {},
    Sh = function (e, t, n) {
        const r = wh,
            i = {
                lOfGa: r(192),
                qWhVC: r(150),
                ZWZry: function (e, t, n) {
                    return e(t, n);
                },
                iWXnI: r(156),
                hQcVf: '[rel="stylesheet"]',
                RIYfW: function (e, t) {
                    return e - t;
                },
                Efnfh: function (e, t) {
                    return e >= t;
                },
                DUiDO: function (e, t) {
                    return e === t;
                },
                vHYNi: function (e, t) {
                    return e === t;
                },
                nKtWJ: r(155),
                mMjmq: r(168),
                kOQTx: function (e, t) {
                    return e === t;
                },
                XGIOF: function (e, t) {
                    return e === t;
                },
                gzfDZ: r(167),
                gxrXk: r(186),
                vMqVL: r(215),
                Ivgka: function (e, t, n) {
                    return e(t, n);
                },
                YCMTn: function (e, t) {
                    return e - t;
                },
                YWJWA: r(171),
                wLkFb: r(142),
                gJUpe: "qfAzq",
                oLFaF: function (e, t) {
                    return e(t);
                },
                flUwp: function (e) {
                    return e();
                },
                qaTvi: function (e, t) {
                    return e && t;
                },
                NCLMe: function (e, t) {
                    return e > t;
                },
                VhKMR: r(194),
                JwZbM: "meta[property=csp-nonce]",
            };
        let s = Promise[r(146)]();
        if (i[r(198)](!0, t) && i[r(172)](t.length, 0))
            if (i[r(159)](i.VhKMR, "KgUQp")) {
                if (((_0x5f51c9 = i[r(208)](_0x590ec2, _0x15ba4c, _0x321e7b)), _0xbc4a48 in _0x4b55c1)) return;
                _0x50ee80[_0x17e62a] = !0;
                const e = _0x27966e.endsWith(i[r(183)]),
                    t = e ? i[r(164)] : "";
                if (!!_0x3a9d0d)
                    for (let s = i[r(204)](_0x1a9e8b[r(212)], 1); i[r(175)](s, 0); s--) {
                        const t = _0x7c0244[s];
                        if (i[r(173)](t[r(187)], _0x4b6f6a) && (!e || i[r(210)](t[r(195)], i[r(143)]))) return;
                    }
                else if (_0x4efb04.querySelector(r(209) + _0x23c0c1 + '"]' + t)) return;
                const n = _0x4155d6[r(153)](r(171));
                if (
                    ((n[r(195)] = e ? i[r(143)] : _0x111555),
                    e || (n.as = "script"),
                    (n[r(197)] = ""),
                    (n[r(187)] = _0x5e2c32),
                    _0x5b94f0 && n[r(201)](i[r(163)], _0x18507f),
                    _0x430606[r(176)].appendChild(n),
                    e)
                )
                    return new _0xe4ecc7((e, t) => {
                        const s = r;
                        n[s(181)](i.lOfGa, e), n[s(181)](i[s(145)], () => t(new _0x4da5bd(s(199) + _0x1acf7d)));
                    });
            } else {
                let e = function (e) {
                    const t = r;
                    if (!i[t(196)](t(190), i[t(169)]))
                        return Promise.all(
                            e.map((e) =>
                                Promise[t(146)](e)[t(166)](
                                    (e) => ({ status: t(213), value: e }),
                                    (e) => ({ status: t(189), reason: e })
                                )
                            )
                        );
                    {
                        const e = _0x5795ac[_0x1e7e3b];
                        if (i[t(159)](e[t(187)], _0x4f6913) && (!_0x176aa5 || e[t(195)] === i[t(143)])) return;
                    }
                };
                const a = document[r(144)](i[r(178)]),
                    o = document[r(202)](i[r(160)]),
                    c = o?.nonce || o?.[r(161)](i.mMjmq);
                s = i[r(203)](
                    e,
                    t[r(191)]((e) => {
                        const t = r,
                            s = { TIMiV: i[t(188)] };
                        if ((e = i[t(162)](_h, e, n)) in vh) return;
                        vh[e] = !0;
                        const o = e[t(214)](i[t(183)]),
                            l = o ? i.hQcVf : "";
                        if (!!n)
                            for (let n = i[t(200)](a[t(212)], 1); n >= 0; n--) {
                                const r = a[n];
                                if (r[t(187)] === e && (!o || i[t(159)](r.rel, i.nKtWJ))) return;
                            }
                        else if (document[t(202)](t(209) + e + '"]' + l)) return;
                        const u = document[t(153)](i[t(178)]);
                        return (
                            (u.rel = o ? i[t(143)] : Th),
                            o || (u.as = i[t(207)]),
                            (u[t(197)] = ""),
                            (u[t(187)] = e),
                            c && u.setAttribute(i[t(163)], c),
                            document[t(176)].appendChild(u),
                            o
                                ? new Promise((n, r) => {
                                      const a = t;
                                      if (i[a(148)] == i[a(148)])
                                          u.addEventListener(i.lOfGa, n),
                                              u[a(181)](i[a(145)], () => r(new Error(a(199) + e)));
                                      else {
                                          const e = new _0x3c03e5(s[a(185)], { cancelable: !0 });
                                          if (((e[a(182)] = _0x86b67), _0x38d3dd[a(165)](e), !e[a(184)]))
                                              throw _0x212d71;
                                      }
                                  })
                                : void 0
                        );
                    })
                );
            }
        function a(e) {
            const t = r,
                n = { tHRzW: i[t(152)], znppt: i[t(145)] };
            if (t(141) !== i[t(180)]) {
                const n = new Event(i.vMqVL, { cancelable: !0 });
                if (((n[t(182)] = e), window[t(165)](n), !n[t(184)])) throw e;
            } else
                _0x573ff0[t(181)](n[t(217)], _0x1c9eb7),
                    _0x30009f[t(181)](n[t(151)], () => _0x146e85(new _0x1cbde0(t(199) + _0x1fa5a0)));
        }
        return s.then((t) => {
            const n = r;
            for (const e of t || []) e.status === n(189) && i[n(203)](a, e[n(170)]);
            return i[n(147)](e).catch(a);
        });
    },
    Eh = {
        parserType: "mpeg",
        extensions: [".mp2", ".mp3", ".m2a", ".aac", "aacp"],
        mimeTypes: ["audio/mpeg", "audio/mp3", "audio/aacs", "audio/aacp"],
        load: async () =>
            (
                await Sh(
                    async () => {
                        const { MpegParser: e } = await Promise.resolve().then(() => RD);
                        return { MpegParser: e };
                    },
                    void 0,
                    import.meta.url
                )
            ).MpegParser,
    },
    Ch = {
        parserType: "apev2",
        extensions: [".ape"],
        mimeTypes: ["audio/ape", "audio/monkeys-audio"],
        load: async () =>
            (
                await Sh(
                    async () => {
                        const { APEv2Parser: e } = await Promise.resolve().then(() => sm);
                        return { APEv2Parser: e };
                    },
                    void 0,
                    import.meta.url
                )
            ).APEv2Parser,
    },
    Ih = {
        parserType: "asf",
        extensions: [".asf"],
        mimeTypes: ["audio/ms-wma", "video/ms-wmv", "audio/ms-asf", "video/ms-asf", "application/vnd.ms-asf"],
        load: async () =>
            (
                await Sh(
                    async () => {
                        const { AsfParser: e } = await Promise.resolve().then(() => sF);
                        return { AsfParser: e };
                    },
                    void 0,
                    import.meta.url
                )
            ).AsfParser,
    },
    xh = {
        parserType: "dsdiff",
        extensions: [".dff"],
        mimeTypes: ["audio/dsf", "audio/dsd"],
        load: async () =>
            (
                await Sh(
                    async () => {
                        const { DsdiffParser: e } = await Promise.resolve().then(() => lF);
                        return { DsdiffParser: e };
                    },
                    void 0,
                    import.meta.url
                )
            ).DsdiffParser,
    },
    Ah = {
        parserType: "aiff",
        extensions: [".aif", "aiff", "aifc"],
        mimeTypes: ["audio/aiff", "audio/aif", "audio/aifc", "application/aiff"],
        load: async () =>
            (
                await Sh(
                    async () => {
                        const { AIFFParser: e } = await Promise.resolve().then(() => fF);
                        return { AIFFParser: e };
                    },
                    void 0,
                    import.meta.url
                )
            ).AIFFParser,
    },
    Ph = {
        parserType: "dsf",
        extensions: [".dsf"],
        mimeTypes: ["audio/dsf"],
        load: async () =>
            (
                await Sh(
                    async () => {
                        const { DsfParser: e } = await Promise.resolve().then(() => TF);
                        return { DsfParser: e };
                    },
                    void 0,
                    import.meta.url
                )
            ).DsfParser,
    },
    Oh = {
        parserType: "flac",
        extensions: [".flac"],
        mimeTypes: ["audio/flac"],
        load: async () =>
            (
                await Sh(
                    async () => {
                        const { FlacParser: e } = await Promise.resolve().then(() => VF);
                        return { FlacParser: e };
                    },
                    void 0,
                    import.meta.url
                )
            ).FlacParser,
    },
    Nh = {
        parserType: "matroska",
        extensions: [".mka", ".mkv", ".mk3d", ".mks", "webm"],
        mimeTypes: ["audio/matroska", "video/matroska", "audio/webm", "video/webm"],
        load: async () =>
            (
                await Sh(
                    async () => {
                        const { MatroskaParser: e } = await Promise.resolve().then(() => cL);
                        return { MatroskaParser: e };
                    },
                    void 0,
                    import.meta.url
                )
            ).MatroskaParser,
    },
    Rh = {
        parserType: "mp4",
        extensions: [".mp4", ".m4a", ".m4b", ".m4pa", "m4v", "m4r", "3gp"],
        mimeTypes: ["audio/mp4", "audio/m4a", "video/m4v", "video/mp4"],
        load: async () =>
            (
                await Sh(
                    async () => {
                        const { MP4Parser: e } = await Promise.resolve().then(() => qL);
                        return { MP4Parser: e };
                    },
                    void 0,
                    import.meta.url
                )
            ).MP4Parser,
    },
    Mh = {
        parserType: "musepack",
        extensions: [".mpc"],
        mimeTypes: ["audio/musepack"],
        load: async () =>
            (
                await Sh(
                    async () => {
                        const { MusepackParser: e } = await Promise.resolve().then(() => aB);
                        return { MusepackParser: e };
                    },
                    void 0,
                    import.meta.url
                )
            ).MusepackParser,
    },
    Dh = {
        parserType: "ogg",
        extensions: [".ogg", ".ogv", ".oga", ".ogm", ".ogx", ".opus", ".spx"],
        mimeTypes: ["audio/ogg", "audio/opus", "audio/speex", "video/ogg"],
        load: async () =>
            (
                await Sh(
                    async () => {
                        const { OggParser: e } = await Promise.resolve().then(() => vB);
                        return { OggParser: e };
                    },
                    void 0,
                    import.meta.url
                )
            ).OggParser,
    },
    Fh = {
        parserType: "wavpack",
        extensions: [".wv", ".wvp"],
        mimeTypes: ["audio/wavpack"],
        load: async () =>
            (
                await Sh(
                    async () => {
                        const { WavPackParser: e } = await Promise.resolve().then(() => OB);
                        return { WavPackParser: e };
                    },
                    void 0,
                    import.meta.url
                )
            ).WavPackParser,
    },
    Lh = {
        parserType: "riff",
        extensions: [".wav", "wave", ".bwf"],
        mimeTypes: ["audio/vnd.wave", "audio/wav", "audio/wave"],
        load: async () =>
            (
                await Sh(
                    async () => {
                        const { WaveParser: e } = await Promise.resolve().then(() => ZB);
                        return { WaveParser: e };
                    },
                    void 0,
                    import.meta.url
                )
            ).WaveParser,
    },
    Bh = Tu("music-metadata:parser:factory");
class zh {
    constructor() {
        (this.parsers = []),
            [Oh, Eh, Ch, Rh, Nh, Lh, Dh, Ih, Ah, Fh, Mh, Ph, xh].forEach((e) => this.registerParser(e));
    }
    registerParser(e) {
        this.parsers.push(e);
    }
    async parse(e, t, n) {
        if (
            (e.supportsRandomAccess()
                ? (Bh("tokenizer supports random-access, scanning for appending headers"),
                  await (async function (e, t = {}) {
                      let n = e.fileInfo.size;
                      if (
                          await (async function (e) {
                              if (e.fileInfo.size >= 128) {
                                  const t = new Uint8Array(3),
                                      n = e.position;
                                  return (
                                      await e.readBuffer(t, { position: e.fileInfo.size - 128 }),
                                      e.setPosition(n),
                                      "TAG" === new TextDecoder("latin1").decode(t)
                                  );
                              }
                              return !1;
                          })(e)
                      ) {
                          n -= 128;
                          const t = await (async function (e) {
                              const t = e.fileInfo.size;
                              if (t >= 143) {
                                  const n = new Uint8Array(15),
                                      r = e.position;
                                  await e.readBuffer(n, { position: t - 143 }), e.setPosition(r);
                                  const i = new TextDecoder("latin1").decode(n);
                                  if (i.slice(6) === dm) return Number.parseInt(i.slice(0, 6), 10) + 15;
                              }
                              return 0;
                          })(e);
                          n -= t;
                      }
                      t.apeHeader = await im.findApeFooterOffset(e, n);
                  })(e, n))
                : Bh("tokenizer does not support random-access, cannot scan for appending headers"),
            !t)
        ) {
            const n = new Uint8Array(4100);
            if (
                (e.fileInfo.mimeType && (t = this.findLoaderForContentType(e.fileInfo.mimeType)),
                !t && e.fileInfo.path && (t = this.findLoaderForExtension(e.fileInfo.path)),
                !t)
            ) {
                Bh("Guess parser on content..."), await e.peekBuffer(n, { mayBeLess: !0 });
                const r = await Zu(n, { mpegOffsetTolerance: 10 });
                if (!r || !r.mime) throw new kd("Failed to determine audio format");
                if (
                    (Bh(`Guessed file type is mime=${r.mime}, extension=${r.ext}`),
                    !(t = this.findLoaderForContentType(r.mime)))
                )
                    throw new Td(`Guessed MIME-type not supported: ${r.mime}`);
            }
        }
        Bh(`Loading ${t.parserType} parser...`);
        const r = new bh(n),
            i = new (await t.load())(r, e, n ?? {});
        return (
            Bh(`Parser ${t.parserType} loaded`),
            await i.parse(),
            r.format.trackInfo &&
                (void 0 === r.format.hasAudio &&
                    r.setFormat("hasAudio", !!r.format.trackInfo.find((e) => e.type === hd)),
                void 0 === r.format.hasVideo &&
                    r.setFormat("hasVideo", !!r.format.trackInfo.find((e) => e.type === dd))),
            r.toCommonMetadata()
        );
    }
    findLoaderForExtension(e) {
        if (!e) return;
        const t =
            (function (e) {
                const t = e.lastIndexOf(".");
                return -1 === t ? "" : e.slice(t);
            })(e).toLocaleLowerCase() || e;
        return this.parsers.find((e) => -1 !== e.extensions.indexOf(t));
    }
    findLoaderForContentType(e) {
        let t;
        if (!e) return;
        try {
            t = (function (e) {
                const t = ad.parse(e),
                    n = ld.parse(t.type);
                return { type: n.type, subtype: n.subtype, suffix: n.suffix, parameters: t.parameters };
            })(e);
        } catch (r) {
            return void Bh(`Invalid HTTP Content-Type header value: ${e}`);
        }
        const n = 0 === t.subtype.indexOf("x-") ? t.subtype.substring(2) : t.subtype;
        return this.parsers.find((e) => e.mimeTypes.find((e) => -1 !== e.indexOf(`${t.type}/${n}`)));
    }
    getSupportedMimeTypes() {
        const e = new Set();
        return (
            this.parsers.forEach((t) => {
                t.mimeTypes.forEach((t) => {
                    e.add(t), e.add(t.replace("/", "/x-"));
                });
            }),
            Array.from(e)
        );
    }
}
class Uh {
    constructor(e, t, n) {
        (this.metadata = e), (this.tokenizer = t), (this.options = n);
    }
}
const $h = /^[\x21-\x7e][\x20-\x7e\x00()]{3}/,
    Vh = {
        len: 4,
        get: (e, t) => {
            const n = Wu(e.slice(t, t + Vh.len), "latin1");
            if (!n.match($h))
                throw new vd(
                    `FourCC contains invalid characters: ${(function (e) {
                        const t = [];
                        for (let n = 0, r = e.length; n < r; n++) {
                            const r = Number(e.charCodeAt(n)).toString(16);
                            t.push(1 === r.length ? `0${r}` : r);
                        }
                        return t.join(" ");
                    })(n)} "${n}"`
                );
            return n;
        },
        put: (e, t, n) => {
            const r = (ju((i = n)), Hu.encode(i));
            var i;
            if (4 !== r.length) throw new Sd("Invalid length");
            return e.set(r, t), t + 4;
        },
    },
    Wh = 0,
    jh = 1,
    Hh = 2,
    qh = 3,
    Xh = {
        len: 52,
        get: (e, t) => ({
            ID: Vh.get(e, t),
            version: hl.get(e, t + 4) / 1e3,
            descriptorBytes: hl.get(e, t + 8),
            headerBytes: hl.get(e, t + 12),
            seekTableBytes: hl.get(e, t + 16),
            headerDataBytes: hl.get(e, t + 20),
            apeFrameDataBytes: hl.get(e, t + 24),
            apeFrameDataBytesHigh: hl.get(e, t + 28),
            terminatingDataBytes: hl.get(e, t + 32),
            fileMD5: new Rl(16).get(e, t + 36),
        }),
    },
    Gh = {
        len: 24,
        get: (e, t) => ({
            compressionLevel: cl.get(e, t),
            formatFlags: cl.get(e, t + 2),
            blocksPerFrame: hl.get(e, t + 4),
            finalFrameBlocks: hl.get(e, t + 8),
            totalFrames: hl.get(e, t + 12),
            bitsPerSample: cl.get(e, t + 16),
            channel: cl.get(e, t + 18),
            sampleRate: hl.get(e, t + 20),
        }),
    },
    Kh = {
        len: 32,
        get: (e, t) => ({
            ID: new Ml(8, "ascii").get(e, t),
            version: hl.get(e, t + 8),
            size: hl.get(e, t + 12),
            fields: hl.get(e, t + 16),
            flags: Qh(hl.get(e, t + 20)),
        }),
    },
    Yh = { len: 8, get: (e, t) => ({ size: hl.get(e, t), flags: Qh(hl.get(e, t + 4)) }) };
function Qh(e) {
    return {
        containsHeader: Jh(e, 31),
        containsFooter: Jh(e, 30),
        isHeader: Jh(e, 29),
        readOnly: Jh(e, 0),
        dataType: (6 & e) >> 1,
    };
}
function Jh(e, t) {
    return !!(e & (1 << t));
}
const Zh = Tu("music-metadata:parser:APEv2"),
    em = "APEv2",
    tm = "APETAGEX";
class nm extends Ed("APEv2") {}
function rm(e, t, n) {
    return new im(e, t, n).tryParseApeHeader();
}
class im extends Uh {
    constructor() {
        super(...arguments), (this.ape = {});
    }
    static calculateDuration(e) {
        let t = e.totalFrames > 1 ? e.blocksPerFrame * (e.totalFrames - 1) : 0;
        return (t += e.finalFrameBlocks), t / e.sampleRate;
    }
    static async findApeFooterOffset(e, t) {
        const n = new Uint8Array(Kh.len),
            r = e.position;
        if (t <= Kh.len) Zh(`Offset is too small to read APE footer: offset=${t}`);
        else if (t > Kh.len) {
            await e.readBuffer(n, { position: t - Kh.len }), e.setPosition(r);
            const i = Kh.get(n, 0);
            if ("APETAGEX" === i.ID)
                return (
                    i.flags.isHeader
                        ? Zh("APE Header found at offset=" + (t - Kh.len))
                        : (Zh("APE Footer found at offset=" + (t - Kh.len)), (t -= i.size)),
                    { footer: i, offset: t }
                );
        }
    }
    static parseTagFooter(e, t, n) {
        const r = Kh.get(t, t.length - Kh.len);
        if (r.ID !== tm) throw new nm("Unexpected APEv2 Footer ID preamble value");
        nl(t);
        return new im(e, nl(t), n).parseTags(r);
    }
    async tryParseApeHeader() {
        if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < Kh.len)
            return void Zh("No APEv2 header found, end-of-file reached");
        const e = await this.tokenizer.peekToken(Kh);
        if (e.ID === tm) return await this.tokenizer.ignore(Kh.len), this.parseTags(e);
        if ((Zh(`APEv2 header not found at offset=${this.tokenizer.position}`), this.tokenizer.fileInfo.size)) {
            const e = this.tokenizer.fileInfo.size - this.tokenizer.position,
                t = new Uint8Array(e);
            return await this.tokenizer.readBuffer(t), im.parseTagFooter(this.metadata, t, this.options);
        }
    }
    async parse() {
        const e = await this.tokenizer.readToken(Xh);
        if ("MAC " !== e.ID) throw new nm("Unexpected descriptor ID");
        this.ape.descriptor = e;
        const t = e.descriptorBytes - Xh.len,
            n = await (t > 0 ? this.parseDescriptorExpansion(t) : this.parseHeader());
        return this.metadata.setAudioOnly(), await this.tokenizer.ignore(n.forwardBytes), this.tryParseApeHeader();
    }
    async parseTags(e) {
        const t = new Uint8Array(256);
        let n = e.size - Kh.len;
        Zh(`Parse APE tags at offset=${this.tokenizer.position}, size=${n}`);
        for (let r = 0; r < e.fields; r++) {
            if (n < Yh.len) {
                this.metadata.addWarning(
                    `APEv2 Tag-header: ${e.fields - r} items remaining, but no more tag data to read.`
                );
                break;
            }
            const i = await this.tokenizer.readToken(Yh);
            (n -= Yh.len + i.size), await this.tokenizer.peekBuffer(t, { length: Math.min(t.length, n) });
            let s = Id(t, 0, t.length);
            const a = await this.tokenizer.readToken(new Ml(s, "ascii"));
            switch ((await this.tokenizer.ignore(1), (n -= a.length + 1), i.flags.dataType)) {
                case Wh: {
                    const e = (await this.tokenizer.readToken(new Ml(i.size, "utf8"))).split(/\x00/g);
                    await Promise.all(e.map((e) => this.metadata.addTag(em, a, e)));
                    break;
                }
                case jh:
                    if (this.options.skipCovers) await this.tokenizer.ignore(i.size);
                    else {
                        const e = new Uint8Array(i.size);
                        await this.tokenizer.readBuffer(e), (s = Id(e, 0, e.length));
                        const t = Wu(e.slice(0, s)),
                            n = e.slice(s + 1);
                        await this.metadata.addTag(em, a, { description: t, data: n });
                    }
                    break;
                case Hh:
                    Zh(`Ignore external info ${a}`), await this.tokenizer.ignore(i.size);
                    break;
                case qh:
                    Zh(`Ignore external info ${a}`),
                        this.metadata.addWarning(`APEv2 header declares a reserved datatype for "${a}"`),
                        await this.tokenizer.ignore(i.size);
            }
        }
    }
    async parseDescriptorExpansion(e) {
        return await this.tokenizer.ignore(e), this.parseHeader();
    }
    async parseHeader() {
        const e = await this.tokenizer.readToken(Gh);
        if (
            (this.metadata.setFormat("lossless", !0),
            this.metadata.setFormat("container", "Monkey's Audio"),
            this.metadata.setFormat("bitsPerSample", e.bitsPerSample),
            this.metadata.setFormat("sampleRate", e.sampleRate),
            this.metadata.setFormat("numberOfChannels", e.channel),
            this.metadata.setFormat("duration", im.calculateDuration(e)),
            !this.ape.descriptor)
        )
            throw new nm("Missing APE descriptor");
        return {
            forwardBytes:
                this.ape.descriptor.seekTableBytes +
                this.ape.descriptor.headerDataBytes +
                this.ape.descriptor.apeFrameDataBytes +
                this.ape.descriptor.terminatingDataBytes,
        };
    }
}
const sm = Object.freeze(
        Object.defineProperty(
            { __proto__: null, APEv2Parser: im, ApeContentError: nm, tryParseApeHeader: rm },
            Symbol.toStringTag,
            { value: "Module" }
        )
    ),
    am = Tu("music-metadata:parser:ID3v1"),
    om = [
        "Blues",
        "Classic Rock",
        "Country",
        "Dance",
        "Disco",
        "Funk",
        "Grunge",
        "Hip-Hop",
        "Jazz",
        "Metal",
        "New Age",
        "Oldies",
        "Other",
        "Pop",
        "R&B",
        "Rap",
        "Reggae",
        "Rock",
        "Techno",
        "Industrial",
        "Alternative",
        "Ska",
        "Death Metal",
        "Pranks",
        "Soundtrack",
        "Euro-Techno",
        "Ambient",
        "Trip-Hop",
        "Vocal",
        "Jazz+Funk",
        "Fusion",
        "Trance",
        "Classical",
        "Instrumental",
        "Acid",
        "House",
        "Game",
        "Sound Clip",
        "Gospel",
        "Noise",
        "Alt. Rock",
        "Bass",
        "Soul",
        "Punk",
        "Space",
        "Meditative",
        "Instrumental Pop",
        "Instrumental Rock",
        "Ethnic",
        "Gothic",
        "Darkwave",
        "Techno-Industrial",
        "Electronic",
        "Pop-Folk",
        "Eurodance",
        "Dream",
        "Southern Rock",
        "Comedy",
        "Cult",
        "Gangsta Rap",
        "Top 40",
        "Christian Rap",
        "Pop/Funk",
        "Jungle",
        "Native American",
        "Cabaret",
        "New Wave",
        "Psychedelic",
        "Rave",
        "Showtunes",
        "Trailer",
        "Lo-Fi",
        "Tribal",
        "Acid Punk",
        "Acid Jazz",
        "Polka",
        "Retro",
        "Musical",
        "Rock & Roll",
        "Hard Rock",
        "Folk",
        "Folk/Rock",
        "National Folk",
        "Swing",
        "Fast-Fusion",
        "Bebob",
        "Latin",
        "Revival",
        "Celtic",
        "Bluegrass",
        "Avantgarde",
        "Gothic Rock",
        "Progressive Rock",
        "Psychedelic Rock",
        "Symphonic Rock",
        "Slow Rock",
        "Big Band",
        "Chorus",
        "Easy Listening",
        "Acoustic",
        "Humour",
        "Speech",
        "Chanson",
        "Opera",
        "Chamber Music",
        "Sonata",
        "Symphony",
        "Booty Bass",
        "Primus",
        "Porn Groove",
        "Satire",
        "Slow Jam",
        "Club",
        "Tango",
        "Samba",
        "Folklore",
        "Ballad",
        "Power Ballad",
        "Rhythmic Soul",
        "Freestyle",
        "Duet",
        "Punk Rock",
        "Drum Solo",
        "A Cappella",
        "Euro-House",
        "Dance Hall",
        "Goa",
        "Drum & Bass",
        "Club-House",
        "Hardcore",
        "Terror",
        "Indie",
        "BritPop",
        "Negerpunk",
        "Polsk Punk",
        "Beat",
        "Christian Gangsta Rap",
        "Heavy Metal",
        "Black Metal",
        "Crossover",
        "Contemporary Christian",
        "Christian Rock",
        "Merengue",
        "Salsa",
        "Thrash Metal",
        "Anime",
        "JPop",
        "Synthpop",
        "Abstract",
        "Art Rock",
        "Baroque",
        "Bhangra",
        "Big Beat",
        "Breakbeat",
        "Chillout",
        "Downtempo",
        "Dub",
        "EBM",
        "Eclectic",
        "Electro",
        "Electroclash",
        "Emo",
        "Experimental",
        "Garage",
        "Global",
        "IDM",
        "Illbient",
        "Industro-Goth",
        "Jam Band",
        "Krautrock",
        "Leftfield",
        "Lounge",
        "Math Rock",
        "New Romantic",
        "Nu-Breakz",
        "Post-Punk",
        "Post-Rock",
        "Psytrance",
        "Shoegaze",
        "Space Rock",
        "Trop Rock",
        "World Music",
        "Neoclassical",
        "Audiobook",
        "Audio Theatre",
        "Neue Deutsche Welle",
        "Podcast",
        "Indie Rock",
        "G-Funk",
        "Dubstep",
        "Garage Rock",
        "Psybient",
    ],
    cm = {
        len: 128,
        get: (e, t) => {
            const n = new lm(3).get(e, t);
            return "TAG" === n
                ? {
                      header: n,
                      title: new lm(30).get(e, t + 3),
                      artist: new lm(30).get(e, t + 33),
                      album: new lm(30).get(e, t + 63),
                      year: new lm(4).get(e, t + 93),
                      comment: new lm(28).get(e, t + 97),
                      zeroByte: ol.get(e, t + 127),
                      track: ol.get(e, t + 126),
                      genre: ol.get(e, t + 127),
                  }
                : null;
        },
    };
class lm {
    constructor(e) {
        (this.len = e), (this.stringType = new Ml(e, "latin1"));
    }
    get(e, t) {
        let n = this.stringType.get(e, t);
        return (n = xd(n)), (n = n.trim()), n.length > 0 ? n : void 0;
    }
}
class um extends Uh {
    constructor(e, t, n) {
        super(e, t, n), (this.apeHeader = n.apeHeader);
    }
    static getGenre(e) {
        if (e < om.length) return om[e];
    }
    async parse() {
        if (!this.tokenizer.fileInfo.size) return void am("Skip checking for ID3v1 because the file-size is unknown");
        if (this.apeHeader) {
            this.tokenizer.ignore(this.apeHeader.offset - this.tokenizer.position);
            const e = new im(this.metadata, this.tokenizer, this.options);
            await e.parseTags(this.apeHeader.footer);
        }
        const e = this.tokenizer.fileInfo.size - cm.len;
        if (this.tokenizer.position > e) return void am("Already consumed the last 128 bytes");
        const t = await this.tokenizer.readToken(cm, e);
        if (t) {
            am("ID3v1 header found at: pos=%s", this.tokenizer.fileInfo.size - cm.len);
            const e = ["title", "artist", "album", "comment", "track", "year"];
            for (const r of e) t[r] && "" !== t[r] && (await this.addTag(r, t[r]));
            const n = um.getGenre(t.genre);
            n && (await this.addTag("genre", n));
        } else am("ID3v1 header not found at: pos=%s", this.tokenizer.fileInfo.size - cm.len);
    }
    async addTag(e, t) {
        await this.metadata.addTag("ID3v1", e, t);
    }
}
const dm = "LYRICS200";
async function hm(e, t, n = {}) {
    return (function (e, t) {
        return new zh().parse(e, void 0, t);
    })(nl(e, { fileInfo: t }), n);
}
function mm(e) {
    return e
        ? e.reduce((e, t) => (t.name && t.name.toLowerCase() in ["front", "cover", "cover (front)"] ? t : e))
        : null;
}
var pm = {};
function fm(e, t) {}
const gm = {};
const bm = "undefined" != typeof window;
let ym, wm;
{
    const e = bm && window.performance;
    e &&
        e.mark &&
        e.measure &&
        e.clearMarks &&
        e.clearMeasures &&
        ((ym = (t) => {
            e.mark(t);
        }),
        (wm = (t, n, r) => {
            e.measure(t, n, r), e.clearMarks(n), e.clearMarks(r);
        }));
}
const km = /\{([0-9a-zA-Z]+)\}/g;
function Tm(e, ...t) {
    return (
        1 === t.length && Lm(t[0]) && (t = t[0]),
        (t && t.hasOwnProperty) || (t = {}),
        e.replace(km, (e, n) => (t.hasOwnProperty(n) ? t[n] : ""))
    );
}
const _m = (e) =>
        JSON.stringify(e)
            .replace(/\u2028/g, "\\u2028")
            .replace(/\u2029/g, "\\u2029")
            .replace(/\u0027/g, "\\u0027"),
    vm = (e) => "number" == typeof e && isFinite(e),
    Sm = (e) => "[object RegExp]" === zm(e),
    Em = (e) => Um(e) && 0 === Object.keys(e).length,
    Cm = Object.assign,
    Im = Object.create,
    xm = (e = null) => Im(e);
function Am(e) {
    return e
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&apos;")
        .replace(/\//g, "&#x2F;")
        .replace(/=/g, "&#x3D;");
}
function Pm(e) {
    return e
        .replace(/&(?![a-zA-Z0-9#]{2,6};)/g, "&amp;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&apos;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
}
const Om = Object.prototype.hasOwnProperty;
function Nm(e, t) {
    return Om.call(e, t);
}
const Rm = Array.isArray,
    Mm = (e) => "function" == typeof e,
    Dm = (e) => "string" == typeof e,
    Fm = (e) => "boolean" == typeof e,
    Lm = (e) => null !== e && "object" == typeof e,
    Bm = Object.prototype.toString,
    zm = (e) => Bm.call(e),
    Um = (e) => "[object Object]" === zm(e);
function $m(e, t = "") {
    return e.reduce((e, n, r) => (0 === r ? e + n : e + t + n), "");
}
function Vm(e, t, n) {
    return { start: e, end: t };
}
const Wm = {
        EXPECTED_TOKEN: 1,
        INVALID_TOKEN_IN_PLACEHOLDER: 2,
        UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
        UNKNOWN_ESCAPE_SEQUENCE: 4,
        INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
        UNBALANCED_CLOSING_BRACE: 6,
        UNTERMINATED_CLOSING_BRACE: 7,
        EMPTY_PLACEHOLDER: 8,
        NOT_ALLOW_NEST_PLACEHOLDER: 9,
        INVALID_LINKED_FORMAT: 10,
        MUST_HAVE_MESSAGES_IN_PLURAL: 11,
        UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
        UNEXPECTED_EMPTY_LINKED_KEY: 13,
        UNEXPECTED_LEXICAL_ANALYSIS: 14,
        UNHANDLED_CODEGEN_NODE_TYPE: 15,
        UNHANDLED_MINIFIER_NODE_TYPE: 16,
    },
    jm = {
        [Wm.EXPECTED_TOKEN]: "Expected token: '{0}'",
        [Wm.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
        [Wm.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
        [Wm.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
        [Wm.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
        [Wm.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
        [Wm.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
        [Wm.EMPTY_PLACEHOLDER]: "Empty placeholder",
        [Wm.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
        [Wm.INVALID_LINKED_FORMAT]: "Invalid linked format",
        [Wm.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
        [Wm.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
        [Wm.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
        [Wm.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'",
        [Wm.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
        [Wm.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'",
    };
function Hm(e, t, n = {}) {
    const { domain: r, messages: i, args: s } = n,
        a = Tm((i || jm)[e] || "", ...(s || [])),
        o = new SyntaxError(String(a));
    return (o.code = e), t && (o.location = t), (o.domain = r), o;
}
function qm(e) {
    throw e;
}
const Xm = /<\/?[\w\s="/.':;#-\/]+>/,
    Gm = " ",
    Km = "\n",
    Ym = String.fromCharCode(8232),
    Qm = String.fromCharCode(8233);
function Jm(e) {
    const t = e;
    let n = 0,
        r = 1,
        i = 1,
        s = 0;
    const a = (e) => "\r" === t[e] && t[e + 1] === Km,
        o = (e) => t[e] === Qm,
        c = (e) => t[e] === Ym,
        l = (e) => a(e) || ((e) => t[e] === Km)(e) || o(e) || c(e),
        u = (e) => (a(e) || o(e) || c(e) ? Km : t[e]);
    function d() {
        return (s = 0), l(n) && (r++, (i = 0)), a(n) && n++, n++, i++, t[n];
    }
    return {
        index: () => n,
        line: () => r,
        column: () => i,
        peekOffset: () => s,
        charAt: u,
        currentChar: () => u(n),
        currentPeek: () => u(n + s),
        next: d,
        peek: function () {
            return a(n + s) && s++, s++, t[n + s];
        },
        reset: function () {
            (n = 0), (r = 1), (i = 1), (s = 0);
        },
        resetPeek: function (e = 0) {
            s = e;
        },
        skipToPeek: function () {
            const e = n + s;
            for (; e !== n; ) d();
            s = 0;
        },
    };
}
const Zm = void 0;
function ep(e, t = {}) {
    const n = !1 !== t.location,
        r = Jm(e),
        i = () => r.index(),
        s = () => {
            return (e = r.line()), (t = r.column()), (n = r.index()), { line: e, column: t, offset: n };
            var e, t, n;
        },
        a = s(),
        o = i(),
        c = {
            currentType: 13,
            offset: o,
            startLoc: a,
            endLoc: a,
            lastType: 13,
            lastOffset: o,
            lastStartLoc: a,
            lastEndLoc: a,
            braceNest: 0,
            inLinked: !1,
            text: "",
        },
        l = () => c,
        { onError: u } = t;
    function d(e, t, r, ...i) {
        const s = l();
        if (((t.column += r), (t.offset += r), u)) {
            const r = Hm(e, n ? Vm(s.startLoc, t) : null, { domain: "tokenizer", args: i });
            u(r);
        }
    }
    function h(e, t, r) {
        (e.endLoc = s()), (e.currentType = t);
        const i = { type: t };
        return n && (i.loc = Vm(e.startLoc, e.endLoc)), null != r && (i.value = r), i;
    }
    const m = (e) => h(e, 13);
    function p(e, t) {
        return e.currentChar() === t ? (e.next(), t) : (d(Wm.EXPECTED_TOKEN, s(), 0, t), "");
    }
    function f(e) {
        let t = "";
        for (; e.currentPeek() === Gm || e.currentPeek() === Km; ) (t += e.currentPeek()), e.peek();
        return t;
    }
    function g(e) {
        const t = f(e);
        return e.skipToPeek(), t;
    }
    function b(e) {
        if (e === Zm) return !1;
        const t = e.charCodeAt(0);
        return (t >= 97 && t <= 122) || (t >= 65 && t <= 90) || 95 === t;
    }
    function y(e, t) {
        const { currentType: n } = t;
        if (2 !== n) return !1;
        f(e);
        const r = (function (e) {
            if (e === Zm) return !1;
            const t = e.charCodeAt(0);
            return t >= 48 && t <= 57;
        })("-" === e.currentPeek() ? e.peek() : e.currentPeek());
        return e.resetPeek(), r;
    }
    function w(e) {
        f(e);
        const t = "|" === e.currentPeek();
        return e.resetPeek(), t;
    }
    function k(e, t = !0) {
        const n = (t = !1, r = "") => {
                const i = e.currentPeek();
                return "{" === i
                    ? t
                    : "@" !== i && i
                      ? "|" === i
                          ? !(r === Gm || r === Km)
                          : i === Gm
                            ? (e.peek(), n(!0, Gm))
                            : i !== Km || (e.peek(), n(!0, Km))
                      : t;
            },
            r = n();
        return t && e.resetPeek(), r;
    }
    function T(e, t) {
        const n = e.currentChar();
        return n === Zm ? Zm : t(n) ? (e.next(), n) : null;
    }
    function _(e) {
        const t = e.charCodeAt(0);
        return (t >= 97 && t <= 122) || (t >= 65 && t <= 90) || (t >= 48 && t <= 57) || 95 === t || 36 === t;
    }
    function v(e) {
        return T(e, _);
    }
    function S(e) {
        const t = e.charCodeAt(0);
        return (
            (t >= 97 && t <= 122) || (t >= 65 && t <= 90) || (t >= 48 && t <= 57) || 95 === t || 36 === t || 45 === t
        );
    }
    function E(e) {
        return T(e, S);
    }
    function C(e) {
        const t = e.charCodeAt(0);
        return t >= 48 && t <= 57;
    }
    function I(e) {
        return T(e, C);
    }
    function x(e) {
        const t = e.charCodeAt(0);
        return (t >= 48 && t <= 57) || (t >= 65 && t <= 70) || (t >= 97 && t <= 102);
    }
    function A(e) {
        return T(e, x);
    }
    function P(e) {
        let t = "",
            n = "";
        for (; (t = I(e)); ) n += t;
        return n;
    }
    function O(e) {
        return "'" !== e && e !== Km;
    }
    function N(e) {
        const t = e.currentChar();
        switch (t) {
            case "\\":
            case "'":
                return e.next(), `\\${t}`;
            case "u":
                return R(e, t, 4);
            case "U":
                return R(e, t, 6);
            default:
                return d(Wm.UNKNOWN_ESCAPE_SEQUENCE, s(), 0, t), "";
        }
    }
    function R(e, t, n) {
        p(e, t);
        let r = "";
        for (let i = 0; i < n; i++) {
            const n = A(e);
            if (!n) {
                d(Wm.INVALID_UNICODE_ESCAPE_SEQUENCE, s(), 0, `\\${t}${r}${e.currentChar()}`);
                break;
            }
            r += n;
        }
        return `\\${t}${r}`;
    }
    function M(e) {
        return "{" !== e && "}" !== e && e !== Gm && e !== Km;
    }
    function D(e) {
        g(e);
        const t = p(e, "|");
        return g(e), t;
    }
    function F(e, t) {
        let n = null;
        switch (e.currentChar()) {
            case "{":
                return (
                    t.braceNest >= 1 && d(Wm.NOT_ALLOW_NEST_PLACEHOLDER, s(), 0),
                    e.next(),
                    (n = h(t, 2, "{")),
                    g(e),
                    t.braceNest++,
                    n
                );
            case "}":
                return (
                    t.braceNest > 0 && 2 === t.currentType && d(Wm.EMPTY_PLACEHOLDER, s(), 0),
                    e.next(),
                    (n = h(t, 3, "}")),
                    t.braceNest--,
                    t.braceNest > 0 && g(e),
                    t.inLinked && 0 === t.braceNest && (t.inLinked = !1),
                    n
                );
            case "@":
                return (
                    t.braceNest > 0 && d(Wm.UNTERMINATED_CLOSING_BRACE, s(), 0),
                    (n = L(e, t) || m(t)),
                    (t.braceNest = 0),
                    n
                );
            default: {
                let r = !0,
                    i = !0,
                    a = !0;
                if (w(e))
                    return (
                        t.braceNest > 0 && d(Wm.UNTERMINATED_CLOSING_BRACE, s(), 0),
                        (n = h(t, 1, D(e))),
                        (t.braceNest = 0),
                        (t.inLinked = !1),
                        n
                    );
                if (t.braceNest > 0 && (4 === t.currentType || 5 === t.currentType || 6 === t.currentType))
                    return d(Wm.UNTERMINATED_CLOSING_BRACE, s(), 0), (t.braceNest = 0), B(e, t);
                if (
                    (r = (function (e, t) {
                        const { currentType: n } = t;
                        if (2 !== n) return !1;
                        f(e);
                        const r = b(e.currentPeek());
                        return e.resetPeek(), r;
                    })(e, t))
                )
                    return (
                        (n = h(
                            t,
                            4,
                            (function (e) {
                                g(e);
                                let t = "",
                                    n = "";
                                for (; (t = E(e)); ) n += t;
                                return e.currentChar() === Zm && d(Wm.UNTERMINATED_CLOSING_BRACE, s(), 0), n;
                            })(e)
                        )),
                        g(e),
                        n
                    );
                if ((i = y(e, t)))
                    return (
                        (n = h(
                            t,
                            5,
                            (function (e) {
                                g(e);
                                let t = "";
                                return (
                                    "-" === e.currentChar() ? (e.next(), (t += `-${P(e)}`)) : (t += P(e)),
                                    e.currentChar() === Zm && d(Wm.UNTERMINATED_CLOSING_BRACE, s(), 0),
                                    t
                                );
                            })(e)
                        )),
                        g(e),
                        n
                    );
                if (
                    (a = (function (e, t) {
                        const { currentType: n } = t;
                        if (2 !== n) return !1;
                        f(e);
                        const r = "'" === e.currentPeek();
                        return e.resetPeek(), r;
                    })(e, t))
                )
                    return (
                        (n = h(
                            t,
                            6,
                            (function (e) {
                                g(e), p(e, "'");
                                let t = "",
                                    n = "";
                                for (; (t = T(e, O)); ) n += "\\" === t ? N(e) : t;
                                const r = e.currentChar();
                                return r === Km || r === Zm
                                    ? (d(Wm.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, s(), 0),
                                      r === Km && (e.next(), p(e, "'")),
                                      n)
                                    : (p(e, "'"), n);
                            })(e)
                        )),
                        g(e),
                        n
                    );
                if (!r && !i && !a)
                    return (
                        (n = h(
                            t,
                            12,
                            (function (e) {
                                g(e);
                                let t = "",
                                    n = "";
                                for (; (t = T(e, M)); ) n += t;
                                return n;
                            })(e)
                        )),
                        d(Wm.INVALID_TOKEN_IN_PLACEHOLDER, s(), 0, n.value),
                        g(e),
                        n
                    );
                break;
            }
        }
        return n;
    }
    function L(e, t) {
        const { currentType: n } = t;
        let r = null;
        const i = e.currentChar();
        switch (
            ((7 !== n && 8 !== n && 11 !== n && 9 !== n) ||
                (i !== Km && i !== Gm) ||
                d(Wm.INVALID_LINKED_FORMAT, s(), 0),
            i)
        ) {
            case "@":
                return e.next(), (r = h(t, 7, "@")), (t.inLinked = !0), r;
            case ".":
                return g(e), e.next(), h(t, 8, ".");
            case ":":
                return g(e), e.next(), h(t, 9, ":");
            default:
                return w(e)
                    ? ((r = h(t, 1, D(e))), (t.braceNest = 0), (t.inLinked = !1), r)
                    : (function (e, t) {
                            const { currentType: n } = t;
                            if (7 !== n) return !1;
                            f(e);
                            const r = "." === e.currentPeek();
                            return e.resetPeek(), r;
                        })(e, t) ||
                        (function (e, t) {
                            const { currentType: n } = t;
                            if (7 !== n && 11 !== n) return !1;
                            f(e);
                            const r = ":" === e.currentPeek();
                            return e.resetPeek(), r;
                        })(e, t)
                      ? (g(e), L(e, t))
                      : (function (e, t) {
                              const { currentType: n } = t;
                              if (8 !== n) return !1;
                              f(e);
                              const r = b(e.currentPeek());
                              return e.resetPeek(), r;
                          })(e, t)
                        ? (g(e),
                          h(
                              t,
                              11,
                              (function (e) {
                                  let t = "",
                                      n = "";
                                  for (; (t = v(e)); ) n += t;
                                  return n;
                              })(e)
                          ))
                        : (function (e, t) {
                                const { currentType: n } = t;
                                if (9 !== n) return !1;
                                const r = () => {
                                        const t = e.currentPeek();
                                        return "{" === t
                                            ? b(e.peek())
                                            : !("@" === t || "|" === t || ":" === t || "." === t || t === Gm || !t) &&
                                                  (t === Km ? (e.peek(), r()) : k(e, !1));
                                    },
                                    i = r();
                                return e.resetPeek(), i;
                            })(e, t)
                          ? (g(e),
                            "{" === i
                                ? F(e, t) || r
                                : h(
                                      t,
                                      10,
                                      (function (e) {
                                          const t = (n) => {
                                              const r = e.currentChar();
                                              return "{" !== r && "@" !== r && "|" !== r && "(" !== r && ")" !== r && r
                                                  ? r === Gm
                                                      ? n
                                                      : ((n += r), e.next(), t(n))
                                                  : n;
                                          };
                                          return t("");
                                      })(e)
                                  ))
                          : (7 === n && d(Wm.INVALID_LINKED_FORMAT, s(), 0),
                            (t.braceNest = 0),
                            (t.inLinked = !1),
                            B(e, t));
        }
    }
    function B(e, t) {
        let n = { type: 13 };
        if (t.braceNest > 0) return F(e, t) || m(t);
        if (t.inLinked) return L(e, t) || m(t);
        switch (e.currentChar()) {
            case "{":
                return F(e, t) || m(t);
            case "}":
                return d(Wm.UNBALANCED_CLOSING_BRACE, s(), 0), e.next(), h(t, 3, "}");
            case "@":
                return L(e, t) || m(t);
            default:
                if (w(e)) return (n = h(t, 1, D(e))), (t.braceNest = 0), (t.inLinked = !1), n;
                if (k(e))
                    return h(
                        t,
                        0,
                        (function (e) {
                            let t = "";
                            for (;;) {
                                const n = e.currentChar();
                                if ("{" === n || "}" === n || "@" === n || "|" === n || !n) break;
                                if (n === Gm || n === Km)
                                    if (k(e)) (t += n), e.next();
                                    else {
                                        if (w(e)) break;
                                        (t += n), e.next();
                                    }
                                else (t += n), e.next();
                            }
                            return t;
                        })(e)
                    );
        }
        return n;
    }
    return {
        nextToken: function () {
            const { currentType: e, offset: t, startLoc: n, endLoc: a } = c;
            return (
                (c.lastType = e),
                (c.lastOffset = t),
                (c.lastStartLoc = n),
                (c.lastEndLoc = a),
                (c.offset = i()),
                (c.startLoc = s()),
                r.currentChar() === Zm ? h(c, 13) : B(r, c)
            );
        },
        currentOffset: i,
        currentPosition: s,
        context: l,
    };
}
const tp = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function np(e, t, n) {
    switch (e) {
        case "\\\\":
            return "\\";
        case "\\'":
            return "'";
        default: {
            const e = parseInt(t || n, 16);
            return e <= 55295 || e >= 57344 ? String.fromCodePoint(e) : "";
        }
    }
}
function rp(e = {}) {
    const t = !1 !== e.location,
        { onError: n } = e;
    function r(e, r, i, s, ...a) {
        const o = e.currentPosition();
        if (((o.offset += s), (o.column += s), n)) {
            const e = Hm(r, t ? Vm(i, o) : null, { domain: "parser", args: a });
            n(e);
        }
    }
    function i(e, n, r) {
        const i = { type: e };
        return t && ((i.start = n), (i.end = n), (i.loc = { start: r, end: r })), i;
    }
    function s(e, n, r, i) {
        t && ((e.end = n), e.loc && (e.loc.end = r));
    }
    function a(e, t) {
        const n = e.context(),
            r = i(3, n.offset, n.startLoc);
        return (r.value = t), s(r, e.currentOffset(), e.currentPosition()), r;
    }
    function o(e, t) {
        const n = e.context(),
            { lastOffset: r, lastStartLoc: a } = n,
            o = i(5, r, a);
        return (o.index = parseInt(t, 10)), e.nextToken(), s(o, e.currentOffset(), e.currentPosition()), o;
    }
    function c(e, t) {
        const n = e.context(),
            { lastOffset: r, lastStartLoc: a } = n,
            o = i(4, r, a);
        return (o.key = t), e.nextToken(), s(o, e.currentOffset(), e.currentPosition()), o;
    }
    function l(e, t) {
        const n = e.context(),
            { lastOffset: r, lastStartLoc: a } = n,
            o = i(9, r, a);
        return (o.value = t.replace(tp, np)), e.nextToken(), s(o, e.currentOffset(), e.currentPosition()), o;
    }
    function u(e) {
        const t = e.context(),
            n = i(6, t.offset, t.startLoc);
        let a = e.nextToken();
        if (8 === a.type) {
            const t = (function (e) {
                const t = e.nextToken(),
                    n = e.context(),
                    { lastOffset: a, lastStartLoc: o } = n,
                    c = i(8, a, o);
                return 11 !== t.type
                    ? (r(e, Wm.UNEXPECTED_EMPTY_LINKED_MODIFIER, n.lastStartLoc, 0),
                      (c.value = ""),
                      s(c, a, o),
                      { nextConsumeToken: t, node: c })
                    : (null == t.value && r(e, Wm.UNEXPECTED_LEXICAL_ANALYSIS, n.lastStartLoc, 0, ip(t)),
                      (c.value = t.value || ""),
                      s(c, e.currentOffset(), e.currentPosition()),
                      { node: c });
            })(e);
            (n.modifier = t.node), (a = t.nextConsumeToken || e.nextToken());
        }
        switch (
            (9 !== a.type && r(e, Wm.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, 0, ip(a)),
            (a = e.nextToken()),
            2 === a.type && (a = e.nextToken()),
            a.type)
        ) {
            case 10:
                null == a.value && r(e, Wm.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, 0, ip(a)),
                    (n.key = (function (e, t) {
                        const n = e.context(),
                            r = i(7, n.offset, n.startLoc);
                        return (r.value = t), s(r, e.currentOffset(), e.currentPosition()), r;
                    })(e, a.value || ""));
                break;
            case 4:
                null == a.value && r(e, Wm.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, 0, ip(a)),
                    (n.key = c(e, a.value || ""));
                break;
            case 5:
                null == a.value && r(e, Wm.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, 0, ip(a)),
                    (n.key = o(e, a.value || ""));
                break;
            case 6:
                null == a.value && r(e, Wm.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, 0, ip(a)),
                    (n.key = l(e, a.value || ""));
                break;
            default: {
                r(e, Wm.UNEXPECTED_EMPTY_LINKED_KEY, t.lastStartLoc, 0);
                const o = e.context(),
                    c = i(7, o.offset, o.startLoc);
                return (
                    (c.value = ""),
                    s(c, o.offset, o.startLoc),
                    (n.key = c),
                    s(n, o.offset, o.startLoc),
                    { nextConsumeToken: a, node: n }
                );
            }
        }
        return s(n, e.currentOffset(), e.currentPosition()), { node: n };
    }
    function d(e) {
        const t = e.context(),
            n = i(2, 1 === t.currentType ? e.currentOffset() : t.offset, 1 === t.currentType ? t.endLoc : t.startLoc);
        n.items = [];
        let d = null;
        do {
            const i = d || e.nextToken();
            switch (((d = null), i.type)) {
                case 0:
                    null == i.value && r(e, Wm.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, 0, ip(i)),
                        n.items.push(a(e, i.value || ""));
                    break;
                case 5:
                    null == i.value && r(e, Wm.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, 0, ip(i)),
                        n.items.push(o(e, i.value || ""));
                    break;
                case 4:
                    null == i.value && r(e, Wm.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, 0, ip(i)),
                        n.items.push(c(e, i.value || ""));
                    break;
                case 6:
                    null == i.value && r(e, Wm.UNEXPECTED_LEXICAL_ANALYSIS, t.lastStartLoc, 0, ip(i)),
                        n.items.push(l(e, i.value || ""));
                    break;
                case 7: {
                    const t = u(e);
                    n.items.push(t.node), (d = t.nextConsumeToken || null);
                    break;
                }
            }
        } while (13 !== t.currentType && 1 !== t.currentType);
        return (
            s(
                n,
                1 === t.currentType ? t.lastOffset : e.currentOffset(),
                1 === t.currentType ? t.lastEndLoc : e.currentPosition()
            ),
            n
        );
    }
    function h(e) {
        const t = e.context(),
            { offset: n, startLoc: a } = t,
            o = d(e);
        return 13 === t.currentType
            ? o
            : (function (e, t, n, a) {
                  const o = e.context();
                  let c = 0 === a.items.length;
                  const l = i(1, t, n);
                  (l.cases = []), l.cases.push(a);
                  do {
                      const t = d(e);
                      c || (c = 0 === t.items.length), l.cases.push(t);
                  } while (13 !== o.currentType);
                  return (
                      c && r(e, Wm.MUST_HAVE_MESSAGES_IN_PLURAL, n, 0), s(l, e.currentOffset(), e.currentPosition()), l
                  );
              })(e, n, a, o);
    }
    return {
        parse: function (n) {
            const a = ep(n, Cm({}, e)),
                o = a.context(),
                c = i(0, o.offset, o.startLoc);
            return (
                t && c.loc && (c.loc.source = n),
                (c.body = h(a)),
                e.onCacheKey && (c.cacheKey = e.onCacheKey(n)),
                13 !== o.currentType && r(a, Wm.UNEXPECTED_LEXICAL_ANALYSIS, o.lastStartLoc, 0, n[o.offset] || ""),
                s(c, a.currentOffset(), a.currentPosition()),
                c
            );
        },
    };
}
function ip(e) {
    if (13 === e.type) return "EOF";
    const t = (e.value || "").replace(/\r?\n/gu, "\\n");
    return t.length > 10 ? t.slice(0, 9) + "" : t;
}
function sp(e, t) {
    for (let n = 0; n < e.length; n++) ap(e[n], t);
}
function ap(e, t) {
    switch (e.type) {
        case 1:
            sp(e.cases, t), t.helper("plural");
            break;
        case 2:
            sp(e.items, t);
            break;
        case 6:
            ap(e.key, t), t.helper("linked"), t.helper("type");
            break;
        case 5:
            t.helper("interpolate"), t.helper("list");
            break;
        case 4:
            t.helper("interpolate"), t.helper("named");
    }
}
function op(e, t = {}) {
    const n = (function (e) {
        const t = { ast: e, helpers: new Set() };
        return { context: () => t, helper: (e) => (t.helpers.add(e), e) };
    })(e);
    n.helper("normalize"), e.body && ap(e.body, n);
    const r = n.context();
    e.helpers = Array.from(r.helpers);
}
function cp(e) {
    if (1 === e.items.length) {
        const t = e.items[0];
        (3 !== t.type && 9 !== t.type) || ((e.static = t.value), delete t.value);
    } else {
        const t = [];
        for (let n = 0; n < e.items.length; n++) {
            const r = e.items[n];
            if (3 !== r.type && 9 !== r.type) break;
            if (null == r.value) break;
            t.push(r.value);
        }
        if (t.length === e.items.length) {
            e.static = $m(t);
            for (let t = 0; t < e.items.length; t++) {
                const n = e.items[t];
                (3 !== n.type && 9 !== n.type) || delete n.value;
            }
        }
    }
}
function lp(e) {
    switch (((e.t = e.type), e.type)) {
        case 0: {
            const t = e;
            lp(t.body), (t.b = t.body), delete t.body;
            break;
        }
        case 1: {
            const t = e,
                n = t.cases;
            for (let e = 0; e < n.length; e++) lp(n[e]);
            (t.c = n), delete t.cases;
            break;
        }
        case 2: {
            const t = e,
                n = t.items;
            for (let e = 0; e < n.length; e++) lp(n[e]);
            (t.i = n), delete t.items, t.static && ((t.s = t.static), delete t.static);
            break;
        }
        case 3:
        case 9:
        case 8:
        case 7: {
            const t = e;
            t.value && ((t.v = t.value), delete t.value);
            break;
        }
        case 6: {
            const t = e;
            lp(t.key),
                (t.k = t.key),
                delete t.key,
                t.modifier && (lp(t.modifier), (t.m = t.modifier), delete t.modifier);
            break;
        }
        case 5: {
            const t = e;
            (t.i = t.index), delete t.index;
            break;
        }
        case 4: {
            const t = e;
            (t.k = t.key), delete t.key;
            break;
        }
        default:
            throw Hm(Wm.UNHANDLED_MINIFIER_NODE_TYPE, null, { domain: "minifier", args: [e.type] });
    }
    delete e.type;
}
function up(e, t) {
    const { helper: n } = e;
    switch (t.type) {
        case 0:
            !(function (e, t) {
                t.body ? up(e, t.body) : e.push("null");
            })(e, t);
            break;
        case 1:
            !(function (e, t) {
                const { helper: n, needIndent: r } = e;
                if (t.cases.length > 1) {
                    e.push(`${n("plural")}([`), e.indent(r());
                    const i = t.cases.length;
                    for (let n = 0; n < i && (up(e, t.cases[n]), n !== i - 1); n++) e.push(", ");
                    e.deindent(r()), e.push("])");
                }
            })(e, t);
            break;
        case 2:
            !(function (e, t) {
                const { helper: n, needIndent: r } = e;
                e.push(`${n("normalize")}([`), e.indent(r());
                const i = t.items.length;
                for (let s = 0; s < i && (up(e, t.items[s]), s !== i - 1); s++) e.push(", ");
                e.deindent(r()), e.push("])");
            })(e, t);
            break;
        case 6:
            !(function (e, t) {
                const { helper: n } = e;
                e.push(`${n("linked")}(`),
                    up(e, t.key),
                    t.modifier ? (e.push(", "), up(e, t.modifier), e.push(", _type")) : e.push(", undefined, _type"),
                    e.push(")");
            })(e, t);
            break;
        case 8:
        case 7:
        case 9:
        case 3:
            e.push(JSON.stringify(t.value), t);
            break;
        case 5:
            e.push(`${n("interpolate")}(${n("list")}(${t.index}))`, t);
            break;
        case 4:
            e.push(`${n("interpolate")}(${n("named")}(${JSON.stringify(t.key)}))`, t);
            break;
        default:
            throw Hm(Wm.UNHANDLED_CODEGEN_NODE_TYPE, null, { domain: "parser", args: [t.type] });
    }
}
function dp(e, t = {}) {
    const n = Cm({}, t),
        r = !!n.jit,
        i = !!n.minify,
        s = null == n.optimize || n.optimize,
        a = rp(n).parse(e);
    return r
        ? (s &&
              (function (e) {
                  const t = e.body;
                  2 === t.type ? cp(t) : t.cases.forEach((e) => cp(e));
              })(a),
          i && lp(a),
          { ast: a, code: "" })
        : (op(a, n),
          ((e, t = {}) => {
              const n = Dm(t.mode) ? t.mode : "normal",
                  r = Dm(t.filename) ? t.filename : "message.intl";
              t.sourceMap;
              const i = null != t.breakLineCode ? t.breakLineCode : "arrow" === n ? ";" : "\n",
                  s = t.needIndent ? t.needIndent : "arrow" !== n,
                  a = e.helpers || [],
                  o = (function (e, t) {
                      const { filename: n, breakLineCode: r, needIndent: i } = t,
                          s = !1 !== t.location,
                          a = {
                              filename: n,
                              code: "",
                              column: 1,
                              line: 1,
                              offset: 0,
                              map: void 0,
                              breakLineCode: r,
                              needIndent: i,
                              indentLevel: 0,
                          };
                      function o(e, t) {
                          a.code += e;
                      }
                      function c(e, t = !0) {
                          const n = t ? r : "";
                          o(i ? n + "  ".repeat(e) : n);
                      }
                      return (
                          s && e.loc && (a.source = e.loc.source),
                          {
                              context: () => a,
                              push: o,
                              indent: function (e = !0) {
                                  const t = ++a.indentLevel;
                                  e && c(t);
                              },
                              deindent: function (e = !0) {
                                  const t = --a.indentLevel;
                                  e && c(t);
                              },
                              newline: function () {
                                  c(a.indentLevel);
                              },
                              helper: (e) => `_${e}`,
                              needIndent: () => a.needIndent,
                          }
                      );
                  })(e, { filename: r, breakLineCode: i, needIndent: s });
              o.push("normal" === n ? "function __msg__ (ctx) {" : "(ctx) => {"),
                  o.indent(s),
                  a.length > 0 &&
                      (o.push(
                          `const { ${$m(
                              a.map((e) => `${e}: _${e}`),
                              ", "
                          )} } = ctx`
                      ),
                      o.newline()),
                  o.push("return "),
                  up(o, e),
                  o.deindent(s),
                  o.push("}"),
                  delete e.helpers;
              const { code: c, map: l } = o.context();
              return { ast: e, code: c, map: l ? l.toJSON() : void 0 };
          })(a, n));
}
function hp(e) {
    return Lm(e) && 0 === yp(e) && (Nm(e, "b") || Nm(e, "body"));
}
const mp = ["b", "body"];
const pp = ["c", "cases"];
const fp = ["s", "static"];
const gp = ["i", "items"];
const bp = ["t", "type"];
function yp(e) {
    return vp(e, bp);
}
const wp = ["v", "value"];
function kp(e, t) {
    const n = vp(e, wp);
    if (null != n) return n;
    throw Ep(t);
}
const Tp = ["m", "modifier"];
const _p = ["k", "key"];
function vp(e, t, n) {
    for (let r = 0; r < t.length; r++) {
        const n = t[r];
        if (Nm(e, n) && null != e[n]) return e[n];
    }
    return n;
}
const Sp = [...mp, ...pp, ...fp, ...gp, ..._p, ...Tp, ...wp, ...bp];
function Ep(e) {
    return new Error(`unhandled node type: ${e}`);
}
function Cp(e) {
    return (t) =>
        (function (e, t) {
            const n = ((r = t), vp(r, mp));
            var r;
            if (null == n) throw Ep(0);
            if (1 === yp(n)) {
                const t = (function (e) {
                    return vp(e, pp, []);
                })(n);
                return e.plural(t.reduce((t, n) => [...t, Ip(e, n)], []));
            }
            return Ip(e, n);
        })(t, e);
}
function Ip(e, t) {
    const n = (function (e) {
        return vp(e, fp);
    })(t);
    if (null != n) return "text" === e.type ? n : e.normalize([n]);
    {
        const n = (function (e) {
            return vp(e, gp, []);
        })(t).reduce((t, n) => [...t, xp(e, n)], []);
        return e.normalize(n);
    }
}
function xp(e, t) {
    const n = yp(t);
    switch (n) {
        case 3:
        case 9:
        case 7:
        case 8:
            return kp(t, n);
        case 4: {
            const r = t;
            if (Nm(r, "k") && r.k) return e.interpolate(e.named(r.k));
            if (Nm(r, "key") && r.key) return e.interpolate(e.named(r.key));
            throw Ep(n);
        }
        case 5: {
            const r = t;
            if (Nm(r, "i") && vm(r.i)) return e.interpolate(e.list(r.i));
            if (Nm(r, "index") && vm(r.index)) return e.interpolate(e.list(r.index));
            throw Ep(n);
        }
        case 6: {
            const n = t,
                r = (function (e) {
                    return vp(e, Tp);
                })(n),
                i = (function (e) {
                    const t = vp(e, _p);
                    if (t) return t;
                    throw Ep(6);
                })(n);
            return e.linked(xp(e, i), r ? xp(e, r) : void 0, e.type);
        }
        default:
            throw new Error(`unhandled node on format message part: ${n}`);
    }
}
function Ap(e, t) {
    t &&
        ((e) => Xm.test(e))(e) &&
        Tm("Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.", { source: e });
}
const Pp = (e) => e;
let Op = xm();
let Np = null;
function Rp(e, t, n) {
    Np && Np.emit("i18n:init", { timestamp: Date.now(), i18n: e, version: t, meta: n });
}
const Mp = Dp("function:translate");
function Dp(e) {
    return (t) => Np && Np.emit(e, t);
}
const Fp = {
    INVALID_ARGUMENT: 17,
    INVALID_DATE_ARGUMENT: 18,
    INVALID_ISO_DATE_ARGUMENT: 19,
    NOT_SUPPORT_NON_STRING_MESSAGE: 20,
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
    NOT_SUPPORT_LOCALE_TYPE: 23,
};
function Lp(e) {
    return Hm(e, null, { messages: Bp });
}
const Bp = {
    [Fp.INVALID_ARGUMENT]: "Invalid arguments",
    [Fp.INVALID_DATE_ARGUMENT]:
        "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
    [Fp.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
    [Fp.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
    [Fp.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
    [Fp.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
    [Fp.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type",
};
function zp(e, t) {
    return null != t.locale ? $p(t.locale) : $p(e.locale);
}
let Up;
function $p(e) {
    if (Dm(e)) return e;
    if (Mm(e)) {
        if (e.resolvedOnce && null != Up) return Up;
        if ("Function" === e.constructor.name) {
            const n = e();
            if (Lm((t = n)) && Mm(t.then) && Mm(t.catch)) throw Lp(Fp.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
            return (Up = n);
        }
        throw Lp(Fp.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
    }
    throw Lp(Fp.NOT_SUPPORT_LOCALE_TYPE);
    var t;
}
function Vp(e, t, n) {
    return [...new Set([n, ...(Rm(t) ? t : Lm(t) ? Object.keys(t) : Dm(t) ? [t] : [n])])];
}
function Wp(e, t, n) {
    let r = !0;
    for (let i = 0; i < t.length && Fm(r); i++) {
        const s = t[i];
        Dm(s) && (r = jp(e, t[i], n));
    }
    return r;
}
function jp(e, t, n) {
    let r;
    const i = t.split("-");
    do {
        (r = Hp(e, i.join("-"), n)), i.splice(-1, 1);
    } while (i.length && !0 === r);
    return r;
}
function Hp(e, t, n) {
    let r = !1;
    if (!e.includes(t) && ((r = !0), t)) {
        r = "!" !== t[t.length - 1];
        const i = t.replace(/!/g, "");
        e.push(i), (Rm(n) || Um(n)) && n[i] && (r = n[i]);
    }
    return r;
}
const qp = [];
(qp[0] = { w: [0], i: [3, 0], "[": [4], o: [7] }),
    (qp[1] = { w: [1], ".": [2], "[": [4], o: [7] }),
    (qp[2] = { w: [2], i: [3, 0], 0: [3, 0] }),
    (qp[3] = { i: [3, 0], 0: [3, 0], w: [1, 1], ".": [2, 1], "[": [4, 1], o: [7, 1] }),
    (qp[4] = { "'": [5, 0], '"': [6, 0], "[": [4, 2], "]": [1, 3], o: 8, l: [4, 0] }),
    (qp[5] = { "'": [4, 0], o: 8, l: [5, 0] }),
    (qp[6] = { '"': [4, 0], o: 8, l: [6, 0] });
const Xp = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function Gp(e) {
    if (null == e) return "o";
    switch (e.charCodeAt(0)) {
        case 91:
        case 93:
        case 46:
        case 34:
        case 39:
            return e;
        case 95:
        case 36:
        case 45:
            return "i";
        case 9:
        case 10:
        case 13:
        case 160:
        case 65279:
        case 8232:
        case 8233:
            return "w";
    }
    return "i";
}
function Kp(e) {
    const t = e.trim();
    return (
        ("0" !== e.charAt(0) || !isNaN(parseInt(e))) &&
        ((n = t),
        Xp.test(n)
            ? (function (e) {
                  const t = e.charCodeAt(0);
                  return t !== e.charCodeAt(e.length - 1) || (34 !== t && 39 !== t) ? e : e.slice(1, -1);
              })(t)
            : "*" + t)
    );
    var n;
}
function Yp(e) {
    const t = [];
    let n,
        r,
        i,
        s,
        a,
        o,
        c,
        l = -1,
        u = 0,
        d = 0;
    const h = [];
    function m() {
        const t = e[l + 1];
        if ((5 === u && "'" === t) || (6 === u && '"' === t)) return l++, (i = "\\" + t), h[0](), !0;
    }
    for (
        h[0] = () => {
            void 0 === r ? (r = i) : (r += i);
        },
            h[1] = () => {
                void 0 !== r && (t.push(r), (r = void 0));
            },
            h[2] = () => {
                h[0](), d++;
            },
            h[3] = () => {
                if (d > 0) d--, (u = 4), h[0]();
                else {
                    if (((d = 0), void 0 === r)) return !1;
                    if (((r = Kp(r)), !1 === r)) return !1;
                    h[1]();
                }
            };
        null !== u;

    )
        if ((l++, (n = e[l]), "\\" !== n || !m())) {
            if (((s = Gp(n)), (c = qp[u]), (a = c[s] || c.l || 8), 8 === a)) return;
            if (((u = a[0]), void 0 !== a[1] && ((o = h[a[1]]), o && ((i = n), !1 === o())))) return;
            if (7 === u) return t;
        }
}
const Qp = new Map();
function Jp(e, t) {
    return Lm(e) ? e[t] : null;
}
const Zp = {
        NOT_FOUND_KEY: 1,
        FALLBACK_TO_TRANSLATE: 2,
        CANNOT_FORMAT_NUMBER: 3,
        FALLBACK_TO_NUMBER_FORMAT: 4,
        CANNOT_FORMAT_DATE: 5,
        FALLBACK_TO_DATE_FORMAT: 6,
        EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: 7,
    },
    ef = {
        [Zp.NOT_FOUND_KEY]: "Not found '{key}' key in '{locale}' locale messages.",
        [Zp.FALLBACK_TO_TRANSLATE]: "Fall back to translate '{key}' key with '{target}' locale.",
        [Zp.CANNOT_FORMAT_NUMBER]: "Cannot format a number value due to not supported Intl.NumberFormat.",
        [Zp.FALLBACK_TO_NUMBER_FORMAT]: "Fall back to number format '{key}' key with '{target}' locale.",
        [Zp.CANNOT_FORMAT_DATE]: "Cannot format a date value due to not supported Intl.DateTimeFormat.",
        [Zp.FALLBACK_TO_DATE_FORMAT]: "Fall back to datetime format '{key}' key with '{target}' locale.",
        [Zp.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]:
            "This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future.",
    };
function tf(e, ...t) {
    return Tm(ef[e], ...t);
}
const nf = "11.1.11",
    rf = "en-US",
    sf = (e) => `${e.charAt(0).toLocaleUpperCase()}${e.substr(1)}`;
let af, of, cf;
let lf = null;
const uf = () => lf;
let df = null;
let hf = 0;
const mf = (e) => ({ [e]: xm() });
function pf(e, t) {
    return e instanceof RegExp ? e.test(t) : e;
}
function ff(e, t) {
    return e instanceof RegExp ? e.test(t) : e;
}
function gf(e, t, n, r, i) {
    const { missing: s, onWarn: a } = e;
    {
        const r = e.__v_emitter;
        r && r.emit("missing", { locale: n, key: t, type: i, groupId: `${i}:${t}` });
    }
    if (null !== s) {
        const r = s(e, n, t, i);
        return Dm(r) ? r : t;
    }
    return ff(r, t) && a(tf(Zp.NOT_FOUND_KEY, { key: t, locale: n })), t;
}
function bf(e, t) {
    return e !== t && e.split("-")[0] === t.split("-")[0];
}
function yf(e, t) {
    const n = t.indexOf(e);
    if (-1 === n) return !1;
    for (let r = n + 1; r < t.length; r++) if (bf(e, t[r])) return !0;
    return !1;
}
const wf = "undefined" != typeof Intl,
    kf = wf && void 0 !== Intl.DateTimeFormat,
    Tf = wf && void 0 !== Intl.NumberFormat;
const _f = [
    "localeMatcher",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName",
    "formatMatcher",
    "hour12",
    "timeZone",
    "dateStyle",
    "timeStyle",
    "calendar",
    "dayPeriod",
    "numberingSystem",
    "hourCycle",
    "fractionalSecondDigits",
];
function vf(...e) {
    const [t, n, r, i] = e,
        s = xm();
    let a,
        o = xm();
    if (Dm(t)) {
        const e = t.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
        if (!e) throw Lp(Fp.INVALID_ISO_DATE_ARGUMENT);
        const n = e[3]
            ? e[3].trim().startsWith("T")
                ? `${e[1].trim()}${e[3].trim()}`
                : `${e[1].trim()}T${e[3].trim()}`
            : e[1].trim();
        a = new Date(n);
        try {
            a.toISOString();
        } catch {
            throw Lp(Fp.INVALID_ISO_DATE_ARGUMENT);
        }
    } else if ("[object Date]" === zm(t)) {
        if (isNaN(t.getTime())) throw Lp(Fp.INVALID_DATE_ARGUMENT);
        a = t;
    } else {
        if (!vm(t)) throw Lp(Fp.INVALID_ARGUMENT);
        a = t;
    }
    return (
        Dm(n)
            ? (s.key = n)
            : Um(n) &&
              Object.keys(n).forEach((e) => {
                  _f.includes(e) ? (o[e] = n[e]) : (s[e] = n[e]);
              }),
        Dm(r) ? (s.locale = r) : Um(r) && (o = r),
        Um(i) && (o = i),
        [s.key || "", a, s, o]
    );
}
const Sf = [
    "localeMatcher",
    "style",
    "currency",
    "currencyDisplay",
    "currencySign",
    "useGrouping",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "compactDisplay",
    "notation",
    "signDisplay",
    "unit",
    "unitDisplay",
    "roundingMode",
    "roundingPriority",
    "roundingIncrement",
    "trailingZeroDisplay",
];
function Ef(...e) {
    const [t, n, r, i] = e,
        s = xm();
    let a = xm();
    if (!vm(t)) throw Lp(Fp.INVALID_ARGUMENT);
    const o = t;
    return (
        Dm(n)
            ? (s.key = n)
            : Um(n) &&
              Object.keys(n).forEach((e) => {
                  Sf.includes(e) ? (a[e] = n[e]) : (s[e] = n[e]);
              }),
        Dm(r) ? (s.locale = r) : Um(r) && (a = r),
        Um(i) && (a = i),
        [s.key || "", o, s, a]
    );
}
const Cf = (e) => e,
    If = (e) => "",
    xf = "text",
    Af = (e) => (0 === e.length ? "" : $m(e)),
    Pf = (e) => (null == e ? "" : Rm(e) || (Um(e) && e.toString === Bm) ? JSON.stringify(e, null, 2) : String(e));
function Of(e, t) {
    return (e = Math.abs(e)), 2 === t ? (e ? (e > 1 ? 1 : 0) : 1) : e ? Math.min(e, 2) : 0;
}
function Nf(e = {}) {
    const t = e.locale,
        n = (function (e) {
            const t = vm(e.pluralIndex) ? e.pluralIndex : -1;
            return e.named && (vm(e.named.count) || vm(e.named.n))
                ? vm(e.named.count)
                    ? e.named.count
                    : vm(e.named.n)
                      ? e.named.n
                      : t
                : t;
        })(e),
        r = Lm(e.pluralRules) && Dm(t) && Mm(e.pluralRules[t]) ? e.pluralRules[t] : Of,
        i = Lm(e.pluralRules) && Dm(t) && Mm(e.pluralRules[t]) ? Of : void 0,
        s = e.list || [],
        a = e.named || xm();
    vm(e.pluralIndex) &&
        (function (e, t) {
            t.count || (t.count = e), t.n || (t.n = e);
        })(n, a);
    function o(t, n) {
        const r = Mm(e.messages) ? e.messages(t, !!n) : !!Lm(e.messages) && e.messages[t];
        return r || (e.parent ? e.parent.message(t) : If);
    }
    const c = Um(e.processor) && Mm(e.processor.normalize) ? e.processor.normalize : Af,
        l = Um(e.processor) && Mm(e.processor.interpolate) ? e.processor.interpolate : Pf,
        u = {
            list: (e) => s[e],
            named: (e) => a[e],
            plural: (e) => e[r(n, e.length, i)],
            linked: (t, ...n) => {
                const [r, i] = n;
                let s = "text",
                    a = "";
                1 === n.length
                    ? Lm(r)
                        ? ((a = r.modifier || a), (s = r.type || s))
                        : Dm(r) && (a = r || a)
                    : 2 === n.length && (Dm(r) && (a = r || a), Dm(i) && (s = i || s));
                const c = o(t, !0)(u),
                    l = "vnode" === s && Rm(c) && a ? c[0] : c;
                return a ? ((d = a), e.modifiers ? e.modifiers[d] : Cf)(l, s) : l;
                var d;
            },
            message: o,
            type: Um(e.processor) && Dm(e.processor.type) ? e.processor.type : xf,
            interpolate: l,
            normalize: c,
            values: Cm(xm(), s, a),
        };
    return u;
}
const Rf = () => "",
    Mf = (e) => Mm(e);
function Df(e, t, n, r, i, s) {
    const { messages: a, onWarn: o, messageResolver: c, localeFallbacker: l } = e,
        u = l(e, r, n);
    let d,
        h = xm(),
        m = null,
        p = n,
        f = null;
    const g = "translate";
    for (let b = 0; b < u.length; b++) {
        if (
            ((d = f = u[b]),
            n !== d && !bf(n, d) && pf(i, t) && o(tf(Zp.FALLBACK_TO_TRANSLATE, { key: t, target: d })),
            n !== d)
        ) {
            const n = e.__v_emitter;
            n && n.emit("fallback", { type: g, key: t, from: p, to: f, groupId: `${g}:${t}` });
        }
        h = a[d] || xm();
        let r,
            l,
            y = null;
        if (
            (bm &&
                ((y = window.performance.now()),
                (r = "intlify-message-resolve-start"),
                (l = "intlify-message-resolve-end"),
                ym && ym(r)),
            null === (m = c(h, t)) && (m = h[t]),
            bm)
        ) {
            const n = window.performance.now(),
                i = e.__v_emitter;
            i &&
                y &&
                m &&
                i.emit("message-resolve", {
                    type: "message-resolve",
                    key: t,
                    message: m,
                    time: n - y,
                    groupId: `${g}:${t}`,
                }),
                r && l && ym && wm && (ym(l), wm("intlify message resolve", r, l));
        }
        if (Dm(m) || hp(m) || Mf(m)) break;
        if (!yf(d, u)) {
            const n = gf(e, t, d, s, g);
            n !== t && (m = n);
        }
        p = f;
    }
    return [m, d, h];
}
function Ff(e, t, n, r, i, s) {
    const { messageCompiler: a, warnHtmlMessage: o } = e;
    if (Mf(r)) {
        const e = r;
        return (e.locale = e.locale || n), (e.key = e.key || t), e;
    }
    if (null == a) {
        const e = () => r;
        return (e.locale = n), (e.key = t), e;
    }
    let c,
        l,
        u = null;
    bm &&
        ((u = window.performance.now()),
        (c = "intlify-message-compilation-start"),
        (l = "intlify-message-compilation-end"),
        ym && ym(c));
    const d = a(
        r,
        (function (e, t, n, r, i, s) {
            return {
                locale: t,
                key: n,
                warnHtmlMessage: i,
                onError: (t) => {
                    s && s(t);
                    {
                        const i = (function (e) {
                                if (Dm(e)) return e;
                                if (e.loc && e.loc.source) return e.loc.source;
                            })(r),
                            s =
                                (t.message,
                                t.location &&
                                    i &&
                                    (function (e, t = 0, n = e.length) {
                                        const r = e.split(/\r?\n/);
                                        let i = 0;
                                        const s = [];
                                        for (let a = 0; a < r.length; a++)
                                            if (((i += r[a].length + 1), i >= t)) {
                                                for (let e = a - 2; e <= a + 2 || n > i; e++) {
                                                    if (e < 0 || e >= r.length) continue;
                                                    const o = e + 1;
                                                    s.push(`${o}${" ".repeat(3 - String(o).length)}|  ${r[e]}`);
                                                    const c = r[e].length;
                                                    if (e === a) {
                                                        const e = t - (i - c) + 1,
                                                            r = Math.max(1, n > i ? c - e : n - t);
                                                        s.push("   |  " + " ".repeat(e) + "^".repeat(r));
                                                    } else if (e > a) {
                                                        if (n > i) {
                                                            const e = Math.max(Math.min(n - i, c), 1);
                                                            s.push("   |  " + "^".repeat(e));
                                                        }
                                                        i += c + 1;
                                                    }
                                                }
                                                break;
                                            }
                                        s.join("\n");
                                    })(i, t.location.start.offset, t.location.end.offset),
                                e.__v_emitter);
                        s &&
                            i &&
                            s.emit("compile-error", {
                                message: i,
                                error: t.message,
                                start: t.location && t.location.start.offset,
                                end: t.location && t.location.end.offset,
                                groupId: `translate:${n}`,
                            });
                    }
                },
                onCacheKey: (e) => ((e, t, n) => _m({ l: e, k: t, s: n }))(t, n, e),
            };
        })(e, n, i, r, o, s)
    );
    if (bm) {
        const n = window.performance.now(),
            i = e.__v_emitter;
        i &&
            u &&
            i.emit("message-compilation", {
                type: "message-compilation",
                message: r,
                time: n - u,
                groupId: `translate:${t}`,
            }),
            c && l && ym && wm && (ym(l), wm("intlify message compilation", c, l));
    }
    return (d.locale = n), (d.key = t), (d.source = r), d;
}
function Lf(...e) {
    const [t, n, r] = e,
        i = xm();
    if (!(Dm(t) || vm(t) || Mf(t) || hp(t))) throw Lp(Fp.INVALID_ARGUMENT);
    const s = vm(t) ? String(t) : (Mf(t), t);
    return (
        vm(n) ? (i.plural = n) : Dm(n) ? (i.default = n) : Um(n) && !Em(n) ? (i.named = n) : Rm(n) && (i.list = n),
        vm(r) ? (i.plural = r) : Dm(r) ? (i.default = r) : Um(r) && Cm(i, r),
        [s, i]
    );
}
const Bf = Object.freeze(
        Object.defineProperty(
            {
                __proto__: null,
                AST_NODE_PROPS_KEYS: Sp,
                CORE_ERROR_CODES_EXTEND_POINT: 24,
                CORE_WARN_CODES_EXTEND_POINT: 8,
                CompileErrorCodes: Wm,
                CoreErrorCodes: Fp,
                CoreWarnCodes: Zp,
                DATETIME_FORMAT_OPTIONS_KEYS: _f,
                DEFAULT_LOCALE: rf,
                DEFAULT_MESSAGE_DATA_TYPE: xf,
                MISSING_RESOLVE_VALUE: "",
                NOT_REOSLVED: -1,
                NUMBER_FORMAT_OPTIONS_KEYS: Sf,
                VERSION: nf,
                clearCompileCache: function () {
                    Op = xm();
                },
                clearDateTimeFormat: function (e, t, n) {
                    const r = e;
                    for (const i in n) {
                        const e = `${t}__${i}`;
                        r.__datetimeFormatters.has(e) && r.__datetimeFormatters.delete(e);
                    }
                },
                clearNumberFormat: function (e, t, n) {
                    const r = e;
                    for (const i in n) {
                        const e = `${t}__${i}`;
                        r.__numberFormatters.has(e) && r.__numberFormatters.delete(e);
                    }
                },
                compile: function (e, t) {
                    if (Dm(e)) {
                        const n = !Fm(t.warnHtmlMessage) || t.warnHtmlMessage;
                        Ap(e, n);
                        const r = (t.onCacheKey || Pp)(e),
                            i = Op[r];
                        if (i) return i;
                        const { ast: s, detectError: a } = (function (e, t = {}) {
                                let n = !1;
                                const r = t.onError || qm;
                                return (
                                    (t.onError = (e) => {
                                        (n = !0), r(e);
                                    }),
                                    { ...dp(e, t), detectError: n }
                                );
                            })(e, { ...t, location: !0, jit: !0 }),
                            o = Cp(s);
                        return a ? o : (Op[r] = o);
                    }
                    {
                        if (!hp(e)) return t.key, () => e;
                        const n = e.cacheKey;
                        if (n) {
                            const t = Op[n];
                            return t || (Op[n] = Cp(e));
                        }
                        return Cp(e);
                    }
                },
                createCompileError: Hm,
                createCoreContext: function (e = {}) {
                    const t = Mm(e.onWarn) ? e.onWarn : fm,
                        n = Dm(e.version) ? e.version : nf,
                        r = Dm(e.locale) || Mm(e.locale) ? e.locale : rf,
                        i = Mm(r) ? rf : r,
                        s =
                            Rm(e.fallbackLocale) ||
                            Um(e.fallbackLocale) ||
                            Dm(e.fallbackLocale) ||
                            !1 === e.fallbackLocale
                                ? e.fallbackLocale
                                : i,
                        a = Um(e.messages) ? e.messages : mf(i),
                        o = Um(e.datetimeFormats) ? e.datetimeFormats : mf(i),
                        c = Um(e.numberFormats) ? e.numberFormats : mf(i),
                        l = Cm(xm(), e.modifiers, {
                            upper: (e, t) =>
                                "text" === t && Dm(e)
                                    ? e.toUpperCase()
                                    : "vnode" === t && Lm(e) && "__v_isVNode" in e
                                      ? e.children.toUpperCase()
                                      : e,
                            lower: (e, t) =>
                                "text" === t && Dm(e)
                                    ? e.toLowerCase()
                                    : "vnode" === t && Lm(e) && "__v_isVNode" in e
                                      ? e.children.toLowerCase()
                                      : e,
                            capitalize: (e, t) =>
                                "text" === t && Dm(e)
                                    ? sf(e)
                                    : "vnode" === t && Lm(e) && "__v_isVNode" in e
                                      ? sf(e.children)
                                      : e,
                        }),
                        u = e.pluralRules || xm(),
                        d = Mm(e.missing) ? e.missing : null,
                        h = (!Fm(e.missingWarn) && !Sm(e.missingWarn)) || e.missingWarn,
                        m = (!Fm(e.fallbackWarn) && !Sm(e.fallbackWarn)) || e.fallbackWarn,
                        p = !!e.fallbackFormat,
                        f = !!e.unresolving,
                        g = Mm(e.postTranslation) ? e.postTranslation : null,
                        b = Um(e.processor) ? e.processor : null,
                        y = !Fm(e.warnHtmlMessage) || e.warnHtmlMessage,
                        w = !!e.escapeParameter,
                        k = Mm(e.messageCompiler) ? e.messageCompiler : af;
                    var T;
                    Mm(e.messageCompiler) && ((T = tf(Zp.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER)), gm[T] || (gm[T] = !0));
                    const _ = Mm(e.messageResolver) ? e.messageResolver : of || Jp,
                        v = Mm(e.localeFallbacker) ? e.localeFallbacker : cf || Vp,
                        S = Lm(e.fallbackContext) ? e.fallbackContext : void 0,
                        E = e,
                        C = Lm(E.__datetimeFormatters) ? E.__datetimeFormatters : new Map(),
                        I = Lm(E.__numberFormatters) ? E.__numberFormatters : new Map(),
                        x = Lm(E.__meta) ? E.__meta : {};
                    hf++;
                    const A = {
                        version: n,
                        cid: hf,
                        locale: r,
                        fallbackLocale: s,
                        messages: a,
                        modifiers: l,
                        pluralRules: u,
                        missing: d,
                        missingWarn: h,
                        fallbackWarn: m,
                        fallbackFormat: p,
                        unresolving: f,
                        postTranslation: g,
                        processor: b,
                        warnHtmlMessage: y,
                        escapeParameter: w,
                        messageCompiler: k,
                        messageResolver: _,
                        localeFallbacker: v,
                        fallbackContext: S,
                        onWarn: t,
                        __meta: x,
                    };
                    return (
                        (A.datetimeFormats = o),
                        (A.numberFormats = c),
                        (A.__datetimeFormatters = C),
                        (A.__numberFormatters = I),
                        (A.__v_emitter = null != E.__v_emitter ? E.__v_emitter : void 0),
                        Rp(A, n, x),
                        A
                    );
                },
                createCoreError: Lp,
                createMessageContext: Nf,
                datetime: function (e, ...t) {
                    const { datetimeFormats: n, unresolving: r, fallbackLocale: i, onWarn: s, localeFallbacker: a } = e,
                        { __datetimeFormatters: o } = e;
                    if (!kf) return s(tf(Zp.CANNOT_FORMAT_DATE)), "";
                    const [c, l, u, d] = vf(...t),
                        h = Fm(u.missingWarn) ? u.missingWarn : e.missingWarn,
                        m = Fm(u.fallbackWarn) ? u.fallbackWarn : e.fallbackWarn,
                        p = !!u.part,
                        f = zp(e, u),
                        g = a(e, i, f);
                    if (!Dm(c) || "" === c) return new Intl.DateTimeFormat(f, d).format(l);
                    let b,
                        y = {},
                        w = null,
                        k = f,
                        T = null;
                    const _ = "datetime format";
                    for (let E = 0; E < g.length; E++) {
                        if (
                            ((b = T = g[E]),
                            f !== b && pf(m, c) && s(tf(Zp.FALLBACK_TO_DATE_FORMAT, { key: c, target: b })),
                            f !== b)
                        ) {
                            const t = e.__v_emitter;
                            t && t.emit("fallback", { type: _, key: c, from: k, to: T, groupId: `${_}:${c}` });
                        }
                        if (((y = n[b] || {}), (w = y[c]), Um(w))) break;
                        gf(e, c, b, h, _), (k = T);
                    }
                    if (!Um(w) || !Dm(b)) return r ? -1 : c;
                    let v = `${b}__${c}`;
                    Em(d) || (v = `${v}__${JSON.stringify(d)}`);
                    let S = o.get(v);
                    return (
                        S || ((S = new Intl.DateTimeFormat(b, Cm({}, w, d))), o.set(v, S)),
                        p ? S.formatToParts(l) : S.format(l)
                    );
                },
                fallbackWithLocaleChain: function (e, t, n) {
                    const r = Dm(n) ? n : rf,
                        i = e;
                    i.__localeChainCache || (i.__localeChainCache = new Map());
                    let s = i.__localeChainCache.get(r);
                    if (!s) {
                        s = [];
                        let e = [n];
                        for (; Rm(e); ) e = Wp(s, e, t);
                        const a = Rm(t) || !Um(t) ? t : t.default ? t.default : null;
                        (e = Dm(a) ? [a] : a), Rm(e) && Wp(s, e, !1), i.__localeChainCache.set(r, s);
                    }
                    return s;
                },
                fallbackWithSimple: Vp,
                getAdditionalMeta: uf,
                getDevToolsHook: function () {
                    return Np;
                },
                getFallbackContext: () => df,
                getLocale: zp,
                getWarnMessage: tf,
                handleMissing: gf,
                initI18nDevTools: Rp,
                isAlmostSameLocale: bf,
                isImplicitFallback: yf,
                isMessageAST: hp,
                isMessageFunction: Mf,
                isTranslateFallbackWarn: pf,
                isTranslateMissingWarn: ff,
                number: function (e, ...t) {
                    const { numberFormats: n, unresolving: r, fallbackLocale: i, onWarn: s, localeFallbacker: a } = e,
                        { __numberFormatters: o } = e;
                    if (!Tf) return s(tf(Zp.CANNOT_FORMAT_NUMBER)), "";
                    const [c, l, u, d] = Ef(...t),
                        h = Fm(u.missingWarn) ? u.missingWarn : e.missingWarn,
                        m = Fm(u.fallbackWarn) ? u.fallbackWarn : e.fallbackWarn,
                        p = !!u.part,
                        f = zp(e, u),
                        g = a(e, i, f);
                    if (!Dm(c) || "" === c) return new Intl.NumberFormat(f, d).format(l);
                    let b,
                        y = {},
                        w = null,
                        k = f,
                        T = null;
                    const _ = "number format";
                    for (let E = 0; E < g.length; E++) {
                        if (
                            ((b = T = g[E]),
                            f !== b && pf(m, c) && s(tf(Zp.FALLBACK_TO_NUMBER_FORMAT, { key: c, target: b })),
                            f !== b)
                        ) {
                            const t = e.__v_emitter;
                            t && t.emit("fallback", { type: _, key: c, from: k, to: T, groupId: `${_}:${c}` });
                        }
                        if (((y = n[b] || {}), (w = y[c]), Um(w))) break;
                        gf(e, c, b, h, _), (k = T);
                    }
                    if (!Um(w) || !Dm(b)) return r ? -1 : c;
                    let v = `${b}__${c}`;
                    Em(d) || (v = `${v}__${JSON.stringify(d)}`);
                    let S = o.get(v);
                    return (
                        S || ((S = new Intl.NumberFormat(b, Cm({}, w, d))), o.set(v, S)),
                        p ? S.formatToParts(l) : S.format(l)
                    );
                },
                parse: Yp,
                parseDateTimeArgs: vf,
                parseNumberArgs: Ef,
                parseTranslateArgs: Lf,
                registerLocaleFallbacker: function (e) {
                    cf = e;
                },
                registerMessageCompiler: function (e) {
                    af = e;
                },
                registerMessageResolver: function (e) {
                    of = e;
                },
                resolveLocale: $p,
                resolveValue: function (e, t) {
                    if (!Lm(e)) return null;
                    let n = Qp.get(t);
                    if ((n || ((n = Yp(t)), n && Qp.set(t, n)), !n)) return null;
                    const r = n.length;
                    let i = e,
                        s = 0;
                    for (; s < r; ) {
                        const e = n[s];
                        if (Sp.includes(e) && hp(i)) return null;
                        const t = i[e];
                        if (void 0 === t) return null;
                        if (Mm(i)) return null;
                        (i = t), s++;
                    }
                    return i;
                },
                resolveWithKeyValue: Jp,
                setAdditionalMeta: (e) => {
                    lf = e;
                },
                setDevToolsHook: function (e) {
                    Np = e;
                },
                setFallbackContext: (e) => {
                    df = e;
                },
                translate: function (e, ...t) {
                    const {
                            fallbackFormat: n,
                            postTranslation: r,
                            unresolving: i,
                            messageCompiler: s,
                            fallbackLocale: a,
                            messages: o,
                        } = e,
                        [c, l] = Lf(...t),
                        u = Fm(l.missingWarn) ? l.missingWarn : e.missingWarn,
                        d = Fm(l.fallbackWarn) ? l.fallbackWarn : e.fallbackWarn,
                        h = Fm(l.escapeParameter) ? l.escapeParameter : e.escapeParameter,
                        m = !!l.resolvedMessage,
                        p =
                            Dm(l.default) || Fm(l.default)
                                ? Fm(l.default)
                                    ? s
                                        ? c
                                        : () => c
                                    : l.default
                                : n
                                  ? s
                                      ? c
                                      : () => c
                                  : null,
                        f = n || (null != p && (Dm(p) || Mm(p))),
                        g = zp(e, l);
                    h &&
                        (function (e) {
                            Rm(e.list)
                                ? (e.list = e.list.map((e) => (Dm(e) ? Am(e) : e)))
                                : Lm(e.named) &&
                                  Object.keys(e.named).forEach((t) => {
                                      Dm(e.named[t]) && (e.named[t] = Am(e.named[t]));
                                  });
                        })(l);
                    let [b, y, w] = m ? [c, g, o[g] || xm()] : Df(e, c, g, a, d, u),
                        k = b,
                        T = c;
                    if (
                        (m || Dm(k) || hp(k) || Mf(k) || (f && ((k = p), (T = k))),
                        !(m || ((Dm(k) || hp(k) || Mf(k)) && Dm(y))))
                    )
                        return i ? -1 : c;
                    if (Dm(k) && null == e.messageCompiler) return c;
                    let _ = !1;
                    const v = Mf(k)
                        ? k
                        : Ff(e, c, y, k, T, () => {
                              _ = !0;
                          });
                    if (_) return k;
                    const S = (function (e, t, n, r) {
                            const {
                                    modifiers: i,
                                    pluralRules: s,
                                    messageResolver: a,
                                    fallbackLocale: o,
                                    fallbackWarn: c,
                                    missingWarn: l,
                                    fallbackContext: u,
                                } = e,
                                d = (r, i) => {
                                    let s = a(n, r);
                                    if (null == s && (u || i)) {
                                        const [, , n] = Df(u || e, r, t, o, c, l);
                                        s = a(n, r);
                                    }
                                    if (Dm(s) || hp(s)) {
                                        let n = !1;
                                        const i = Ff(e, r, t, s, r, () => {
                                            n = !0;
                                        });
                                        return n ? Rf : i;
                                    }
                                    return Mf(s) ? s : Rf;
                                },
                                h = { locale: t, modifiers: i, pluralRules: s, messages: d };
                            e.processor && (h.processor = e.processor);
                            r.list && (h.list = r.list);
                            r.named && (h.named = r.named);
                            vm(r.plural) && (h.pluralIndex = r.plural);
                            return h;
                        })(e, y, w, l),
                        E = (function (e, t, n) {
                            let r,
                                i,
                                s = null;
                            bm &&
                                ((s = window.performance.now()),
                                (r = "intlify-message-evaluation-start"),
                                (i = "intlify-message-evaluation-end"),
                                ym && ym(r));
                            const a = t(n);
                            if (bm) {
                                const n = window.performance.now(),
                                    o = e.__v_emitter;
                                o &&
                                    s &&
                                    o.emit("message-evaluation", {
                                        type: "message-evaluation",
                                        value: a,
                                        time: n - s,
                                        groupId: `translate:${t.key}`,
                                    }),
                                    r && i && ym && wm && (ym(i), wm("intlify message evaluation", r, i));
                            }
                            return a;
                        })(e, v, Nf(S));
                    let C = r ? r(E, c) : E;
                    var I;
                    h &&
                        Dm(C) &&
                        ((I = (I = (I = C).replace(/(\w+)\s*=\s*"([^"]*)"/g, (e, t, n) => `${t}="${Pm(n)}"`)).replace(
                            /(\w+)\s*=\s*'([^']*)'/g,
                            (e, t, n) => `${t}='${Pm(n)}'`
                        )),
                        /\s*on\w+\s*=\s*["']?[^"'>]+["']?/gi.test(I) &&
                            (I = I.replace(/(\s+)(on)(\w+\s*=)/gi, "$1&#111;n$3")),
                        [
                            /(\s+(?:href|src|action|formaction)\s*=\s*["']?)\s*javascript:/gi,
                            /(style\s*=\s*["'][^"']*url\s*\(\s*)javascript:/gi,
                        ].forEach((e) => {
                            I = I.replace(e, "$1javascript&#58;");
                        }),
                        (C = I));
                    {
                        const t = {
                            timestamp: Date.now(),
                            key: Dm(c) ? c : Mf(k) ? k.key : "",
                            locale: y || (Mf(k) ? k.locale : ""),
                            format: Dm(k) ? k : Mf(k) ? k.source : "",
                            message: C,
                        };
                        (t.meta = Cm({}, e.__meta, uf() || {})), Mp(t);
                    }
                    return C;
                },
                translateDevTools: Mp,
                updateFallbackLocale: function (e, t, n) {
                    (e.__localeChainCache = new Map()), e.localeFallbacker(e, n, t);
                },
            },
            Symbol.toStringTag,
            { value: "Module" }
        )
    ),
    zf = Tc(Bf);
function Uf(e, t) {}
const $f = {};
const Vf = "undefined" != typeof window;
let Wf, jf;
{
    const e = Vf && window.performance;
    e &&
        e.mark &&
        e.measure &&
        e.clearMarks &&
        e.clearMeasures &&
        ((Wf = (t) => {
            e.mark(t);
        }),
        (jf = (t, n, r) => {
            e.measure(t, n, r), e.clearMarks(n), e.clearMarks(r);
        }));
}
const Hf = /\{([0-9a-zA-Z]+)\}/g;
const qf = (e) =>
        JSON.stringify(e)
            .replace(/\u2028/g, "\\u2028")
            .replace(/\u2029/g, "\\u2029")
            .replace(/\u0027/g, "\\u0027"),
    Xf = Object.assign,
    Gf = Object.create,
    Kf = (e = null) => Gf(e);
let Yf;
function Qf(e) {
    return e
        .replace(/&(?![a-zA-Z0-9#]{2,6};)/g, "&amp;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&apos;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
}
const Jf = Object.prototype.hasOwnProperty;
const Zf = Array.isArray,
    eg = (e) => "function" == typeof e,
    tg = (e) => null !== e && "object" == typeof e,
    ng = Object.prototype.toString,
    rg = (e) => ng.call(e),
    ig = (e) => "[object Object]" === rg(e);
const sg = (e) => !tg(e) || Zf(e);
const ag = Object.freeze(
        Object.defineProperty(
            {
                __proto__: null,
                assign: Xf,
                create: Kf,
                createEmitter: function () {
                    const e = new Map();
                    return {
                        events: e,
                        on(t, n) {
                            const r = e.get(t);
                            (r && r.push(n)) || e.set(t, [n]);
                        },
                        off(t, n) {
                            const r = e.get(t);
                            r && r.splice(r.indexOf(n) >>> 0, 1);
                        },
                        emit(t, n) {
                            (e.get(t) || []).slice().map((e) => e(n)), (e.get("*") || []).slice().map((e) => e(t, n));
                        },
                    };
                },
                deepCopy: function (e, t) {
                    if (sg(e) || sg(t)) throw new Error("Invalid value");
                    const n = [{ src: e, des: t }];
                    for (; n.length; ) {
                        const { src: e, des: t } = n.pop();
                        Object.keys(e).forEach((r) => {
                            "__proto__" !== r &&
                                (tg(e[r]) && !tg(t[r]) && (t[r] = Array.isArray(e[r]) ? [] : Kf()),
                                sg(t[r]) || sg(e[r]) ? (t[r] = e[r]) : n.push({ src: e[r], des: t[r] }));
                        });
                    }
                },
                escapeHtml: function (e) {
                    return e
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(/"/g, "&quot;")
                        .replace(/'/g, "&apos;")
                        .replace(/\//g, "&#x2F;")
                        .replace(/=/g, "&#x3D;");
                },
                format: function (e, ...t) {
                    return (
                        1 === t.length && tg(t[0]) && (t = t[0]),
                        (t && t.hasOwnProperty) || (t = {}),
                        e.replace(Hf, (e, n) => (t.hasOwnProperty(n) ? t[n] : ""))
                    );
                },
                friendlyJSONstringify: qf,
                generateCodeFrame: function (e, t = 0, n = e.length) {
                    const r = e.split(/\r?\n/);
                    let i = 0;
                    const s = [];
                    for (let a = 0; a < r.length; a++)
                        if (((i += r[a].length + 1), i >= t)) {
                            for (let e = a - 2; e <= a + 2 || n > i; e++) {
                                if (e < 0 || e >= r.length) continue;
                                const o = e + 1;
                                s.push(`${o}${" ".repeat(3 - String(o).length)}|  ${r[e]}`);
                                const c = r[e].length;
                                if (e === a) {
                                    const e = t - (i - c) + 1,
                                        r = Math.max(1, n > i ? c - e : n - t);
                                    s.push("   |  " + " ".repeat(e) + "^".repeat(r));
                                } else if (e > a) {
                                    if (n > i) {
                                        const e = Math.max(Math.min(n - i, c), 1);
                                        s.push("   |  " + "^".repeat(e));
                                    }
                                    i += c + 1;
                                }
                            }
                            break;
                        }
                    return s.join("\n");
                },
                generateFormatCacheKey: (e, t, n) => qf({ l: e, k: t, s: n }),
                getGlobalThis: () =>
                    Yf ||
                    (Yf =
                        "undefined" != typeof globalThis
                            ? globalThis
                            : "undefined" != typeof self
                              ? self
                              : "undefined" != typeof window
                                ? window
                                : "undefined" != typeof global
                                  ? global
                                  : Kf()),
                hasOwn: function (e, t) {
                    return Jf.call(e, t);
                },
                inBrowser: Vf,
                isArray: Zf,
                isBoolean: (e) => "boolean" == typeof e,
                isDate: (e) => "[object Date]" === rg(e),
                isEmptyObject: (e) => ig(e) && 0 === Object.keys(e).length,
                isFunction: eg,
                isNumber: (e) => "number" == typeof e && isFinite(e),
                isObject: tg,
                isPlainObject: ig,
                isPromise: (e) => tg(e) && eg(e.then) && eg(e.catch),
                isRegExp: (e) => "[object RegExp]" === rg(e),
                isString: (e) => "string" == typeof e,
                isSymbol: (e) => "symbol" == typeof e,
                join: function (e, t = "") {
                    return e.reduce((e, n, r) => (0 === r ? e + n : e + t + n), "");
                },
                makeSymbol: (e, t = !1) => (t ? Symbol.for(e) : Symbol(e)),
                get mark() {
                    return Wf;
                },
                get measure() {
                    return jf;
                },
                objectToString: ng,
                sanitizeTranslatedHtml: function (e) {
                    return (
                        (e = (e = e.replace(/(\w+)\s*=\s*"([^"]*)"/g, (e, t, n) => `${t}="${Qf(n)}"`)).replace(
                            /(\w+)\s*=\s*'([^']*)'/g,
                            (e, t, n) => `${t}='${Qf(n)}'`
                        )),
                        /\s*on\w+\s*=\s*["']?[^"'>]+["']?/gi.test(e) &&
                            (e = e.replace(/(\s+)(on)(\w+\s*=)/gi, "$1&#111;n$3")),
                        [
                            /(\s+(?:href|src|action|formaction)\s*=\s*["']?)\s*javascript:/gi,
                            /(style\s*=\s*["'][^"']*url\s*\(\s*)javascript:/gi,
                        ].forEach((t) => {
                            e = e.replace(t, "$1javascript&#58;");
                        }),
                        e
                    );
                },
                toDisplayString: (e) =>
                    null == e ? "" : Zf(e) || (ig(e) && e.toString === ng) ? JSON.stringify(e, null, 2) : String(e),
                toTypeString: rg,
                warn: Uf,
                warnOnce: function (e) {
                    $f[e] || ($f[e] = !0);
                },
            },
            Symbol.toStringTag,
            { value: "Module" }
        )
    ),
    og = Tc(ag);
var cg = { exports: {} },
    lg = {};
const ug = Symbol(""),
    dg = Symbol(""),
    hg = Symbol(""),
    mg = Symbol(""),
    pg = Symbol(""),
    fg = Symbol(""),
    gg = Symbol(""),
    bg = Symbol(""),
    yg = Symbol(""),
    wg = Symbol(""),
    kg = Symbol(""),
    Tg = Symbol(""),
    _g = Symbol(""),
    vg = Symbol(""),
    Sg = Symbol(""),
    Eg = Symbol(""),
    Cg = Symbol(""),
    Ig = Symbol(""),
    xg = Symbol(""),
    Ag = Symbol(""),
    Pg = Symbol(""),
    Og = Symbol(""),
    Ng = Symbol(""),
    Rg = Symbol(""),
    Mg = Symbol(""),
    Dg = Symbol(""),
    Fg = Symbol(""),
    Lg = Symbol(""),
    Bg = Symbol(""),
    zg = Symbol(""),
    Ug = Symbol(""),
    $g = Symbol(""),
    Vg = Symbol(""),
    Wg = Symbol(""),
    jg = Symbol(""),
    Hg = Symbol(""),
    qg = Symbol(""),
    Xg = Symbol(""),
    Gg = Symbol(""),
    Kg = {
        [ug]: "Fragment",
        [dg]: "Teleport",
        [hg]: "Suspense",
        [mg]: "KeepAlive",
        [pg]: "BaseTransition",
        [fg]: "openBlock",
        [gg]: "createBlock",
        [bg]: "createElementBlock",
        [yg]: "createVNode",
        [wg]: "createElementVNode",
        [kg]: "createCommentVNode",
        [Tg]: "createTextVNode",
        [_g]: "createStaticVNode",
        [vg]: "resolveComponent",
        [Sg]: "resolveDynamicComponent",
        [Eg]: "resolveDirective",
        [Cg]: "resolveFilter",
        [Ig]: "withDirectives",
        [xg]: "renderList",
        [Ag]: "renderSlot",
        [Pg]: "createSlots",
        [Og]: "toDisplayString",
        [Ng]: "mergeProps",
        [Rg]: "normalizeClass",
        [Mg]: "normalizeStyle",
        [Dg]: "normalizeProps",
        [Fg]: "guardReactiveProps",
        [Lg]: "toHandlers",
        [Bg]: "camelize",
        [zg]: "capitalize",
        [Ug]: "toHandlerKey",
        [$g]: "setBlockTracking",
        [Vg]: "pushScopeId",
        [Wg]: "popScopeId",
        [jg]: "withCtx",
        [Hg]: "unref",
        [qg]: "isRef",
        [Xg]: "withMemo",
        [Gg]: "isMemoSame",
    };
function Yg(e) {
    Object.getOwnPropertySymbols(e).forEach((t) => {
        Kg[t] = e[t];
    });
}
const Qg = { start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 }, source: "" };
function Jg(e, t = "") {
    return {
        type: 0,
        source: t,
        children: e,
        helpers: new Set(),
        components: [],
        directives: [],
        hoists: [],
        imports: [],
        cached: [],
        temps: 0,
        codegenNode: void 0,
        loc: Qg,
    };
}
function Zg(e, t, n, r, i, s, a, o = !1, c = !1, l = !1, u = Qg) {
    return (
        e && (o ? (e.helper(fg), e.helper(db(e.inSSR, l))) : e.helper(ub(e.inSSR, l)), a && e.helper(Ig)),
        {
            type: 13,
            tag: t,
            props: n,
            children: r,
            patchFlag: i,
            dynamicProps: s,
            directives: a,
            isBlock: o,
            disableTracking: c,
            isComponent: l,
            loc: u,
        }
    );
}
function eb(e, t = Qg) {
    return { type: 17, loc: t, elements: e };
}
function tb(e, t = Qg) {
    return { type: 15, loc: t, properties: e };
}
function nb(e, t) {
    return { type: 16, loc: Qg, key: b(e) ? rb(e, !0) : e, value: t };
}
function rb(e, t = !1, n = Qg, r = 0) {
    return { type: 4, loc: n, content: e, isStatic: t, constType: t ? 3 : r };
}
function ib(e, t = Qg) {
    return { type: 8, loc: t, children: e };
}
function sb(e, t = [], n = Qg) {
    return { type: 14, loc: n, callee: e, arguments: t };
}
function ab(e, t = void 0, n = !1, r = !1, i = Qg) {
    return { type: 18, params: e, returns: t, newline: n, isSlot: r, loc: i };
}
function ob(e, t, n, r = !0) {
    return { type: 19, test: e, consequent: t, alternate: n, newline: r, loc: Qg };
}
function cb(e, t, n = !1, r = !1) {
    return { type: 20, index: e, value: t, needPauseTracking: n, inVOnce: r, needArraySpread: !1, loc: Qg };
}
function lb(e) {
    return { type: 21, body: e, loc: Qg };
}
function ub(e, t) {
    return e || t ? yg : wg;
}
function db(e, t) {
    return e || t ? gg : bg;
}
function hb(e, { helper: t, removeHelper: n, inSSR: r }) {
    e.isBlock || ((e.isBlock = !0), n(ub(r, e.isComponent)), t(fg), t(db(r, e.isComponent)));
}
const mb = new Uint8Array([123, 123]),
    pb = new Uint8Array([125, 125]);
function fb(e) {
    return (e >= 97 && e <= 122) || (e >= 65 && e <= 90);
}
function gb(e) {
    return 32 === e || 10 === e || 9 === e || 12 === e || 13 === e;
}
function bb(e) {
    return 47 === e || 62 === e || gb(e);
}
function yb(e) {
    const t = new Uint8Array(e.length);
    for (let n = 0; n < e.length; n++) t[n] = e.charCodeAt(n);
    return t;
}
const wb = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    CdataEnd: new Uint8Array([93, 93, 62]),
    CommentEnd: new Uint8Array([45, 45, 62]),
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
    TextareaEnd: new Uint8Array([60, 47, 116, 101, 120, 116, 97, 114, 101, 97]),
};
const kb = {
    COMPILER_IS_ON_ELEMENT: {
        message:
            'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".',
        link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html",
    },
    COMPILER_V_BIND_SYNC: {
        message: (e) =>
            `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${e}.sync\` should be changed to \`v-model:${e}\`.`,
        link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html",
    },
    COMPILER_V_BIND_OBJECT_ORDER: {
        message:
            'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',
        link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html",
    },
    COMPILER_V_ON_NATIVE: {
        message: ".native modifier for v-on has been removed as is no longer necessary.",
        link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html",
    },
    COMPILER_V_IF_V_FOR_PRECEDENCE: {
        message:
            "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.",
        link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html",
    },
    COMPILER_NATIVE_TEMPLATE: {
        message:
            "<template> with no special directives will render as a native template element instead of its inner content in Vue 3.",
    },
    COMPILER_INLINE_TEMPLATE: {
        message: '"inline-template" has been removed in Vue 3.',
        link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html",
    },
    COMPILER_FILTERS: {
        message:
            'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',
        link: "https://v3-migration.vuejs.org/breaking-changes/filters.html",
    },
};
function Tb(e, { compatConfig: t }) {
    const n = t && t[e];
    return "MODE" === e ? n || 3 : n;
}
function _b(e, t) {
    const n = Tb("MODE", t),
        r = Tb(e, t);
    return 3 === n ? !0 === r : !1 !== r;
}
function vb(e, t, n, ...r) {
    return _b(e, t);
}
function Sb(e) {
    throw e;
}
function Eb(e) {}
function Cb(e, t, n, r) {
    const i = new SyntaxError(String(`https://vuejs.org/error-reference/#compiler-${e}`));
    return (i.code = e), (i.loc = t), i;
}
const Ib = {
    0: "Illegal comment.",
    1: "CDATA section is allowed only in XML context.",
    2: "Duplicate attribute.",
    3: "End tag cannot have attributes.",
    4: "Illegal '/' in tags.",
    5: "Unexpected EOF in tag.",
    6: "Unexpected EOF in CDATA section.",
    7: "Unexpected EOF in comment.",
    8: "Unexpected EOF in script.",
    9: "Unexpected EOF in tag.",
    10: "Incorrectly closed comment.",
    11: "Incorrectly opened comment.",
    12: "Illegal tag name. Use '&lt;' to print '<'.",
    13: "Attribute value was expected.",
    14: "End tag name was expected.",
    15: "Whitespace was expected.",
    16: "Unexpected '\x3c!--' in comment.",
    17: "Attribute name cannot contain U+0022 (\"), U+0027 ('), and U+003C (<).",
    18: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
    19: "Attribute name cannot start with '='.",
    21: "'<?' is allowed only in XML context.",
    20: "Unexpected null character.",
    22: "Illegal '/' in tags.",
    23: "Invalid end tag.",
    24: "Element is missing end tag.",
    25: "Interpolation end sign was not found.",
    27: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
    26: "Legal directive name was expected.",
    28: "v-if/v-else-if is missing expression.",
    29: "v-if/else branches must use unique keys.",
    30: "v-else/v-else-if has no adjacent v-if or v-else-if.",
    31: "v-for is missing expression.",
    32: "v-for has invalid expression.",
    33: "<template v-for> key should be placed on the <template> tag.",
    34: "v-bind is missing expression.",
    52: "v-bind with same-name shorthand only allows static argument.",
    35: "v-on is missing expression.",
    36: "Unexpected custom directive on <slot> outlet.",
    37: "Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.",
    38: "Duplicate slot names found. ",
    39: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.",
    40: "v-slot can only be used on components or <template> tags.",
    41: "v-model is missing expression.",
    42: "v-model value must be a valid JavaScript member expression.",
    43: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.",
    44: "v-model cannot be used on a prop, because local prop bindings are not writable.\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.",
    45: "Error parsing JavaScript expression: ",
    46: "<KeepAlive> expects exactly one child component.",
    51: "@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.",
    47: '"prefixIdentifiers" option is not supported in this build of compiler.',
    48: "ES module mode is not supported in this build of compiler.",
    49: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.',
    50: '"scopeId" option is only supported in module mode.',
    53: "",
};
function xb(e) {
    return "ForOfStatement" === e.type || "ForInStatement" === e.type || "ForStatement" === e.type;
}
function Ab(e, t, n) {
    const r = "ForStatement" === e.type ? e.init : e.left;
    if (r && "VariableDeclaration" === r.type && ("var" === r.kind ? t : !t))
        for (const i of r.declarations) for (const e of Pb(i.id)) n(e);
}
function Pb(e, t = []) {
    switch (e.type) {
        case "Identifier":
            t.push(e);
            break;
        case "MemberExpression":
            let n = e;
            for (; "MemberExpression" === n.type; ) n = n.object;
            t.push(n);
            break;
        case "ObjectPattern":
            for (const r of e.properties) "RestElement" === r.type ? Pb(r.argument, t) : Pb(r.value, t);
            break;
        case "ArrayPattern":
            e.elements.forEach((e) => {
                e && Pb(e, t);
            });
            break;
        case "RestElement":
            Pb(e.argument, t);
            break;
        case "AssignmentPattern":
            Pb(e.left, t);
    }
    return t;
}
const Ob = (e) => e && ("ObjectProperty" === e.type || "ObjectMethod" === e.type) && !e.computed,
    Nb = [
        "TSAsExpression",
        "TSTypeAssertion",
        "TSNonNullExpression",
        "TSInstantiationExpression",
        "TSSatisfiesExpression",
    ];
const Rb = (e) => 4 === e.type && e.isStatic;
function Mb(e) {
    switch (e) {
        case "Teleport":
        case "teleport":
            return dg;
        case "Suspense":
        case "suspense":
            return hg;
        case "KeepAlive":
        case "keep-alive":
            return mg;
        case "BaseTransition":
        case "base-transition":
            return pg;
    }
}
const Db = /^\d|[^\$\w\xA0-\uFFFF]/,
    Fb = (e) => !Db.test(e),
    Lb = /[A-Za-z_$\xA0-\uFFFF]/,
    Bb = /[\.\?\w$\xA0-\uFFFF]/,
    zb = /\s+[.[]\s*|\s*[.[]\s+/g,
    Ub = (e) => (4 === e.type ? e.content : e.loc.source),
    $b = (e) => {
        const t = Ub(e)
            .trim()
            .replace(zb, (e) => e.trim());
        let n = 0,
            r = [],
            i = 0,
            s = 0,
            a = null;
        for (let o = 0; o < t.length; o++) {
            const e = t.charAt(o);
            switch (n) {
                case 0:
                    if ("[" === e) r.push(n), (n = 1), i++;
                    else if ("(" === e) r.push(n), (n = 2), s++;
                    else if (!(0 === o ? Lb : Bb).test(e)) return !1;
                    break;
                case 1:
                    "'" === e || '"' === e || "`" === e
                        ? (r.push(n), (n = 3), (a = e))
                        : "[" === e
                          ? i++
                          : "]" === e && (--i || (n = r.pop()));
                    break;
                case 2:
                    if ("'" === e || '"' === e || "`" === e) r.push(n), (n = 3), (a = e);
                    else if ("(" === e) s++;
                    else if (")" === e) {
                        if (o === t.length - 1) return !1;
                        --s || (n = r.pop());
                    }
                    break;
                case 3:
                    e === a && ((n = r.pop()), (a = null));
            }
        }
        return !i && !s;
    },
    Vb = r,
    Wb = $b,
    jb = /^\s*(async\s*)?(\([^)]*?\)|[\w$_]+)\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/,
    Hb = (e) => jb.test(Ub(e)),
    qb = r,
    Xb = Hb;
function Gb(e, t, n = t.length) {
    let r = 0,
        i = -1;
    for (let s = 0; s < n; s++) 10 === t.charCodeAt(s) && (r++, (i = s));
    return (e.offset += n), (e.line += r), (e.column = -1 === i ? e.column + n : n - i), e;
}
function Kb(e, t, n = !1) {
    for (let r = 0; r < e.props.length; r++) {
        const i = e.props[r];
        if (7 === i.type && (n || i.exp) && (b(t) ? i.name === t : t.test(i.name))) return i;
    }
}
function Yb(e, t, n = !1, r = !1) {
    for (let i = 0; i < e.props.length; i++) {
        const s = e.props[i];
        if (6 === s.type) {
            if (n) continue;
            if (s.name === t && (s.value || r)) return s;
        } else if ("bind" === s.name && (s.exp || r) && Qb(s.arg, t)) return s;
    }
}
function Qb(e, t) {
    return !(!e || !Rb(e) || e.content !== t);
}
function Jb(e) {
    return e.props.some((e) => !(7 !== e.type || "bind" !== e.name || (e.arg && 4 === e.arg.type && e.arg.isStatic)));
}
function Zb(e) {
    return 5 === e.type || 2 === e.type;
}
function ey(e) {
    return 7 === e.type && "slot" === e.name;
}
function ty(e) {
    return 1 === e.type && 3 === e.tagType;
}
function ny(e) {
    return 1 === e.type && 2 === e.tagType;
}
const ry = new Set([Dg, Fg]);
function iy(e, t = []) {
    if (e && !b(e) && 14 === e.type) {
        const n = e.callee;
        if (!b(n) && ry.has(n)) return iy(e.arguments[0], t.concat(e));
    }
    return [e, t];
}
function sy(e, t, n) {
    let r,
        i,
        s = 13 === e.type ? e.props : e.arguments[2],
        a = [];
    if (s && !b(s) && 14 === s.type) {
        const e = iy(s);
        (s = e[0]), (a = e[1]), (i = a[a.length - 1]);
    }
    if (null == s || b(s)) r = tb([t]);
    else if (14 === s.type) {
        const e = s.arguments[0];
        b(e) || 15 !== e.type
            ? s.callee === Lg
                ? (r = sb(n.helper(Ng), [tb([t]), s]))
                : s.arguments.unshift(tb([t]))
            : ay(t, e) || e.properties.unshift(t),
            !r && (r = s);
    } else
        15 === s.type
            ? (ay(t, s) || s.properties.unshift(t), (r = s))
            : ((r = sb(n.helper(Ng), [tb([t]), s])), i && i.callee === Fg && (i = a[a.length - 2]));
    13 === e.type ? (i ? (i.arguments[0] = r) : (e.props = r)) : i ? (i.arguments[0] = r) : (e.arguments[2] = r);
}
function ay(e, t) {
    let n = !1;
    if (4 === e.key.type) {
        const r = e.key.content;
        n = t.properties.some((e) => 4 === e.key.type && e.key.content === r);
    }
    return n;
}
function oy(e, t) {
    return `_${t}_${e.replace(/[^\w]/g, (t, n) => ("-" === t ? "_" : e.charCodeAt(n).toString()))}`;
}
function cy(e) {
    return 14 === e.type && e.callee === Xg ? e.arguments[1].returns : e;
}
const ly = /([\s\S]*?)\s+(?:in|of)\s+(\S[\s\S]*)/,
    uy = {
        parseMode: "base",
        ns: 0,
        delimiters: ["{{", "}}"],
        getNamespace: () => 0,
        isVoidTag: i,
        isPreTag: i,
        isIgnoreNewlineTag: i,
        isCustomElement: i,
        onError: Sb,
        onWarn: Eb,
        comments: !1,
        prefixIdentifiers: !1,
    };
let dy = uy,
    hy = null,
    my = "",
    py = null,
    fy = null,
    gy = "",
    by = -1,
    yy = -1,
    wy = 0,
    ky = !1,
    Ty = null;
const _y = [],
    vy = new (class {
        constructor(e, t) {
            (this.stack = e),
                (this.cbs = t),
                (this.state = 1),
                (this.buffer = ""),
                (this.sectionStart = 0),
                (this.index = 0),
                (this.entityStart = 0),
                (this.baseState = 1),
                (this.inRCDATA = !1),
                (this.inXML = !1),
                (this.inVPre = !1),
                (this.newlines = []),
                (this.mode = 0),
                (this.delimiterOpen = mb),
                (this.delimiterClose = pb),
                (this.delimiterIndex = -1),
                (this.currentSequence = void 0),
                (this.sequenceIndex = 0);
        }
        get inSFCRoot() {
            return 2 === this.mode && 0 === this.stack.length;
        }
        reset() {
            (this.state = 1),
                (this.mode = 0),
                (this.buffer = ""),
                (this.sectionStart = 0),
                (this.index = 0),
                (this.baseState = 1),
                (this.inRCDATA = !1),
                (this.currentSequence = void 0),
                (this.newlines.length = 0),
                (this.delimiterOpen = mb),
                (this.delimiterClose = pb);
        }
        getPos(e) {
            let t = 1,
                n = e + 1;
            for (let r = this.newlines.length - 1; r >= 0; r--) {
                const i = this.newlines[r];
                if (e > i) {
                    (t = r + 2), (n = e - i);
                    break;
                }
            }
            return { column: n, line: t, offset: e };
        }
        peek() {
            return this.buffer.charCodeAt(this.index + 1);
        }
        stateText(e) {
            60 === e
                ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index),
                  (this.state = 5),
                  (this.sectionStart = this.index))
                : this.inVPre ||
                  e !== this.delimiterOpen[0] ||
                  ((this.state = 2), (this.delimiterIndex = 0), this.stateInterpolationOpen(e));
        }
        stateInterpolationOpen(e) {
            if (e === this.delimiterOpen[this.delimiterIndex])
                if (this.delimiterIndex === this.delimiterOpen.length - 1) {
                    const e = this.index + 1 - this.delimiterOpen.length;
                    e > this.sectionStart && this.cbs.ontext(this.sectionStart, e),
                        (this.state = 3),
                        (this.sectionStart = e);
                } else this.delimiterIndex++;
            else this.inRCDATA ? ((this.state = 32), this.stateInRCDATA(e)) : ((this.state = 1), this.stateText(e));
        }
        stateInterpolation(e) {
            e === this.delimiterClose[0] &&
                ((this.state = 4), (this.delimiterIndex = 0), this.stateInterpolationClose(e));
        }
        stateInterpolationClose(e) {
            e === this.delimiterClose[this.delimiterIndex]
                ? this.delimiterIndex === this.delimiterClose.length - 1
                    ? (this.cbs.oninterpolation(this.sectionStart, this.index + 1),
                      this.inRCDATA ? (this.state = 32) : (this.state = 1),
                      (this.sectionStart = this.index + 1))
                    : this.delimiterIndex++
                : ((this.state = 3), this.stateInterpolation(e));
        }
        stateSpecialStartSequence(e) {
            const t = this.sequenceIndex === this.currentSequence.length;
            if (t ? bb(e) : (32 | e) === this.currentSequence[this.sequenceIndex]) {
                if (!t) return void this.sequenceIndex++;
            } else this.inRCDATA = !1;
            (this.sequenceIndex = 0), (this.state = 6), this.stateInTagName(e);
        }
        stateInRCDATA(e) {
            if (this.sequenceIndex === this.currentSequence.length) {
                if (62 === e || gb(e)) {
                    const t = this.index - this.currentSequence.length;
                    if (this.sectionStart < t) {
                        const e = this.index;
                        (this.index = t), this.cbs.ontext(this.sectionStart, t), (this.index = e);
                    }
                    return (this.sectionStart = t + 2), this.stateInClosingTagName(e), void (this.inRCDATA = !1);
                }
                this.sequenceIndex = 0;
            }
            (32 | e) === this.currentSequence[this.sequenceIndex]
                ? (this.sequenceIndex += 1)
                : 0 === this.sequenceIndex
                  ? this.currentSequence === wb.TitleEnd || (this.currentSequence === wb.TextareaEnd && !this.inSFCRoot)
                      ? this.inVPre ||
                        e !== this.delimiterOpen[0] ||
                        ((this.state = 2), (this.delimiterIndex = 0), this.stateInterpolationOpen(e))
                      : this.fastForwardTo(60) && (this.sequenceIndex = 1)
                  : (this.sequenceIndex = Number(60 === e));
        }
        stateCDATASequence(e) {
            e === wb.Cdata[this.sequenceIndex]
                ? ++this.sequenceIndex === wb.Cdata.length &&
                  ((this.state = 28),
                  (this.currentSequence = wb.CdataEnd),
                  (this.sequenceIndex = 0),
                  (this.sectionStart = this.index + 1))
                : ((this.sequenceIndex = 0), (this.state = 23), this.stateInDeclaration(e));
        }
        fastForwardTo(e) {
            for (; ++this.index < this.buffer.length; ) {
                const t = this.buffer.charCodeAt(this.index);
                if ((10 === t && this.newlines.push(this.index), t === e)) return !0;
            }
            return (this.index = this.buffer.length - 1), !1;
        }
        stateInCommentLike(e) {
            e === this.currentSequence[this.sequenceIndex]
                ? ++this.sequenceIndex === this.currentSequence.length &&
                  (this.currentSequence === wb.CdataEnd
                      ? this.cbs.oncdata(this.sectionStart, this.index - 2)
                      : this.cbs.oncomment(this.sectionStart, this.index - 2),
                  (this.sequenceIndex = 0),
                  (this.sectionStart = this.index + 1),
                  (this.state = 1))
                : 0 === this.sequenceIndex
                  ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1)
                  : e !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
        }
        startSpecial(e, t) {
            this.enterRCDATA(e, t), (this.state = 31);
        }
        enterRCDATA(e, t) {
            (this.inRCDATA = !0), (this.currentSequence = e), (this.sequenceIndex = t);
        }
        stateBeforeTagName(e) {
            33 === e
                ? ((this.state = 22), (this.sectionStart = this.index + 1))
                : 63 === e
                  ? ((this.state = 24), (this.sectionStart = this.index + 1))
                  : fb(e)
                    ? ((this.sectionStart = this.index),
                      0 === this.mode
                          ? (this.state = 6)
                          : this.inSFCRoot
                            ? (this.state = 34)
                            : this.inXML
                              ? (this.state = 6)
                              : (this.state = 116 === e ? 30 : 115 === e ? 29 : 6))
                    : 47 === e
                      ? (this.state = 8)
                      : ((this.state = 1), this.stateText(e));
        }
        stateInTagName(e) {
            bb(e) && this.handleTagName(e);
        }
        stateInSFCRootTagName(e) {
            if (bb(e)) {
                const t = this.buffer.slice(this.sectionStart, this.index);
                "template" !== t && this.enterRCDATA(yb("</" + t), 0), this.handleTagName(e);
            }
        }
        handleTagName(e) {
            this.cbs.onopentagname(this.sectionStart, this.index),
                (this.sectionStart = -1),
                (this.state = 11),
                this.stateBeforeAttrName(e);
        }
        stateBeforeClosingTagName(e) {
            gb(e) ||
                (62 === e
                    ? ((this.state = 1), (this.sectionStart = this.index + 1))
                    : ((this.state = fb(e) ? 9 : 27), (this.sectionStart = this.index)));
        }
        stateInClosingTagName(e) {
            (62 === e || gb(e)) &&
                (this.cbs.onclosetag(this.sectionStart, this.index),
                (this.sectionStart = -1),
                (this.state = 10),
                this.stateAfterClosingTagName(e));
        }
        stateAfterClosingTagName(e) {
            62 === e && ((this.state = 1), (this.sectionStart = this.index + 1));
        }
        stateBeforeAttrName(e) {
            62 === e
                ? (this.cbs.onopentagend(this.index),
                  this.inRCDATA ? (this.state = 32) : (this.state = 1),
                  (this.sectionStart = this.index + 1))
                : 47 === e
                  ? (this.state = 7)
                  : 60 === e && 47 === this.peek()
                    ? (this.cbs.onopentagend(this.index), (this.state = 5), (this.sectionStart = this.index))
                    : gb(e) || this.handleAttrStart(e);
        }
        handleAttrStart(e) {
            118 === e && 45 === this.peek()
                ? ((this.state = 13), (this.sectionStart = this.index))
                : 46 === e || 58 === e || 64 === e || 35 === e
                  ? (this.cbs.ondirname(this.index, this.index + 1),
                    (this.state = 14),
                    (this.sectionStart = this.index + 1))
                  : ((this.state = 12), (this.sectionStart = this.index));
        }
        stateInSelfClosingTag(e) {
            62 === e
                ? (this.cbs.onselfclosingtag(this.index),
                  (this.state = 1),
                  (this.sectionStart = this.index + 1),
                  (this.inRCDATA = !1))
                : gb(e) || ((this.state = 11), this.stateBeforeAttrName(e));
        }
        stateInAttrName(e) {
            (61 === e || bb(e)) && (this.cbs.onattribname(this.sectionStart, this.index), this.handleAttrNameEnd(e));
        }
        stateInDirName(e) {
            61 === e || bb(e)
                ? (this.cbs.ondirname(this.sectionStart, this.index), this.handleAttrNameEnd(e))
                : 58 === e
                  ? (this.cbs.ondirname(this.sectionStart, this.index),
                    (this.state = 14),
                    (this.sectionStart = this.index + 1))
                  : 46 === e &&
                    (this.cbs.ondirname(this.sectionStart, this.index),
                    (this.state = 16),
                    (this.sectionStart = this.index + 1));
        }
        stateInDirArg(e) {
            61 === e || bb(e)
                ? (this.cbs.ondirarg(this.sectionStart, this.index), this.handleAttrNameEnd(e))
                : 91 === e
                  ? (this.state = 15)
                  : 46 === e &&
                    (this.cbs.ondirarg(this.sectionStart, this.index),
                    (this.state = 16),
                    (this.sectionStart = this.index + 1));
        }
        stateInDynamicDirArg(e) {
            93 === e
                ? (this.state = 14)
                : (61 === e || bb(e)) &&
                  (this.cbs.ondirarg(this.sectionStart, this.index + 1), this.handleAttrNameEnd(e));
        }
        stateInDirModifier(e) {
            61 === e || bb(e)
                ? (this.cbs.ondirmodifier(this.sectionStart, this.index), this.handleAttrNameEnd(e))
                : 46 === e &&
                  (this.cbs.ondirmodifier(this.sectionStart, this.index), (this.sectionStart = this.index + 1));
        }
        handleAttrNameEnd(e) {
            (this.sectionStart = this.index),
                (this.state = 17),
                this.cbs.onattribnameend(this.index),
                this.stateAfterAttrName(e);
        }
        stateAfterAttrName(e) {
            61 === e
                ? (this.state = 18)
                : 47 === e || 62 === e
                  ? (this.cbs.onattribend(0, this.sectionStart),
                    (this.sectionStart = -1),
                    (this.state = 11),
                    this.stateBeforeAttrName(e))
                  : gb(e) || (this.cbs.onattribend(0, this.sectionStart), this.handleAttrStart(e));
        }
        stateBeforeAttrValue(e) {
            34 === e
                ? ((this.state = 19), (this.sectionStart = this.index + 1))
                : 39 === e
                  ? ((this.state = 20), (this.sectionStart = this.index + 1))
                  : gb(e) || ((this.sectionStart = this.index), (this.state = 21), this.stateInAttrValueNoQuotes(e));
        }
        handleInAttrValue(e, t) {
            (e === t || this.fastForwardTo(t)) &&
                (this.cbs.onattribdata(this.sectionStart, this.index),
                (this.sectionStart = -1),
                this.cbs.onattribend(34 === t ? 3 : 2, this.index + 1),
                (this.state = 11));
        }
        stateInAttrValueDoubleQuotes(e) {
            this.handleInAttrValue(e, 34);
        }
        stateInAttrValueSingleQuotes(e) {
            this.handleInAttrValue(e, 39);
        }
        stateInAttrValueNoQuotes(e) {
            gb(e) || 62 === e
                ? (this.cbs.onattribdata(this.sectionStart, this.index),
                  (this.sectionStart = -1),
                  this.cbs.onattribend(1, this.index),
                  (this.state = 11),
                  this.stateBeforeAttrName(e))
                : (39 !== e && 60 !== e && 61 !== e && 96 !== e) || this.cbs.onerr(18, this.index);
        }
        stateBeforeDeclaration(e) {
            91 === e ? ((this.state = 26), (this.sequenceIndex = 0)) : (this.state = 45 === e ? 25 : 23);
        }
        stateInDeclaration(e) {
            (62 === e || this.fastForwardTo(62)) && ((this.state = 1), (this.sectionStart = this.index + 1));
        }
        stateInProcessingInstruction(e) {
            (62 === e || this.fastForwardTo(62)) &&
                (this.cbs.onprocessinginstruction(this.sectionStart, this.index),
                (this.state = 1),
                (this.sectionStart = this.index + 1));
        }
        stateBeforeComment(e) {
            45 === e
                ? ((this.state = 28),
                  (this.currentSequence = wb.CommentEnd),
                  (this.sequenceIndex = 2),
                  (this.sectionStart = this.index + 1))
                : (this.state = 23);
        }
        stateInSpecialComment(e) {
            (62 === e || this.fastForwardTo(62)) &&
                (this.cbs.oncomment(this.sectionStart, this.index),
                (this.state = 1),
                (this.sectionStart = this.index + 1));
        }
        stateBeforeSpecialS(e) {
            e === wb.ScriptEnd[3]
                ? this.startSpecial(wb.ScriptEnd, 4)
                : e === wb.StyleEnd[3]
                  ? this.startSpecial(wb.StyleEnd, 4)
                  : ((this.state = 6), this.stateInTagName(e));
        }
        stateBeforeSpecialT(e) {
            e === wb.TitleEnd[3]
                ? this.startSpecial(wb.TitleEnd, 4)
                : e === wb.TextareaEnd[3]
                  ? this.startSpecial(wb.TextareaEnd, 4)
                  : ((this.state = 6), this.stateInTagName(e));
        }
        startEntity() {}
        stateInEntity() {}
        parse(e) {
            for (this.buffer = e; this.index < this.buffer.length; ) {
                const e = this.buffer.charCodeAt(this.index);
                switch ((10 === e && 33 !== this.state && this.newlines.push(this.index), this.state)) {
                    case 1:
                        this.stateText(e);
                        break;
                    case 2:
                        this.stateInterpolationOpen(e);
                        break;
                    case 3:
                        this.stateInterpolation(e);
                        break;
                    case 4:
                        this.stateInterpolationClose(e);
                        break;
                    case 31:
                        this.stateSpecialStartSequence(e);
                        break;
                    case 32:
                        this.stateInRCDATA(e);
                        break;
                    case 26:
                        this.stateCDATASequence(e);
                        break;
                    case 19:
                        this.stateInAttrValueDoubleQuotes(e);
                        break;
                    case 12:
                        this.stateInAttrName(e);
                        break;
                    case 13:
                        this.stateInDirName(e);
                        break;
                    case 14:
                        this.stateInDirArg(e);
                        break;
                    case 15:
                        this.stateInDynamicDirArg(e);
                        break;
                    case 16:
                        this.stateInDirModifier(e);
                        break;
                    case 28:
                        this.stateInCommentLike(e);
                        break;
                    case 27:
                        this.stateInSpecialComment(e);
                        break;
                    case 11:
                        this.stateBeforeAttrName(e);
                        break;
                    case 6:
                        this.stateInTagName(e);
                        break;
                    case 34:
                        this.stateInSFCRootTagName(e);
                        break;
                    case 9:
                        this.stateInClosingTagName(e);
                        break;
                    case 5:
                        this.stateBeforeTagName(e);
                        break;
                    case 17:
                        this.stateAfterAttrName(e);
                        break;
                    case 20:
                        this.stateInAttrValueSingleQuotes(e);
                        break;
                    case 18:
                        this.stateBeforeAttrValue(e);
                        break;
                    case 8:
                        this.stateBeforeClosingTagName(e);
                        break;
                    case 10:
                        this.stateAfterClosingTagName(e);
                        break;
                    case 29:
                        this.stateBeforeSpecialS(e);
                        break;
                    case 30:
                        this.stateBeforeSpecialT(e);
                        break;
                    case 21:
                        this.stateInAttrValueNoQuotes(e);
                        break;
                    case 7:
                        this.stateInSelfClosingTag(e);
                        break;
                    case 23:
                        this.stateInDeclaration(e);
                        break;
                    case 22:
                        this.stateBeforeDeclaration(e);
                        break;
                    case 25:
                        this.stateBeforeComment(e);
                        break;
                    case 24:
                        this.stateInProcessingInstruction(e);
                        break;
                    case 33:
                        this.stateInEntity();
                }
                this.index++;
            }
            this.cleanup(), this.finish();
        }
        cleanup() {
            this.sectionStart !== this.index &&
                (1 === this.state || (32 === this.state && 0 === this.sequenceIndex)
                    ? (this.cbs.ontext(this.sectionStart, this.index), (this.sectionStart = this.index))
                    : (19 !== this.state && 20 !== this.state && 21 !== this.state) ||
                      (this.cbs.onattribdata(this.sectionStart, this.index), (this.sectionStart = this.index)));
        }
        finish() {
            this.handleTrailingData(), this.cbs.onend();
        }
        handleTrailingData() {
            const e = this.buffer.length;
            this.sectionStart >= e ||
                (28 === this.state
                    ? this.currentSequence === wb.CdataEnd
                        ? this.cbs.oncdata(this.sectionStart, e)
                        : this.cbs.oncomment(this.sectionStart, e)
                    : 6 === this.state ||
                      11 === this.state ||
                      18 === this.state ||
                      17 === this.state ||
                      12 === this.state ||
                      13 === this.state ||
                      14 === this.state ||
                      15 === this.state ||
                      16 === this.state ||
                      20 === this.state ||
                      19 === this.state ||
                      21 === this.state ||
                      9 === this.state ||
                      this.cbs.ontext(this.sectionStart, e));
        }
        emitCodePoint(e, t) {}
    })(_y, {
        onerr: Wy,
        ontext(e, t) {
            xy(Cy(e, t), e, t);
        },
        ontextentity(e, t, n) {
            xy(e, t, n);
        },
        oninterpolation(e, t) {
            if (ky) return xy(Cy(e, t), e, t);
            let n = e + vy.delimiterOpen.length,
                r = t - vy.delimiterClose.length;
            for (; gb(my.charCodeAt(n)); ) n++;
            for (; gb(my.charCodeAt(r - 1)); ) r--;
            let i = Cy(n, r);
            i.includes("&") && (i = dy.decodeEntities(i, !1)),
                By({ type: 5, content: Vy(i, !1, zy(n, r)), loc: zy(e, t) });
        },
        onopentagname(e, t) {
            const n = Cy(e, t);
            py = {
                type: 1,
                tag: n,
                ns: dy.getNamespace(n, _y[0], dy.ns),
                tagType: 0,
                props: [],
                children: [],
                loc: zy(e - 1, t),
                codegenNode: void 0,
            };
        },
        onopentagend(e) {
            Iy(e);
        },
        onclosetag(e, t) {
            const n = Cy(e, t);
            if (!dy.isVoidTag(n)) {
                let r = !1;
                for (let e = 0; e < _y.length; e++) {
                    if (_y[e].tag.toLowerCase() === n.toLowerCase()) {
                        (r = !0), e > 0 && Wy(24, _y[0].loc.start.offset);
                        for (let n = 0; n <= e; n++) {
                            Ay(_y.shift(), t, n < e);
                        }
                        break;
                    }
                }
                r || Wy(23, Py(e, 60));
            }
        },
        onselfclosingtag(e) {
            const t = py.tag;
            (py.isSelfClosing = !0), Iy(e), _y[0] && _y[0].tag === t && Ay(_y.shift(), e);
        },
        onattribname(e, t) {
            fy = { type: 6, name: Cy(e, t), nameLoc: zy(e, t), value: void 0, loc: zy(e) };
        },
        ondirname(e, t) {
            const n = Cy(e, t),
                r = "." === n || ":" === n ? "bind" : "@" === n ? "on" : "#" === n ? "slot" : n.slice(2);
            if ((ky || "" !== r || Wy(26, e), ky || "" === r))
                fy = { type: 6, name: n, nameLoc: zy(e, t), value: void 0, loc: zy(e) };
            else if (
                ((fy = {
                    type: 7,
                    name: r,
                    rawName: n,
                    exp: void 0,
                    arg: void 0,
                    modifiers: "." === n ? [rb("prop")] : [],
                    loc: zy(e),
                }),
                "pre" === r)
            ) {
                (ky = vy.inVPre = !0), (Ty = py);
                const e = py.props;
                for (let t = 0; t < e.length; t++) 7 === e[t].type && (e[t] = $y(e[t]));
            }
        },
        ondirarg(e, t) {
            if (e === t) return;
            const n = Cy(e, t);
            if (ky) (fy.name += n), Uy(fy.nameLoc, t);
            else {
                const r = "[" !== n[0];
                fy.arg = Vy(r ? n : n.slice(1, -1), r, zy(e, t), r ? 3 : 0);
            }
        },
        ondirmodifier(e, t) {
            const n = Cy(e, t);
            if (ky) (fy.name += "." + n), Uy(fy.nameLoc, t);
            else if ("slot" === fy.name) {
                const e = fy.arg;
                e && ((e.content += "." + n), Uy(e.loc, t));
            } else {
                const r = rb(n, !0, zy(e, t));
                fy.modifiers.push(r);
            }
        },
        onattribdata(e, t) {
            (gy += Cy(e, t)), by < 0 && (by = e), (yy = t);
        },
        onattribentity(e, t, n) {
            (gy += e), by < 0 && (by = t), (yy = n);
        },
        onattribnameend(e) {
            const t = fy.loc.start.offset,
                n = Cy(t, e);
            7 === fy.type && (fy.rawName = n),
                py.props.some((e) => (7 === e.type ? e.rawName : e.name) === n) && Wy(2, t);
        },
        onattribend(e, t) {
            if (py && fy) {
                if ((Uy(fy.loc, t), 0 !== e))
                    if ((gy.includes("&") && (gy = dy.decodeEntities(gy, !0)), 6 === fy.type))
                        "class" === fy.name && (gy = Ly(gy).trim()),
                            1 !== e || gy || Wy(13, t),
                            (fy.value = { type: 2, content: gy, loc: 1 === e ? zy(by, yy) : zy(by - 1, yy + 1) }),
                            vy.inSFCRoot &&
                                "template" === py.tag &&
                                "lang" === fy.name &&
                                gy &&
                                "html" !== gy &&
                                vy.enterRCDATA(yb("</template"), 0);
                    else {
                        let e = 0;
                        (fy.exp = Vy(gy, !1, zy(by, yy), 0, e)),
                            "for" === fy.name &&
                                (fy.forParseResult = (function (e) {
                                    const t = e.loc,
                                        n = e.content,
                                        r = n.match(ly);
                                    if (!r) return;
                                    const [, i, s] = r,
                                        a = (e, n, r = !1) => {
                                            const i = t.start.offset + n;
                                            return Vy(e, !1, zy(i, i + e.length), 0, r ? 1 : 0);
                                        },
                                        o = {
                                            source: a(s.trim(), n.indexOf(s, i.length)),
                                            value: void 0,
                                            key: void 0,
                                            index: void 0,
                                            finalized: !1,
                                        };
                                    let c = i.trim().replace(Ey, "").trim();
                                    const l = i.indexOf(c),
                                        u = c.match(Sy);
                                    if (u) {
                                        c = c.replace(Sy, "").trim();
                                        const e = u[1].trim();
                                        let t;
                                        if ((e && ((t = n.indexOf(e, l + c.length)), (o.key = a(e, t, !0))), u[2])) {
                                            const r = u[2].trim();
                                            r &&
                                                (o.index = a(r, n.indexOf(r, o.key ? t + e.length : l + c.length), !0));
                                        }
                                    }
                                    c && (o.value = a(c, l, !0));
                                    return o;
                                })(fy.exp));
                        let t = -1;
                        "bind" === fy.name &&
                            (t = fy.modifiers.findIndex((e) => "sync" === e.content)) > -1 &&
                            vb("COMPILER_V_BIND_SYNC", dy, fy.loc, fy.arg.loc.source) &&
                            ((fy.name = "model"), fy.modifiers.splice(t, 1));
                    }
                (7 === fy.type && "pre" === fy.name) || py.props.push(fy);
            }
            (gy = ""), (by = yy = -1);
        },
        oncomment(e, t) {
            dy.comments && By({ type: 3, content: Cy(e, t), loc: zy(e - 4, t + 3) });
        },
        onend() {
            const e = my.length;
            for (let t = 0; t < _y.length; t++) Ay(_y[t], e - 1), Wy(24, _y[t].loc.start.offset);
        },
        oncdata(e, t) {
            0 !== _y[0].ns ? xy(Cy(e, t), e, t) : Wy(1, e - 9);
        },
        onprocessinginstruction(e) {
            0 === (_y[0] ? _y[0].ns : dy.ns) && Wy(21, e - 1);
        },
    }),
    Sy = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/,
    Ey = /^\(|\)$/g;
function Cy(e, t) {
    return my.slice(e, t);
}
function Iy(e) {
    vy.inSFCRoot && (py.innerLoc = zy(e + 1, e + 1)), By(py);
    const { tag: t, ns: n } = py;
    0 === n && dy.isPreTag(t) && wy++,
        dy.isVoidTag(t) ? Ay(py, e) : (_y.unshift(py), (1 !== n && 2 !== n) || (vy.inXML = !0)),
        (py = null);
}
function xy(e, t, n) {
    {
        const t = _y[0] && _y[0].tag;
        "script" !== t && "style" !== t && e.includes("&") && (e = dy.decodeEntities(e, !1));
    }
    const r = _y[0] || hy,
        i = r.children[r.children.length - 1];
    i && 2 === i.type ? ((i.content += e), Uy(i.loc, n)) : r.children.push({ type: 2, content: e, loc: zy(t, n) });
}
function Ay(e, t, n = !1) {
    Uy(
        e.loc,
        n
            ? Py(t, 60)
            : (function (e, t) {
                  let n = e;
                  for (; my.charCodeAt(n) !== t && n < my.length - 1; ) n++;
                  return n;
              })(t, 62) + 1
    ),
        vy.inSFCRoot &&
            (e.children.length
                ? (e.innerLoc.end = o({}, e.children[e.children.length - 1].loc.end))
                : (e.innerLoc.end = o({}, e.innerLoc.start)),
            (e.innerLoc.source = Cy(e.innerLoc.start.offset, e.innerLoc.end.offset)));
    const { tag: r, ns: i, children: s } = e;
    if (
        (ky ||
            ("slot" === r
                ? (e.tagType = 2)
                : Ny(e)
                  ? (e.tagType = 3)
                  : (function ({ tag: e, props: t }) {
                        if (dy.isCustomElement(e)) return !1;
                        if (
                            "component" === e ||
                            ((n = e.charCodeAt(0)), n > 64 && n < 91) ||
                            Mb(e) ||
                            (dy.isBuiltInComponent && dy.isBuiltInComponent(e)) ||
                            (dy.isNativeTag && !dy.isNativeTag(e))
                        )
                            return !0;
                        var n;
                        for (let r = 0; r < t.length; r++) {
                            const e = t[r];
                            if (6 === e.type) {
                                if ("is" === e.name && e.value) {
                                    if (e.value.content.startsWith("vue:")) return !0;
                                    if (vb("COMPILER_IS_ON_ELEMENT", dy, e.loc)) return !0;
                                }
                            } else if ("bind" === e.name && Qb(e.arg, "is") && vb("COMPILER_IS_ON_ELEMENT", dy, e.loc))
                                return !0;
                        }
                        return !1;
                    })(e) && (e.tagType = 1)),
        vy.inRCDATA || (e.children = My(s)),
        0 === i && dy.isIgnoreNewlineTag(r))
    ) {
        const e = s[0];
        e && 2 === e.type && (e.content = e.content.replace(/^\r?\n/, ""));
    }
    0 === i && dy.isPreTag(r) && wy--,
        Ty === e && ((ky = vy.inVPre = !1), (Ty = null)),
        vy.inXML && 0 === (_y[0] ? _y[0].ns : dy.ns) && (vy.inXML = !1);
    {
        const t = e.props;
        if (!vy.inSFCRoot && _b("COMPILER_NATIVE_TEMPLATE", dy) && "template" === e.tag && !Ny(e)) {
            const t = _y[0] || hy,
                n = t.children.indexOf(e);
            t.children.splice(n, 1, ...e.children);
        }
        const n = t.find((e) => 6 === e.type && "inline-template" === e.name);
        n &&
            vb("COMPILER_INLINE_TEMPLATE", dy, n.loc) &&
            e.children.length &&
            (n.value = {
                type: 2,
                content: Cy(e.children[0].loc.start.offset, e.children[e.children.length - 1].loc.end.offset),
                loc: n.loc,
            });
    }
}
function Py(e, t) {
    let n = e;
    for (; my.charCodeAt(n) !== t && n >= 0; ) n--;
    return n;
}
const Oy = new Set(["if", "else", "else-if", "for", "slot"]);
function Ny({ tag: e, props: t }) {
    if ("template" === e) for (let n = 0; n < t.length; n++) if (7 === t[n].type && Oy.has(t[n].name)) return !0;
    return !1;
}
const Ry = /\r\n/g;
function My(e) {
    const t = "preserve" !== dy.whitespace;
    let n = !1;
    for (let r = 0; r < e.length; r++) {
        const i = e[r];
        if (2 === i.type)
            if (wy) i.content = i.content.replace(Ry, "\n");
            else if (Dy(i.content)) {
                const s = e[r - 1] && e[r - 1].type,
                    a = e[r + 1] && e[r + 1].type;
                !s ||
                !a ||
                (t && ((3 === s && (3 === a || 1 === a)) || (1 === s && (3 === a || (1 === a && Fy(i.content))))))
                    ? ((n = !0), (e[r] = null))
                    : (i.content = " ");
            } else t && (i.content = Ly(i.content));
    }
    return n ? e.filter(Boolean) : e;
}
function Dy(e) {
    for (let t = 0; t < e.length; t++) if (!gb(e.charCodeAt(t))) return !1;
    return !0;
}
function Fy(e) {
    for (let t = 0; t < e.length; t++) {
        const n = e.charCodeAt(t);
        if (10 === n || 13 === n) return !0;
    }
    return !1;
}
function Ly(e) {
    let t = "",
        n = !1;
    for (let r = 0; r < e.length; r++) gb(e.charCodeAt(r)) ? n || ((t += " "), (n = !0)) : ((t += e[r]), (n = !1));
    return t;
}
function By(e) {
    (_y[0] || hy).children.push(e);
}
function zy(e, t) {
    return { start: vy.getPos(e), end: null == t ? t : vy.getPos(t), source: null == t ? t : Cy(e, t) };
}
function Uy(e, t) {
    (e.end = vy.getPos(t)), (e.source = Cy(e.start.offset, t));
}
function $y(e) {
    const t = {
        type: 6,
        name: e.rawName,
        nameLoc: zy(e.loc.start.offset, e.loc.start.offset + e.rawName.length),
        value: void 0,
        loc: e.loc,
    };
    if (e.exp) {
        const n = e.exp.loc;
        n.end.offset < e.loc.end.offset && (n.start.offset--, n.start.column--, n.end.offset++, n.end.column++),
            (t.value = { type: 2, content: e.exp.content, loc: n });
    }
    return t;
}
function Vy(e, t = !1, n, r = 0, i = 0) {
    return rb(e, t, n, r);
}
function Wy(e, t, n) {
    dy.onError(Cb(e, zy(t, t)));
}
function jy(e, t) {
    if (
        (vy.reset(),
        (py = null),
        (fy = null),
        (gy = ""),
        (by = -1),
        (yy = -1),
        (_y.length = 0),
        (my = e),
        (dy = o({}, uy)),
        t)
    ) {
        let e;
        for (e in t) null != t[e] && (dy[e] = t[e]);
    }
    (vy.mode = "html" === dy.parseMode ? 1 : "sfc" === dy.parseMode ? 2 : 0), (vy.inXML = 1 === dy.ns || 2 === dy.ns);
    const n = t && t.delimiters;
    n && ((vy.delimiterOpen = yb(n[0])), (vy.delimiterClose = yb(n[1])));
    const r = (hy = Jg([], e));
    return vy.parse(my), (r.loc = zy(0, e.length)), (r.children = My(r.children)), (hy = null), r;
}
function Hy(e, t) {
    Xy(e, void 0, t, !!qy(e));
}
function qy(e) {
    const t = e.children.filter((e) => 3 !== e.type);
    return 1 !== t.length || 1 !== t[0].type || ny(t[0]) ? null : t[0];
}
function Xy(e, t, n, r = !1, i = !1) {
    const { children: s } = e,
        a = [];
    for (let d = 0; d < s.length; d++) {
        const t = s[d];
        if (1 === t.type && 0 === t.tagType) {
            const e = r ? 0 : Gy(t, n);
            if (e > 0) {
                if (e >= 2) {
                    (t.codegenNode.patchFlag = -1), a.push(t);
                    continue;
                }
            } else {
                const e = t.codegenNode;
                if (13 === e.type) {
                    const r = e.patchFlag;
                    if ((void 0 === r || 512 === r || 1 === r) && Qy(t, n) >= 2) {
                        const r = Jy(t);
                        r && (e.props = n.hoist(r));
                    }
                    e.dynamicProps && (e.dynamicProps = n.hoist(e.dynamicProps));
                }
            }
        } else if (12 === t.type) {
            if ((r ? 0 : Gy(t, n)) >= 2) {
                a.push(t);
                continue;
            }
        }
        if (1 === t.type) {
            const r = 1 === t.tagType;
            r && n.scopes.vSlot++, Xy(t, e, n, !1, i), r && n.scopes.vSlot--;
        } else if (11 === t.type) Xy(t, e, n, 1 === t.children.length, !0);
        else if (9 === t.type)
            for (let r = 0; r < t.branches.length; r++) Xy(t.branches[r], e, n, 1 === t.branches[r].children.length, i);
    }
    let o = !1;
    const c = [];
    if (a.length === s.length && 1 === e.type)
        if (0 === e.tagType && e.codegenNode && 13 === e.codegenNode.type && d(e.codegenNode.children))
            (e.codegenNode.children = l(eb(e.codegenNode.children))), (o = !0);
        else if (
            1 === e.tagType &&
            e.codegenNode &&
            13 === e.codegenNode.type &&
            e.codegenNode.children &&
            !d(e.codegenNode.children) &&
            15 === e.codegenNode.children.type
        ) {
            const t = u(e.codegenNode, "default");
            t && (c.push(n.cached.length), (t.returns = l(eb(t.returns))), (o = !0));
        } else if (
            3 === e.tagType &&
            t &&
            1 === t.type &&
            1 === t.tagType &&
            t.codegenNode &&
            13 === t.codegenNode.type &&
            t.codegenNode.children &&
            !d(t.codegenNode.children) &&
            15 === t.codegenNode.children.type
        ) {
            const r = Kb(e, "slot", !0),
                i = r && r.arg && u(t.codegenNode, r.arg);
            i && (c.push(n.cached.length), (i.returns = l(eb(i.returns))), (o = !0));
        }
    if (!o) for (const d of a) c.push(n.cached.length), (d.codegenNode = n.cache(d.codegenNode));
    function l(e) {
        const t = n.cache(e);
        return i && n.hmr && (t.needArraySpread = !0), t;
    }
    function u(e, t) {
        if (e.children && !d(e.children) && 15 === e.children.type) {
            const n = e.children.properties.find((e) => e.key === t || e.key.content === t);
            return n && n.value;
        }
    }
    c.length &&
        1 === e.type &&
        1 === e.tagType &&
        e.codegenNode &&
        13 === e.codegenNode.type &&
        e.codegenNode.children &&
        !d(e.codegenNode.children) &&
        15 === e.codegenNode.children.type &&
        e.codegenNode.children.properties.push(nb("__", rb(JSON.stringify(c), !1))),
        a.length && n.transformHoist && n.transformHoist(s, n, e);
}
function Gy(e, t) {
    const { constantCache: n } = t;
    switch (e.type) {
        case 1:
            if (0 !== e.tagType) return 0;
            const r = n.get(e);
            if (void 0 !== r) return r;
            const i = e.codegenNode;
            if (13 !== i.type) return 0;
            if (i.isBlock && "svg" !== e.tag && "foreignObject" !== e.tag && "math" !== e.tag) return 0;
            if (void 0 === i.patchFlag) {
                let r = 3;
                const s = Qy(e, t);
                if (0 === s) return n.set(e, 0), 0;
                s < r && (r = s);
                for (let i = 0; i < e.children.length; i++) {
                    const s = Gy(e.children[i], t);
                    if (0 === s) return n.set(e, 0), 0;
                    s < r && (r = s);
                }
                if (r > 1)
                    for (let i = 0; i < e.props.length; i++) {
                        const s = e.props[i];
                        if (7 === s.type && "bind" === s.name && s.exp) {
                            const i = Gy(s.exp, t);
                            if (0 === i) return n.set(e, 0), 0;
                            i < r && (r = i);
                        }
                    }
                if (i.isBlock) {
                    for (let t = 0; t < e.props.length; t++) {
                        if (7 === e.props[t].type) return n.set(e, 0), 0;
                    }
                    t.removeHelper(fg),
                        t.removeHelper(db(t.inSSR, i.isComponent)),
                        (i.isBlock = !1),
                        t.helper(ub(t.inSSR, i.isComponent));
                }
                return n.set(e, r), r;
            }
            return n.set(e, 0), 0;
        case 2:
        case 3:
            return 3;
        case 9:
        case 11:
        case 10:
        default:
            return 0;
        case 5:
        case 12:
            return Gy(e.content, t);
        case 4:
            return e.constType;
        case 8:
            let s = 3;
            for (let n = 0; n < e.children.length; n++) {
                const r = e.children[n];
                if (b(r) || y(r)) continue;
                const i = Gy(r, t);
                if (0 === i) return 0;
                i < s && (s = i);
            }
            return s;
        case 20:
            return 2;
    }
}
const Ky = new Set([Rg, Mg, Dg, Fg]);
function Yy(e, t) {
    if (14 === e.type && !b(e.callee) && Ky.has(e.callee)) {
        const n = e.arguments[0];
        if (4 === n.type) return Gy(n, t);
        if (14 === n.type) return Yy(n, t);
    }
    return 0;
}
function Qy(e, t) {
    let n = 3;
    const r = Jy(e);
    if (r && 15 === r.type) {
        const { properties: e } = r;
        for (let r = 0; r < e.length; r++) {
            const { key: i, value: s } = e[r],
                a = Gy(i, t);
            if (0 === a) return a;
            let o;
            if ((a < n && (n = a), (o = 4 === s.type ? Gy(s, t) : 14 === s.type ? Yy(s, t) : 0), 0 === o)) return o;
            o < n && (n = o);
        }
    }
    return n;
}
function Jy(e) {
    const t = e.codegenNode;
    if (13 === t.type) return t.props;
}
function Zy(
    e,
    {
        filename: n = "",
        prefixIdentifiers: i = !1,
        hoistStatic: s = !1,
        hmr: a = !1,
        cacheHandlers: o = !1,
        nodeTransforms: c = [],
        directiveTransforms: l = {},
        transformHoist: u = null,
        isBuiltInComponent: d = r,
        isCustomElement: h = r,
        expressionPlugins: m = [],
        scopeId: p = null,
        slotted: f = !0,
        ssr: g = !1,
        inSSR: y = !1,
        ssrCssVars: w = "",
        bindingMetadata: k = t,
        inline: T = !1,
        isTS: _ = !1,
        onError: v = Sb,
        onWarn: S = Eb,
        compatConfig: E,
    }
) {
    const C = n.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/),
        I = {
            filename: n,
            selfName: C && R(P(C[1])),
            prefixIdentifiers: i,
            hoistStatic: s,
            hmr: a,
            cacheHandlers: o,
            nodeTransforms: c,
            directiveTransforms: l,
            transformHoist: u,
            isBuiltInComponent: d,
            isCustomElement: h,
            expressionPlugins: m,
            scopeId: p,
            slotted: f,
            ssr: g,
            inSSR: y,
            ssrCssVars: w,
            bindingMetadata: k,
            inline: T,
            isTS: _,
            onError: v,
            onWarn: S,
            compatConfig: E,
            root: e,
            helpers: new Map(),
            components: new Set(),
            directives: new Set(),
            hoists: [],
            imports: [],
            cached: [],
            constantCache: new WeakMap(),
            temps: 0,
            identifiers: Object.create(null),
            scopes: { vFor: 0, vSlot: 0, vPre: 0, vOnce: 0 },
            parent: null,
            grandParent: null,
            currentNode: e,
            childIndex: 0,
            inVOnce: !1,
            helper(e) {
                const t = I.helpers.get(e) || 0;
                return I.helpers.set(e, t + 1), e;
            },
            removeHelper(e) {
                const t = I.helpers.get(e);
                if (t) {
                    const n = t - 1;
                    n ? I.helpers.set(e, n) : I.helpers.delete(e);
                }
            },
            helperString: (e) => `_${Kg[I.helper(e)]}`,
            replaceNode(e) {
                I.parent.children[I.childIndex] = I.currentNode = e;
            },
            removeNode(e) {
                const t = I.parent.children,
                    n = e ? t.indexOf(e) : I.currentNode ? I.childIndex : -1;
                e && e !== I.currentNode
                    ? I.childIndex > n && (I.childIndex--, I.onNodeRemoved())
                    : ((I.currentNode = null), I.onNodeRemoved()),
                    I.parent.children.splice(n, 1);
            },
            onNodeRemoved: r,
            addIdentifiers(e) {},
            removeIdentifiers(e) {},
            hoist(e) {
                b(e) && (e = rb(e)), I.hoists.push(e);
                const t = rb(`_hoisted_${I.hoists.length}`, !1, e.loc, 2);
                return (t.hoisted = e), t;
            },
            cache(e, t = !1, n = !1) {
                const r = cb(I.cached.length, e, t, n);
                return I.cached.push(r), r;
            },
        };
    return (I.filters = new Set()), I;
}
function ew(e, t) {
    const n = Zy(e, t);
    tw(e, n),
        t.hoistStatic && Hy(e, n),
        t.ssr ||
            (function (e, t) {
                const { helper: n } = t,
                    { children: r } = e;
                if (1 === r.length) {
                    const n = qy(e);
                    if (n && n.codegenNode) {
                        const r = n.codegenNode;
                        13 === r.type && hb(r, t), (e.codegenNode = r);
                    } else e.codegenNode = r[0];
                } else if (r.length > 1) {
                    let r = 64;
                    e.codegenNode = Zg(t, n(ug), void 0, e.children, r, void 0, void 0, !0, void 0, !1);
                }
            })(e, n),
        (e.helpers = new Set([...n.helpers.keys()])),
        (e.components = [...n.components]),
        (e.directives = [...n.directives]),
        (e.imports = n.imports),
        (e.hoists = n.hoists),
        (e.temps = n.temps),
        (e.cached = n.cached),
        (e.transformed = !0),
        (e.filters = [...n.filters]);
}
function tw(e, t) {
    t.currentNode = e;
    const { nodeTransforms: n } = t,
        r = [];
    for (let s = 0; s < n.length; s++) {
        const i = n[s](e, t);
        if ((i && (d(i) ? r.push(...i) : r.push(i)), !t.currentNode)) return;
        e = t.currentNode;
    }
    switch (e.type) {
        case 3:
            t.ssr || t.helper(kg);
            break;
        case 5:
            t.ssr || t.helper(Og);
            break;
        case 9:
            for (let n = 0; n < e.branches.length; n++) tw(e.branches[n], t);
            break;
        case 10:
        case 11:
        case 1:
        case 0:
            !(function (e, t) {
                let n = 0;
                const r = () => {
                    n--;
                };
                for (; n < e.children.length; n++) {
                    const i = e.children[n];
                    b(i) ||
                        ((t.grandParent = t.parent),
                        (t.parent = e),
                        (t.childIndex = n),
                        (t.onNodeRemoved = r),
                        tw(i, t));
                }
            })(e, t);
    }
    t.currentNode = e;
    let i = r.length;
    for (; i--; ) r[i]();
}
function nw(e, t) {
    const n = b(e) ? (t) => t === e : (t) => e.test(t);
    return (e, r) => {
        if (1 === e.type) {
            const { props: i } = e;
            if (3 === e.tagType && i.some(ey)) return;
            const s = [];
            for (let a = 0; a < i.length; a++) {
                const o = i[a];
                if (7 === o.type && n(o.name)) {
                    i.splice(a, 1), a--;
                    const n = t(e, o, r);
                    n && s.push(n);
                }
            }
            return s;
        }
    };
}
const rw = "/*@__PURE__*/",
    iw = (e) => `${Kg[e]}: _${Kg[e]}`;
function sw(e, t = {}) {
    const n = (function (
        e,
        {
            mode: t = "function",
            prefixIdentifiers: n = "module" === t,
            sourceMap: r = !1,
            filename: i = "template.vue.html",
            scopeId: s = null,
            optimizeImports: a = !1,
            runtimeGlobalName: o = "Vue",
            runtimeModuleName: c = "vue",
            ssrRuntimeModuleName: l = "vue/server-renderer",
            ssr: u = !1,
            isTS: d = !1,
            inSSR: h = !1,
        }
    ) {
        const m = {
            mode: t,
            prefixIdentifiers: n,
            sourceMap: r,
            filename: i,
            scopeId: s,
            optimizeImports: a,
            runtimeGlobalName: o,
            runtimeModuleName: c,
            ssrRuntimeModuleName: l,
            ssr: u,
            isTS: d,
            inSSR: h,
            source: e.source,
            code: "",
            column: 1,
            line: 1,
            offset: 0,
            indentLevel: 0,
            pure: !1,
            map: void 0,
            helper: (e) => `_${Kg[e]}`,
            push(e, t = -2, n) {
                m.code += e;
            },
            indent() {
                p(++m.indentLevel);
            },
            deindent(e = !1) {
                e ? --m.indentLevel : p(--m.indentLevel);
            },
            newline() {
                p(m.indentLevel);
            },
        };
        function p(e) {
            m.push("\n" + "  ".repeat(e), 0);
        }
        return m;
    })(e, t);
    t.onContextCreated && t.onContextCreated(n);
    const { mode: r, push: i, prefixIdentifiers: s, indent: a, deindent: o, newline: c, scopeId: l, ssr: u } = n,
        d = Array.from(e.helpers),
        h = d.length > 0,
        m = !s && "module" !== r;
    !(function (e, t) {
        const {
                ssr: n,
                prefixIdentifiers: r,
                push: i,
                newline: s,
                runtimeModuleName: a,
                runtimeGlobalName: o,
                ssrRuntimeModuleName: c,
            } = t,
            l = o,
            u = Array.from(e.helpers);
        if (u.length > 0 && (i(`const _Vue = ${l}\n`, -1), e.hoists.length)) {
            i(
                `const { ${[yg, wg, kg, Tg, _g]
                    .filter((e) => u.includes(e))
                    .map(iw)
                    .join(", ")} } = _Vue\n`,
                -1
            );
        }
        (function (e, t) {
            if (!e.length) return;
            t.pure = !0;
            const { push: n, newline: r } = t;
            r();
            for (let i = 0; i < e.length; i++) {
                const s = e[i];
                s && (n(`const _hoisted_${i + 1} = `), lw(s, t), r());
            }
            t.pure = !1;
        })(e.hoists, t),
            s(),
            i("return ");
    })(e, n);
    if (
        (i(
            `function ${u ? "ssrRender" : "render"}(${(u ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"]).join(", ")}) {`
        ),
        a(),
        m && (i("with (_ctx) {"), a(), h && (i(`const { ${d.map(iw).join(", ")} } = _Vue\n`, -1), c())),
        e.components.length && (aw(e.components, "component", n), (e.directives.length || e.temps > 0) && c()),
        e.directives.length && (aw(e.directives, "directive", n), e.temps > 0 && c()),
        e.filters && e.filters.length && (c(), aw(e.filters, "filter", n), c()),
        e.temps > 0)
    ) {
        i("let ");
        for (let t = 0; t < e.temps; t++) i(`${t > 0 ? ", " : ""}_temp${t}`);
    }
    return (
        (e.components.length || e.directives.length || e.temps) && (i("\n", 0), c()),
        u || i("return "),
        e.codegenNode ? lw(e.codegenNode, n) : i("null"),
        m && (o(), i("}")),
        o(),
        i("}"),
        { ast: e, code: n.code, preamble: "", map: n.map ? n.map.toJSON() : void 0 }
    );
}
function aw(e, t, { helper: n, push: r, newline: i, isTS: s }) {
    const a = n("filter" === t ? Cg : "component" === t ? vg : Eg);
    for (let o = 0; o < e.length; o++) {
        let n = e[o];
        const c = n.endsWith("__self");
        c && (n = n.slice(0, -6)),
            r(`const ${oy(n, t)} = ${a}(${JSON.stringify(n)}${c ? ", true" : ""})${s ? "!" : ""}`),
            o < e.length - 1 && i();
    }
}
function ow(e, t) {
    const n = e.length > 3 || !1;
    t.push("["), n && t.indent(), cw(e, t, n), n && t.deindent(), t.push("]");
}
function cw(e, t, n = !1, r = !0) {
    const { push: i, newline: s } = t;
    for (let a = 0; a < e.length; a++) {
        const o = e[a];
        b(o) ? i(o, -3) : d(o) ? ow(o, t) : lw(o, t), a < e.length - 1 && (n ? (r && i(","), s()) : r && i(", "));
    }
}
function lw(e, t) {
    if (b(e)) t.push(e, -3);
    else if (y(e)) t.push(t.helper(e));
    else
        switch (e.type) {
            case 1:
            case 9:
            case 11:
            case 12:
                lw(e.codegenNode, t);
                break;
            case 2:
                !(function (e, t) {
                    t.push(JSON.stringify(e.content), -3, e);
                })(e, t);
                break;
            case 4:
                uw(e, t);
                break;
            case 5:
                !(function (e, t) {
                    const { push: n, helper: r, pure: i } = t;
                    i && n(rw);
                    n(`${r(Og)}(`), lw(e.content, t), n(")");
                })(e, t);
                break;
            case 8:
                dw(e, t);
                break;
            case 3:
                !(function (e, t) {
                    const { push: n, helper: r, pure: i } = t;
                    i && n(rw);
                    n(`${r(kg)}(${JSON.stringify(e.content)})`, -3, e);
                })(e, t);
                break;
            case 13:
                !(function (e, t) {
                    const { push: n, helper: r, pure: i } = t,
                        {
                            tag: s,
                            props: a,
                            children: o,
                            patchFlag: c,
                            dynamicProps: l,
                            directives: u,
                            isBlock: d,
                            disableTracking: h,
                            isComponent: m,
                        } = e;
                    let p;
                    c && (p = String(c));
                    u && n(r(Ig) + "(");
                    d && n(`(${r(fg)}(${h ? "true" : ""}), `);
                    i && n(rw);
                    const f = d ? db(t.inSSR, m) : ub(t.inSSR, m);
                    n(r(f) + "(", -2, e),
                        cw(
                            (function (e) {
                                let t = e.length;
                                for (; t-- && null == e[t]; );
                                return e.slice(0, t + 1).map((e) => e || "null");
                            })([s, a, o, p, l]),
                            t
                        ),
                        n(")"),
                        d && n(")");
                    u && (n(", "), lw(u, t), n(")"));
                })(e, t);
                break;
            case 14:
                !(function (e, t) {
                    const { push: n, helper: r, pure: i } = t,
                        s = b(e.callee) ? e.callee : r(e.callee);
                    i && n(rw);
                    n(s + "(", -2, e), cw(e.arguments, t), n(")");
                })(e, t);
                break;
            case 15:
                !(function (e, t) {
                    const { push: n, indent: r, deindent: i, newline: s } = t,
                        { properties: a } = e;
                    if (!a.length) return void n("{}", -2, e);
                    const o = a.length > 1 || !1;
                    n(o ? "{" : "{ "), o && r();
                    for (let c = 0; c < a.length; c++) {
                        const { key: e, value: r } = a[c];
                        hw(e, t), n(": "), lw(r, t), c < a.length - 1 && (n(","), s());
                    }
                    o && i(), n(o ? "}" : " }");
                })(e, t);
                break;
            case 17:
                !(function (e, t) {
                    ow(e.elements, t);
                })(e, t);
                break;
            case 18:
                !(function (e, t) {
                    const { push: n, indent: r, deindent: i } = t,
                        { params: s, returns: a, body: o, newline: c, isSlot: l } = e;
                    l && n(`_${Kg[jg]}(`);
                    n("(", -2, e), d(s) ? cw(s, t) : s && lw(s, t);
                    n(") => "), (c || o) && (n("{"), r());
                    a ? (c && n("return "), d(a) ? ow(a, t) : lw(a, t)) : o && lw(o, t);
                    (c || o) && (i(), n("}"));
                    l && (e.isNonScopedSlot && n(", undefined, true"), n(")"));
                })(e, t);
                break;
            case 19:
                !(function (e, t) {
                    const { test: n, consequent: r, alternate: i, newline: s } = e,
                        { push: a, indent: o, deindent: c, newline: l } = t;
                    if (4 === n.type) {
                        const e = !Fb(n.content);
                        e && a("("), uw(n, t), e && a(")");
                    } else a("("), lw(n, t), a(")");
                    s && o(),
                        t.indentLevel++,
                        s || a(" "),
                        a("? "),
                        lw(r, t),
                        t.indentLevel--,
                        s && l(),
                        s || a(" "),
                        a(": ");
                    const u = 19 === i.type;
                    u || t.indentLevel++;
                    lw(i, t), u || t.indentLevel--;
                    s && c(!0);
                })(e, t);
                break;
            case 20:
                !(function (e, t) {
                    const { push: n, helper: r, indent: i, deindent: s, newline: a } = t,
                        { needPauseTracking: o, needArraySpread: c } = e;
                    c && n("[...(");
                    n(`_cache[${e.index}] || (`),
                        o && (i(), n(`${r($g)}(-1`), e.inVOnce && n(", true"), n("),"), a(), n("("));
                    n(`_cache[${e.index}] = `),
                        lw(e.value, t),
                        o &&
                            (n(`).cacheIndex = ${e.index},`),
                            a(),
                            n(`${r($g)}(1),`),
                            a(),
                            n(`_cache[${e.index}]`),
                            s());
                    n(")"), c && n(")]");
                })(e, t);
                break;
            case 21:
                cw(e.body, t, !0, !1);
        }
}
function uw(e, t) {
    const { content: n, isStatic: r } = e;
    t.push(r ? JSON.stringify(n) : n, -3, e);
}
function dw(e, t) {
    for (let n = 0; n < e.children.length; n++) {
        const r = e.children[n];
        b(r) ? t.push(r, -3) : lw(r, t);
    }
}
function hw(e, t) {
    const { push: n } = t;
    if (8 === e.type) n("["), dw(e, t), n("]");
    else if (e.isStatic) {
        n(Fb(e.content) ? e.content : JSON.stringify(e.content), -2, e);
    } else n(`[${e.content}]`, -3, e);
}
new RegExp(
    "\\b" +
        "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield"
            .split(",")
            .join("\\b|\\b") +
        "\\b"
);
function mw(e, t, n = !1, r = !1, i = Object.create(t.identifiers)) {
    return e;
}
const pw = nw(/^(if|else|else-if)$/, (e, t, n) =>
    fw(e, t, n, (e, t, r) => {
        const i = n.parent.children;
        let s = i.indexOf(e),
            a = 0;
        for (; s-- >= 0; ) {
            const e = i[s];
            e && 9 === e.type && (a += e.branches.length);
        }
        return () => {
            if (r) e.codegenNode = bw(t, a, n);
            else {
                const r = (function (e) {
                    for (;;)
                        if (19 === e.type) {
                            if (19 !== e.alternate.type) return e;
                            e = e.alternate;
                        } else 20 === e.type && (e = e.value);
                })(e.codegenNode);
                r.alternate = bw(t, a + e.branches.length - 1, n);
            }
        };
    })
);
function fw(e, t, n, r) {
    if (!("else" === t.name || (t.exp && t.exp.content.trim()))) {
        const r = t.exp ? t.exp.loc : e.loc;
        n.onError(Cb(28, t.loc)), (t.exp = rb("true", !1, r));
    }
    if ("if" === t.name) {
        const s = gw(e, t),
            a = { type: 9, loc: ((i = e.loc), zy(i.start.offset, i.end.offset)), branches: [s] };
        if ((n.replaceNode(a), r)) return r(a, s, !0);
    } else {
        const i = n.parent.children;
        let s = i.indexOf(e);
        for (; s-- >= -1; ) {
            const a = i[s];
            if (a && 3 === a.type) n.removeNode(a);
            else {
                if (!a || 2 !== a.type || a.content.trim().length) {
                    if (a && 9 === a.type) {
                        "else-if" === t.name &&
                            void 0 === a.branches[a.branches.length - 1].condition &&
                            n.onError(Cb(30, e.loc)),
                            n.removeNode();
                        const i = gw(e, t);
                        a.branches.push(i);
                        const s = r && r(a, i, !1);
                        tw(i, n), s && s(), (n.currentNode = null);
                    } else n.onError(Cb(30, e.loc));
                    break;
                }
                n.removeNode(a);
            }
        }
    }
    var i;
}
function gw(e, t) {
    const n = 3 === e.tagType;
    return {
        type: 10,
        loc: e.loc,
        condition: "else" === t.name ? void 0 : t.exp,
        children: n && !Kb(e, "for") ? e.children : [e],
        userKey: Yb(e, "key"),
        isTemplateIf: n,
    };
}
function bw(e, t, n) {
    return e.condition ? ob(e.condition, yw(e, t, n), sb(n.helper(kg), ['""', "true"])) : yw(e, t, n);
}
function yw(e, t, n) {
    const { helper: r } = n,
        i = nb("key", rb(`${t}`, !1, Qg, 2)),
        { children: s } = e,
        a = s[0];
    if (1 !== s.length || 1 !== a.type) {
        if (1 === s.length && 11 === a.type) {
            const e = a.codegenNode;
            return sy(e, i, n), e;
        }
        {
            let t = 64;
            return Zg(n, r(ug), tb([i]), s, t, void 0, void 0, !0, !1, !1, e.loc);
        }
    }
    {
        const e = a.codegenNode,
            t = cy(e);
        return 13 === t.type && hb(t, n), sy(t, i, n), e;
    }
}
const ww = (e, t, n) => {
        const { modifiers: r, loc: i } = e,
            s = e.arg;
        let { exp: a } = e;
        if ((a && 4 === a.type && !a.content.trim() && (a = void 0), !a)) {
            if (4 !== s.type || !s.isStatic) return n.onError(Cb(52, s.loc)), { props: [nb(s, rb("", !0, i))] };
            kw(e), (a = e.exp);
        }
        return (
            4 !== s.type
                ? (s.children.unshift("("), s.children.push(') || ""'))
                : s.isStatic || (s.content = `${s.content} || ""`),
            r.some((e) => "camel" === e.content) &&
                (4 === s.type
                    ? s.isStatic
                        ? (s.content = P(s.content))
                        : (s.content = `${n.helperString(Bg)}(${s.content})`)
                    : (s.children.unshift(`${n.helperString(Bg)}(`), s.children.push(")"))),
            n.inSSR ||
                (r.some((e) => "prop" === e.content) && Tw(s, "."), r.some((e) => "attr" === e.content) && Tw(s, "^")),
            { props: [nb(s, a)] }
        );
    },
    kw = (e, t) => {
        const n = e.arg,
            r = P(n.content);
        e.exp = rb(r, !1, n.loc);
    },
    Tw = (e, t) => {
        4 === e.type
            ? e.isStatic
                ? (e.content = t + e.content)
                : (e.content = `\`${t}\${${e.content}}\``)
            : (e.children.unshift(`'${t}' + (`), e.children.push(")"));
    },
    _w = nw("for", (e, t, n) => {
        const { helper: r, removeHelper: i } = n;
        return vw(e, t, n, (t) => {
            const s = sb(r(xg), [t.source]),
                a = ty(e),
                o = Kb(e, "memo"),
                c = Yb(e, "key", !1, !0);
            c && 7 === c.type && !c.exp && kw(c);
            let l = c && (6 === c.type ? (c.value ? rb(c.value.content, !0) : void 0) : c.exp);
            const u = c && l ? nb("key", l) : null,
                d = 4 === t.source.type && t.source.constType > 0,
                h = d ? 64 : c ? 128 : 256;
            return (
                (t.codegenNode = Zg(n, r(ug), void 0, s, h, void 0, void 0, !0, !d, !1, e.loc)),
                () => {
                    let c;
                    const { children: h } = t,
                        m = 1 !== h.length || 1 !== h[0].type,
                        p = ny(e) ? e : a && 1 === e.children.length && ny(e.children[0]) ? e.children[0] : null;
                    if (
                        (p
                            ? ((c = p.codegenNode), a && u && sy(c, u, n))
                            : m
                              ? (c = Zg(n, r(ug), u ? tb([u]) : void 0, e.children, 64, void 0, void 0, !0, void 0, !1))
                              : ((c = h[0].codegenNode),
                                a && u && sy(c, u, n),
                                c.isBlock !== !d &&
                                    (c.isBlock
                                        ? (i(fg), i(db(n.inSSR, c.isComponent)))
                                        : i(ub(n.inSSR, c.isComponent))),
                                (c.isBlock = !d),
                                c.isBlock ? (r(fg), r(db(n.inSSR, c.isComponent))) : r(ub(n.inSSR, c.isComponent))),
                        o)
                    ) {
                        const e = ab(Ew(t.parseResult, [rb("_cached")]));
                        (e.body = lb([
                            ib(["const _memo = (", o.exp, ")"]),
                            ib([
                                "if (_cached",
                                ...(l ? [" && _cached.key === ", l] : []),
                                ` && ${n.helperString(Gg)}(_cached, _memo)) return _cached`,
                            ]),
                            ib(["const _item = ", c]),
                            rb("_item.memo = _memo"),
                            rb("return _item"),
                        ])),
                            s.arguments.push(e, rb("_cache"), rb(String(n.cached.length))),
                            n.cached.push(null);
                    } else s.arguments.push(ab(Ew(t.parseResult), c, !0));
                }
            );
        });
    });
function vw(e, t, n, r) {
    if (!t.exp) return void n.onError(Cb(31, t.loc));
    const i = t.forParseResult;
    if (!i) return void n.onError(Cb(32, t.loc));
    Sw(i);
    const { addIdentifiers: s, removeIdentifiers: a, scopes: o } = n,
        { source: c, value: l, key: u, index: d } = i,
        h = {
            type: 11,
            loc: t.loc,
            source: c,
            valueAlias: l,
            keyAlias: u,
            objectIndexAlias: d,
            parseResult: i,
            children: ty(e) ? e.children : [e],
        };
    n.replaceNode(h), o.vFor++;
    const m = r && r(h);
    return () => {
        o.vFor--, m && m();
    };
}
function Sw(e, t) {
    e.finalized || (e.finalized = !0);
}
function Ew({ value: e, key: t, index: n }, r = []) {
    return (function (e) {
        let t = e.length;
        for (; t-- && !e[t]; );
        return e.slice(0, t + 1).map((e, t) => e || rb("_".repeat(t + 1), !1));
    })([e, t, n, ...r]);
}
const Cw = rb("undefined", !1),
    Iw = (e, t) => {
        if (1 === e.type && (1 === e.tagType || 3 === e.tagType)) {
            const n = Kb(e, "slot");
            if (n)
                return (
                    n.exp,
                    t.scopes.vSlot++,
                    () => {
                        t.scopes.vSlot--;
                    }
                );
        }
    },
    xw = (e, t, n, r) => ab(e, n, !1, !0, n.length ? n[0].loc : r);
function Aw(e, t, n = xw) {
    t.helper(jg);
    const { children: r, loc: i } = e,
        s = [],
        a = [];
    let o = t.scopes.vSlot > 0 || t.scopes.vFor > 0;
    const c = Kb(e, "slot", !0);
    if (c) {
        const { arg: e, exp: t } = c;
        e && !Rb(e) && (o = !0), s.push(nb(e || rb("default", !0), n(t, void 0, r, i)));
    }
    let l = !1,
        u = !1;
    const d = [],
        h = new Set();
    let m = 0;
    for (let g = 0; g < r.length; g++) {
        const e = r[g];
        let i;
        if (!ty(e) || !(i = Kb(e, "slot", !0))) {
            3 !== e.type && d.push(e);
            continue;
        }
        if (c) {
            t.onError(Cb(37, i.loc));
            break;
        }
        l = !0;
        const { children: p, loc: f } = e,
            { arg: b = rb("default", !0), exp: y, loc: w } = i;
        let k;
        Rb(b) ? (k = b ? b.content : "default") : (o = !0);
        const T = Kb(e, "for"),
            _ = n(y, T, p, f);
        let v, S;
        if ((v = Kb(e, "if"))) (o = !0), a.push(ob(v.exp, Pw(b, _, m++), Cw));
        else if ((S = Kb(e, /^else(-if)?$/, !0))) {
            let e,
                n = g;
            for (; n-- && ((e = r[n]), 3 === e.type || !Nw(e)); );
            if (e && ty(e) && Kb(e, /^(else-)?if$/)) {
                let e = a[a.length - 1];
                for (; 19 === e.alternate.type; ) e = e.alternate;
                e.alternate = S.exp ? ob(S.exp, Pw(b, _, m++), Cw) : Pw(b, _, m++);
            } else t.onError(Cb(30, S.loc));
        } else if (T) {
            o = !0;
            const e = T.forParseResult;
            e ? (Sw(e), a.push(sb(t.helper(xg), [e.source, ab(Ew(e), Pw(b, _), !0)]))) : t.onError(Cb(32, T.loc));
        } else {
            if (k) {
                if (h.has(k)) {
                    t.onError(Cb(38, w));
                    continue;
                }
                h.add(k), "default" === k && (u = !0);
            }
            s.push(nb(b, _));
        }
    }
    if (!c) {
        const e = (e, r) => {
            const s = n(e, void 0, r, i);
            return t.compatConfig && (s.isNonScopedSlot = !0), nb("default", s);
        };
        l
            ? d.length && d.some((e) => Nw(e)) && (u ? t.onError(Cb(39, d[0].loc)) : s.push(e(void 0, d)))
            : s.push(e(void 0, r));
    }
    const p = o ? 2 : Ow(e.children) ? 3 : 1;
    let f = tb(s.concat(nb("_", rb(p + "", !1))), i);
    return a.length && (f = sb(t.helper(Pg), [f, eb(a)])), { slots: f, hasDynamicSlots: o };
}
function Pw(e, t, n) {
    const r = [nb("name", e), nb("fn", t)];
    return null != n && r.push(nb("key", rb(String(n), !0))), tb(r);
}
function Ow(e) {
    for (let t = 0; t < e.length; t++) {
        const n = e[t];
        switch (n.type) {
            case 1:
                if (2 === n.tagType || Ow(n.children)) return !0;
                break;
            case 9:
                if (Ow(n.branches)) return !0;
                break;
            case 10:
            case 11:
                if (Ow(n.children)) return !0;
        }
    }
    return !1;
}
function Nw(e) {
    return (2 !== e.type && 12 !== e.type) || (2 === e.type ? !!e.content.trim() : Nw(e.content));
}
const Rw = new WeakMap(),
    Mw = (e, t) =>
        function () {
            if (1 !== (e = t.currentNode).type || (0 !== e.tagType && 1 !== e.tagType)) return;
            const { tag: n, props: r } = e,
                i = 1 === e.tagType;
            let s = i ? Dw(e, t) : `"${n}"`;
            const a = w(s) && s.callee === Sg;
            let o,
                c,
                l,
                u,
                d,
                h = 0,
                m = a || s === dg || s === hg || (!i && ("svg" === n || "foreignObject" === n || "math" === n));
            if (r.length > 0) {
                const n = Fw(e, t, void 0, i, a);
                (o = n.props), (h = n.patchFlag), (u = n.dynamicPropNames);
                const r = n.directives;
                (d = r && r.length ? eb(r.map((e) => zw(e, t))) : void 0), n.shouldUseBlock && (m = !0);
            }
            if (e.children.length > 0) {
                s === mg && ((m = !0), (h |= 1024));
                if (i && s !== dg && s !== mg) {
                    const { slots: n, hasDynamicSlots: r } = Aw(e, t);
                    (c = n), r && (h |= 1024);
                } else if (1 === e.children.length && s !== dg) {
                    const n = e.children[0],
                        r = n.type,
                        i = 5 === r || 8 === r;
                    i && 0 === Gy(n, t) && (h |= 1), (c = i || 2 === r ? n : e.children);
                } else c = e.children;
            }
            u &&
                u.length &&
                (l = (function (e) {
                    let t = "[";
                    for (let n = 0, r = e.length; n < r; n++) (t += JSON.stringify(e[n])), n < r - 1 && (t += ", ");
                    return t + "]";
                })(u)),
                (e.codegenNode = Zg(t, s, o, c, 0 === h ? void 0 : h, l, d, !!m, !1, i, e.loc));
        };
function Dw(e, t, n = !1) {
    let { tag: r } = e;
    const i = Uw(r),
        s = Yb(e, "is", !1, !0);
    if (s)
        if (i || _b("COMPILER_IS_ON_ELEMENT", t)) {
            let e;
            if (
                (6 === s.type
                    ? (e = s.value && rb(s.value.content, !0))
                    : ((e = s.exp), e || (e = rb("is", !1, s.arg.loc))),
                e)
            )
                return sb(t.helper(Sg), [e]);
        } else 6 === s.type && s.value.content.startsWith("vue:") && (r = s.value.content.slice(4));
    const a = Mb(r) || t.isBuiltInComponent(r);
    return a ? (n || t.helper(a), a) : (t.helper(vg), t.components.add(r), oy(r, "component"));
}
function Fw(e, t, n = e.props, r, i, a = !1) {
    const { tag: o, loc: c, children: l } = e;
    let u = [];
    const d = [],
        h = [],
        m = l.length > 0;
    let p = !1,
        f = 0,
        g = !1,
        b = !1,
        w = !1,
        k = !1,
        T = !1,
        _ = !1;
    const v = [],
        S = (e) => {
            u.length && (d.push(tb(Lw(u), c)), (u = [])), e && d.push(e);
        },
        E = () => {
            t.scopes.vFor > 0 && u.push(nb(rb("ref_for", !0), rb("true")));
        },
        x = ({ key: e, value: n }) => {
            if (Rb(e)) {
                const a = e.content,
                    o = s(a);
                if (
                    (!o ||
                        (r && !i) ||
                        "onclick" === a.toLowerCase() ||
                        "onUpdate:modelValue" === a ||
                        C(a) ||
                        (k = !0),
                    o && C(a) && (_ = !0),
                    o && 14 === n.type && (n = n.arguments[0]),
                    20 === n.type || ((4 === n.type || 8 === n.type) && Gy(n, t) > 0))
                )
                    return;
                "ref" === a
                    ? (g = !0)
                    : "class" === a
                      ? (b = !0)
                      : "style" === a
                        ? (w = !0)
                        : "key" === a || v.includes(a) || v.push(a),
                    !r || ("class" !== a && "style" !== a) || v.includes(a) || v.push(a);
            } else T = !0;
        };
    for (let s = 0; s < n.length; s++) {
        const i = n[s];
        if (6 === i.type) {
            const { loc: e, name: n, nameLoc: r, value: s } = i;
            let a = !0;
            if (
                ("ref" === n && ((g = !0), E()),
                "is" === n && (Uw(o) || (s && s.content.startsWith("vue:")) || _b("COMPILER_IS_ON_ELEMENT", t)))
            )
                continue;
            u.push(nb(rb(n, !0, r), rb(s ? s.content : "", a, s ? s.loc : e)));
        } else {
            const { name: n, arg: s, exp: l, loc: g, modifiers: b } = i,
                w = "bind" === n,
                k = "on" === n;
            if ("slot" === n) {
                r || t.onError(Cb(40, g));
                continue;
            }
            if ("once" === n || "memo" === n) continue;
            if ("is" === n || (w && Qb(s, "is") && (Uw(o) || _b("COMPILER_IS_ON_ELEMENT", t)))) continue;
            if (k && a) continue;
            if (
                (((w && Qb(s, "key")) || (k && m && Qb(s, "vue:before-update"))) && (p = !0),
                w && Qb(s, "ref") && E(),
                !s && (w || k))
            ) {
                if (((T = !0), l))
                    if (w) {
                        if ((S(), _b("COMPILER_V_BIND_OBJECT_ORDER", t))) {
                            d.unshift(l);
                            continue;
                        }
                        E(), S(), d.push(l);
                    } else S({ type: 14, loc: g, callee: t.helper(Lg), arguments: r ? [l] : [l, "true"] });
                else t.onError(Cb(w ? 34 : 35, g));
                continue;
            }
            w && b.some((e) => "prop" === e.content) && (f |= 32);
            const _ = t.directiveTransforms[n];
            if (_) {
                const { props: n, needRuntime: r } = _(i, e, t);
                !a && n.forEach(x),
                    k && s && !Rb(s) ? S(tb(n, c)) : u.push(...n),
                    r && (h.push(i), y(r) && Rw.set(i, r));
            } else I(n) || (h.push(i), m && (p = !0));
        }
    }
    let A;
    if (
        (d.length ? (S(), (A = d.length > 1 ? sb(t.helper(Ng), d, c) : d[0])) : u.length && (A = tb(Lw(u), c)),
        T ? (f |= 16) : (b && !r && (f |= 2), w && !r && (f |= 4), v.length && (f |= 8), k && (f |= 32)),
        p || (0 !== f && 32 !== f) || !(g || _ || h.length > 0) || (f |= 512),
        !t.inSSR && A)
    )
        switch (A.type) {
            case 15:
                let e = -1,
                    n = -1,
                    r = !1;
                for (let t = 0; t < A.properties.length; t++) {
                    const i = A.properties[t].key;
                    Rb(i)
                        ? "class" === i.content
                            ? (e = t)
                            : "style" === i.content && (n = t)
                        : i.isHandlerKey || (r = !0);
                }
                const i = A.properties[e],
                    s = A.properties[n];
                r
                    ? (A = sb(t.helper(Dg), [A]))
                    : (i && !Rb(i.value) && (i.value = sb(t.helper(Rg), [i.value])),
                      s &&
                          (w || (4 === s.value.type && "[" === s.value.content.trim()[0]) || 17 === s.value.type) &&
                          (s.value = sb(t.helper(Mg), [s.value])));
                break;
            case 14:
                break;
            default:
                A = sb(t.helper(Dg), [sb(t.helper(Fg), [A])]);
        }
    return { props: A, directives: h, patchFlag: f, dynamicPropNames: v, shouldUseBlock: p };
}
function Lw(e) {
    const t = new Map(),
        n = [];
    for (let r = 0; r < e.length; r++) {
        const i = e[r];
        if (8 === i.key.type || !i.key.isStatic) {
            n.push(i);
            continue;
        }
        const a = i.key.content,
            o = t.get(a);
        o ? ("style" === a || "class" === a || s(a)) && Bw(o, i) : (t.set(a, i), n.push(i));
    }
    return n;
}
function Bw(e, t) {
    17 === e.value.type ? e.value.elements.push(t.value) : (e.value = eb([e.value, t.value], e.loc));
}
function zw(e, t) {
    const n = [],
        r = Rw.get(e);
    r ? n.push(t.helperString(r)) : (t.helper(Eg), t.directives.add(e.name), n.push(oy(e.name, "directive")));
    const { loc: i } = e;
    if (
        (e.exp && n.push(e.exp), e.arg && (e.exp || n.push("void 0"), n.push(e.arg)), Object.keys(e.modifiers).length)
    ) {
        e.arg || (e.exp || n.push("void 0"), n.push("void 0"));
        const t = rb("true", !1, i);
        n.push(
            tb(
                e.modifiers.map((e) => nb(e, t)),
                i
            )
        );
    }
    return eb(n, e.loc);
}
function Uw(e) {
    return "component" === e || "Component" === e;
}
const $w = (e, t) => {
    if (ny(e)) {
        const { children: n, loc: r } = e,
            { slotName: i, slotProps: s } = Vw(e, t),
            a = [t.prefixIdentifiers ? "_ctx.$slots" : "$slots", i, "{}", "undefined", "true"];
        let o = 2;
        s && ((a[2] = s), (o = 3)),
            n.length && ((a[3] = ab([], n, !1, !1, r)), (o = 4)),
            t.scopeId && !t.slotted && (o = 5),
            a.splice(o),
            (e.codegenNode = sb(t.helper(Ag), a, r));
    }
};
function Vw(e, t) {
    let n,
        r = '"default"';
    const i = [];
    for (let s = 0; s < e.props.length; s++) {
        const t = e.props[s];
        if (6 === t.type)
            t.value && ("name" === t.name ? (r = JSON.stringify(t.value.content)) : ((t.name = P(t.name)), i.push(t)));
        else if ("bind" === t.name && Qb(t.arg, "name")) {
            if (t.exp) r = t.exp;
            else if (t.arg && 4 === t.arg.type) {
                const e = P(t.arg.content);
                r = t.exp = rb(e, !1, t.arg.loc);
            }
        } else "bind" === t.name && t.arg && Rb(t.arg) && (t.arg.content = P(t.arg.content)), i.push(t);
    }
    if (i.length > 0) {
        const { props: r, directives: s } = Fw(e, t, i, !1, !1);
        (n = r), s.length && t.onError(Cb(36, s[0].loc));
    }
    return { slotName: r, slotProps: n };
}
const Ww = (e, t, n, r) => {
        const { loc: i, modifiers: s, arg: a } = e;
        let o;
        if ((e.exp || s.length || n.onError(Cb(35, i)), 4 === a.type))
            if (a.isStatic) {
                let e = a.content;
                e.startsWith("vue:") && (e = `vnode-${e.slice(4)}`);
                o = rb(0 !== t.tagType || e.startsWith("vnode") || !/[A-Z]/.test(e) ? M(P(e)) : `on:${e}`, !0, a.loc);
            } else o = ib([`${n.helperString(Ug)}(`, a, ")"]);
        else (o = a), o.children.unshift(`${n.helperString(Ug)}(`), o.children.push(")");
        let c = e.exp;
        c && !c.content.trim() && (c = void 0);
        let l = n.cacheHandlers && !c && !n.inVOnce;
        if (c) {
            const e = Wb(c),
                t = !(e || Xb(c)),
                n = c.content.includes(";");
            (t || (l && e)) && (c = ib([`${t ? "$event" : "(...args)"} => ${n ? "{" : "("}`, c, n ? "}" : ")"]));
        }
        let u = { props: [nb(o, c || rb("() => {}", !1, i))] };
        return (
            r && (u = r(u)),
            l && (u.props[0].value = n.cache(u.props[0].value)),
            u.props.forEach((e) => (e.key.isHandlerKey = !0)),
            u
        );
    },
    jw = (e, t) => {
        if (0 === e.type || 1 === e.type || 11 === e.type || 10 === e.type)
            return () => {
                const n = e.children;
                let r,
                    i = !1;
                for (let e = 0; e < n.length; e++) {
                    const t = n[e];
                    if (Zb(t)) {
                        i = !0;
                        for (let i = e + 1; i < n.length; i++) {
                            const s = n[i];
                            if (!Zb(s)) {
                                r = void 0;
                                break;
                            }
                            r || (r = n[e] = ib([t], t.loc)), r.children.push(" + ", s), n.splice(i, 1), i--;
                        }
                    }
                }
                if (
                    i &&
                    (1 !== n.length ||
                        (0 !== e.type &&
                            (1 !== e.type ||
                                0 !== e.tagType ||
                                e.props.find((e) => 7 === e.type && !t.directiveTransforms[e.name]) ||
                                "template" === e.tag)))
                )
                    for (let e = 0; e < n.length; e++) {
                        const r = n[e];
                        if (Zb(r) || 8 === r.type) {
                            const i = [];
                            (2 === r.type && " " === r.content) || i.push(r),
                                t.ssr || 0 !== Gy(r, t) || i.push("1"),
                                (n[e] = { type: 12, content: r, loc: r.loc, codegenNode: sb(t.helper(Tg), i) });
                        }
                    }
            };
    },
    Hw = new WeakSet(),
    qw = (e, t) => {
        if (1 === e.type && Kb(e, "once", !0)) {
            if (Hw.has(e) || t.inVOnce || t.inSSR) return;
            return (
                Hw.add(e),
                (t.inVOnce = !0),
                t.helper($g),
                () => {
                    t.inVOnce = !1;
                    const e = t.currentNode;
                    e.codegenNode && (e.codegenNode = t.cache(e.codegenNode, !0, !0));
                }
            );
        }
    },
    Xw = (e, t, n) => {
        const { exp: r, arg: i } = e;
        if (!r) return n.onError(Cb(41, e.loc)), Gw();
        const s = r.loc.source.trim(),
            a = 4 === r.type ? r.content : s,
            o = n.bindingMetadata[s];
        if ("props" === o || "props-aliased" === o) return n.onError(Cb(44, r.loc)), Gw();
        if (!a.trim() || !Wb(r)) return n.onError(Cb(42, r.loc)), Gw();
        const c = i || rb("modelValue", !0),
            l = i ? (Rb(i) ? `onUpdate:${P(i.content)}` : ib(['"onUpdate:" + ', i])) : "onUpdate:modelValue";
        let u;
        u = ib([`${n.isTS ? "($event: any)" : "$event"} => ((`, r, ") = $event)"]);
        const d = [nb(c, e.exp), nb(l, u)];
        if (e.modifiers.length && 1 === t.tagType) {
            const t = e.modifiers
                    .map((e) => e.content)
                    .map((e) => (Fb(e) ? e : JSON.stringify(e)) + ": true")
                    .join(", "),
                n = i ? (Rb(i) ? `${i.content}Modifiers` : ib([i, ' + "Modifiers"'])) : "modelModifiers";
            d.push(nb(n, rb(`{ ${t} }`, !1, e.loc, 2)));
        }
        return Gw(d);
    };
function Gw(e = []) {
    return { props: e };
}
const Kw = /[\w).+\-_$\]]/,
    Yw = (e, t) => {
        _b("COMPILER_FILTERS", t) &&
            (5 === e.type
                ? Qw(e.content, t)
                : 1 === e.type &&
                  e.props.forEach((e) => {
                      7 === e.type && "for" !== e.name && e.exp && Qw(e.exp, t);
                  }));
    };
function Qw(e, t) {
    if (4 === e.type) Jw(e, t);
    else
        for (let n = 0; n < e.children.length; n++) {
            const r = e.children[n];
            "object" == typeof r &&
                (4 === r.type ? Jw(r, t) : 8 === r.type ? Qw(e, t) : 5 === r.type && Qw(r.content, t));
        }
}
function Jw(e, t) {
    const n = e.content;
    let r,
        i,
        s,
        a,
        o = !1,
        c = !1,
        l = !1,
        u = !1,
        d = 0,
        h = 0,
        m = 0,
        p = 0,
        f = [];
    for (s = 0; s < n.length; s++)
        if (((i = r), (r = n.charCodeAt(s)), o)) 39 === r && 92 !== i && (o = !1);
        else if (c) 34 === r && 92 !== i && (c = !1);
        else if (l) 96 === r && 92 !== i && (l = !1);
        else if (u) 47 === r && 92 !== i && (u = !1);
        else if (124 !== r || 124 === n.charCodeAt(s + 1) || 124 === n.charCodeAt(s - 1) || d || h || m) {
            switch (r) {
                case 34:
                    c = !0;
                    break;
                case 39:
                    o = !0;
                    break;
                case 96:
                    l = !0;
                    break;
                case 40:
                    m++;
                    break;
                case 41:
                    m--;
                    break;
                case 91:
                    h++;
                    break;
                case 93:
                    h--;
                    break;
                case 123:
                    d++;
                    break;
                case 125:
                    d--;
            }
            if (47 === r) {
                let e,
                    t = s - 1;
                for (; t >= 0 && ((e = n.charAt(t)), " " === e); t--);
                (e && Kw.test(e)) || (u = !0);
            }
        } else void 0 === a ? ((p = s + 1), (a = n.slice(0, s).trim())) : g();
    function g() {
        f.push(n.slice(p, s).trim()), (p = s + 1);
    }
    if ((void 0 === a ? (a = n.slice(0, s).trim()) : 0 !== p && g(), f.length)) {
        for (s = 0; s < f.length; s++) a = Zw(a, f[s], t);
        (e.content = a), (e.ast = void 0);
    }
}
function Zw(e, t, n) {
    n.helper(Cg);
    const r = t.indexOf("(");
    if (r < 0) return n.filters.add(t), `${oy(t, "filter")}(${e})`;
    {
        const i = t.slice(0, r),
            s = t.slice(r + 1);
        return n.filters.add(i), `${oy(i, "filter")}(${e}${")" !== s ? "," + s : s}`;
    }
}
const ek = new WeakSet(),
    tk = (e, t) => {
        if (1 === e.type) {
            const n = Kb(e, "memo");
            if (!n || ek.has(e)) return;
            return (
                ek.add(e),
                () => {
                    const r = e.codegenNode || t.currentNode.codegenNode;
                    r &&
                        13 === r.type &&
                        (1 !== e.tagType && hb(r, t),
                        (e.codegenNode = sb(t.helper(Xg), [n.exp, ab(void 0, r), "_cache", String(t.cached.length)])),
                        t.cached.push(null));
                }
            );
        }
    };
function nk(e) {
    return [[qw, pw, tk, _w, Yw, $w, Mw, Iw, jw], { on: Ww, bind: ww, model: Xw }];
}
function rk(e, t = {}) {
    const n = t.onError || Sb,
        r = "module" === t.mode;
    !0 === t.prefixIdentifiers ? n(Cb(47)) : r && n(Cb(48));
    t.cacheHandlers && n(Cb(49)), t.scopeId && !r && n(Cb(50));
    const i = o({}, t, { prefixIdentifiers: !1 }),
        s = b(e) ? jy(e, i) : e,
        [a, c] = nk();
    return (
        ew(
            s,
            o({}, i, {
                nodeTransforms: [...a, ...(t.nodeTransforms || [])],
                directiveTransforms: o({}, c, t.directiveTransforms || {}),
            })
        ),
        sw(s, i)
    );
}
const ik = () => ({ props: [] }),
    sk = Symbol(""),
    ak = Symbol(""),
    ok = Symbol(""),
    ck = Symbol(""),
    lk = Symbol(""),
    uk = Symbol(""),
    dk = Symbol(""),
    hk = Symbol(""),
    mk = Symbol(""),
    pk = Symbol("");
let fk;
Yg({
    [sk]: "vModelRadio",
    [ak]: "vModelCheckbox",
    [ok]: "vModelText",
    [ck]: "vModelSelect",
    [lk]: "vModelDynamic",
    [uk]: "withModifiers",
    [dk]: "withKeys",
    [hk]: "vShow",
    [mk]: "Transition",
    [pk]: "TransitionGroup",
});
const gk = {
        parseMode: "html",
        isVoidTag: ie,
        isNativeTag: (e) => te(e) || ne(e) || re(e),
        isPreTag: (e) => "pre" === e,
        isIgnoreNewlineTag: (e) => "pre" === e || "textarea" === e,
        decodeEntities: function (e, t = !1) {
            return (
                fk || (fk = document.createElement("div")),
                t
                    ? ((fk.innerHTML = `<div foo="${e.replace(/"/g, "&quot;")}">`), fk.children[0].getAttribute("foo"))
                    : ((fk.innerHTML = e), fk.textContent)
            );
        },
        isBuiltInComponent: (e) =>
            "Transition" === e || "transition" === e
                ? mk
                : "TransitionGroup" === e || "transition-group" === e
                  ? pk
                  : void 0,
        getNamespace(e, t, n) {
            let r = t ? t.ns : n;
            if (t && 2 === r)
                if ("annotation-xml" === t.tag) {
                    if ("svg" === e) return 1;
                    t.props.some(
                        (e) =>
                            6 === e.type &&
                            "encoding" === e.name &&
                            null != e.value &&
                            ("text/html" === e.value.content || "application/xhtml+xml" === e.value.content)
                    ) && (r = 0);
                } else /^m(?:[ions]|text)$/.test(t.tag) && "mglyph" !== e && "malignmark" !== e && (r = 0);
            else t && 1 === r && (("foreignObject" !== t.tag && "desc" !== t.tag && "title" !== t.tag) || (r = 0));
            if (0 === r) {
                if ("svg" === e) return 1;
                if ("math" === e) return 2;
            }
            return r;
        },
    },
    bk = (e) => {
        1 === e.type &&
            e.props.forEach((t, n) => {
                6 === t.type &&
                    "style" === t.name &&
                    t.value &&
                    (e.props[n] = {
                        type: 7,
                        name: "bind",
                        arg: rb("style", !0, t.loc),
                        exp: yk(t.value.content, t.loc),
                        modifiers: [],
                        loc: t.loc,
                    });
            });
    },
    yk = (e, t) => {
        const n = J(e);
        return rb(JSON.stringify(n), !1, t, 3);
    };
function wk(e, t) {
    return Cb(e, t);
}
const kk = {
        53: "v-html is missing expression.",
        54: "v-html will override element children.",
        55: "v-text is missing expression.",
        56: "v-text will override element children.",
        57: "v-model can only be used on <input>, <textarea> and <select> elements.",
        58: "v-model argument is not supported on plain elements.",
        59: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.",
        60: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.",
        61: "v-show is missing expression.",
        62: "<Transition> expects exactly one child element or component.",
        63: "Tags with side effect (<script> and <style>) are ignored in client component templates.",
    },
    Tk = e("passive,once,capture"),
    _k = e("stop,prevent,self,ctrl,shift,alt,meta,exact,middle"),
    vk = e("left,right"),
    Sk = e("onkeyup,onkeydown,onkeypress"),
    Ek = (e, t) =>
        Rb(e) && "onclick" === e.content.toLowerCase()
            ? rb(t, !0)
            : 4 !== e.type
              ? ib(["(", e, `) === "onClick" ? "${t}" : (`, e, ")"])
              : e,
    Ck = (e, t) => {
        1 !== e.type || 0 !== e.tagType || ("script" !== e.tag && "style" !== e.tag) || t.removeNode();
    },
    Ik = [bk],
    xk = {
        cloak: ik,
        html: (e, t, n) => {
            const { exp: r, loc: i } = e;
            return (
                r || n.onError(wk(53, i)),
                t.children.length && (n.onError(wk(54, i)), (t.children.length = 0)),
                { props: [nb(rb("innerHTML", !0, i), r || rb("", !0))] }
            );
        },
        text: (e, t, n) => {
            const { exp: r, loc: i } = e;
            return (
                r || n.onError(wk(55, i)),
                t.children.length && (n.onError(wk(56, i)), (t.children.length = 0)),
                {
                    props: [
                        nb(rb("textContent", !0), r ? (Gy(r, n) > 0 ? r : sb(n.helperString(Og), [r], i)) : rb("", !0)),
                    ],
                }
            );
        },
        model: (e, t, n) => {
            const r = Xw(e, t, n);
            if (!r.props.length || 1 === t.tagType) return r;
            e.arg && n.onError(wk(58, e.arg.loc));
            const { tag: i } = t,
                s = n.isCustomElement(i);
            if ("input" === i || "textarea" === i || "select" === i || s) {
                let a = ok,
                    o = !1;
                if ("input" === i || s) {
                    const r = Yb(t, "type");
                    if (r) {
                        if (7 === r.type) a = lk;
                        else if (r.value)
                            switch (r.value.content) {
                                case "radio":
                                    a = sk;
                                    break;
                                case "checkbox":
                                    a = ak;
                                    break;
                                case "file":
                                    (o = !0), n.onError(wk(59, e.loc));
                            }
                    } else Jb(t) && (a = lk);
                } else "select" === i && (a = ck);
                o || (r.needRuntime = n.helper(a));
            } else n.onError(wk(57, e.loc));
            return (r.props = r.props.filter((e) => !(4 === e.key.type && "modelValue" === e.key.content))), r;
        },
        on: (e, t, n) =>
            Ww(e, t, n, (t) => {
                const { modifiers: r } = e;
                if (!r.length) return t;
                let { key: i, value: s } = t.props[0];
                const {
                    keyModifiers: a,
                    nonKeyModifiers: o,
                    eventOptionModifiers: c,
                } = ((e, t, n) => {
                    const r = [],
                        i = [],
                        s = [];
                    for (let a = 0; a < t.length; a++) {
                        const o = t[a].content;
                        ("native" === o && vb("COMPILER_V_ON_NATIVE", n)) || Tk(o)
                            ? s.push(o)
                            : vk(o)
                              ? Rb(e)
                                  ? Sk(e.content.toLowerCase())
                                      ? r.push(o)
                                      : i.push(o)
                                  : (r.push(o), i.push(o))
                              : _k(o)
                                ? i.push(o)
                                : r.push(o);
                    }
                    return { keyModifiers: r, nonKeyModifiers: i, eventOptionModifiers: s };
                })(i, r, n, e.loc);
                if (
                    (o.includes("right") && (i = Ek(i, "onContextmenu")),
                    o.includes("middle") && (i = Ek(i, "onMouseup")),
                    o.length && (s = sb(n.helper(uk), [s, JSON.stringify(o)])),
                    !a.length ||
                        (Rb(i) && !Sk(i.content.toLowerCase())) ||
                        (s = sb(n.helper(dk), [s, JSON.stringify(a)])),
                    c.length)
                ) {
                    const e = c.map(R).join("");
                    i = Rb(i) ? rb(`${i.content}${e}`, !0) : ib(["(", i, `) + "${e}"`]);
                }
                return { props: [nb(i, s)] };
            }),
        show: (e, t, n) => {
            const { exp: r, loc: i } = e;
            return r || n.onError(wk(61, i)), { props: [], needRuntime: n.helper(hk) };
        },
    };
const Ak = Object.freeze(
        Object.defineProperty(
            {
                __proto__: null,
                BASE_TRANSITION: pg,
                BindingTypes: {
                    DATA: "data",
                    PROPS: "props",
                    PROPS_ALIASED: "props-aliased",
                    SETUP_LET: "setup-let",
                    SETUP_CONST: "setup-const",
                    SETUP_REACTIVE_CONST: "setup-reactive-const",
                    SETUP_MAYBE_REF: "setup-maybe-ref",
                    SETUP_REF: "setup-ref",
                    OPTIONS: "options",
                    LITERAL_CONST: "literal-const",
                },
                CAMELIZE: Bg,
                CAPITALIZE: zg,
                CREATE_BLOCK: gg,
                CREATE_COMMENT: kg,
                CREATE_ELEMENT_BLOCK: bg,
                CREATE_ELEMENT_VNODE: wg,
                CREATE_SLOTS: Pg,
                CREATE_STATIC: _g,
                CREATE_TEXT: Tg,
                CREATE_VNODE: yg,
                CompilerDeprecationTypes: {
                    COMPILER_IS_ON_ELEMENT: "COMPILER_IS_ON_ELEMENT",
                    COMPILER_V_BIND_SYNC: "COMPILER_V_BIND_SYNC",
                    COMPILER_V_BIND_OBJECT_ORDER: "COMPILER_V_BIND_OBJECT_ORDER",
                    COMPILER_V_ON_NATIVE: "COMPILER_V_ON_NATIVE",
                    COMPILER_V_IF_V_FOR_PRECEDENCE: "COMPILER_V_IF_V_FOR_PRECEDENCE",
                    COMPILER_NATIVE_TEMPLATE: "COMPILER_NATIVE_TEMPLATE",
                    COMPILER_INLINE_TEMPLATE: "COMPILER_INLINE_TEMPLATE",
                    COMPILER_FILTERS: "COMPILER_FILTERS",
                },
                ConstantTypes: {
                    NOT_CONSTANT: 0,
                    0: "NOT_CONSTANT",
                    CAN_SKIP_PATCH: 1,
                    1: "CAN_SKIP_PATCH",
                    CAN_CACHE: 2,
                    2: "CAN_CACHE",
                    CAN_STRINGIFY: 3,
                    3: "CAN_STRINGIFY",
                },
                DOMDirectiveTransforms: xk,
                DOMErrorCodes: {
                    X_V_HTML_NO_EXPRESSION: 53,
                    53: "X_V_HTML_NO_EXPRESSION",
                    X_V_HTML_WITH_CHILDREN: 54,
                    54: "X_V_HTML_WITH_CHILDREN",
                    X_V_TEXT_NO_EXPRESSION: 55,
                    55: "X_V_TEXT_NO_EXPRESSION",
                    X_V_TEXT_WITH_CHILDREN: 56,
                    56: "X_V_TEXT_WITH_CHILDREN",
                    X_V_MODEL_ON_INVALID_ELEMENT: 57,
                    57: "X_V_MODEL_ON_INVALID_ELEMENT",
                    X_V_MODEL_ARG_ON_ELEMENT: 58,
                    58: "X_V_MODEL_ARG_ON_ELEMENT",
                    X_V_MODEL_ON_FILE_INPUT_ELEMENT: 59,
                    59: "X_V_MODEL_ON_FILE_INPUT_ELEMENT",
                    X_V_MODEL_UNNECESSARY_VALUE: 60,
                    60: "X_V_MODEL_UNNECESSARY_VALUE",
                    X_V_SHOW_NO_EXPRESSION: 61,
                    61: "X_V_SHOW_NO_EXPRESSION",
                    X_TRANSITION_INVALID_CHILDREN: 62,
                    62: "X_TRANSITION_INVALID_CHILDREN",
                    X_IGNORED_SIDE_EFFECT_TAG: 63,
                    63: "X_IGNORED_SIDE_EFFECT_TAG",
                    __EXTEND_POINT__: 64,
                    64: "__EXTEND_POINT__",
                },
                DOMErrorMessages: kk,
                DOMNodeTransforms: Ik,
                ElementTypes: {
                    ELEMENT: 0,
                    0: "ELEMENT",
                    COMPONENT: 1,
                    1: "COMPONENT",
                    SLOT: 2,
                    2: "SLOT",
                    TEMPLATE: 3,
                    3: "TEMPLATE",
                },
                ErrorCodes: {
                    ABRUPT_CLOSING_OF_EMPTY_COMMENT: 0,
                    0: "ABRUPT_CLOSING_OF_EMPTY_COMMENT",
                    CDATA_IN_HTML_CONTENT: 1,
                    1: "CDATA_IN_HTML_CONTENT",
                    DUPLICATE_ATTRIBUTE: 2,
                    2: "DUPLICATE_ATTRIBUTE",
                    END_TAG_WITH_ATTRIBUTES: 3,
                    3: "END_TAG_WITH_ATTRIBUTES",
                    END_TAG_WITH_TRAILING_SOLIDUS: 4,
                    4: "END_TAG_WITH_TRAILING_SOLIDUS",
                    EOF_BEFORE_TAG_NAME: 5,
                    5: "EOF_BEFORE_TAG_NAME",
                    EOF_IN_CDATA: 6,
                    6: "EOF_IN_CDATA",
                    EOF_IN_COMMENT: 7,
                    7: "EOF_IN_COMMENT",
                    EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT: 8,
                    8: "EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT",
                    EOF_IN_TAG: 9,
                    9: "EOF_IN_TAG",
                    INCORRECTLY_CLOSED_COMMENT: 10,
                    10: "INCORRECTLY_CLOSED_COMMENT",
                    INCORRECTLY_OPENED_COMMENT: 11,
                    11: "INCORRECTLY_OPENED_COMMENT",
                    INVALID_FIRST_CHARACTER_OF_TAG_NAME: 12,
                    12: "INVALID_FIRST_CHARACTER_OF_TAG_NAME",
                    MISSING_ATTRIBUTE_VALUE: 13,
                    13: "MISSING_ATTRIBUTE_VALUE",
                    MISSING_END_TAG_NAME: 14,
                    14: "MISSING_END_TAG_NAME",
                    MISSING_WHITESPACE_BETWEEN_ATTRIBUTES: 15,
                    15: "MISSING_WHITESPACE_BETWEEN_ATTRIBUTES",
                    NESTED_COMMENT: 16,
                    16: "NESTED_COMMENT",
                    UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME: 17,
                    17: "UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME",
                    UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE: 18,
                    18: "UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE",
                    UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME: 19,
                    19: "UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME",
                    UNEXPECTED_NULL_CHARACTER: 20,
                    20: "UNEXPECTED_NULL_CHARACTER",
                    UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME: 21,
                    21: "UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME",
                    UNEXPECTED_SOLIDUS_IN_TAG: 22,
                    22: "UNEXPECTED_SOLIDUS_IN_TAG",
                    X_INVALID_END_TAG: 23,
                    23: "X_INVALID_END_TAG",
                    X_MISSING_END_TAG: 24,
                    24: "X_MISSING_END_TAG",
                    X_MISSING_INTERPOLATION_END: 25,
                    25: "X_MISSING_INTERPOLATION_END",
                    X_MISSING_DIRECTIVE_NAME: 26,
                    26: "X_MISSING_DIRECTIVE_NAME",
                    X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END: 27,
                    27: "X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END",
                    X_V_IF_NO_EXPRESSION: 28,
                    28: "X_V_IF_NO_EXPRESSION",
                    X_V_IF_SAME_KEY: 29,
                    29: "X_V_IF_SAME_KEY",
                    X_V_ELSE_NO_ADJACENT_IF: 30,
                    30: "X_V_ELSE_NO_ADJACENT_IF",
                    X_V_FOR_NO_EXPRESSION: 31,
                    31: "X_V_FOR_NO_EXPRESSION",
                    X_V_FOR_MALFORMED_EXPRESSION: 32,
                    32: "X_V_FOR_MALFORMED_EXPRESSION",
                    X_V_FOR_TEMPLATE_KEY_PLACEMENT: 33,
                    33: "X_V_FOR_TEMPLATE_KEY_PLACEMENT",
                    X_V_BIND_NO_EXPRESSION: 34,
                    34: "X_V_BIND_NO_EXPRESSION",
                    X_V_ON_NO_EXPRESSION: 35,
                    35: "X_V_ON_NO_EXPRESSION",
                    X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET: 36,
                    36: "X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET",
                    X_V_SLOT_MIXED_SLOT_USAGE: 37,
                    37: "X_V_SLOT_MIXED_SLOT_USAGE",
                    X_V_SLOT_DUPLICATE_SLOT_NAMES: 38,
                    38: "X_V_SLOT_DUPLICATE_SLOT_NAMES",
                    X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN: 39,
                    39: "X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN",
                    X_V_SLOT_MISPLACED: 40,
                    40: "X_V_SLOT_MISPLACED",
                    X_V_MODEL_NO_EXPRESSION: 41,
                    41: "X_V_MODEL_NO_EXPRESSION",
                    X_V_MODEL_MALFORMED_EXPRESSION: 42,
                    42: "X_V_MODEL_MALFORMED_EXPRESSION",
                    X_V_MODEL_ON_SCOPE_VARIABLE: 43,
                    43: "X_V_MODEL_ON_SCOPE_VARIABLE",
                    X_V_MODEL_ON_PROPS: 44,
                    44: "X_V_MODEL_ON_PROPS",
                    X_INVALID_EXPRESSION: 45,
                    45: "X_INVALID_EXPRESSION",
                    X_KEEP_ALIVE_INVALID_CHILDREN: 46,
                    46: "X_KEEP_ALIVE_INVALID_CHILDREN",
                    X_PREFIX_ID_NOT_SUPPORTED: 47,
                    47: "X_PREFIX_ID_NOT_SUPPORTED",
                    X_MODULE_MODE_NOT_SUPPORTED: 48,
                    48: "X_MODULE_MODE_NOT_SUPPORTED",
                    X_CACHE_HANDLER_NOT_SUPPORTED: 49,
                    49: "X_CACHE_HANDLER_NOT_SUPPORTED",
                    X_SCOPE_ID_NOT_SUPPORTED: 50,
                    50: "X_SCOPE_ID_NOT_SUPPORTED",
                    X_VNODE_HOOKS: 51,
                    51: "X_VNODE_HOOKS",
                    X_V_BIND_INVALID_SAME_NAME_ARGUMENT: 52,
                    52: "X_V_BIND_INVALID_SAME_NAME_ARGUMENT",
                    __EXTEND_POINT__: 53,
                    53: "__EXTEND_POINT__",
                },
                FRAGMENT: ug,
                GUARD_REACTIVE_PROPS: Fg,
                IS_MEMO_SAME: Gg,
                IS_REF: qg,
                KEEP_ALIVE: mg,
                MERGE_PROPS: Ng,
                NORMALIZE_CLASS: Rg,
                NORMALIZE_PROPS: Dg,
                NORMALIZE_STYLE: Mg,
                Namespaces: { HTML: 0, 0: "HTML", SVG: 1, 1: "SVG", MATH_ML: 2, 2: "MATH_ML" },
                NodeTypes: {
                    ROOT: 0,
                    0: "ROOT",
                    ELEMENT: 1,
                    1: "ELEMENT",
                    TEXT: 2,
                    2: "TEXT",
                    COMMENT: 3,
                    3: "COMMENT",
                    SIMPLE_EXPRESSION: 4,
                    4: "SIMPLE_EXPRESSION",
                    INTERPOLATION: 5,
                    5: "INTERPOLATION",
                    ATTRIBUTE: 6,
                    6: "ATTRIBUTE",
                    DIRECTIVE: 7,
                    7: "DIRECTIVE",
                    COMPOUND_EXPRESSION: 8,
                    8: "COMPOUND_EXPRESSION",
                    IF: 9,
                    9: "IF",
                    IF_BRANCH: 10,
                    10: "IF_BRANCH",
                    FOR: 11,
                    11: "FOR",
                    TEXT_CALL: 12,
                    12: "TEXT_CALL",
                    VNODE_CALL: 13,
                    13: "VNODE_CALL",
                    JS_CALL_EXPRESSION: 14,
                    14: "JS_CALL_EXPRESSION",
                    JS_OBJECT_EXPRESSION: 15,
                    15: "JS_OBJECT_EXPRESSION",
                    JS_PROPERTY: 16,
                    16: "JS_PROPERTY",
                    JS_ARRAY_EXPRESSION: 17,
                    17: "JS_ARRAY_EXPRESSION",
                    JS_FUNCTION_EXPRESSION: 18,
                    18: "JS_FUNCTION_EXPRESSION",
                    JS_CONDITIONAL_EXPRESSION: 19,
                    19: "JS_CONDITIONAL_EXPRESSION",
                    JS_CACHE_EXPRESSION: 20,
                    20: "JS_CACHE_EXPRESSION",
                    JS_BLOCK_STATEMENT: 21,
                    21: "JS_BLOCK_STATEMENT",
                    JS_TEMPLATE_LITERAL: 22,
                    22: "JS_TEMPLATE_LITERAL",
                    JS_IF_STATEMENT: 23,
                    23: "JS_IF_STATEMENT",
                    JS_ASSIGNMENT_EXPRESSION: 24,
                    24: "JS_ASSIGNMENT_EXPRESSION",
                    JS_SEQUENCE_EXPRESSION: 25,
                    25: "JS_SEQUENCE_EXPRESSION",
                    JS_RETURN_STATEMENT: 26,
                    26: "JS_RETURN_STATEMENT",
                },
                OPEN_BLOCK: fg,
                POP_SCOPE_ID: Wg,
                PUSH_SCOPE_ID: Vg,
                RENDER_LIST: xg,
                RENDER_SLOT: Ag,
                RESOLVE_COMPONENT: vg,
                RESOLVE_DIRECTIVE: Eg,
                RESOLVE_DYNAMIC_COMPONENT: Sg,
                RESOLVE_FILTER: Cg,
                SET_BLOCK_TRACKING: $g,
                SUSPENSE: hg,
                TELEPORT: dg,
                TO_DISPLAY_STRING: Og,
                TO_HANDLERS: Lg,
                TO_HANDLER_KEY: Ug,
                TRANSITION: mk,
                TRANSITION_GROUP: pk,
                TS_NODE_TYPES: Nb,
                UNREF: Hg,
                V_MODEL_CHECKBOX: ak,
                V_MODEL_DYNAMIC: lk,
                V_MODEL_RADIO: sk,
                V_MODEL_SELECT: ck,
                V_MODEL_TEXT: ok,
                V_ON_WITH_KEYS: dk,
                V_ON_WITH_MODIFIERS: uk,
                V_SHOW: hk,
                WITH_CTX: jg,
                WITH_DIRECTIVES: Ig,
                WITH_MEMO: Xg,
                advancePositionWithClone: function (e, t, n = t.length) {
                    return Gb({ offset: e.offset, line: e.line, column: e.column }, t, n);
                },
                advancePositionWithMutation: Gb,
                assert: function (e, t) {
                    if (!e) throw new Error(t || "unexpected compiler condition");
                },
                baseCompile: rk,
                baseParse: jy,
                buildDirectiveArgs: zw,
                buildProps: Fw,
                buildSlots: Aw,
                checkCompatEnabled: vb,
                compile: function (e, t = {}) {
                    return rk(
                        e,
                        o({}, gk, t, {
                            nodeTransforms: [Ck, ...Ik, ...(t.nodeTransforms || [])],
                            directiveTransforms: o({}, xk, t.directiveTransforms || {}),
                            transformHoist: null,
                        })
                    );
                },
                convertToBlock: hb,
                createArrayExpression: eb,
                createAssignmentExpression: function (e, t) {
                    return { type: 24, left: e, right: t, loc: Qg };
                },
                createBlockStatement: lb,
                createCacheExpression: cb,
                createCallExpression: sb,
                createCompilerError: Cb,
                createCompoundExpression: ib,
                createConditionalExpression: ob,
                createDOMCompilerError: wk,
                createForLoopParams: Ew,
                createFunctionExpression: ab,
                createIfStatement: function (e, t, n) {
                    return { type: 23, test: e, consequent: t, alternate: n, loc: Qg };
                },
                createInterpolation: function (e, t) {
                    return { type: 5, loc: t, content: b(e) ? rb(e, !1, t) : e };
                },
                createObjectExpression: tb,
                createObjectProperty: nb,
                createReturnStatement: function (e) {
                    return { type: 26, returns: e, loc: Qg };
                },
                createRoot: Jg,
                createSequenceExpression: function (e) {
                    return { type: 25, expressions: e, loc: Qg };
                },
                createSimpleExpression: rb,
                createStructuralDirectiveTransform: nw,
                createTemplateLiteral: function (e) {
                    return { type: 22, elements: e, loc: Qg };
                },
                createTransformContext: Zy,
                createVNodeCall: Zg,
                errorMessages: Ib,
                extractIdentifiers: Pb,
                findDir: Kb,
                findProp: Yb,
                forAliasRE: ly,
                generate: sw,
                generateCodeFrame: X,
                getBaseTransformPreset: nk,
                getConstantType: Gy,
                getMemoedVNodeCall: cy,
                getVNodeBlockHelper: db,
                getVNodeHelper: ub,
                hasDynamicKeyVBind: Jb,
                hasScopeRef: function e(t, n) {
                    if (!t || 0 === Object.keys(n).length) return !1;
                    switch (t.type) {
                        case 1:
                            for (let r = 0; r < t.props.length; r++) {
                                const i = t.props[r];
                                if (7 === i.type && (e(i.arg, n) || e(i.exp, n))) return !0;
                            }
                            return t.children.some((t) => e(t, n));
                        case 11:
                            return !!e(t.source, n) || t.children.some((t) => e(t, n));
                        case 9:
                            return t.branches.some((t) => e(t, n));
                        case 10:
                            return !!e(t.condition, n) || t.children.some((t) => e(t, n));
                        case 4:
                            return !t.isStatic && Fb(t.content) && !!n[t.content];
                        case 8:
                            return t.children.some((t) => w(t) && e(t, n));
                        case 5:
                        case 12:
                            return e(t.content, n);
                        default:
                            return !1;
                    }
                },
                helperNameMap: Kg,
                injectProp: sy,
                isCoreComponent: Mb,
                isFnExpression: Xb,
                isFnExpressionBrowser: Hb,
                isFnExpressionNode: qb,
                isFunctionType: (e) => /Function(?:Expression|Declaration)$|Method$/.test(e.type),
                isInDestructureAssignment: function (e, t) {
                    if (e && ("ObjectProperty" === e.type || "ArrayPattern" === e.type)) {
                        let e = t.length;
                        for (; e--; ) {
                            const n = t[e];
                            if ("AssignmentExpression" === n.type) return !0;
                            if ("ObjectProperty" !== n.type && !n.type.endsWith("Pattern")) break;
                        }
                    }
                    return !1;
                },
                isInNewExpression: function (e) {
                    let t = e.length;
                    for (; t--; ) {
                        const n = e[t];
                        if ("NewExpression" === n.type) return !0;
                        if ("MemberExpression" !== n.type) break;
                    }
                    return !1;
                },
                isMemberExpression: Wb,
                isMemberExpressionBrowser: $b,
                isMemberExpressionNode: Vb,
                isReferencedIdentifier: function (e, t, n) {
                    return !1;
                },
                isSimpleIdentifier: Fb,
                isSlotOutlet: ny,
                isStaticArgOf: Qb,
                isStaticExp: Rb,
                isStaticProperty: Ob,
                isStaticPropertyKey: (e, t) => Ob(t) && t.key === e,
                isTemplateNode: ty,
                isText: Zb,
                isVSlot: ey,
                locStub: Qg,
                noopDirectiveTransform: ik,
                parse: function (e, t = {}) {
                    return jy(e, o({}, gk, t));
                },
                parserOptions: gk,
                processExpression: mw,
                processFor: vw,
                processIf: fw,
                processSlotOutlet: Vw,
                registerRuntimeHelpers: Yg,
                resolveComponentType: Dw,
                stringifyExpression: function e(t) {
                    return b(t) ? t : 4 === t.type ? t.content : t.children.map(e).join("");
                },
                toValidAssetId: oy,
                trackSlotScopes: Iw,
                trackVForSlotScopes: (e, t) => {
                    let n;
                    if (ty(e) && e.props.some(ey) && (n = Kb(e, "for"))) {
                        const e = n.forParseResult;
                        if (e) {
                            Sw(e);
                            const { value: n, key: r, index: i } = e,
                                { addIdentifiers: s, removeIdentifiers: a } = t;
                            return (
                                n && s(n),
                                r && s(r),
                                i && s(i),
                                () => {
                                    n && a(n), r && a(r), i && a(i);
                                }
                            );
                        }
                    }
                },
                transform: ew,
                transformBind: ww,
                transformElement: Mw,
                transformExpression: (e, t) => {
                    if (5 === e.type) e.content = mw(e.content, t);
                    else if (1 === e.type) {
                        const n = Kb(e, "memo");
                        for (let r = 0; r < e.props.length; r++) {
                            const i = e.props[r];
                            if (7 === i.type && "for" !== i.name) {
                                const e = i.exp,
                                    r = i.arg;
                                !e ||
                                    4 !== e.type ||
                                    ("on" === i.name && r) ||
                                    (n && r && 4 === r.type && "key" === r.content) ||
                                    (i.exp = mw(e, t, "slot" === i.name)),
                                    r && 4 === r.type && !r.isStatic && (i.arg = mw(r, t));
                            }
                        }
                    }
                },
                transformModel: Xw,
                transformOn: Ww,
                transformStyle: bk,
                traverseNode: tw,
                unwrapTSNode: function e(t) {
                    return Nb.includes(t.type) ? e(t.expression) : t;
                },
                walkBlockDeclarations: function (e, t) {
                    for (const n of e.body)
                        if ("VariableDeclaration" === n.type) {
                            if (n.declare) continue;
                            for (const e of n.declarations) for (const n of Pb(e.id)) t(n);
                        } else if ("FunctionDeclaration" === n.type || "ClassDeclaration" === n.type) {
                            if (n.declare || !n.id) continue;
                            t(n.id);
                        } else xb(n) && Ab(n, !0, t);
                },
                walkFunctionParams: function (e, t) {
                    for (const n of e.params) for (const e of Pb(n)) t(e);
                },
                walkIdentifiers: function (e, t, n = !1, r = [], i = Object.create(null)) {},
                warnDeprecation: function (e, t, n, ...r) {
                    if ("suppress-warning" === Tb(e, t)) return;
                    const { message: i, link: s } = kb[e],
                        a = `(deprecation ${e}) ${"function" == typeof i ? i(...r) : i}${s ? `\n  Details: ${s}` : ""}`,
                        o = new SyntaxError(a);
                    (o.code = e), n && (o.loc = n), t.onWarn(o);
                },
            },
            Symbol.toStringTag,
            { value: "Module" }
        )
    ),
    Pk = Tc(Ak),
    Ok = Tc(gc),
    Nk = Tc(ve);
var Rk, Mk, Dk, Fk, Lk;
function Bk() {
    return (
        Mk ||
            ((Mk = 1),
            (cg.exports =
                (Rk ||
                    ((Rk = 1),
                    (function (e) {
                        Object.defineProperty(e, "__esModule", { value: !0 });
                        var t = Pk,
                            n = Ok,
                            r = Nk;
                        function i(e) {
                            var t = Object.create(null);
                            if (e) for (var n in e) t[n] = e[n];
                            return (t.default = e), Object.freeze(t);
                        }
                        var s = i(n);
                        const a = Object.create(null);
                        function o(e, n) {
                            if (!r.isString(e)) {
                                if (!e.nodeType) return r.NOOP;
                                e = e.innerHTML;
                            }
                            const i = r.genCacheKey(e, n),
                                o = a[i];
                            if (o) return o;
                            if ("#" === e[0]) {
                                const t = document.querySelector(e);
                                e = t ? t.innerHTML : "";
                            }
                            const c = r.extend({ hoistStatic: !0, onError: void 0, onWarn: r.NOOP }, n);
                            c.isCustomElement ||
                                "undefined" == typeof customElements ||
                                (c.isCustomElement = (e) => !!customElements.get(e));
                            const { code: l } = t.compile(e, c),
                                u = new Function("Vue", l)(s);
                            return (u._rc = !0), (a[i] = u);
                        }
                        n.registerRuntimeCompiler(o),
                            (e.compile = o),
                            Object.keys(n).forEach(function (t) {
                                "default" === t || Object.prototype.hasOwnProperty.call(e, t) || (e[t] = n[t]);
                            });
                    })(lg)),
                lg))),
        cg.exports
    );
}
function zk() {
    if (Dk) return pm;
    Dk = 1;
    var e = zf,
        t = og,
        n = Bk();
    const r = "11.1.11",
        i = {
            UNEXPECTED_RETURN_TYPE: e.CORE_ERROR_CODES_EXTEND_POINT,
            INVALID_ARGUMENT: 25,
            MUST_BE_CALL_SETUP_TOP: 26,
            NOT_INSTALLED: 27,
            REQUIRED_VALUE: 28,
            INVALID_VALUE: 29,
            NOT_INSTALLED_WITH_PROVIDE: 31,
            UNEXPECTED_ERROR: 32,
        };
    function s(t, ...n) {
        return e.createCompileError(t, null, void 0);
    }
    const a = t.makeSymbol("__translateVNode"),
        o = t.makeSymbol("__datetimeParts"),
        c = t.makeSymbol("__numberParts"),
        l = t.makeSymbol("__setPluralRules");
    t.makeSymbol("__intlifyMeta");
    const u = t.makeSymbol("__injectWithOption"),
        d = t.makeSymbol("__dispose");
    function h(n) {
        if (!t.isObject(n)) return n;
        if (e.isMessageAST(n)) return n;
        for (const r in n)
            if (t.hasOwn(n, r))
                if (r.includes(".")) {
                    const i = r.split("."),
                        s = i.length - 1;
                    let a = n,
                        o = !1;
                    for (let e = 0; e < s; e++) {
                        if ("__proto__" === i[e]) throw new Error(`unsafe key: ${i[e]}`);
                        if ((i[e] in a || (a[i[e]] = t.create()), !t.isObject(a[i[e]]))) {
                            o = !0;
                            break;
                        }
                        a = a[i[e]];
                    }
                    if (
                        (o ||
                            (e.isMessageAST(a)
                                ? e.AST_NODE_PROPS_KEYS.includes(i[s]) || delete n[r]
                                : ((a[i[s]] = n[r]), delete n[r])),
                        !e.isMessageAST(a))
                    ) {
                        const e = a[i[s]];
                        t.isObject(e) && h(e);
                    }
                } else t.isObject(n[r]) && h(n[r]);
        return n;
    }
    function m(e, n) {
        const { messages: r, __i18n: i, messageResolver: s, flatJson: a } = n,
            o = t.isPlainObject(r) ? r : t.isArray(i) ? t.create() : { [e]: t.create() };
        if (
            (t.isArray(i) &&
                i.forEach((e) => {
                    if ("locale" in e && "resource" in e) {
                        const { locale: n, resource: r } = e;
                        n ? ((o[n] = o[n] || t.create()), t.deepCopy(r, o[n])) : t.deepCopy(r, o);
                    } else t.isString(e) && t.deepCopy(JSON.parse(e), o);
                }),
            null == s && a)
        )
            for (const c in o) t.hasOwn(o, c) && h(o[c]);
        return o;
    }
    function p(e, n, r) {
        let i = t.isObject(n.messages) ? n.messages : t.create();
        "__i18nGlobal" in r && (i = m(e.locale.value, { messages: i, __i18n: r.__i18nGlobal }));
        const s = Object.keys(i);
        if (
            (s.length &&
                s.forEach((t) => {
                    e.mergeLocaleMessage(t, i[t]);
                }),
            t.isObject(n.datetimeFormats))
        ) {
            const t = Object.keys(n.datetimeFormats);
            t.length &&
                t.forEach((t) => {
                    e.mergeDateTimeFormat(t, n.datetimeFormats[t]);
                });
        }
        if (t.isObject(n.numberFormats)) {
            const t = Object.keys(n.numberFormats);
            t.length &&
                t.forEach((t) => {
                    e.mergeNumberFormat(t, n.numberFormats[t]);
                });
        }
    }
    function f(e) {
        return n.createVNode(n.Text, null, e, 0);
    }
    const g = () => [],
        b = () => !1;
    let y = 0;
    function w(e) {
        return (t, r, i, s) => e(r, i, n.getCurrentInstance() || void 0, s);
    }
    function k(d = {}) {
        const { __root: p, __injectWithOption: k } = d,
            T = void 0 === p,
            _ = d.flatJson,
            v = t.inBrowser ? n.ref : n.shallowRef;
        let S = !t.isBoolean(d.inheritLocale) || d.inheritLocale;
        const E = v(p && S ? p.locale.value : t.isString(d.locale) ? d.locale : e.DEFAULT_LOCALE),
            C = v(
                p && S
                    ? p.fallbackLocale.value
                    : t.isString(d.fallbackLocale) ||
                        t.isArray(d.fallbackLocale) ||
                        t.isPlainObject(d.fallbackLocale) ||
                        !1 === d.fallbackLocale
                      ? d.fallbackLocale
                      : E.value
            ),
            I = v(m(E.value, d)),
            x = v(t.isPlainObject(d.datetimeFormats) ? d.datetimeFormats : { [E.value]: {} }),
            A = v(t.isPlainObject(d.numberFormats) ? d.numberFormats : { [E.value]: {} });
        let P = p ? p.missingWarn : (!t.isBoolean(d.missingWarn) && !t.isRegExp(d.missingWarn)) || d.missingWarn,
            O = p ? p.fallbackWarn : (!t.isBoolean(d.fallbackWarn) && !t.isRegExp(d.fallbackWarn)) || d.fallbackWarn,
            N = p ? p.fallbackRoot : !t.isBoolean(d.fallbackRoot) || d.fallbackRoot,
            R = !!d.fallbackFormat,
            M = t.isFunction(d.missing) ? d.missing : null,
            D = t.isFunction(d.missing) ? w(d.missing) : null,
            F = t.isFunction(d.postTranslation) ? d.postTranslation : null,
            L = p ? p.warnHtmlMessage : !t.isBoolean(d.warnHtmlMessage) || d.warnHtmlMessage,
            B = !!d.escapeParameter;
        const z = p ? p.modifiers : t.isPlainObject(d.modifiers) ? d.modifiers : {};
        let U,
            $ = d.pluralRules || (p && p.pluralRules);
        (U = (() => {
            T && e.setFallbackContext(null);
            const n = {
                version: r,
                locale: E.value,
                fallbackLocale: C.value,
                messages: I.value,
                modifiers: z,
                pluralRules: $,
                missing: null === D ? void 0 : D,
                missingWarn: P,
                fallbackWarn: O,
                fallbackFormat: R,
                unresolving: !0,
                postTranslation: null === F ? void 0 : F,
                warnHtmlMessage: L,
                escapeParameter: B,
                messageResolver: d.messageResolver,
                messageCompiler: d.messageCompiler,
                __meta: { framework: "vue" },
            };
            (n.datetimeFormats = x.value),
                (n.numberFormats = A.value),
                (n.__datetimeFormatters = t.isPlainObject(U) ? U.__datetimeFormatters : void 0),
                (n.__numberFormatters = t.isPlainObject(U) ? U.__numberFormatters : void 0);
            const i = e.createCoreContext(n);
            return T && e.setFallbackContext(i), i;
        })()),
            e.updateFallbackLocale(U, E.value, C.value);
        const V = n.computed({
                get: () => E.value,
                set: (e) => {
                    (U.locale = e), (E.value = e);
                },
            }),
            W = n.computed({
                get: () => C.value,
                set: (t) => {
                    (U.fallbackLocale = t), (C.value = t), e.updateFallbackLocale(U, E.value, t);
                },
            }),
            j = n.computed(() => I.value),
            H = n.computed(() => x.value),
            q = n.computed(() => A.value);
        const X = (n, r, a, o, c, l) => {
            let u;
            E.value, C.value, I.value, x.value, A.value;
            try {
                0, T || (U.fallbackContext = p ? e.getFallbackContext() : void 0), (u = n(U));
            } finally {
                T || (U.fallbackContext = void 0);
            }
            if (
                ("translate exists" !== a && t.isNumber(u) && u === e.NOT_REOSLVED) ||
                ("translate exists" === a && !u)
            ) {
                const [e, t] = r();
                return p && N ? o(p) : c(e);
            }
            if (l(u)) return u;
            throw s(i.UNEXPECTED_RETURN_TYPE);
        };
        function G(...n) {
            return X(
                (t) => Reflect.apply(e.translate, null, [t, ...n]),
                () => e.parseTranslateArgs(...n),
                "translate",
                (e) => Reflect.apply(e.t, e, [...n]),
                (e) => e,
                (e) => t.isString(e)
            );
        }
        const K = {
            normalize: function (e) {
                return e.map((e) => (t.isString(e) || t.isNumber(e) || t.isBoolean(e) ? f(String(e)) : e));
            },
            interpolate: (e) => e,
            type: "vnode",
        };
        function Y(e) {
            return I.value[e] || {};
        }
        y++,
            p &&
                t.inBrowser &&
                (n.watch(p.locale, (t) => {
                    S && ((E.value = t), (U.locale = t), e.updateFallbackLocale(U, E.value, C.value));
                }),
                n.watch(p.fallbackLocale, (t) => {
                    S && ((C.value = t), (U.fallbackLocale = t), e.updateFallbackLocale(U, E.value, C.value));
                }));
        const Q = {
            id: y,
            locale: V,
            fallbackLocale: W,
            get inheritLocale() {
                return S;
            },
            set inheritLocale(t) {
                (S = t),
                    t &&
                        p &&
                        ((E.value = p.locale.value),
                        (C.value = p.fallbackLocale.value),
                        e.updateFallbackLocale(U, E.value, C.value));
            },
            get availableLocales() {
                return Object.keys(I.value).sort();
            },
            messages: j,
            get modifiers() {
                return z;
            },
            get pluralRules() {
                return $ || {};
            },
            get isGlobal() {
                return T;
            },
            get missingWarn() {
                return P;
            },
            set missingWarn(e) {
                (P = e), (U.missingWarn = P);
            },
            get fallbackWarn() {
                return O;
            },
            set fallbackWarn(e) {
                (O = e), (U.fallbackWarn = O);
            },
            get fallbackRoot() {
                return N;
            },
            set fallbackRoot(e) {
                N = e;
            },
            get fallbackFormat() {
                return R;
            },
            set fallbackFormat(e) {
                (R = e), (U.fallbackFormat = R);
            },
            get warnHtmlMessage() {
                return L;
            },
            set warnHtmlMessage(e) {
                (L = e), (U.warnHtmlMessage = e);
            },
            get escapeParameter() {
                return B;
            },
            set escapeParameter(e) {
                (B = e), (U.escapeParameter = e);
            },
            t: G,
            getLocaleMessage: Y,
            setLocaleMessage: function (e, n) {
                if (_) {
                    const r = { [e]: n };
                    for (const e in r) t.hasOwn(r, e) && h(r[e]);
                    n = r[e];
                }
                (I.value[e] = n), (U.messages = I.value);
            },
            mergeLocaleMessage: function (e, n) {
                I.value[e] = I.value[e] || {};
                const r = { [e]: n };
                if (_) for (const i in r) t.hasOwn(r, i) && h(r[i]);
                (n = r[e]), t.deepCopy(n, I.value[e]), (U.messages = I.value);
            },
            getPostTranslationHandler: function () {
                return t.isFunction(F) ? F : null;
            },
            setPostTranslationHandler: function (e) {
                (F = e), (U.postTranslation = e);
            },
            getMissingHandler: function () {
                return M;
            },
            setMissingHandler: function (e) {
                null !== e && (D = w(e)), (M = e), (U.missing = D);
            },
            [l]: function (e) {
                ($ = e), (U.pluralRules = $);
            },
        };
        return (
            (Q.datetimeFormats = H),
            (Q.numberFormats = q),
            (Q.rt = function (...e) {
                const [n, r, a] = e;
                if (a && !t.isObject(a)) throw s(i.INVALID_ARGUMENT);
                return G(n, r, t.assign({ resolvedMessage: !0 }, a || {}));
            }),
            (Q.te = function (n, r) {
                return X(
                    () => {
                        if (!n) return !1;
                        const i = Y(t.isString(r) ? r : E.value),
                            s = U.messageResolver(i, n);
                        return e.isMessageAST(s) || e.isMessageFunction(s) || t.isString(s);
                    },
                    () => [n],
                    "translate exists",
                    (e) => Reflect.apply(e.te, e, [n, r]),
                    b,
                    (e) => t.isBoolean(e)
                );
            }),
            (Q.tm = function (t) {
                const n = (function (t) {
                    let n = null;
                    const r = e.fallbackWithLocaleChain(U, C.value, E.value);
                    for (let e = 0; e < r.length; e++) {
                        const i = I.value[r[e]] || {},
                            s = U.messageResolver(i, t);
                        if (null != s) {
                            n = s;
                            break;
                        }
                    }
                    return n;
                })(t);
                return null != n ? n : (p && p.tm(t)) || {};
            }),
            (Q.d = function (...n) {
                return X(
                    (t) => Reflect.apply(e.datetime, null, [t, ...n]),
                    () => e.parseDateTimeArgs(...n),
                    "datetime format",
                    (e) => Reflect.apply(e.d, e, [...n]),
                    () => e.MISSING_RESOLVE_VALUE,
                    (e) => t.isString(e) || t.isArray(e)
                );
            }),
            (Q.n = function (...n) {
                return X(
                    (t) => Reflect.apply(e.number, null, [t, ...n]),
                    () => e.parseNumberArgs(...n),
                    "number format",
                    (e) => Reflect.apply(e.n, e, [...n]),
                    () => e.MISSING_RESOLVE_VALUE,
                    (e) => t.isString(e) || t.isArray(e)
                );
            }),
            (Q.getDateTimeFormat = function (e) {
                return x.value[e] || {};
            }),
            (Q.setDateTimeFormat = function (t, n) {
                (x.value[t] = n), (U.datetimeFormats = x.value), e.clearDateTimeFormat(U, t, n);
            }),
            (Q.mergeDateTimeFormat = function (n, r) {
                (x.value[n] = t.assign(x.value[n] || {}, r)),
                    (U.datetimeFormats = x.value),
                    e.clearDateTimeFormat(U, n, r);
            }),
            (Q.getNumberFormat = function (e) {
                return A.value[e] || {};
            }),
            (Q.setNumberFormat = function (t, n) {
                (A.value[t] = n), (U.numberFormats = A.value), e.clearNumberFormat(U, t, n);
            }),
            (Q.mergeNumberFormat = function (n, r) {
                (A.value[n] = t.assign(A.value[n] || {}, r)), (U.numberFormats = A.value), e.clearNumberFormat(U, n, r);
            }),
            (Q[u] = k),
            (Q[a] = function (...n) {
                return X(
                    (t) => {
                        let r;
                        const i = t;
                        try {
                            (i.processor = K), (r = Reflect.apply(e.translate, null, [i, ...n]));
                        } finally {
                            i.processor = null;
                        }
                        return r;
                    },
                    () => e.parseTranslateArgs(...n),
                    "translate",
                    (e) => e[a](...n),
                    (e) => [f(e)],
                    (e) => t.isArray(e)
                );
            }),
            (Q[o] = function (...n) {
                return X(
                    (t) => Reflect.apply(e.datetime, null, [t, ...n]),
                    () => e.parseDateTimeArgs(...n),
                    "datetime format",
                    (e) => e[o](...n),
                    g,
                    (e) => t.isString(e) || t.isArray(e)
                );
            }),
            (Q[c] = function (...n) {
                return X(
                    (t) => Reflect.apply(e.number, null, [t, ...n]),
                    () => e.parseNumberArgs(...n),
                    "number format",
                    (e) => e[c](...n),
                    g,
                    (e) => t.isString(e) || t.isArray(e)
                );
            }),
            Q
        );
    }
    function T(n = {}) {
        const r = k(
                (function (n) {
                    const r = t.isString(n.locale) ? n.locale : e.DEFAULT_LOCALE,
                        i =
                            t.isString(n.fallbackLocale) ||
                            t.isArray(n.fallbackLocale) ||
                            t.isPlainObject(n.fallbackLocale) ||
                            !1 === n.fallbackLocale
                                ? n.fallbackLocale
                                : r,
                        s = t.isFunction(n.missing) ? n.missing : void 0,
                        a =
                            (!t.isBoolean(n.silentTranslationWarn) && !t.isRegExp(n.silentTranslationWarn)) ||
                            !n.silentTranslationWarn,
                        o =
                            (!t.isBoolean(n.silentFallbackWarn) && !t.isRegExp(n.silentFallbackWarn)) ||
                            !n.silentFallbackWarn,
                        c = !t.isBoolean(n.fallbackRoot) || n.fallbackRoot,
                        l = !!n.formatFallbackMessages,
                        u = t.isPlainObject(n.modifiers) ? n.modifiers : {},
                        d = n.pluralizationRules,
                        h = t.isFunction(n.postTranslation) ? n.postTranslation : void 0,
                        m = !t.isString(n.warnHtmlInMessage) || "off" !== n.warnHtmlInMessage,
                        p = !!n.escapeParameterHtml,
                        f = !t.isBoolean(n.sync) || n.sync;
                    let g = n.messages;
                    if (t.isPlainObject(n.sharedMessages)) {
                        const e = n.sharedMessages;
                        g = Object.keys(e).reduce((n, r) => {
                            const i = n[r] || (n[r] = {});
                            return t.assign(i, e[r]), n;
                        }, g || {});
                    }
                    const { __i18n: b, __root: y, __injectWithOption: w } = n,
                        k = n.datetimeFormats,
                        T = n.numberFormats;
                    return {
                        locale: r,
                        fallbackLocale: i,
                        messages: g,
                        flatJson: n.flatJson,
                        datetimeFormats: k,
                        numberFormats: T,
                        missing: s,
                        missingWarn: a,
                        fallbackWarn: o,
                        fallbackRoot: c,
                        fallbackFormat: l,
                        modifiers: u,
                        pluralRules: d,
                        postTranslation: h,
                        warnHtmlMessage: m,
                        escapeParameter: p,
                        messageResolver: n.messageResolver,
                        inheritLocale: f,
                        __i18n: b,
                        __root: y,
                        __injectWithOption: w,
                    };
                })(n)
            ),
            { __extender: i } = n,
            s = {
                id: r.id,
                get locale() {
                    return r.locale.value;
                },
                set locale(e) {
                    r.locale.value = e;
                },
                get fallbackLocale() {
                    return r.fallbackLocale.value;
                },
                set fallbackLocale(e) {
                    r.fallbackLocale.value = e;
                },
                get messages() {
                    return r.messages.value;
                },
                get datetimeFormats() {
                    return r.datetimeFormats.value;
                },
                get numberFormats() {
                    return r.numberFormats.value;
                },
                get availableLocales() {
                    return r.availableLocales;
                },
                get missing() {
                    return r.getMissingHandler();
                },
                set missing(e) {
                    r.setMissingHandler(e);
                },
                get silentTranslationWarn() {
                    return t.isBoolean(r.missingWarn) ? !r.missingWarn : r.missingWarn;
                },
                set silentTranslationWarn(e) {
                    r.missingWarn = t.isBoolean(e) ? !e : e;
                },
                get silentFallbackWarn() {
                    return t.isBoolean(r.fallbackWarn) ? !r.fallbackWarn : r.fallbackWarn;
                },
                set silentFallbackWarn(e) {
                    r.fallbackWarn = t.isBoolean(e) ? !e : e;
                },
                get modifiers() {
                    return r.modifiers;
                },
                get formatFallbackMessages() {
                    return r.fallbackFormat;
                },
                set formatFallbackMessages(e) {
                    r.fallbackFormat = e;
                },
                get postTranslation() {
                    return r.getPostTranslationHandler();
                },
                set postTranslation(e) {
                    r.setPostTranslationHandler(e);
                },
                get sync() {
                    return r.inheritLocale;
                },
                set sync(e) {
                    r.inheritLocale = e;
                },
                get warnHtmlInMessage() {
                    return r.warnHtmlMessage ? "warn" : "off";
                },
                set warnHtmlInMessage(e) {
                    r.warnHtmlMessage = "off" !== e;
                },
                get escapeParameterHtml() {
                    return r.escapeParameter;
                },
                set escapeParameterHtml(e) {
                    r.escapeParameter = e;
                },
                get pluralizationRules() {
                    return r.pluralRules || {};
                },
                __composer: r,
                t: (...e) => Reflect.apply(r.t, r, [...e]),
                rt: (...e) => Reflect.apply(r.rt, r, [...e]),
                te: (e, t) => r.te(e, t),
                tm: (e) => r.tm(e),
                getLocaleMessage: (e) => r.getLocaleMessage(e),
                setLocaleMessage(e, t) {
                    r.setLocaleMessage(e, t);
                },
                mergeLocaleMessage(e, t) {
                    r.mergeLocaleMessage(e, t);
                },
                d: (...e) => Reflect.apply(r.d, r, [...e]),
                getDateTimeFormat: (e) => r.getDateTimeFormat(e),
                setDateTimeFormat(e, t) {
                    r.setDateTimeFormat(e, t);
                },
                mergeDateTimeFormat(e, t) {
                    r.mergeDateTimeFormat(e, t);
                },
                n: (...e) => Reflect.apply(r.n, r, [...e]),
                getNumberFormat: (e) => r.getNumberFormat(e),
                setNumberFormat(e, t) {
                    r.setNumberFormat(e, t);
                },
                mergeNumberFormat(e, t) {
                    r.mergeNumberFormat(e, t);
                },
            };
        return (s.__extender = i), s;
    }
    function _(e, t) {
        (e.locale = t.locale || e.locale),
            (e.fallbackLocale = t.fallbackLocale || e.fallbackLocale),
            (e.missing = t.missing || e.missing),
            (e.silentTranslationWarn = t.silentTranslationWarn || e.silentFallbackWarn),
            (e.silentFallbackWarn = t.silentFallbackWarn || e.silentFallbackWarn),
            (e.formatFallbackMessages = t.formatFallbackMessages || e.formatFallbackMessages),
            (e.postTranslation = t.postTranslation || e.postTranslation),
            (e.warnHtmlInMessage = t.warnHtmlInMessage || e.warnHtmlInMessage),
            (e.escapeParameterHtml = t.escapeParameterHtml || e.escapeParameterHtml),
            (e.sync = t.sync || e.sync),
            e.__composer[l](t.pluralizationRules || e.pluralizationRules);
        const n = m(e.locale, { messages: t.messages, __i18n: t.__i18n });
        return (
            Object.keys(n).forEach((t) => e.mergeLocaleMessage(t, n[t])),
            t.datetimeFormats &&
                Object.keys(t.datetimeFormats).forEach((n) => e.mergeDateTimeFormat(n, t.datetimeFormats[n])),
            t.numberFormats && Object.keys(t.numberFormats).forEach((n) => e.mergeNumberFormat(n, t.numberFormats[n])),
            e
        );
    }
    const v = {
        tag: { type: [String, Object] },
        locale: { type: String },
        scope: { type: String, validator: (e) => "parent" === e || "global" === e, default: "parent" },
        i18n: { type: Object },
    };
    function S() {
        return n.Fragment;
    }
    const E = n.defineComponent({
            name: "i18n-t",
            props: t.assign(
                {
                    keypath: { type: String, required: !0 },
                    plural: { type: [Number, String], validator: (e) => t.isNumber(e) || !isNaN(e) },
                },
                v
            ),
            setup(e, r) {
                const { slots: i, attrs: s } = r,
                    o = e.i18n || M({ useScope: e.scope, __useComponent: !0 });
                return () => {
                    const c = Object.keys(i).filter((e) => "_" !== e[0]),
                        l = t.create();
                    e.locale && (l.locale = e.locale),
                        void 0 !== e.plural && (l.plural = t.isString(e.plural) ? +e.plural : e.plural);
                    const u = (function ({ slots: e }, r) {
                            if (1 === r.length && "default" === r[0])
                                return (e.default ? e.default() : []).reduce(
                                    (e, t) => [...e, ...(t.type === n.Fragment ? t.children : [t])],
                                    []
                                );
                            return r.reduce((t, n) => {
                                const r = e[n];
                                return r && (t[n] = r()), t;
                            }, t.create());
                        })(r, c),
                        d = o[a](e.keypath, u, l),
                        h = t.assign(t.create(), s),
                        m = t.isString(e.tag) || t.isObject(e.tag) ? e.tag : S();
                    return n.h(m, h, d);
                };
            },
        }),
        C = E;
    function I(e, r, i, s) {
        const { slots: a, attrs: o } = r;
        return () => {
            const r = { part: !0 };
            let c = t.create();
            e.locale && (r.locale = e.locale),
                t.isString(e.format)
                    ? (r.key = e.format)
                    : t.isObject(e.format) &&
                      (t.isString(e.format.key) && (r.key = e.format.key),
                      (c = Object.keys(e.format).reduce(
                          (n, r) => (i.includes(r) ? t.assign(t.create(), n, { [r]: e.format[r] }) : n),
                          t.create()
                      )));
            const l = s(e.value, r, c);
            let u = [r.key];
            t.isArray(l)
                ? (u = l.map((e, n) => {
                      const r = a[e.type],
                          i = r ? r({ [e.type]: e.value, index: n, parts: l }) : [e.value];
                      var s;
                      return (s = i), t.isArray(s) && !t.isString(s[0]) && (i[0].key = `${e.type}-${n}`), i;
                  }))
                : t.isString(l) && (u = [l]);
            const d = t.assign(t.create(), o),
                h = t.isString(e.tag) || t.isObject(e.tag) ? e.tag : S();
            return n.h(h, d, u);
        };
    }
    const x = n.defineComponent({
            name: "i18n-n",
            props: t.assign({ value: { type: Number, required: !0 }, format: { type: [String, Object] } }, v),
            setup(t, n) {
                const r = t.i18n || M({ useScope: t.scope, __useComponent: !0 });
                return I(t, n, e.NUMBER_FORMAT_OPTIONS_KEYS, (...e) => r[c](...e));
            },
        }),
        A = x;
    function P(e) {
        const r = (t) => {
            const { instance: n, value: r } = t;
            if (!n || !n.$) throw s(i.UNEXPECTED_ERROR);
            const a = (function (e, t) {
                    const n = e;
                    if ("composition" === e.mode) return n.__getInstance(t) || e.global;
                    {
                        const r = n.__getInstance(t);
                        return null != r ? r.__composer : e.global.__composer;
                    }
                })(e, n.$),
                o = O(r);
            return [Reflect.apply(a.t, a, [...N(o)]), a];
        };
        return {
            created: (i, s) => {
                const [a, o] = r(s);
                t.inBrowser &&
                    e.global === o &&
                    (i.__i18nWatcher = n.watch(o.locale, () => {
                        s.instance && s.instance.$forceUpdate();
                    })),
                    (i.__composer = o),
                    (i.textContent = a);
            },
            unmounted: (e) => {
                t.inBrowser &&
                    e.__i18nWatcher &&
                    (e.__i18nWatcher(), (e.__i18nWatcher = void 0), delete e.__i18nWatcher),
                    e.__composer && ((e.__composer = void 0), delete e.__composer);
            },
            beforeUpdate: (e, { value: t }) => {
                if (e.__composer) {
                    const n = e.__composer,
                        r = O(t);
                    e.textContent = Reflect.apply(n.t, n, [...N(r)]);
                }
            },
            getSSRProps: (e) => {
                const [t] = r(e);
                return { textContent: t };
            },
        };
    }
    function O(e) {
        if (t.isString(e)) return { path: e };
        if (t.isPlainObject(e)) {
            if (!("path" in e)) throw s(i.REQUIRED_VALUE);
            return e;
        }
        throw s(i.INVALID_VALUE);
    }
    function N(e) {
        const { path: n, locale: r, args: i, choice: s, plural: a } = e,
            o = {},
            c = i || {};
        return (
            t.isString(r) && (o.locale = r), t.isNumber(s) && (o.plural = s), t.isNumber(a) && (o.plural = a), [n, c, o]
        );
    }
    const R = t.makeSymbol("global-vue-i18n");
    function M(e = {}) {
        const r = n.getCurrentInstance();
        if (null == r) throw s(i.MUST_BE_CALL_SETUP_TOP);
        if (!r.isCE && null != r.appContext.app && !r.appContext.app.__VUE_I18N_SYMBOL__) throw s(i.NOT_INSTALLED);
        const a = (function (e) {
                const t = n.inject(e.isCE ? R : e.appContext.app.__VUE_I18N_SYMBOL__);
                if (!t) throw s(e.isCE ? i.NOT_INSTALLED_WITH_PROVIDE : i.UNEXPECTED_ERROR);
                return t;
            })(r),
            o = (function (e) {
                return "composition" === e.mode ? e.global : e.global.__composer;
            })(a),
            c = (function (e) {
                return e.type;
            })(r),
            l = (function (e, n) {
                return t.isEmptyObject(e) ? ("__i18n" in n ? "local" : "global") : e.useScope ? e.useScope : "local";
            })(e, c);
        if ("global" === l) return p(o, e, c), o;
        if ("parent" === l) {
            let t = (function (e, t, n = !1) {
                let r = null;
                const i = t.root;
                let s = (function (e, t = !1) {
                    if (null == e) return null;
                    return (t && e.vnode.ctx) || e.parent;
                })(t, n);
                for (; null != s; ) {
                    const t = e;
                    if ("composition" === e.mode) r = t.__getInstance(s);
                    else {
                        const e = t.__getInstance(s);
                        null != e && ((r = e.__composer), n && r && !r[u] && (r = null));
                    }
                    if (null != r) break;
                    if (i === s) break;
                    s = s.parent;
                }
                return r;
            })(a, r, e.__useComponent);
            return null == t && (t = o), t;
        }
        const h = a;
        let m = h.__getInstance(r);
        if (null == m) {
            const i = t.assign({}, e);
            "__i18n" in c && (i.__i18n = c.__i18n),
                o && (i.__root = o),
                (m = k(i)),
                h.__composerExtend && (m[d] = h.__composerExtend(m)),
                (function (e, t, r) {
                    n.onMounted(() => {}, t),
                        n.onUnmounted(() => {
                            const n = r;
                            e.__deleteInstance(t);
                            const i = n[d];
                            i && (i(), delete n[d]);
                        }, t);
                })(h, r, m),
                h.__setInstance(r, m);
        }
        return m;
    }
    const D = ["locale", "fallbackLocale", "availableLocales"],
        F = ["t", "rt", "d", "n", "tm", "te"];
    const L = n.defineComponent({
            name: "i18n-d",
            props: t.assign({ value: { type: [Number, Date], required: !0 }, format: { type: [String, Object] } }, v),
            setup(t, n) {
                const r = t.i18n || M({ useScope: t.scope, __useComponent: !0 });
                return I(t, n, e.DATETIME_FORMAT_OPTIONS_KEYS, (...e) => r[o](...e));
            },
        }),
        B = L;
    return (
        e.registerMessageCompiler(e.compile),
        e.registerMessageResolver(e.resolveValue),
        e.registerLocaleFallbacker(e.fallbackWithLocaleChain),
        (pm.DatetimeFormat = L),
        (pm.I18nD = B),
        (pm.I18nInjectionKey = R),
        (pm.I18nN = A),
        (pm.I18nT = C),
        (pm.NumberFormat = x),
        (pm.Translation = E),
        (pm.VERSION = r),
        (pm.createI18n = function (e = {}) {
            const r = !t.isBoolean(e.legacy) || e.legacy,
                a = !t.isBoolean(e.globalInjection) || e.globalInjection,
                o = new Map(),
                [c, l] = (function (e, t) {
                    const r = n.effectScope(),
                        a = t ? r.run(() => T(e)) : r.run(() => k(e));
                    if (null == a) throw s(i.UNEXPECTED_ERROR);
                    return [r, a];
                })(e, r),
                u = t.makeSymbol(""),
                d = {
                    get mode() {
                        return r ? "legacy" : "composition";
                    },
                    async install(e, ...o) {
                        if (((e.__VUE_I18N_SYMBOL__ = u), e.provide(e.__VUE_I18N_SYMBOL__, d), t.isPlainObject(o[0]))) {
                            const e = o[0];
                            (d.__composerExtend = e.__composerExtend), (d.__vueI18nExtend = e.__vueI18nExtend);
                        }
                        let c = null;
                        !r &&
                            a &&
                            (c = (function (e, t) {
                                const r = Object.create(null);
                                D.forEach((e) => {
                                    const a = Object.getOwnPropertyDescriptor(t, e);
                                    if (!a) throw s(i.UNEXPECTED_ERROR);
                                    const o = n.isRef(a.value)
                                        ? {
                                              get: () => a.value.value,
                                              set(e) {
                                                  a.value.value = e;
                                              },
                                          }
                                        : { get: () => a.get && a.get() };
                                    Object.defineProperty(r, e, o);
                                }),
                                    (e.config.globalProperties.$i18n = r),
                                    F.forEach((n) => {
                                        const r = Object.getOwnPropertyDescriptor(t, n);
                                        if (!r || !r.value) throw s(i.UNEXPECTED_ERROR);
                                        Object.defineProperty(e.config.globalProperties, `$${n}`, r);
                                    });
                                const a = () => {
                                    delete e.config.globalProperties.$i18n,
                                        F.forEach((t) => {
                                            delete e.config.globalProperties[`$${t}`];
                                        });
                                };
                                return a;
                            })(e, d.global)),
                            (function (e, n, ...r) {
                                const i = t.isPlainObject(r[0]) ? r[0] : {};
                                (!t.isBoolean(i.globalInstall) || i.globalInstall) &&
                                    ([E.name, "I18nT"].forEach((t) => e.component(t, E)),
                                    [x.name, "I18nN"].forEach((t) => e.component(t, x)),
                                    [L.name, "I18nD"].forEach((t) => e.component(t, L))),
                                    e.directive("t", P(n));
                            })(e, d, ...o),
                            r &&
                                e.mixin(
                                    (function (e, t, r) {
                                        return {
                                            beforeCreate() {
                                                const a = n.getCurrentInstance();
                                                if (!a) throw s(i.UNEXPECTED_ERROR);
                                                const o = this.$options;
                                                if (o.i18n) {
                                                    const n = o.i18n;
                                                    if (
                                                        (o.__i18n && (n.__i18n = o.__i18n),
                                                        (n.__root = t),
                                                        this === this.$root)
                                                    )
                                                        this.$i18n = _(e, n);
                                                    else {
                                                        (n.__injectWithOption = !0),
                                                            (n.__extender = r.__vueI18nExtend),
                                                            (this.$i18n = T(n));
                                                        const e = this.$i18n;
                                                        e.__extender && (e.__disposer = e.__extender(this.$i18n));
                                                    }
                                                } else if (o.__i18n)
                                                    if (this === this.$root) this.$i18n = _(e, o);
                                                    else {
                                                        this.$i18n = T({
                                                            __i18n: o.__i18n,
                                                            __injectWithOption: !0,
                                                            __extender: r.__vueI18nExtend,
                                                            __root: t,
                                                        });
                                                        const e = this.$i18n;
                                                        e.__extender && (e.__disposer = e.__extender(this.$i18n));
                                                    }
                                                else this.$i18n = e;
                                                o.__i18nGlobal && p(t, o, o),
                                                    (this.$t = (...e) => this.$i18n.t(...e)),
                                                    (this.$rt = (...e) => this.$i18n.rt(...e)),
                                                    (this.$te = (e, t) => this.$i18n.te(e, t)),
                                                    (this.$d = (...e) => this.$i18n.d(...e)),
                                                    (this.$n = (...e) => this.$i18n.n(...e)),
                                                    (this.$tm = (e) => this.$i18n.tm(e)),
                                                    r.__setInstance(a, this.$i18n);
                                            },
                                            mounted() {},
                                            unmounted() {
                                                const e = n.getCurrentInstance();
                                                if (!e) throw s(i.UNEXPECTED_ERROR);
                                                const t = this.$i18n;
                                                delete this.$t,
                                                    delete this.$rt,
                                                    delete this.$te,
                                                    delete this.$d,
                                                    delete this.$n,
                                                    delete this.$tm,
                                                    t.__disposer &&
                                                        (t.__disposer(), delete t.__disposer, delete t.__extender),
                                                    r.__deleteInstance(e),
                                                    delete this.$i18n;
                                            },
                                        };
                                    })(l, l.__composer, d)
                                );
                        const h = e.unmount;
                        e.unmount = () => {
                            c && c(), d.dispose(), h();
                        };
                    },
                    get global() {
                        return l;
                    },
                    dispose() {
                        c.stop();
                    },
                    __instances: o,
                    __getInstance: function (e) {
                        return o.get(e) || null;
                    },
                    __setInstance: function (e, t) {
                        o.set(e, t);
                    },
                    __deleteInstance: function (e) {
                        o.delete(e);
                    },
                };
            return d;
        }),
        (pm.useI18n = M),
        (pm.vTDirective = P),
        pm
    );
}
function Uk() {
    return Lk ? Fk : ((Lk = 1), (Fk = zk()));
}
var $k = Uk();
function Vk(e) {
    if (!e) throw new Error("Assertion failed.");
}
const Wk = (e) => {
        const t = ((e % 360) + 360) % 360;
        if (0 === t || 90 === t || 180 === t || 270 === t) return t;
        throw new Error(`Invalid rotation ${e}.`);
    },
    jk = (e) => e && e[e.length - 1],
    Hk = (e) => e >= 0 && e < 2 ** 32;
class qk {
    constructor(e) {
        (this.bytes = e), (this.pos = 0);
    }
    seekToByte(e) {
        this.pos = 8 * e;
    }
    readBit() {
        const e = Math.floor(this.pos / 8),
            t = this.bytes[e] ?? 0,
            n = 7 - (7 & this.pos),
            r = (t & (1 << n)) >> n;
        return this.pos++, r;
    }
    readBits(e) {
        if (1 === e) return this.readBit();
        let t = 0;
        for (let n = 0; n < e; n++) (t <<= 1), (t |= this.readBit());
        return t;
    }
    writeBits(e, t) {
        const n = this.pos + e;
        for (let r = this.pos; r < n; r++) {
            const e = Math.floor(r / 8);
            let i = this.bytes[e];
            const s = 7 - (7 & r);
            (i &= ~(1 << s)), (i |= ((t & (1 << (n - r - 1))) >> (n - r - 1)) << s), (this.bytes[e] = i);
        }
        this.pos = n;
    }
    readAlignedByte() {
        if (this.pos % 8 != 0) throw new Error("Bitstream is not byte-aligned.");
        const e = this.pos / 8,
            t = this.bytes[e] ?? 0;
        return (this.pos += 8), t;
    }
    skipBits(e) {
        this.pos += e;
    }
    getBitsLeft() {
        return 8 * this.bytes.length - this.pos;
    }
    clone() {
        const e = new qk(this.bytes);
        return (e.pos = this.pos), e;
    }
}
const Xk = (e) => {
        let t = 0;
        for (; 0 === e.readBits(1) && t < 32; ) t++;
        if (t >= 32) throw new Error("Invalid exponential-Golomb code.");
        return (1 << t) - 1 + e.readBits(t);
    },
    Gk = (e) => {
        const t = Xk(e);
        return 1 & t ? (t + 1) >> 1 : -(t >> 1);
    },
    Kk = (e) =>
        e.constructor === Uint8Array
            ? e
            : e instanceof ArrayBuffer
              ? new Uint8Array(e)
              : new Uint8Array(e.buffer, e.byteOffset, e.byteLength),
    Yk = (e) =>
        e.constructor === DataView
            ? e
            : e instanceof ArrayBuffer
              ? new DataView(e)
              : new DataView(e.buffer, e.byteOffset, e.byteLength),
    Qk = new TextDecoder(),
    Jk = new TextEncoder(),
    Zk = (e) => {
        for (let t = 0; t < e.length; t++) {
            if (e.charCodeAt(t) > 255) return !1;
        }
        return !0;
    },
    eT = (e) => Object.fromEntries(Object.entries(e).map(([e, t]) => [t, e])),
    tT = { bt709: 1, bt470bg: 5, smpte170m: 6, bt2020: 9, smpte432: 12 },
    nT = eT(tT),
    rT = { bt709: 1, smpte170m: 6, linear: 8, "iec61966-2-1": 13, pq: 16, hlg: 18 },
    iT = eT(rT),
    sT = { rgb: 0, bt709: 1, bt470bg: 5, smpte170m: 6, "bt2020-ncl": 9 },
    aT = eT(sT),
    oT = (e) => !!(e && e.primaries && e.transfer && e.matrix && void 0 !== e.fullRange),
    cT = (e) =>
        e instanceof ArrayBuffer ||
        ("undefined" != typeof SharedArrayBuffer && e instanceof SharedArrayBuffer) ||
        ArrayBuffer.isView(e);
class lT {
    constructor() {
        this.currentPromise = Promise.resolve();
    }
    async acquire() {
        let e;
        const t = new Promise((t) => {
                e = t;
            }),
            n = this.currentPromise;
        return (this.currentPromise = t), await n, e;
    }
}
const uT = (e) => [...e].map((e) => e.toString(16).padStart(2, "0")).join(""),
    dT = (e) =>
        (e =
            (((e =
                (((e =
                    (((e =
                        (((e = ((e >> 1) & 1431655765) | ((1431655765 & e) << 1)) >> 2) & 858993459) |
                        ((858993459 & e) << 2)) >>
                        4) &
                        252645135) |
                    ((252645135 & e) << 4)) >>
                    8) &
                    16711935) |
                ((16711935 & e) << 8)) >>
                16) &
                65535) |
            ((65535 & e) << 16)) >>> 0,
    hT = (e, t, n) => {
        let r = 0,
            i = e.length - 1,
            s = -1;
        for (; r <= i; ) {
            const a = (r + i) >> 1,
                o = n(e[a]);
            o === t ? ((s = a), (i = a - 1)) : o < t ? (r = a + 1) : (i = a - 1);
        }
        return s;
    },
    mT = (e, t, n) => {
        let r = 0,
            i = e.length - 1,
            s = -1;
        for (; r <= i; ) {
            const a = (r + (i - r + 1) / 2) | 0;
            n(e[a]) <= t ? ((s = a), (r = a + 1)) : (i = a - 1);
        }
        return s;
    },
    pT = (e, t, n) => {
        const r = mT(e, n(t), n);
        e.splice(r + 1, 0, t);
    },
    fT = () => {
        let e, t;
        return {
            promise: new Promise((n, r) => {
                (e = n), (t = r);
            }),
            resolve: e,
            reject: t,
        };
    },
    gT = (e, t) => {
        for (let n = e.length - 1; n >= 0; n--) if (t(e[n])) return e[n];
    },
    bT = (e, t) => {
        for (let n = e.length - 1; n >= 0; n--) if (t(e[n])) return n;
        return -1;
    },
    yT = (e) => {
        throw new Error(`Unexpected value: ${e}`);
    },
    wT = (e, t, n) => {
        const r = e.getUint8(t),
            i = e.getUint8(t + 1),
            s = e.getUint8(t + 2);
        return n ? r | (i << 8) | (s << 16) : (r << 16) | (i << 8) | s;
    },
    kT = (e, t, n, r) => {
        (n >>>= 0),
            (n &= 16777215),
            r
                ? (e.setUint8(t, 255 & n), e.setUint8(t + 1, (n >>> 8) & 255), e.setUint8(t + 2, (n >>> 16) & 255))
                : (e.setUint8(t, (n >>> 16) & 255), e.setUint8(t + 1, (n >>> 8) & 255), e.setUint8(t + 2, 255 & n));
    },
    TT = (e, t) => ({
        async next() {
            const n = await e.next();
            return n.done ? { value: void 0, done: !0 } : { value: t(n.value), done: !1 };
        },
        return: () => e.return(),
        throw: (t) => e.throw(t),
        [Symbol.asyncIterator]() {
            return this;
        },
    }),
    _T = (e, t, n) => Math.max(t, Math.min(n, e)),
    vT = "und",
    ST = (e, t) => {
        const n = 10 ** t;
        return Math.round(e * n) / n;
    },
    ET = (e, t) => Math.round(e / t) * t,
    CT = /^[a-z]{3}$/,
    IT = (e) => CT.test(e),
    xT = 1e6 * (1 + Number.EPSILON),
    AT = (e, t) => {
        const n = { ...e, ...t };
        if (e.headers || t.headers) {
            const r = e.headers ? PT(e.headers) : {},
                i = t.headers ? PT(t.headers) : {},
                s = { ...r };
            Object.entries(i).forEach(([e, t]) => {
                const n = Object.keys(s).find((t) => t.toLowerCase() === e.toLowerCase());
                n && delete s[n], (s[e] = t);
            }),
                (n.headers = s);
        }
        return n;
    },
    PT = (e) => {
        if (e instanceof Headers) {
            const t = {};
            return (
                e.forEach((e, n) => {
                    t[n] = e;
                }),
                t
            );
        }
        if (Array.isArray(e)) {
            const t = {};
            return (
                e.forEach(([e, n]) => {
                    t[e] = n;
                }),
                t
            );
        }
        return e;
    },
    OT = async (e, t, n, r) => {
        let i = 0;
        for (;;)
            try {
                return await e(t, n);
            } catch (s) {
                i++;
                const e = r(i, s, t);
                if (null === e) throw s;
                if (!Number.isFinite(e) || e < 0)
                    throw new TypeError("Retry delay must be a non-negative finite number.");
                e > 0 && (await new Promise((t) => setTimeout(t, 1e3 * e)));
            }
    };
class NT {
    constructor() {
        this.currentPromise = Promise.resolve();
    }
    call(e) {
        return (this.currentPromise = this.currentPromise.then(e));
    }
}
let RT = null;
const MT = () => {
    if (null !== RT) return RT;
    const e = !(
        "undefined" == typeof navigator ||
        !navigator.vendor?.match(/apple/i) ||
        navigator.userAgent?.match(/crios/i) ||
        navigator.userAgent?.match(/fxios/i) ||
        navigator.userAgent?.match(/Opera|OPT\//)
    );
    return (RT = e), e;
};
let DT = null;
const FT = () =>
        null !== DT ? DT : (DT = "undefined" != typeof navigator && navigator.userAgent?.includes("Firefox")),
    LT = (e, t) => (-1 !== e ? e : t),
    BT = (e, t, n, r) => e <= r && n <= t,
    zT = function* (e) {
        for (const t in e) {
            const n = e[t];
            void 0 !== n && (yield { key: t, value: n });
        }
    },
    UT = (e) => {
        switch (e.toLowerCase()) {
            case "image/jpeg":
            case "image/jpg":
                return ".jpg";
            case "image/png":
                return ".png";
            case "image/gif":
                return ".gif";
            case "image/webp":
                return ".webp";
            case "image/bmp":
                return ".bmp";
            case "image/svg+xml":
                return ".svg";
            case "image/tiff":
                return ".tiff";
            case "image/avif":
                return ".avif";
            case "image/x-icon":
            case "image/vnd.microsoft.icon":
                return ".ico";
            default:
                return null;
        }
    },
    $T = (e) => {
        const t = atob(e),
            n = new Uint8Array(t.length);
        for (let r = 0; r < t.length; r++) n[r] = t.charCodeAt(r);
        return n;
    },
    VT = (e, t) => {
        if (e.length !== t.length) return !1;
        for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
        return !0;
    },
    WT = () => {
        Symbol.dispose ??= Symbol("Symbol.dispose");
    },
    jT = (e) => "number" == typeof e && !Number.isNaN(e);
class HT {
    constructor(e, t) {
        if (((this.data = e), (this.mimeType = t), !(e instanceof Uint8Array)))
            throw new TypeError("data must be a Uint8Array.");
        if ("string" != typeof t) throw new TypeError("mimeType must be a string.");
    }
}
class qT {
    constructor(e, t, n, r) {
        if (((this.data = e), (this.mimeType = t), (this.name = n), (this.description = r), !(e instanceof Uint8Array)))
            throw new TypeError("data must be a Uint8Array.");
        if (void 0 !== t && "string" != typeof t) throw new TypeError("mimeType, when provided, must be a string.");
        if (void 0 !== n && "string" != typeof n) throw new TypeError("name, when provided, must be a string.");
        if (void 0 !== r && "string" != typeof r) throw new TypeError("description, when provided, must be a string.");
    }
}
const XT = (e) => {
        if (!e || "object" != typeof e) throw new TypeError("tags must be an object.");
        if (void 0 !== e.title && "string" != typeof e.title)
            throw new TypeError("tags.title, when provided, must be a string.");
        if (void 0 !== e.description && "string" != typeof e.description)
            throw new TypeError("tags.description, when provided, must be a string.");
        if (void 0 !== e.artist && "string" != typeof e.artist)
            throw new TypeError("tags.artist, when provided, must be a string.");
        if (void 0 !== e.album && "string" != typeof e.album)
            throw new TypeError("tags.album, when provided, must be a string.");
        if (void 0 !== e.albumArtist && "string" != typeof e.albumArtist)
            throw new TypeError("tags.albumArtist, when provided, must be a string.");
        if (void 0 !== e.trackNumber && (!Number.isInteger(e.trackNumber) || e.trackNumber <= 0))
            throw new TypeError("tags.trackNumber, when provided, must be a positive integer.");
        if (void 0 !== e.tracksTotal && (!Number.isInteger(e.tracksTotal) || e.tracksTotal <= 0))
            throw new TypeError("tags.tracksTotal, when provided, must be a positive integer.");
        if (void 0 !== e.discNumber && (!Number.isInteger(e.discNumber) || e.discNumber <= 0))
            throw new TypeError("tags.discNumber, when provided, must be a positive integer.");
        if (void 0 !== e.discsTotal && (!Number.isInteger(e.discsTotal) || e.discsTotal <= 0))
            throw new TypeError("tags.discsTotal, when provided, must be a positive integer.");
        if (void 0 !== e.genre && "string" != typeof e.genre)
            throw new TypeError("tags.genre, when provided, must be a string.");
        if (void 0 !== e.date && (!(e.date instanceof Date) || Number.isNaN(e.date.getTime())))
            throw new TypeError("tags.date, when provided, must be a valid Date.");
        if (void 0 !== e.lyrics && "string" != typeof e.lyrics)
            throw new TypeError("tags.lyrics, when provided, must be a string.");
        if (void 0 !== e.images) {
            if (!Array.isArray(e.images)) throw new TypeError("tags.images, when provided, must be an array.");
            for (const t of e.images) {
                if (!t || "object" != typeof t) throw new TypeError("Each image in tags.images must be an object.");
                if (!(t.data instanceof Uint8Array)) throw new TypeError("Each image.data must be a Uint8Array.");
                if ("string" != typeof t.mimeType) throw new TypeError("Each image.mimeType must be a string.");
                if (!["coverFront", "coverBack", "unknown"].includes(t.kind))
                    throw new TypeError("Each image.kind must be 'coverFront', 'coverBack', or 'unknown'.");
            }
        }
        if (void 0 !== e.comment && "string" != typeof e.comment)
            throw new TypeError("tags.comment, when provided, must be a string.");
        if (void 0 !== e.raw) {
            if (!e.raw || "object" != typeof e.raw) throw new TypeError("tags.raw, when provided, must be an object.");
            for (const t of Object.values(e.raw))
                if (
                    !(
                        null === t ||
                        "string" == typeof t ||
                        t instanceof Uint8Array ||
                        t instanceof HT ||
                        t instanceof qT
                    )
                )
                    throw new TypeError(
                        "Each value in tags.raw must be a string, Uint8Array, RichImageData, AttachedFile, or null."
                    );
        }
    },
    GT = ["avc", "hevc", "vp9", "av1", "vp8"],
    KT = [
        "pcm-s16",
        "pcm-s16be",
        "pcm-s24",
        "pcm-s24be",
        "pcm-s32",
        "pcm-s32be",
        "pcm-f32",
        "pcm-f32be",
        "pcm-f64",
        "pcm-f64be",
        "pcm-u8",
        "pcm-s8",
        "ulaw",
        "alaw",
    ],
    YT = ["aac", "opus", "mp3", "vorbis", "flac"],
    QT = [...YT, ...KT],
    JT = ["webvtt"],
    ZT = [
        { maxMacroblocks: 99, maxBitrate: 64e3, level: 10 },
        { maxMacroblocks: 396, maxBitrate: 192e3, level: 11 },
        { maxMacroblocks: 396, maxBitrate: 384e3, level: 12 },
        { maxMacroblocks: 396, maxBitrate: 768e3, level: 13 },
        { maxMacroblocks: 396, maxBitrate: 2e6, level: 20 },
        { maxMacroblocks: 792, maxBitrate: 4e6, level: 21 },
        { maxMacroblocks: 1620, maxBitrate: 4e6, level: 22 },
        { maxMacroblocks: 1620, maxBitrate: 1e7, level: 30 },
        { maxMacroblocks: 3600, maxBitrate: 14e6, level: 31 },
        { maxMacroblocks: 5120, maxBitrate: 2e7, level: 32 },
        { maxMacroblocks: 8192, maxBitrate: 2e7, level: 40 },
        { maxMacroblocks: 8192, maxBitrate: 5e7, level: 41 },
        { maxMacroblocks: 8704, maxBitrate: 5e7, level: 42 },
        { maxMacroblocks: 22080, maxBitrate: 135e6, level: 50 },
        { maxMacroblocks: 36864, maxBitrate: 24e7, level: 51 },
        { maxMacroblocks: 36864, maxBitrate: 24e7, level: 52 },
        { maxMacroblocks: 139264, maxBitrate: 24e7, level: 60 },
        { maxMacroblocks: 139264, maxBitrate: 48e7, level: 61 },
        { maxMacroblocks: 139264, maxBitrate: 8e8, level: 62 },
    ],
    e_ = [
        { maxPictureSize: 36864, maxBitrate: 128e3, tier: "L", level: 30 },
        { maxPictureSize: 122880, maxBitrate: 15e5, tier: "L", level: 60 },
        { maxPictureSize: 245760, maxBitrate: 3e6, tier: "L", level: 63 },
        { maxPictureSize: 552960, maxBitrate: 6e6, tier: "L", level: 90 },
        { maxPictureSize: 983040, maxBitrate: 1e7, tier: "L", level: 93 },
        { maxPictureSize: 2228224, maxBitrate: 12e6, tier: "L", level: 120 },
        { maxPictureSize: 2228224, maxBitrate: 3e7, tier: "H", level: 120 },
        { maxPictureSize: 2228224, maxBitrate: 2e7, tier: "L", level: 123 },
        { maxPictureSize: 2228224, maxBitrate: 5e7, tier: "H", level: 123 },
        { maxPictureSize: 8912896, maxBitrate: 25e6, tier: "L", level: 150 },
        { maxPictureSize: 8912896, maxBitrate: 1e8, tier: "H", level: 150 },
        { maxPictureSize: 8912896, maxBitrate: 4e7, tier: "L", level: 153 },
        { maxPictureSize: 8912896, maxBitrate: 16e7, tier: "H", level: 153 },
        { maxPictureSize: 8912896, maxBitrate: 6e7, tier: "L", level: 156 },
        { maxPictureSize: 8912896, maxBitrate: 24e7, tier: "H", level: 156 },
        { maxPictureSize: 35651584, maxBitrate: 6e7, tier: "L", level: 180 },
        { maxPictureSize: 35651584, maxBitrate: 24e7, tier: "H", level: 180 },
        { maxPictureSize: 35651584, maxBitrate: 12e7, tier: "L", level: 183 },
        { maxPictureSize: 35651584, maxBitrate: 48e7, tier: "H", level: 183 },
        { maxPictureSize: 35651584, maxBitrate: 24e7, tier: "L", level: 186 },
        { maxPictureSize: 35651584, maxBitrate: 8e8, tier: "H", level: 186 },
    ],
    t_ = [
        { maxPictureSize: 36864, maxBitrate: 2e5, level: 10 },
        { maxPictureSize: 73728, maxBitrate: 8e5, level: 11 },
        { maxPictureSize: 122880, maxBitrate: 18e5, level: 20 },
        { maxPictureSize: 245760, maxBitrate: 36e5, level: 21 },
        { maxPictureSize: 552960, maxBitrate: 72e5, level: 30 },
        { maxPictureSize: 983040, maxBitrate: 12e6, level: 31 },
        { maxPictureSize: 2228224, maxBitrate: 18e6, level: 40 },
        { maxPictureSize: 2228224, maxBitrate: 3e7, level: 41 },
        { maxPictureSize: 8912896, maxBitrate: 6e7, level: 50 },
        { maxPictureSize: 8912896, maxBitrate: 12e7, level: 51 },
        { maxPictureSize: 8912896, maxBitrate: 18e7, level: 52 },
        { maxPictureSize: 35651584, maxBitrate: 18e7, level: 60 },
        { maxPictureSize: 35651584, maxBitrate: 24e7, level: 61 },
        { maxPictureSize: 35651584, maxBitrate: 48e7, level: 62 },
    ],
    n_ = [
        { maxPictureSize: 147456, maxBitrate: 15e5, tier: "M", level: 0 },
        { maxPictureSize: 278784, maxBitrate: 3e6, tier: "M", level: 1 },
        { maxPictureSize: 665856, maxBitrate: 6e6, tier: "M", level: 4 },
        { maxPictureSize: 1065024, maxBitrate: 1e7, tier: "M", level: 5 },
        { maxPictureSize: 2359296, maxBitrate: 12e6, tier: "M", level: 8 },
        { maxPictureSize: 2359296, maxBitrate: 3e7, tier: "H", level: 8 },
        { maxPictureSize: 2359296, maxBitrate: 2e7, tier: "M", level: 9 },
        { maxPictureSize: 2359296, maxBitrate: 5e7, tier: "H", level: 9 },
        { maxPictureSize: 8912896, maxBitrate: 3e7, tier: "M", level: 12 },
        { maxPictureSize: 8912896, maxBitrate: 1e8, tier: "H", level: 12 },
        { maxPictureSize: 8912896, maxBitrate: 4e7, tier: "M", level: 13 },
        { maxPictureSize: 8912896, maxBitrate: 16e7, tier: "H", level: 13 },
        { maxPictureSize: 8912896, maxBitrate: 6e7, tier: "M", level: 14 },
        { maxPictureSize: 8912896, maxBitrate: 24e7, tier: "H", level: 14 },
        { maxPictureSize: 35651584, maxBitrate: 6e7, tier: "M", level: 15 },
        { maxPictureSize: 35651584, maxBitrate: 24e7, tier: "H", level: 15 },
        { maxPictureSize: 35651584, maxBitrate: 6e7, tier: "M", level: 16 },
        { maxPictureSize: 35651584, maxBitrate: 24e7, tier: "H", level: 16 },
        { maxPictureSize: 35651584, maxBitrate: 1e8, tier: "M", level: 17 },
        { maxPictureSize: 35651584, maxBitrate: 48e7, tier: "H", level: 17 },
        { maxPictureSize: 35651584, maxBitrate: 16e7, tier: "M", level: 18 },
        { maxPictureSize: 35651584, maxBitrate: 8e8, tier: "H", level: 18 },
        { maxPictureSize: 35651584, maxBitrate: 16e7, tier: "M", level: 19 },
        { maxPictureSize: 35651584, maxBitrate: 8e8, tier: "H", level: 19 },
    ],
    r_ = ".01.01.01.01.00",
    i_ = ".0.110.01.01.01.0",
    s_ = (e, t, n, r) => {
        if ("avc" === e) {
            const e = 100,
                i = Math.ceil(t / 16) * Math.ceil(n / 16),
                s = ZT.find((e) => i <= e.maxMacroblocks && r <= e.maxBitrate) ?? jk(ZT),
                a = s ? s.level : 0;
            return `avc1.${e.toString(16).padStart(2, "0")}${"00"}${a.toString(16).padStart(2, "0")}`;
        }
        if ("hevc" === e) {
            const e = "",
                i = 1,
                s = "6",
                a = t * n,
                o = e_.find((e) => a <= e.maxPictureSize && r <= e.maxBitrate) ?? jk(e_),
                c = "B0";
            return `hev1.${e}${i}.${s}.${o.tier}${o.level}.${c}`;
        }
        if ("vp8" === e) return "vp8";
        if ("vp9" === e) {
            const e = t * n,
                i = "08";
            return `vp09.${"00"}.${(t_.find((t) => e <= t.maxPictureSize && r <= t.maxBitrate) ?? jk(t_)).level.toString().padStart(2, "0")}.${i}`;
        }
        if ("av1" === e) {
            const e = 0,
                i = t * n,
                s = n_.find((e) => i <= e.maxPictureSize && r <= e.maxBitrate) ?? jk(n_),
                a = "08";
            return `av01.${e}.${s.level.toString().padStart(2, "0")}${s.tier}.${a}`;
        }
        throw new TypeError(`Unhandled codec '${e}'.`);
    },
    a_ = (e) => {
        const t = e.split(".");
        return [1, 1, Number(t[1]), 2, 1, Number(t[2]), 3, 1, Number(t[3]), 4, 1, t[4] ? Number(t[4]) : 1];
    },
    o_ = (e) => {
        const t = e.split("."),
            n = Number(t[1]),
            r = t[2];
        return [
            129,
            (n << 5) + Number(r.slice(0, -1)),
            (("H" === r.slice(-1) ? 1 : 0) << 7) +
                ((8 === Number(t[3]) ? 0 : 1) << 6) +
                0 +
                ((t[4] ? Number(t[4]) : 0) << 4) +
                ((t[5] ? Number(t[5][0]) : 1) << 3) +
                ((t[5] ? Number(t[5][1]) : 1) << 2) +
                (t[5] ? Number(t[5][2]) : 0),
            0,
        ];
    },
    c_ = (e) => {
        const {
            codec: t,
            codecDescription: n,
            colorSpace: r,
            avcCodecInfo: i,
            hevcCodecInfo: s,
            vp9CodecInfo: a,
            av1CodecInfo: o,
        } = e;
        if ("avc" === t) {
            if (i) {
                const e = new Uint8Array([i.avcProfileIndication, i.profileCompatibility, i.avcLevelIndication]);
                return `avc1.${uT(e)}`;
            }
            if (!n || n.byteLength < 4)
                throw new TypeError("AVC decoder description is not provided or is not at least 4 bytes long.");
            return `avc1.${uT(n.subarray(1, 4))}`;
        }
        if ("hevc" === t) {
            let e, t, r, i, a, o;
            if (s)
                (e = s.generalProfileSpace),
                    (t = s.generalProfileIdc),
                    (r = dT(s.generalProfileCompatibilityFlags)),
                    (i = s.generalTierFlag),
                    (a = s.generalLevelIdc),
                    (o = [...s.generalConstraintIndicatorFlags]);
            else {
                if (!n || n.byteLength < 23)
                    throw new TypeError("HEVC decoder description is not provided or is not at least 23 bytes long.");
                const s = Yk(n),
                    c = s.getUint8(1);
                (e = (c >> 6) & 3),
                    (t = 31 & c),
                    (r = dT(s.getUint32(2))),
                    (i = (c >> 5) & 1),
                    (a = s.getUint8(12)),
                    (o = []);
                for (let e = 0; e < 6; e++) o.push(s.getUint8(6 + e));
            }
            let c = "hev1.";
            for (
                c += ["", "A", "B", "C"][e] + t,
                    c += ".",
                    c += r.toString(16).toUpperCase(),
                    c += ".",
                    c += 0 === i ? "L" : "H",
                    c += a;
                o.length > 0 && 0 === o[o.length - 1];

            )
                o.pop();
            return o.length > 0 && ((c += "."), (c += o.map((e) => e.toString(16).toUpperCase()).join("."))), c;
        }
        if ("vp8" === t) return "vp8";
        if ("vp9" === t) {
            if (!a) {
                const t = e.width * e.height;
                let n = jk(t_).level;
                for (const e of t_)
                    if (t <= e.maxPictureSize) {
                        n = e.level;
                        break;
                    }
                return `vp09.00.${n.toString().padStart(2, "0")}.08`;
            }
            let t = `vp09.${a.profile.toString().padStart(2, "0")}.${a.level.toString().padStart(2, "0")}.${a.bitDepth.toString().padStart(2, "0")}.${a.chromaSubsampling.toString().padStart(2, "0")}`;
            return (
                (t += `.${a.colourPrimaries.toString().padStart(2, "0")}.${a.transferCharacteristics.toString().padStart(2, "0")}.${a.matrixCoefficients.toString().padStart(2, "0")}.${a.videoFullRangeFlag.toString().padStart(2, "0")}`),
                t.endsWith(r_) && (t = t.slice(0, -15)),
                t
            );
        }
        if ("av1" === t) {
            if (!o) {
                const t = e.width * e.height;
                let n = jk(t_).level;
                for (const e of t_)
                    if (t <= e.maxPictureSize) {
                        n = e.level;
                        break;
                    }
                return `av01.0.${n.toString().padStart(2, "0")}M.08`;
            }
            const t = o.profile,
                n = o.level.toString().padStart(2, "0"),
                i = o.tier ? "H" : "M",
                s = o.bitDepth.toString().padStart(2, "0"),
                a = o.monochrome ? "1" : "0",
                c =
                    100 * o.chromaSubsamplingX +
                    10 * o.chromaSubsamplingY +
                    1 * (o.chromaSubsamplingX && o.chromaSubsamplingY ? o.chromaSamplePosition : 0),
                l = r?.primaries ? tT[r.primaries] : 1,
                u = r?.transfer ? rT[r.transfer] : 1,
                d = r?.matrix ? sT[r.matrix] : 1,
                h = r?.fullRange ? 1 : 0;
            let m = `av01.${t}.${n}${i}.${s}`;
            return (
                (m += `.${a}.${c.toString().padStart(3, "0")}`),
                (m += `.${l.toString().padStart(2, "0")}`),
                (m += `.${u.toString().padStart(2, "0")}`),
                (m += `.${d.toString().padStart(2, "0")}`),
                (m += `.${h}`),
                m.endsWith(i_) && (m = m.slice(0, -17)),
                m
            );
        }
        throw new TypeError(`Unhandled codec '${t}'.`);
    },
    l_ = (e, t, n) => {
        if ("aac" === e) return t >= 2 && n <= 24e3 ? "mp4a.40.29" : n <= 24e3 ? "mp4a.40.5" : "mp4a.40.2";
        if ("mp3" === e) return "mp3";
        if ("opus" === e) return "opus";
        if ("vorbis" === e) return "vorbis";
        if ("flac" === e) return "flac";
        if (KT.includes(e)) return e;
        throw new TypeError(`Unhandled codec '${e}'.`);
    },
    u_ = (e) => {
        const { codec: t, codecDescription: n, aacCodecInfo: r } = e;
        if ("aac" === t) {
            if (!r) throw new TypeError("AAC codec info must be provided.");
            if (r.isMpeg2) return "mp4a.67";
            return `mp4a.40.${m_(n).objectType}`;
        }
        if ("mp3" === t) return "mp3";
        if ("opus" === t) return "opus";
        if ("vorbis" === t) return "vorbis";
        if ("flac" === t) return "flac";
        if (t && KT.includes(t)) return t;
        throw new TypeError(`Unhandled codec '${t}'.`);
    },
    d_ = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350],
    h_ = [-1, 1, 2, 3, 4, 5, 6, 8],
    m_ = (e) => {
        if (!e || e.byteLength < 2) throw new TypeError("AAC description must be at least 2 bytes long.");
        const t = new qk(e);
        let n = t.readBits(5);
        31 === n && (n = 32 + t.readBits(6));
        const r = t.readBits(4);
        let i = null;
        15 === r ? (i = t.readBits(24)) : r < d_.length && (i = d_[r]);
        const s = t.readBits(4);
        let a = null;
        return (
            s >= 1 && s <= 7 && (a = h_[s]),
            { objectType: n, frequencyIndex: r, sampleRate: i, channelConfiguration: s, numberOfChannels: a }
        );
    },
    p_ = 48e3,
    f_ = /^pcm-([usf])(\d+)+(be)?$/,
    g_ = (e) => {
        if ((Vk(KT.includes(e)), "ulaw" === e))
            return { dataType: "ulaw", sampleSize: 1, littleEndian: !0, silentValue: 255 };
        if ("alaw" === e) return { dataType: "alaw", sampleSize: 1, littleEndian: !0, silentValue: 213 };
        const t = f_.exec(e);
        let n;
        Vk(t), (n = "u" === t[1] ? "unsigned" : "s" === t[1] ? "signed" : "float");
        return {
            dataType: n,
            sampleSize: Number(t[2]) / 8,
            littleEndian: "be" !== t[3],
            silentValue: "pcm-u8" === e ? 128 : 0,
        };
    },
    b_ = (e) =>
        e.startsWith("avc1") || e.startsWith("avc3")
            ? "avc"
            : e.startsWith("hev1") || e.startsWith("hvc1")
              ? "hevc"
              : "vp8" === e
                ? "vp8"
                : e.startsWith("vp09")
                  ? "vp9"
                  : e.startsWith("av01")
                    ? "av1"
                    : e.startsWith("mp4a.40") || "mp4a.67" === e
                      ? "aac"
                      : "mp3" === e || "mp4a.69" === e || "mp4a.6B" === e || "mp4a.6b" === e
                        ? "mp3"
                        : "opus" === e
                          ? "opus"
                          : "vorbis" === e
                            ? "vorbis"
                            : "flac" === e
                              ? "flac"
                              : "ulaw" === e
                                ? "ulaw"
                                : "alaw" === e
                                  ? "alaw"
                                  : f_.test(e)
                                    ? e
                                    : "webvtt" === e
                                      ? "webvtt"
                                      : null,
    y_ = ["avc1", "avc3", "hev1", "hvc1", "vp8", "vp09", "av01"],
    w_ = /^(avc1|avc3)\.[0-9a-fA-F]{6}$/,
    k_ = /^(hev1|hvc1)\.(?:[ABC]?\d+)\.[0-9a-fA-F]{1,8}\.[LH]\d+(?:\.[0-9a-fA-F]{1,2}){0,6}$/,
    T_ = /^vp09(?:\.\d{2}){3}(?:(?:\.\d{2}){5})?$/,
    __ = /^av01\.\d\.\d{2}[MH]\.\d{2}(?:\.\d\.\d{3}\.\d{2}\.\d{2}\.\d{2}\.\d)?$/,
    v_ = (e) => {
        if (!e) throw new TypeError("Video chunk metadata must be provided.");
        if ("object" != typeof e) throw new TypeError("Video chunk metadata must be an object.");
        if (!e.decoderConfig) throw new TypeError("Video chunk metadata must include a decoder configuration.");
        if ("object" != typeof e.decoderConfig)
            throw new TypeError("Video chunk metadata decoder configuration must be an object.");
        if ("string" != typeof e.decoderConfig.codec)
            throw new TypeError("Video chunk metadata decoder configuration must specify a codec string.");
        if (!y_.some((t) => e.decoderConfig.codec.startsWith(t)))
            throw new TypeError(
                "Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in the WebCodecs Codec Registry."
            );
        if (!Number.isInteger(e.decoderConfig.codedWidth) || e.decoderConfig.codedWidth <= 0)
            throw new TypeError(
                "Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer)."
            );
        if (!Number.isInteger(e.decoderConfig.codedHeight) || e.decoderConfig.codedHeight <= 0)
            throw new TypeError(
                "Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer)."
            );
        if (void 0 !== e.decoderConfig.description && !cT(e.decoderConfig.description))
            throw new TypeError(
                "Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view."
            );
        if (void 0 !== e.decoderConfig.colorSpace) {
            const { colorSpace: t } = e.decoderConfig;
            if ("object" != typeof t)
                throw new TypeError(
                    "Video chunk metadata decoder configuration colorSpace, when provided, must be an object."
                );
            const n = Object.keys(tT);
            if (null != t.primaries && !n.includes(t.primaries))
                throw new TypeError(
                    `Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of ${n.join(", ")}.`
                );
            const r = Object.keys(rT);
            if (null != t.transfer && !r.includes(t.transfer))
                throw new TypeError(
                    `Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of ${r.join(", ")}.`
                );
            const i = Object.keys(sT);
            if (null != t.matrix && !i.includes(t.matrix))
                throw new TypeError(
                    `Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of ${i.join(", ")}.`
                );
            if (null != t.fullRange && "boolean" != typeof t.fullRange)
                throw new TypeError(
                    "Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean."
                );
        }
        if (e.decoderConfig.codec.startsWith("avc1") || e.decoderConfig.codec.startsWith("avc3")) {
            if (!w_.test(e.decoderConfig.codec))
                throw new TypeError(
                    "Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as specified in Section 3.4 of RFC 6381."
                );
        } else if (e.decoderConfig.codec.startsWith("hev1") || e.decoderConfig.codec.startsWith("hvc1")) {
            if (!k_.test(e.decoderConfig.codec))
                throw new TypeError(
                    "Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as specified in Section E.3 of ISO 14496-15."
                );
        } else if (e.decoderConfig.codec.startsWith("vp8")) {
            if ("vp8" !== e.decoderConfig.codec)
                throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be "vp8".');
        } else if (e.decoderConfig.codec.startsWith("vp09")) {
            if (!T_.test(e.decoderConfig.codec))
                throw new TypeError(
                    'Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as specified in Section "Codecs Parameter String" of https://www.webmproject.org/vp9/mp4/.'
                );
        } else if (e.decoderConfig.codec.startsWith("av01") && !__.test(e.decoderConfig.codec))
            throw new TypeError(
                'Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as specified in Section "Codecs Parameter String" of https://aomediacodec.github.io/av1-isobmff/.'
            );
    },
    S_ = ["mp4a", "mp3", "opus", "vorbis", "flac", "ulaw", "alaw", "pcm"],
    E_ = (e) => {
        if (!e) throw new TypeError("Audio chunk metadata must be provided.");
        if ("object" != typeof e) throw new TypeError("Audio chunk metadata must be an object.");
        if (!e.decoderConfig) throw new TypeError("Audio chunk metadata must include a decoder configuration.");
        if ("object" != typeof e.decoderConfig)
            throw new TypeError("Audio chunk metadata decoder configuration must be an object.");
        if ("string" != typeof e.decoderConfig.codec)
            throw new TypeError("Audio chunk metadata decoder configuration must specify a codec string.");
        if (!S_.some((t) => e.decoderConfig.codec.startsWith(t)))
            throw new TypeError(
                "Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in the WebCodecs Codec Registry."
            );
        if (!Number.isInteger(e.decoderConfig.sampleRate) || e.decoderConfig.sampleRate <= 0)
            throw new TypeError(
                "Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer)."
            );
        if (!Number.isInteger(e.decoderConfig.numberOfChannels) || e.decoderConfig.numberOfChannels <= 0)
            throw new TypeError(
                "Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer)."
            );
        if (void 0 !== e.decoderConfig.description && !cT(e.decoderConfig.description))
            throw new TypeError(
                "Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view."
            );
        if (
            e.decoderConfig.codec.startsWith("mp4a") &&
            "mp4a.69" !== e.decoderConfig.codec &&
            "mp4a.6B" !== e.decoderConfig.codec &&
            "mp4a.6b" !== e.decoderConfig.codec
        ) {
            if (
                !["mp4a.40.2", "mp4a.40.02", "mp4a.40.5", "mp4a.40.05", "mp4a.40.29", "mp4a.67"].includes(
                    e.decoderConfig.codec
                )
            )
                throw new TypeError(
                    "Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/."
                );
            if (!e.decoderConfig.description)
                throw new TypeError(
                    "Audio chunk metadata decoder configuration for AAC must include a description, which is expected to be an AudioSpecificConfig as specified in ISO 14496-3."
                );
        } else if (e.decoderConfig.codec.startsWith("mp3") || e.decoderConfig.codec.startsWith("mp4a")) {
            if (
                "mp3" !== e.decoderConfig.codec &&
                "mp4a.69" !== e.decoderConfig.codec &&
                "mp4a.6B" !== e.decoderConfig.codec &&
                "mp4a.6b" !== e.decoderConfig.codec
            )
                throw new TypeError(
                    'Audio chunk metadata decoder configuration codec string for MP3 must be "mp3", "mp4a.69" or "mp4a.6B".'
                );
        } else if (e.decoderConfig.codec.startsWith("opus")) {
            if ("opus" !== e.decoderConfig.codec)
                throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be "opus".');
            if (e.decoderConfig.description && e.decoderConfig.description.byteLength < 18)
                throw new TypeError(
                    "Audio chunk metadata decoder configuration description, when specified, is expected to be an Identification Header as specified in Section 5.1 of RFC 7845."
                );
        } else if (e.decoderConfig.codec.startsWith("vorbis")) {
            if ("vorbis" !== e.decoderConfig.codec)
                throw new TypeError(
                    'Audio chunk metadata decoder configuration codec string for Vorbis must be "vorbis".'
                );
            if (!e.decoderConfig.description)
                throw new TypeError(
                    "Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/."
                );
        } else if (e.decoderConfig.codec.startsWith("flac")) {
            if ("flac" !== e.decoderConfig.codec)
                throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be "flac".');
            const t = 42;
            if (!e.decoderConfig.description || e.decoderConfig.description.byteLength < t)
                throw new TypeError(
                    "Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/."
                );
        } else if (
            (e.decoderConfig.codec.startsWith("pcm") ||
                e.decoderConfig.codec.startsWith("ulaw") ||
                e.decoderConfig.codec.startsWith("alaw")) &&
            !KT.includes(e.decoderConfig.codec)
        )
            throw new TypeError(
                `Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM codecs (${KT.join(", ")}).`
            );
    },
    C_ = (e) => {
        if (!e) throw new TypeError("Subtitle metadata must be provided.");
        if ("object" != typeof e) throw new TypeError("Subtitle metadata must be an object.");
        if (!e.config) throw new TypeError("Subtitle metadata must include a config object.");
        if ("object" != typeof e.config) throw new TypeError("Subtitle metadata config must be an object.");
        if ("string" != typeof e.config.description)
            throw new TypeError("Subtitle metadata config description must be a string.");
    };
class I_ {
    constructor(e) {
        (this.mutex = new lT()),
            (this.firstMediaStreamTimestamp = null),
            (this.trackTimestampInfo = new WeakMap()),
            (this.output = e);
    }
    onTrackClose(e) {}
    validateAndNormalizeTimestamp(e, t, n) {
        t += e.source._timestampOffset;
        let r = this.trackTimestampInfo.get(e);
        if (!r) {
            if (!n) throw new Error("First frame must be a key frame.");
            (r = { maxTimestamp: t, maxTimestampBeforeLastKeyFrame: t }), this.trackTimestampInfo.set(e, r);
        }
        if (t < 0) throw new Error(`Timestamps must be non-negative (got ${t}s).`);
        if ((n && (r.maxTimestampBeforeLastKeyFrame = r.maxTimestamp), t < r.maxTimestampBeforeLastKeyFrame))
            throw new Error(
                `Timestamps cannot be smaller than the highest timestamp of the previous GOP (a GOP begins with a key frame and ends right before the next key frame). Got ${t}s, but highest timestamp is ${r.maxTimestampBeforeLastKeyFrame}s.`
            );
        return (r.maxTimestamp = Math.max(r.maxTimestamp, t)), t;
    }
}
var x_, A_, P_, O_;
((A_ = x_ || (x_ = {}))[(A_.IDR = 5)] = "IDR"),
    (A_[(A_.SPS = 7)] = "SPS"),
    (A_[(A_.PPS = 8)] = "PPS"),
    (A_[(A_.SPS_EXT = 13)] = "SPS_EXT"),
    ((O_ = P_ || (P_ = {}))[(O_.RASL_N = 8)] = "RASL_N"),
    (O_[(O_.RASL_R = 9)] = "RASL_R"),
    (O_[(O_.BLA_W_LP = 16)] = "BLA_W_LP"),
    (O_[(O_.RSV_IRAP_VCL23 = 23)] = "RSV_IRAP_VCL23"),
    (O_[(O_.VPS_NUT = 32)] = "VPS_NUT"),
    (O_[(O_.SPS_NUT = 33)] = "SPS_NUT"),
    (O_[(O_.PPS_NUT = 34)] = "PPS_NUT"),
    (O_[(O_.PREFIX_SEI_NUT = 39)] = "PREFIX_SEI_NUT"),
    (O_[(O_.SUFFIX_SEI_NUT = 40)] = "SUFFIX_SEI_NUT");
const N_ = (e) => {
        const t = [];
        let n = 0;
        for (; n < e.length; ) {
            let r = -1,
                i = 0;
            for (let t = n; t < e.length - 3; t++) {
                if (0 === e[t] && 0 === e[t + 1] && 1 === e[t + 2]) {
                    (r = t), (i = 3);
                    break;
                }
                if (t < e.length - 4 && 0 === e[t] && 0 === e[t + 1] && 0 === e[t + 2] && 1 === e[t + 3]) {
                    (r = t), (i = 4);
                    break;
                }
            }
            if (-1 === r) break;
            if (n > 0 && r > n) {
                const i = e.subarray(n, r);
                i.length > 0 && t.push(i);
            }
            n = r + i;
        }
        if (n < e.length) {
            const r = e.subarray(n);
            r.length > 0 && t.push(r);
        }
        return t;
    },
    R_ = (e, t) => {
        const n = [];
        let r = 0;
        const i = new DataView(e.buffer, e.byteOffset, e.byteLength);
        for (; r + t <= e.length; ) {
            let s;
            1 === t
                ? (s = i.getUint8(r))
                : 2 === t
                  ? (s = i.getUint16(r, !1))
                  : 3 === t
                    ? (s = wT(i, r, !1))
                    : 4 === t
                      ? (s = i.getUint32(r, !1))
                      : (yT(t), Vk(!1)),
                (r += t);
            const a = e.subarray(r, r + s);
            n.push(a), (r += s);
        }
        return n;
    },
    M_ = (e) => {
        const t = [],
            n = e.length;
        for (let r = 0; r < n; r++)
            r + 2 < n && 0 === e[r] && 0 === e[r + 1] && 3 === e[r + 2] ? (t.push(0, 0), (r += 2)) : t.push(e[r]);
        return new Uint8Array(t);
    },
    D_ = (e) => 31 & e[0],
    F_ = (e) => {
        try {
            const t = N_(e),
                n = t.filter((e) => D_(e) === x_.SPS),
                r = t.filter((e) => D_(e) === x_.PPS),
                i = t.filter((e) => D_(e) === x_.SPS_EXT);
            if (0 === n.length) return null;
            if (0 === r.length) return null;
            const s = n[0],
                a = new qk(M_(s));
            a.skipBits(1), a.skipBits(2);
            if (7 !== a.readBits(5)) return null;
            const o = a.readAlignedByte(),
                c = a.readAlignedByte(),
                l = {
                    configurationVersion: 1,
                    avcProfileIndication: o,
                    profileCompatibility: c,
                    avcLevelIndication: a.readAlignedByte(),
                    lengthSizeMinusOne: 3,
                    sequenceParameterSets: n,
                    pictureParameterSets: r,
                    chromaFormat: null,
                    bitDepthLumaMinus8: null,
                    bitDepthChromaMinus8: null,
                    sequenceParameterSetExt: null,
                };
            if (100 === o || 110 === o || 122 === o || 144 === o) {
                Xk(a);
                const e = Xk(a);
                3 === e && a.skipBits(1);
                const t = Xk(a),
                    n = Xk(a);
                (l.chromaFormat = e),
                    (l.bitDepthLumaMinus8 = t),
                    (l.bitDepthChromaMinus8 = n),
                    (l.sequenceParameterSetExt = i);
            }
            return l;
        } catch (t) {
            return null;
        }
    },
    L_ = (e, t) => {
        if (t.description) {
            const n = 3 & Kk(t.description)[21];
            return R_(e, n + 1);
        }
        return N_(e);
    },
    B_ = (e) => (e[0] >> 1) & 63,
    z_ = (e) => {
        try {
            const t = N_(e),
                n = t.filter((e) => B_(e) === P_.VPS_NUT),
                r = t.filter((e) => B_(e) === P_.SPS_NUT),
                i = t.filter((e) => B_(e) === P_.PPS_NUT),
                s = t.filter((e) => B_(e) === P_.PREFIX_SEI_NUT || B_(e) === P_.SUFFIX_SEI_NUT);
            if (0 === r.length || 0 === i.length) return null;
            const a = r[0],
                o = new qk(M_(a));
            o.skipBits(16), o.readBits(4);
            const c = o.readBits(3),
                l = o.readBits(1),
                {
                    general_profile_space: u,
                    general_tier_flag: d,
                    general_profile_idc: h,
                    general_profile_compatibility_flags: m,
                    general_constraint_indicator_flags: p,
                    general_level_idc: f,
                } = U_(o, c);
            Xk(o);
            const g = Xk(o);
            3 === g && o.skipBits(1), Xk(o), Xk(o), o.readBits(1) && (Xk(o), Xk(o), Xk(o), Xk(o));
            const b = Xk(o),
                y = Xk(o);
            Xk(o);
            const w = o.readBits(1);
            for (let e = w ? 0 : c; e <= c; e++) Xk(o), Xk(o), Xk(o);
            Xk(o),
                Xk(o),
                Xk(o),
                Xk(o),
                Xk(o),
                Xk(o),
                o.readBits(1) && o.readBits(1) && $_(o),
                o.skipBits(1),
                o.skipBits(1),
                o.readBits(1) && (o.skipBits(4), o.skipBits(4), Xk(o), Xk(o), o.skipBits(1));
            const k = Xk(o);
            if ((V_(o, k), o.readBits(1))) {
                const e = Xk(o);
                for (let t = 0; t < e; t++) Xk(o), o.skipBits(1);
            }
            o.skipBits(1), o.skipBits(1);
            let T = 0;
            o.readBits(1) && (T = j_(o, c));
            let _ = 0;
            if (i.length > 0) {
                const e = i[0],
                    t = new qk(M_(e));
                t.skipBits(16),
                    Xk(t),
                    Xk(t),
                    t.skipBits(1),
                    t.skipBits(1),
                    t.skipBits(3),
                    t.skipBits(1),
                    t.skipBits(1),
                    Xk(t),
                    Xk(t),
                    Gk(t),
                    t.skipBits(1),
                    t.skipBits(1),
                    t.readBits(1) && Xk(t),
                    Gk(t),
                    Gk(t),
                    t.skipBits(1),
                    t.skipBits(1),
                    t.skipBits(1),
                    t.skipBits(1);
                const n = t.readBits(1),
                    r = t.readBits(1);
                _ = n || r ? (n && !r ? 2 : !n && r ? 3 : 0) : 0;
            }
            const v = [
                ...(n.length ? [{ arrayCompleteness: 1, nalUnitType: P_.VPS_NUT, nalUnits: n }] : []),
                ...(r.length ? [{ arrayCompleteness: 1, nalUnitType: P_.SPS_NUT, nalUnits: r }] : []),
                ...(i.length ? [{ arrayCompleteness: 1, nalUnitType: P_.PPS_NUT, nalUnits: i }] : []),
                ...(s.length ? [{ arrayCompleteness: 1, nalUnitType: B_(s[0]), nalUnits: s }] : []),
            ];
            return {
                configurationVersion: 1,
                generalProfileSpace: u,
                generalTierFlag: d,
                generalProfileIdc: h,
                generalProfileCompatibilityFlags: m,
                generalConstraintIndicatorFlags: p,
                generalLevelIdc: f,
                minSpatialSegmentationIdc: T,
                parallelismType: _,
                chromaFormatIdc: g,
                bitDepthLumaMinus8: b,
                bitDepthChromaMinus8: y,
                avgFrameRate: 0,
                constantFrameRate: 0,
                numTemporalLayers: c + 1,
                temporalIdNested: l,
                lengthSizeMinusOne: 3,
                arrays: v,
            };
        } catch (t) {
            return null;
        }
    },
    U_ = (e, t) => {
        const n = e.readBits(2),
            r = e.readBits(1),
            i = e.readBits(5);
        let s = 0;
        for (let u = 0; u < 32; u++) s = (s << 1) | e.readBits(1);
        const a = new Uint8Array(6);
        for (let u = 0; u < 6; u++) a[u] = e.readBits(8);
        const o = e.readBits(8),
            c = [],
            l = [];
        for (let u = 0; u < t; u++) c.push(e.readBits(1)), l.push(e.readBits(1));
        if (t > 0) for (let u = t; u < 8; u++) e.skipBits(2);
        for (let u = 0; u < t; u++) c[u] && e.skipBits(88), l[u] && e.skipBits(8);
        return {
            general_profile_space: n,
            general_tier_flag: r,
            general_profile_idc: i,
            general_profile_compatibility_flags: s,
            general_constraint_indicator_flags: a,
            general_level_idc: o,
        };
    },
    $_ = (e) => {
        for (let t = 0; t < 4; t++)
            for (let n = 0; n < (3 === t ? 2 : 6); n++) {
                if (e.readBits(1)) {
                    const n = Math.min(64, 1 << (4 + (t << 1)));
                    t > 1 && Gk(e);
                    for (let t = 0; t < n; t++) Gk(e);
                } else Xk(e);
            }
    },
    V_ = (e, t) => {
        const n = [];
        for (let r = 0; r < t; r++) n[r] = W_(e, r, t, n);
    },
    W_ = (e, t, n, r) => {
        let i = 0,
            s = 0,
            a = 0;
        if ((0 !== t && (s = e.readBits(1)), s)) {
            if (t === n) {
                a = t - (Xk(e) + 1);
            } else a = t - 1;
            e.readBits(1), Xk(e);
            const s = r[a] ?? 0;
            for (let t = 0; t <= s; t++) {
                e.readBits(1) || e.readBits(1);
            }
            i = r[a];
        } else {
            const t = Xk(e),
                n = Xk(e);
            for (let r = 0; r < t; r++) Xk(e), e.readBits(1);
            for (let r = 0; r < n; r++) Xk(e), e.readBits(1);
            i = t + n;
        }
        return i;
    },
    j_ = (e, t) => {
        if (e.readBits(1)) {
            255 === e.readBits(8) && (e.readBits(16), e.readBits(16));
        }
        if (
            (e.readBits(1) && e.readBits(1),
            e.readBits(1) &&
                (e.readBits(3), e.readBits(1), e.readBits(1) && (e.readBits(8), e.readBits(8), e.readBits(8))),
            e.readBits(1) && (Xk(e), Xk(e)),
            e.readBits(1),
            e.readBits(1),
            e.readBits(1),
            e.readBits(1) && (Xk(e), Xk(e), Xk(e), Xk(e)),
            e.readBits(1) && (e.readBits(32), e.readBits(32), e.readBits(1) && Xk(e), e.readBits(1) && H_(e, !0, t)),
            e.readBits(1))
        ) {
            e.readBits(1), e.readBits(1), e.readBits(1);
            const t = Xk(e);
            return Xk(e), Xk(e), Xk(e), Xk(e), t;
        }
        return 0;
    },
    H_ = (e, t, n) => {
        let r = !1,
            i = !1,
            s = !1;
        (r = 1 === e.readBits(1)),
            (i = 1 === e.readBits(1)),
            (r || i) &&
                ((s = 1 === e.readBits(1)),
                s && (e.readBits(8), e.readBits(5), e.readBits(1), e.readBits(5)),
                e.readBits(4),
                e.readBits(4),
                s && e.readBits(4),
                e.readBits(5),
                e.readBits(5),
                e.readBits(5));
        for (let a = 0; a <= n; a++) {
            let t = !0;
            1 === e.readBits(1) || (t = 1 === e.readBits(1));
            let n = !1;
            t ? Xk(e) : (n = 1 === e.readBits(1));
            let a = 1;
            if (!n) {
                a = Xk(e) + 1;
            }
            r && q_(e, a, s), i && q_(e, a, s);
        }
    },
    q_ = (e, t, n) => {
        for (let r = 0; r < t; r++) Xk(e), Xk(e), n && (Xk(e), Xk(e)), e.readBits(1);
    },
    X_ = (e) => {
        const t = new qk(e);
        if (2 !== t.readBits(2)) return null;
        const n = t.readBits(1),
            r = (t.readBits(1) << 1) + n;
        3 === r && t.skipBits(1);
        if (1 === t.readBits(1)) return null;
        if (0 !== t.readBits(1)) return null;
        t.skipBits(2);
        if (4817730 !== t.readBits(24)) return null;
        let i = 8;
        if (r >= 2) {
            i = t.readBits(1) ? 12 : 10;
        }
        const s = t.readBits(3);
        let a = 0,
            o = 0;
        if (7 !== s) {
            if (((o = t.readBits(1)), 1 === r || 3 === r)) {
                const e = t.readBits(1),
                    n = t.readBits(1);
                (a = e || n ? (e && !n ? 2 : 1) : 3), t.skipBits(1);
            } else a = 1;
        } else (a = 3), (o = 1);
        const c = (t.readBits(16) + 1) * (t.readBits(16) + 1);
        let l = jk(t_).level;
        for (const u of t_)
            if (c <= u.maxPictureSize) {
                l = u.level;
                break;
            }
        return {
            profile: r,
            level: l,
            bitDepth: i,
            chromaSubsampling: a,
            videoFullRangeFlag: o,
            colourPrimaries: 2 === s ? 1 : 1 === s ? 6 : 2,
            transferCharacteristics: 2 === s ? 1 : 1 === s ? 6 : 2,
            matrixCoefficients: 7 === s ? 0 : 2 === s ? 1 : 1 === s ? 6 : 2,
        };
    },
    G_ = function* (e) {
        const t = new qk(e),
            n = () => {
                let e = 0;
                for (let n = 0; n < 8; n++) {
                    const r = t.readAlignedByte();
                    if (((e |= (127 & r) << (7 * n)), !(128 & r))) break;
                    if (7 === n && 128 & r) return null;
                }
                return e >= 2 ** 32 - 1 ? null : e;
            };
        for (; t.getBitsLeft() >= 8; ) {
            t.skipBits(1);
            const r = t.readBits(4),
                i = t.readBits(1),
                s = t.readBits(1);
            let a;
            if ((t.skipBits(1), i && t.skipBits(8), s)) {
                const e = n();
                if (null === e) return;
                a = e;
            } else a = Math.floor(t.getBitsLeft() / 8);
            Vk(t.pos % 8 == 0), yield { type: r, data: e.subarray(t.pos / 8, t.pos / 8 + a) }, t.skipBits(8 * a);
        }
    },
    K_ = (e) => {
        for (const { type: t, data: n } of G_(e)) {
            if (1 !== t) continue;
            const e = new qk(n),
                r = e.readBits(3);
            e.readBits(1);
            let i = 0,
                s = 0,
                a = 0;
            if (e.readBits(1)) i = e.readBits(5);
            else {
                if (e.readBits(1)) {
                    e.skipBits(32), e.skipBits(32);
                    if (e.readBits(1)) return null;
                }
                const t = e.readBits(1);
                t && ((a = e.readBits(5)), e.skipBits(32), e.skipBits(5), e.skipBits(5));
                const n = e.readBits(5);
                for (let r = 0; r <= n; r++) {
                    e.skipBits(12);
                    const n = e.readBits(5);
                    if ((0 === r && (i = n), n > 7)) {
                        const t = e.readBits(1);
                        0 === r && (s = t);
                    }
                    if (t) {
                        if (e.readBits(1)) {
                            const t = a + 1;
                            e.skipBits(t), e.skipBits(t), e.skipBits(1);
                        }
                    }
                    e.readBits(1) && e.skipBits(4);
                }
            }
            const o = e.readBits(1);
            let c = 8;
            if (2 === r && o) {
                c = e.readBits(1) ? 12 : 10;
            } else r <= 2 && (c = o ? 10 : 8);
            let l = 0;
            1 !== r && (l = e.readBits(1));
            let u = 1,
                d = 1,
                h = 0;
            return (
                l ||
                    (0 === r
                        ? ((u = 1), (d = 1))
                        : 1 === r
                          ? ((u = 0), (d = 0))
                          : 12 === c && ((u = e.readBits(1)), u && (d = e.readBits(1))),
                    u && d && (h = e.readBits(2))),
                {
                    profile: r,
                    level: i,
                    tier: s,
                    bitDepth: c,
                    monochrome: l,
                    chromaSubsamplingX: u,
                    chromaSubsamplingY: d,
                    chromaSamplePosition: h,
                }
            );
        }
        return null;
    },
    Y_ = (e) => {
        const t = Yk(e),
            n = t.getUint8(9),
            r = t.getUint16(10, !0),
            i = t.getUint32(12, !0),
            s = t.getInt16(16, !0),
            a = t.getUint8(18);
        let o = null;
        return (
            a && (o = e.subarray(19, 21 + n)),
            {
                outputChannelCount: n,
                preSkip: r,
                inputSampleRate: i,
                outputGain: s,
                channelMappingFamily: a,
                channelMappingTable: o,
            }
        );
    },
    Q_ = [
        480, 960, 1920, 2880, 480, 960, 1920, 2880, 480, 960, 1920, 2880, 480, 960, 480, 960, 120, 240, 480, 960, 120,
        240, 480, 960, 120, 240, 480, 960, 120, 240, 480, 960,
    ],
    J_ = (e) => {
        if (e.length < 7) throw new Error("Setup header is too short.");
        if (5 !== e[0]) throw new Error("Wrong packet type in Setup header.");
        if ("vorbis" !== String.fromCharCode(...e.slice(1, 7)))
            throw new Error("Invalid packet signature in Setup header.");
        const t = e.length,
            n = new Uint8Array(t);
        for (let u = 0; u < t; u++) n[u] = e[t - 1 - u];
        const r = new qk(n);
        let i = 0;
        for (; r.getBitsLeft() > 97; )
            if (1 === r.readBits(1)) {
                i = r.pos;
                break;
            }
        if (0 === i) throw new Error("Invalid Setup header: framing bit not found.");
        let s = 0,
            a = !1,
            o = 0;
        for (; r.getBitsLeft() >= 97; ) {
            const e = r.pos,
                t = r.readBits(8),
                n = r.readBits(16),
                i = r.readBits(16);
            if (t > 63 || 0 !== n || 0 !== i) {
                r.pos = e;
                break;
            }
            if ((r.skipBits(1), s++, s > 64)) break;
            r.clone().readBits(6) + 1 === s && ((a = !0), (o = s));
        }
        if (!a) throw new Error("Invalid Setup header: mode header not found.");
        if (o > 63) throw new Error(`Unsupported mode count: ${o}.`);
        const c = o;
        (r.pos = 0), r.skipBits(i);
        const l = Array(c).fill(0);
        for (let u = c - 1; u >= 0; u--) r.skipBits(40), (l[u] = r.readBits(1));
        return { modeBlockflags: l };
    },
    Z_ = (e, t, n) => {
        switch (e) {
            case "avc": {
                const e = ((e, t) => {
                        if (t.description) {
                            const n = 3 & Kk(t.description)[4];
                            return R_(e, n + 1);
                        }
                        return N_(e);
                    })(n, t),
                    r = e.some((e) => D_(e) === x_.IDR);
                return r ? "key" : "delta";
            }
            case "hevc": {
                const e = L_(n, t).some((e) => {
                    const t = B_(e);
                    return P_.BLA_W_LP <= t && t <= P_.RSV_IRAP_VCL23;
                });
                return e ? "key" : "delta";
            }
            case "vp8":
                return 0 === (1 & n[0]) ? "key" : "delta";
            case "vp9": {
                const e = new qk(n);
                if (2 !== e.readBits(2)) return null;
                const t = e.readBits(1);
                3 === (e.readBits(1) << 1) + t && e.skipBits(1);
                if (e.readBits(1)) return null;
                return 0 === e.readBits(1) ? "key" : "delta";
            }
            case "av1": {
                let e = !1;
                for (const { type: t, data: r } of G_(n))
                    if (1 === t) {
                        const t = new qk(r);
                        t.skipBits(4), (e = !!t.readBits(1));
                    } else if (3 === t || 6 === t || 7 === t) {
                        if (e) return "key";
                        const t = new qk(r);
                        if (t.readBits(1)) return null;
                        return 0 === t.readBits(2) ? "key" : "delta";
                    }
                return null;
            }
            default:
                yT(e), Vk(!1);
        }
    };
var ev, tv;
((tv = ev || (ev = {}))[(tv.STREAMINFO = 0)] = "STREAMINFO"),
    (tv[(tv.VORBIS_COMMENT = 4)] = "VORBIS_COMMENT"),
    (tv[(tv.PICTURE = 6)] = "PICTURE");
const nv = (e, t) => {
    const n = Yk(e);
    let r = 0;
    const i = n.getUint32(r, !0);
    r += 4;
    const s = Qk.decode(e.subarray(r, r + i));
    (r += i), i > 0 && ((t.raw ??= {}), (t.raw.vendor ??= s));
    const a = n.getUint32(r, !0);
    r += 4;
    for (let o = 0; o < a; o++) {
        const i = n.getUint32(r, !0);
        r += 4;
        const s = Qk.decode(e.subarray(r, r + i));
        r += i;
        const a = s.indexOf("=");
        if (-1 === a) continue;
        const o = s.slice(0, a).toUpperCase(),
            c = s.slice(a + 1);
        switch (((t.raw ??= {}), (t.raw[o] ??= c), o)) {
            case "TITLE":
                t.title ??= c;
                break;
            case "DESCRIPTION":
                t.description ??= c;
                break;
            case "ARTIST":
                t.artist ??= c;
                break;
            case "ALBUM":
                t.album ??= c;
                break;
            case "ALBUMARTIST":
                t.albumArtist ??= c;
                break;
            case "COMMENT":
                t.comment ??= c;
                break;
            case "LYRICS":
                t.lyrics ??= c;
                break;
            case "TRACKNUMBER":
                {
                    const e = c.split("/"),
                        n = Number.parseInt(e[0], 10),
                        r = e[1] && Number.parseInt(e[1], 10);
                    Number.isInteger(n) && n > 0 && (t.trackNumber ??= n),
                        r && Number.isInteger(r) && r > 0 && (t.tracksTotal ??= r);
                }
                break;
            case "TRACKTOTAL":
                {
                    const e = Number.parseInt(c, 10);
                    Number.isInteger(e) && e > 0 && (t.tracksTotal ??= e);
                }
                break;
            case "DISCNUMBER":
                {
                    const e = c.split("/"),
                        n = Number.parseInt(e[0], 10),
                        r = e[1] && Number.parseInt(e[1], 10);
                    Number.isInteger(n) && n > 0 && (t.discNumber ??= n),
                        r && Number.isInteger(r) && r > 0 && (t.discsTotal ??= r);
                }
                break;
            case "DISCTOTAL":
                {
                    const e = Number.parseInt(c, 10);
                    Number.isInteger(e) && e > 0 && (t.discsTotal ??= e);
                }
                break;
            case "DATE":
                {
                    const e = new Date(c);
                    Number.isNaN(e.getTime()) || (t.date ??= e);
                }
                break;
            case "GENRE":
                t.genre ??= c;
                break;
            case "METADATA_BLOCK_PICTURE": {
                const e = $T(c),
                    n = Yk(e),
                    r = n.getUint32(0, !1),
                    i = n.getUint32(4, !1),
                    s = String.fromCharCode(...e.subarray(8, 8 + i)),
                    a = n.getUint32(8 + i, !1),
                    o = Qk.decode(e.subarray(12 + i, 12 + i + a)),
                    l = n.getUint32(i + a + 28),
                    u = e.subarray(i + a + 32, i + a + 32 + l);
                (t.images ??= []),
                    t.images.push({
                        data: u,
                        mimeType: s,
                        kind: 3 === r ? "coverFront" : 4 === r ? "coverBack" : "unknown",
                        name: void 0,
                        description: o || void 0,
                    });
            }
        }
    }
};
class rv {
    constructor(e) {
        this.input = e;
    }
}
const iv = [],
    sv = [],
    av = [],
    ov = [],
    cv = new Uint8Array(0);
class lv {
    constructor(e, t, n, r, i = -1, s, a) {
        if (
            ((this.data = e),
            (this.type = t),
            (this.timestamp = n),
            (this.duration = r),
            (this.sequenceNumber = i),
            e === cv && void 0 === s)
        )
            throw new Error(
                "Internal error: byteLength must be explicitly provided when constructing metadata-only packets."
            );
        if ((void 0 === s && (s = e.byteLength), !(e instanceof Uint8Array)))
            throw new TypeError("data must be a Uint8Array.");
        if ("key" !== t && "delta" !== t) throw new TypeError('type must be either "key" or "delta".');
        if (!Number.isFinite(n)) throw new TypeError("timestamp must be a number.");
        if (!Number.isFinite(r) || r < 0) throw new TypeError("duration must be a non-negative number.");
        if (!Number.isFinite(i)) throw new TypeError("sequenceNumber must be a number.");
        if (!Number.isInteger(s) || s < 0) throw new TypeError("byteLength must be a non-negative integer.");
        if (void 0 !== a && ("object" != typeof a || !a))
            throw new TypeError("sideData, when provided, must be an object.");
        if (void 0 !== a?.alpha && !(a.alpha instanceof Uint8Array))
            throw new TypeError("sideData.alpha, when provided, must be a Uint8Array.");
        if (void 0 !== a?.alphaByteLength && (!Number.isInteger(a.alphaByteLength) || a.alphaByteLength < 0))
            throw new TypeError("sideData.alphaByteLength, when provided, must be a non-negative integer.");
        (this.byteLength = s),
            (this.sideData = a ?? {}),
            this.sideData.alpha &&
                void 0 === this.sideData.alphaByteLength &&
                (this.sideData.alphaByteLength = this.sideData.alpha.byteLength);
    }
    get isMetadataOnly() {
        return this.data === cv;
    }
    get microsecondTimestamp() {
        return Math.trunc(xT * this.timestamp);
    }
    get microsecondDuration() {
        return Math.trunc(xT * this.duration);
    }
    toEncodedVideoChunk() {
        if (this.isMetadataOnly) throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");
        if ("undefined" == typeof EncodedVideoChunk)
            throw new Error("Your browser does not support EncodedVideoChunk.");
        return new EncodedVideoChunk({
            data: this.data,
            type: this.type,
            timestamp: this.microsecondTimestamp,
            duration: this.microsecondDuration,
        });
    }
    alphaToEncodedVideoChunk(e = this.type) {
        if (!this.sideData.alpha) throw new TypeError("This packet does not contain alpha side data.");
        if (this.isMetadataOnly) throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");
        if ("undefined" == typeof EncodedVideoChunk)
            throw new Error("Your browser does not support EncodedVideoChunk.");
        return new EncodedVideoChunk({
            data: this.sideData.alpha,
            type: e,
            timestamp: this.microsecondTimestamp,
            duration: this.microsecondDuration,
        });
    }
    toEncodedAudioChunk() {
        if (this.isMetadataOnly) throw new TypeError("Metadata-only packets cannot be converted to an audio chunk.");
        if ("undefined" == typeof EncodedAudioChunk)
            throw new Error("Your browser does not support EncodedAudioChunk.");
        return new EncodedAudioChunk({
            data: this.data,
            type: this.type,
            timestamp: this.microsecondTimestamp,
            duration: this.microsecondDuration,
        });
    }
    static fromEncodedChunk(e, t) {
        if (!(e instanceof EncodedVideoChunk || e instanceof EncodedAudioChunk))
            throw new TypeError("chunk must be an EncodedVideoChunk or EncodedAudioChunk.");
        const n = new Uint8Array(e.byteLength);
        return e.copyTo(n), new lv(n, e.type, e.timestamp / 1e6, (e.duration ?? 0) / 1e6, void 0, void 0, t);
    }
    clone(e) {
        if (void 0 !== e && ("object" != typeof e || null === e))
            throw new TypeError("options, when provided, must be an object.");
        if (void 0 !== e?.timestamp && !Number.isFinite(e.timestamp))
            throw new TypeError("options.timestamp, when provided, must be a number.");
        if (void 0 !== e?.duration && !Number.isFinite(e.duration))
            throw new TypeError("options.duration, when provided, must be a number.");
        return new lv(
            this.data,
            this.type,
            e?.timestamp ?? this.timestamp,
            e?.duration ?? this.duration,
            this.sequenceNumber,
            this.byteLength
        );
    }
}
WT();
class uv {
    get displayWidth() {
        return this.rotation % 180 == 0 ? this.codedWidth : this.codedHeight;
    }
    get displayHeight() {
        return this.rotation % 180 == 0 ? this.codedHeight : this.codedWidth;
    }
    get microsecondTimestamp() {
        return Math.trunc(xT * this.timestamp);
    }
    get microsecondDuration() {
        return Math.trunc(xT * this.duration);
    }
    get hasAlpha() {
        return this.format && this.format.includes("A");
    }
    constructor(e, t) {
        if (((this._closed = !1), e instanceof ArrayBuffer || ArrayBuffer.isView(e))) {
            if (!t || "object" != typeof t) throw new TypeError("init must be an object.");
            if (!("format" in t) || "string" != typeof t.format) throw new TypeError("init.format must be a string.");
            if (!Number.isInteger(t.codedWidth) || t.codedWidth <= 0)
                throw new TypeError("init.codedWidth must be a positive integer.");
            if (!Number.isInteger(t.codedHeight) || t.codedHeight <= 0)
                throw new TypeError("init.codedHeight must be a positive integer.");
            if (void 0 !== t.rotation && ![0, 90, 180, 270].includes(t.rotation))
                throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");
            if (!Number.isFinite(t.timestamp)) throw new TypeError("init.timestamp must be a number.");
            if (void 0 !== t.duration && (!Number.isFinite(t.duration) || t.duration < 0))
                throw new TypeError("init.duration, when provided, must be a non-negative number.");
            (this._data = Kk(e).slice()),
                (this.format = t.format),
                (this.codedWidth = t.codedWidth),
                (this.codedHeight = t.codedHeight),
                (this.rotation = t.rotation ?? 0),
                (this.timestamp = t.timestamp),
                (this.duration = t.duration ?? 0),
                (this.colorSpace = new VideoColorSpace(t.colorSpace));
        } else if ("undefined" != typeof VideoFrame && e instanceof VideoFrame) {
            if (void 0 !== t?.rotation && ![0, 90, 180, 270].includes(t.rotation))
                throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");
            if (void 0 !== t?.timestamp && !Number.isFinite(t?.timestamp))
                throw new TypeError("init.timestamp, when provided, must be a number.");
            if (void 0 !== t?.duration && (!Number.isFinite(t.duration) || t.duration < 0))
                throw new TypeError("init.duration, when provided, must be a non-negative number.");
            (this._data = e),
                (this.format = e.format),
                (this.codedWidth = e.displayWidth),
                (this.codedHeight = e.displayHeight),
                (this.rotation = t?.rotation ?? 0),
                (this.timestamp = t?.timestamp ?? e.timestamp / 1e6),
                (this.duration = t?.duration ?? (e.duration ?? 0) / 1e6),
                (this.colorSpace = e.colorSpace);
        } else {
            if (
                !(
                    ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement) ||
                    ("undefined" != typeof SVGImageElement && e instanceof SVGImageElement) ||
                    ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap) ||
                    ("undefined" != typeof HTMLVideoElement && e instanceof HTMLVideoElement) ||
                    ("undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement) ||
                    ("undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas)
                )
            )
                throw new TypeError("Invalid data type: Must be a BufferSource or CanvasImageSource.");
            {
                if (!t || "object" != typeof t) throw new TypeError("init must be an object.");
                if (void 0 !== t.rotation && ![0, 90, 180, 270].includes(t.rotation))
                    throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");
                if (!Number.isFinite(t.timestamp)) throw new TypeError("init.timestamp must be a number.");
                if (void 0 !== t.duration && (!Number.isFinite(t.duration) || t.duration < 0))
                    throw new TypeError("init.duration, when provided, must be a non-negative number.");
                if ("undefined" != typeof VideoFrame)
                    return new uv(
                        new VideoFrame(e, {
                            timestamp: Math.trunc(t.timestamp * xT),
                            duration: Math.trunc((t.duration ?? 0) * xT) || void 0,
                        }),
                        t
                    );
                let n = 0,
                    r = 0;
                if (
                    ("naturalWidth" in e
                        ? ((n = e.naturalWidth), (r = e.naturalHeight))
                        : "videoWidth" in e
                          ? ((n = e.videoWidth), (r = e.videoHeight))
                          : "width" in e && ((n = Number(e.width)), (r = Number(e.height))),
                    !n || !r)
                )
                    throw new TypeError("Could not determine dimensions.");
                const i = new OffscreenCanvas(n, r),
                    s = i.getContext("2d", { alpha: FT(), willReadFrequently: !0 });
                Vk(s),
                    s.drawImage(e, 0, 0),
                    (this._data = i),
                    (this.format = "RGBX"),
                    (this.codedWidth = n),
                    (this.codedHeight = r),
                    (this.rotation = t.rotation ?? 0),
                    (this.timestamp = t.timestamp),
                    (this.duration = t.duration ?? 0),
                    (this.colorSpace = new VideoColorSpace({
                        matrix: "rgb",
                        primaries: "bt709",
                        transfer: "iec61966-2-1",
                        fullRange: !0,
                    }));
            }
        }
    }
    clone() {
        if (this._closed) throw new Error("VideoSample is closed.");
        return (
            Vk(null !== this._data),
            dv(this._data)
                ? new uv(this._data.clone(), {
                      timestamp: this.timestamp,
                      duration: this.duration,
                      rotation: this.rotation,
                  })
                : this._data instanceof Uint8Array
                  ? new uv(this._data.slice(), {
                        format: this.format,
                        codedWidth: this.codedWidth,
                        codedHeight: this.codedHeight,
                        timestamp: this.timestamp,
                        duration: this.duration,
                        colorSpace: this.colorSpace,
                        rotation: this.rotation,
                    })
                  : new uv(this._data, {
                        format: this.format,
                        codedWidth: this.codedWidth,
                        codedHeight: this.codedHeight,
                        timestamp: this.timestamp,
                        duration: this.duration,
                        colorSpace: this.colorSpace,
                        rotation: this.rotation,
                    })
        );
    }
    close() {
        this._closed || (dv(this._data) ? this._data.close() : (this._data = null), (this._closed = !0));
    }
    allocationSize() {
        if (this._closed) throw new Error("VideoSample is closed.");
        return (
            Vk(null !== this._data),
            dv(this._data)
                ? this._data.allocationSize()
                : this._data instanceof Uint8Array
                  ? this._data.byteLength
                  : this.codedWidth * this.codedHeight * 4
        );
    }
    async copyTo(e) {
        if (!cT(e)) throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");
        if (this._closed) throw new Error("VideoSample is closed.");
        if ((Vk(null !== this._data), dv(this._data))) await this._data.copyTo(e);
        else if (this._data instanceof Uint8Array) {
            Kk(e).set(this._data);
        } else {
            const t = this._data.getContext("2d");
            Vk(t);
            const n = t.getImageData(0, 0, this.codedWidth, this.codedHeight);
            Kk(e).set(n.data);
        }
    }
    toVideoFrame() {
        if (this._closed) throw new Error("VideoSample is closed.");
        return (
            Vk(null !== this._data),
            dv(this._data)
                ? new VideoFrame(this._data, {
                      timestamp: this.microsecondTimestamp,
                      duration: this.microsecondDuration || void 0,
                  })
                : this._data instanceof Uint8Array
                  ? new VideoFrame(this._data, {
                        format: this.format,
                        codedWidth: this.codedWidth,
                        codedHeight: this.codedHeight,
                        timestamp: this.microsecondTimestamp,
                        duration: this.microsecondDuration || void 0,
                        colorSpace: this.colorSpace,
                    })
                  : new VideoFrame(this._data, {
                        timestamp: this.microsecondTimestamp,
                        duration: this.microsecondDuration || void 0,
                    })
        );
    }
    draw(e, t, n, r, i, s, a, o, c) {
        let l = 0,
            u = 0,
            d = this.displayWidth,
            h = this.displayHeight,
            m = 0,
            p = 0,
            f = this.displayWidth,
            g = this.displayHeight;
        if (
            (void 0 !== s
                ? ((l = t),
                  (u = n),
                  (d = r),
                  (h = i),
                  (m = s),
                  (p = a),
                  void 0 !== o ? ((f = o), (g = c)) : ((f = d), (g = h)))
                : ((m = t), (p = n), void 0 !== r && ((f = r), (g = i))),
            !(
                ("undefined" != typeof CanvasRenderingContext2D && e instanceof CanvasRenderingContext2D) ||
                ("undefined" != typeof OffscreenCanvasRenderingContext2D &&
                    e instanceof OffscreenCanvasRenderingContext2D)
            ))
        )
            throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");
        if (!Number.isFinite(l)) throw new TypeError("sx must be a number.");
        if (!Number.isFinite(u)) throw new TypeError("sy must be a number.");
        if (!Number.isFinite(d) || d < 0) throw new TypeError("sWidth must be a non-negative number.");
        if (!Number.isFinite(h) || h < 0) throw new TypeError("sHeight must be a non-negative number.");
        if (!Number.isFinite(m)) throw new TypeError("dx must be a number.");
        if (!Number.isFinite(p)) throw new TypeError("dy must be a number.");
        if (!Number.isFinite(f) || f < 0) throw new TypeError("dWidth must be a non-negative number.");
        if (!Number.isFinite(g) || g < 0) throw new TypeError("dHeight must be a non-negative number.");
        if (this._closed) throw new Error("VideoSample is closed.");
        ({ sx: l, sy: u, sWidth: d, sHeight: h } = this._rotateSourceRegion(l, u, d, h, this.rotation));
        const b = this.toCanvasImageSource();
        e.save();
        const y = m + f / 2,
            w = p + g / 2;
        e.translate(y, w), e.rotate((this.rotation * Math.PI) / 180);
        const k = this.rotation % 180 == 0 ? 1 : f / g;
        e.scale(1 / k, k), e.drawImage(b, l, u, d, h, -f / 2, -g / 2, f, g), e.restore();
    }
    drawWithFit(e, t) {
        if (
            !(
                ("undefined" != typeof CanvasRenderingContext2D && e instanceof CanvasRenderingContext2D) ||
                ("undefined" != typeof OffscreenCanvasRenderingContext2D &&
                    e instanceof OffscreenCanvasRenderingContext2D)
            )
        )
            throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");
        if (!t || "object" != typeof t) throw new TypeError("options must be an object.");
        if (!["fill", "contain", "cover"].includes(t.fit))
            throw new TypeError("options.fit must be 'fill', 'contain', or 'cover'.");
        if (void 0 !== t.rotation && ![0, 90, 180, 270].includes(t.rotation))
            throw new TypeError("options.rotation, when provided, must be 0, 90, 180, or 270.");
        void 0 !== t.crop && mv(t.crop, "options.");
        const n = e.canvas.width,
            r = e.canvas.height,
            i = t.rotation ?? this.rotation,
            [s, a] = i % 180 == 0 ? [this.codedWidth, this.codedHeight] : [this.codedHeight, this.codedWidth];
        let o, c, l, u;
        t.crop && hv(t.crop, s, a);
        const {
            sx: d,
            sy: h,
            sWidth: m,
            sHeight: p,
        } = this._rotateSourceRegion(t.crop?.left ?? 0, t.crop?.top ?? 0, t.crop?.width ?? s, t.crop?.height ?? a, i);
        if ("fill" === t.fit) (o = 0), (c = 0), (l = n), (u = r);
        else {
            const [e, i] = t.crop ? [t.crop.width, t.crop.height] : [s, a],
                d = "contain" === t.fit ? Math.min(n / e, r / i) : Math.max(n / e, r / i);
            (l = e * d), (u = i * d), (o = (n - l) / 2), (c = (r - u) / 2);
        }
        const f = i % 180 == 0 ? 1 : l / u;
        e.translate(n / 2, r / 2),
            e.rotate((i * Math.PI) / 180),
            e.scale(1 / f, f),
            e.translate(-n / 2, -r / 2),
            e.drawImage(this.toCanvasImageSource(), d, h, m, p, o, c, l, u);
    }
    _rotateSourceRegion(e, t, n, r, i) {
        return (
            90 === i
                ? ([e, t, n, r] = [t, this.codedHeight - e - n, r, n])
                : 180 === i
                  ? ([e, t] = [this.codedWidth - e - n, this.codedHeight - t - r])
                  : 270 === i && ([e, t, n, r] = [this.codedWidth - t - r, e, r, n]),
            { sx: e, sy: t, sWidth: n, sHeight: r }
        );
    }
    toCanvasImageSource() {
        if (this._closed) throw new Error("VideoSample is closed.");
        if ((Vk(null !== this._data), this._data instanceof Uint8Array)) {
            const e = this.toVideoFrame();
            return queueMicrotask(() => e.close()), e;
        }
        return this._data;
    }
    setRotation(e) {
        if (![0, 90, 180, 270].includes(e)) throw new TypeError("newRotation must be 0, 90, 180, or 270.");
        this.rotation = e;
    }
    setTimestamp(e) {
        if (!Number.isFinite(e)) throw new TypeError("newTimestamp must be a number.");
        this.timestamp = e;
    }
    setDuration(e) {
        if (!Number.isFinite(e) || e < 0) throw new TypeError("newDuration must be a non-negative number.");
        this.duration = e;
    }
    [Symbol.dispose]() {
        this.close();
    }
}
const dv = (e) => "undefined" != typeof VideoFrame && e instanceof VideoFrame,
    hv = (e, t, n) => {
        (e.left = Math.min(e.left, t)),
            (e.top = Math.min(e.top, n)),
            (e.width = Math.min(e.width, t - e.left)),
            (e.height = Math.min(e.height, n - e.top)),
            Vk(e.width >= 0),
            Vk(e.height >= 0);
    },
    mv = (e, t) => {
        if (!e || "object" != typeof e) throw new TypeError(t + "crop, when provided, must be an object.");
        if (!Number.isInteger(e.left) || e.left < 0)
            throw new TypeError(t + "crop.left must be a non-negative integer.");
        if (!Number.isInteger(e.top) || e.top < 0) throw new TypeError(t + "crop.top must be a non-negative integer.");
        if (!Number.isInteger(e.width) || e.width < 0)
            throw new TypeError(t + "crop.width must be a non-negative integer.");
        if (!Number.isInteger(e.height) || e.height < 0)
            throw new TypeError(t + "crop.height must be a non-negative integer.");
    },
    pv = new Set(["f32", "f32-planar", "s16", "s16-planar", "s32", "s32-planar", "u8", "u8-planar"]);
class fv {
    get microsecondTimestamp() {
        return Math.trunc(xT * this.timestamp);
    }
    get microsecondDuration() {
        return Math.trunc(xT * this.duration);
    }
    constructor(e) {
        if (((this._closed = !1), kv(e))) {
            if (null === e.format) throw new TypeError("AudioData with null format is not supported.");
            (this._data = e),
                (this.format = e.format),
                (this.sampleRate = e.sampleRate),
                (this.numberOfFrames = e.numberOfFrames),
                (this.numberOfChannels = e.numberOfChannels),
                (this.timestamp = e.timestamp / 1e6),
                (this.duration = e.numberOfFrames / e.sampleRate);
        } else {
            if (!e || "object" != typeof e) throw new TypeError("Invalid AudioDataInit: must be an object.");
            if (!pv.has(e.format)) throw new TypeError("Invalid AudioDataInit: invalid format.");
            if (!Number.isFinite(e.sampleRate) || e.sampleRate <= 0)
                throw new TypeError("Invalid AudioDataInit: sampleRate must be > 0.");
            if (!Number.isInteger(e.numberOfChannels) || 0 === e.numberOfChannels)
                throw new TypeError("Invalid AudioDataInit: numberOfChannels must be an integer > 0.");
            if (!Number.isFinite(e?.timestamp)) throw new TypeError("init.timestamp must be a number.");
            const t = e.data.byteLength / (gv(e.format) * e.numberOfChannels);
            if (!Number.isInteger(t))
                throw new TypeError("Invalid AudioDataInit: data size is not a multiple of frame size.");
            let n;
            if (
                ((this.format = e.format),
                (this.sampleRate = e.sampleRate),
                (this.numberOfFrames = t),
                (this.numberOfChannels = e.numberOfChannels),
                (this.timestamp = e.timestamp),
                (this.duration = t / e.sampleRate),
                e.data instanceof ArrayBuffer)
            )
                n = new Uint8Array(e.data);
            else {
                if (!ArrayBuffer.isView(e.data))
                    throw new TypeError("Invalid AudioDataInit: data is not a BufferSource.");
                n = new Uint8Array(e.data.buffer, e.data.byteOffset, e.data.byteLength);
            }
            const r = this.numberOfFrames * this.numberOfChannels * gv(this.format);
            if (n.byteLength < r) throw new TypeError("Invalid AudioDataInit: insufficient data size.");
            this._data = n;
        }
    }
    allocationSize(e) {
        if (!e || "object" != typeof e) throw new TypeError("options must be an object.");
        if (!Number.isInteger(e.planeIndex) || e.planeIndex < 0)
            throw new TypeError("planeIndex must be a non-negative integer.");
        if (void 0 !== e.format && !pv.has(e.format)) throw new TypeError("Invalid format.");
        if (void 0 !== e.frameOffset && (!Number.isInteger(e.frameOffset) || e.frameOffset < 0))
            throw new TypeError("frameOffset must be a non-negative integer.");
        if (void 0 !== e.frameCount && (!Number.isInteger(e.frameCount) || e.frameCount < 0))
            throw new TypeError("frameCount must be a non-negative integer.");
        if (this._closed) throw new Error("AudioSample is closed.");
        const t = e.format ?? this.format,
            n = e.frameOffset ?? 0;
        if (n >= this.numberOfFrames) throw new RangeError("frameOffset out of range");
        const r = void 0 !== e.frameCount ? e.frameCount : this.numberOfFrames - n;
        if (r > this.numberOfFrames - n) throw new RangeError("frameCount out of range");
        const i = gv(t),
            s = bv(t);
        if (s && e.planeIndex >= this.numberOfChannels) throw new RangeError("planeIndex out of range");
        if (!s && 0 !== e.planeIndex) throw new RangeError("planeIndex out of range");
        return (s ? r : r * this.numberOfChannels) * i;
    }
    copyTo(e, t) {
        if (!cT(e)) throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");
        if (!t || "object" != typeof t) throw new TypeError("options must be an object.");
        if (!Number.isInteger(t.planeIndex) || t.planeIndex < 0)
            throw new TypeError("planeIndex must be a non-negative integer.");
        if (void 0 !== t.format && !pv.has(t.format)) throw new TypeError("Invalid format.");
        if (void 0 !== t.frameOffset && (!Number.isInteger(t.frameOffset) || t.frameOffset < 0))
            throw new TypeError("frameOffset must be a non-negative integer.");
        if (void 0 !== t.frameCount && (!Number.isInteger(t.frameCount) || t.frameCount < 0))
            throw new TypeError("frameCount must be a non-negative integer.");
        if (this._closed) throw new Error("AudioSample is closed.");
        const { planeIndex: n, format: r, frameCount: i, frameOffset: s } = t,
            a = r ?? this.format;
        if (!a) throw new Error("Destination format not determined");
        const o = this.numberOfFrames,
            c = this.numberOfChannels,
            l = s ?? 0;
        if (l >= o) throw new RangeError("frameOffset out of range");
        const u = void 0 !== i ? i : o - l;
        if (u > o - l) throw new RangeError("frameCount out of range");
        const d = gv(a),
            h = bv(a);
        if (h && n >= c) throw new RangeError("planeIndex out of range");
        if (!h && 0 !== n) throw new RangeError("planeIndex out of range");
        const m = (h ? u : u * c) * d;
        if (e.byteLength < m) throw new RangeError("Destination buffer is too small");
        const p = Yk(e),
            f = wv(a);
        if (kv(this._data))
            if (h)
                if ("f32-planar" === a)
                    this._data.copyTo(e, { planeIndex: n, frameOffset: l, frameCount: u, format: "f32-planar" });
                else {
                    const e = new ArrayBuffer(4 * u),
                        t = new Float32Array(e);
                    this._data.copyTo(t, { planeIndex: n, frameOffset: l, frameCount: u, format: "f32-planar" });
                    const r = new DataView(e);
                    for (let n = 0; n < u; n++) {
                        f(p, n * d, r.getFloat32(4 * n, !0));
                    }
                }
            else {
                const e = c,
                    t = new Float32Array(u);
                for (let n = 0; n < e; n++) {
                    this._data.copyTo(t, { planeIndex: n, frameOffset: l, frameCount: u, format: "f32-planar" });
                    for (let r = 0; r < u; r++) {
                        f(p, (r * e + n) * d, t[r]);
                    }
                }
            }
        else {
            const e = this._data,
                t = new DataView(e.buffer, e.byteOffset, e.byteLength),
                r = this.format,
                i = yv(r),
                s = gv(r),
                a = bv(r);
            for (let m = 0; m < u; m++)
                if (h) {
                    let e;
                    e = a ? (n * o + (m + l)) * s : ((m + l) * c + n) * s;
                    f(p, m * d, i(t, e));
                } else
                    for (let e = 0; e < c; e++) {
                        let n;
                        n = a ? (e * o + (m + l)) * s : ((m + l) * c + e) * s;
                        f(p, (m * c + e) * d, i(t, n));
                    }
        }
    }
    clone() {
        if (this._closed) throw new Error("AudioSample is closed.");
        if (kv(this._data)) {
            const e = new fv(this._data.clone());
            return e.setTimestamp(this.timestamp), e;
        }
        return new fv({
            format: this.format,
            sampleRate: this.sampleRate,
            numberOfFrames: this.numberOfFrames,
            numberOfChannels: this.numberOfChannels,
            timestamp: this.timestamp,
            data: this._data,
        });
    }
    close() {
        this._closed || (kv(this._data) ? this._data.close() : (this._data = new Uint8Array(0)), (this._closed = !0));
    }
    toAudioData() {
        if (this._closed) throw new Error("AudioSample is closed.");
        if (kv(this._data)) {
            if (this._data.timestamp === this.microsecondTimestamp) return this._data.clone();
            if (bv(this.format)) {
                const e = this.allocationSize({ planeIndex: 0, format: this.format }),
                    t = new ArrayBuffer(e * this.numberOfChannels);
                for (let n = 0; n < this.numberOfChannels; n++)
                    this.copyTo(new Uint8Array(t, n * e, e), { planeIndex: n, format: this.format });
                return new AudioData({
                    format: this.format,
                    sampleRate: this.sampleRate,
                    numberOfFrames: this.numberOfFrames,
                    numberOfChannels: this.numberOfChannels,
                    timestamp: this.microsecondTimestamp,
                    data: t,
                });
            }
            {
                const e = new ArrayBuffer(this.allocationSize({ planeIndex: 0, format: this.format }));
                return (
                    this.copyTo(e, { planeIndex: 0, format: this.format }),
                    new AudioData({
                        format: this.format,
                        sampleRate: this.sampleRate,
                        numberOfFrames: this.numberOfFrames,
                        numberOfChannels: this.numberOfChannels,
                        timestamp: this.microsecondTimestamp,
                        data: e,
                    })
                );
            }
        }
        return new AudioData({
            format: this.format,
            sampleRate: this.sampleRate,
            numberOfFrames: this.numberOfFrames,
            numberOfChannels: this.numberOfChannels,
            timestamp: this.microsecondTimestamp,
            data: this._data,
        });
    }
    toAudioBuffer() {
        if (this._closed) throw new Error("AudioSample is closed.");
        const e = new AudioBuffer({
                numberOfChannels: this.numberOfChannels,
                length: this.numberOfFrames,
                sampleRate: this.sampleRate,
            }),
            t = new Float32Array(this.allocationSize({ planeIndex: 0, format: "f32-planar" }) / 4);
        for (let n = 0; n < this.numberOfChannels; n++)
            this.copyTo(t, { planeIndex: n, format: "f32-planar" }), e.copyToChannel(t, n);
        return e;
    }
    setTimestamp(e) {
        if (!Number.isFinite(e)) throw new TypeError("newTimestamp must be a number.");
        this.timestamp = e;
    }
    [Symbol.dispose]() {
        this.close();
    }
    static *_fromAudioBuffer(e, t) {
        if (!(e instanceof AudioBuffer)) throw new TypeError("audioBuffer must be an AudioBuffer.");
        const n = e.numberOfChannels,
            r = e.sampleRate,
            i = e.length,
            s = Math.floor(24e4 / n);
        let a = 0,
            o = i;
        for (; o > 0; ) {
            const i = Math.min(s, o),
                c = new Float32Array(n * i);
            for (let t = 0; t < n; t++) e.copyFromChannel(c.subarray(t * i, (t + 1) * i), t, a);
            yield new fv({
                format: "f32-planar",
                sampleRate: r,
                numberOfFrames: i,
                numberOfChannels: n,
                timestamp: t + a / r,
                data: c,
            }),
                (a += i),
                (o -= i);
        }
    }
    static fromAudioBuffer(e, t) {
        if (!(e instanceof AudioBuffer)) throw new TypeError("audioBuffer must be an AudioBuffer.");
        const n = e.numberOfChannels,
            r = e.sampleRate,
            i = e.length,
            s = Math.floor(24e4 / n);
        let a = 0,
            o = i;
        const c = [];
        for (; o > 0; ) {
            const i = Math.min(s, o),
                l = new Float32Array(n * i);
            for (let t = 0; t < n; t++) e.copyFromChannel(l.subarray(t * i, (t + 1) * i), t, a);
            const u = new fv({
                format: "f32-planar",
                sampleRate: r,
                numberOfFrames: i,
                numberOfChannels: n,
                timestamp: t + a / r,
                data: l,
            });
            c.push(u), (a += i), (o -= i);
        }
        return c;
    }
}
const gv = (e) => {
        switch (e) {
            case "u8":
            case "u8-planar":
                return 1;
            case "s16":
            case "s16-planar":
                return 2;
            case "s32":
            case "s32-planar":
            case "f32":
            case "f32-planar":
                return 4;
            default:
                throw new Error("Unknown AudioSampleFormat");
        }
    },
    bv = (e) => {
        switch (e) {
            case "u8-planar":
            case "s16-planar":
            case "s32-planar":
            case "f32-planar":
                return !0;
            default:
                return !1;
        }
    },
    yv = (e) => {
        switch (e) {
            case "u8":
            case "u8-planar":
                return (e, t) => (e.getUint8(t) - 128) / 128;
            case "s16":
            case "s16-planar":
                return (e, t) => e.getInt16(t, !0) / 32768;
            case "s32":
            case "s32-planar":
                return (e, t) => e.getInt32(t, !0) / 2147483648;
            case "f32":
            case "f32-planar":
                return (e, t) => e.getFloat32(t, !0);
        }
    },
    wv = (e) => {
        switch (e) {
            case "u8":
            case "u8-planar":
                return (e, t, n) => e.setUint8(t, _T(127.5 * (n + 1), 0, 255));
            case "s16":
            case "s16-planar":
                return (e, t, n) => e.setInt16(t, _T(Math.round(32767 * n), -32768, 32767), !0);
            case "s32":
            case "s32-planar":
                return (e, t, n) => e.setInt32(t, _T(Math.round(2147483647 * n), -2147483648, 2147483647), !0);
            case "f32":
            case "f32-planar":
                return (e, t, n) => e.setFloat32(t, n, !0);
        }
    },
    kv = (e) => "undefined" != typeof AudioData && e instanceof AudioData,
    Tv = (e) => {
        if (!e || "object" != typeof e) throw new TypeError("options must be an object.");
        if (void 0 !== e.metadataOnly && "boolean" != typeof e.metadataOnly)
            throw new TypeError("options.metadataOnly, when defined, must be a boolean.");
        if (void 0 !== e.verifyKeyPackets && "boolean" != typeof e.verifyKeyPackets)
            throw new TypeError("options.verifyKeyPackets, when defined, must be a boolean.");
        if (e.verifyKeyPackets && e.metadataOnly)
            throw new TypeError("options.verifyKeyPackets and options.metadataOnly cannot be enabled together.");
    },
    _v = (e) => {
        if (!jT(e)) throw new TypeError("timestamp must be a number.");
    },
    vv = (e, t, n) =>
        n.verifyKeyPackets
            ? t.then(async (t) => {
                  if (!t || "delta" === t.type) return t;
                  const n = await e.determinePacketType(t);
                  return n && (t.type = n), t;
              })
            : t;
class Sv {
    constructor(e) {
        if (!(e instanceof Fv)) throw new TypeError("track must be an InputTrack.");
        this._track = e;
    }
    getFirstPacket(e = {}) {
        if ((Tv(e), this._track.input._disposed)) throw new JE();
        return vv(this._track, this._track._backing.getFirstPacket(e), e);
    }
    getPacket(e, t = {}) {
        if ((_v(e), Tv(t), this._track.input._disposed)) throw new JE();
        return vv(this._track, this._track._backing.getPacket(e, t), t);
    }
    getNextPacket(e, t = {}) {
        if (!(e instanceof lv)) throw new TypeError("packet must be an EncodedPacket.");
        if ((Tv(t), this._track.input._disposed)) throw new JE();
        return vv(this._track, this._track._backing.getNextPacket(e, t), t);
    }
    async getKeyPacket(e, t = {}) {
        if ((_v(e), Tv(t), this._track.input._disposed)) throw new JE();
        if (!t.verifyKeyPackets) return this._track._backing.getKeyPacket(e, t);
        const n = await this._track._backing.getKeyPacket(e, t);
        if (!n || "delta" === n.type) return n;
        return "delta" === (await this._track.determinePacketType(n))
            ? this.getKeyPacket(n.timestamp - 1 / this._track.timeResolution, t)
            : n;
    }
    async getNextKeyPacket(e, t = {}) {
        if (!(e instanceof lv)) throw new TypeError("packet must be an EncodedPacket.");
        if ((Tv(t), this._track.input._disposed)) throw new JE();
        if (!t.verifyKeyPackets) return this._track._backing.getNextKeyPacket(e, t);
        const n = await this._track._backing.getNextKeyPacket(e, t);
        if (!n || "delta" === n.type) return n;
        return "delta" === (await this._track.determinePacketType(n)) ? this.getNextKeyPacket(n, t) : n;
    }
    packets(e, t, n = {}) {
        if (void 0 !== e && !(e instanceof lv)) throw new TypeError("startPacket must be an EncodedPacket.");
        if (void 0 !== e && e.isMetadataOnly && !n?.metadataOnly)
            throw new TypeError("startPacket can only be metadata-only if options.metadataOnly is enabled.");
        if (void 0 !== t && !(t instanceof lv)) throw new TypeError("endPacket must be an EncodedPacket.");
        if ((Tv(n), this._track.input._disposed)) throw new JE();
        const r = [];
        let { promise: i, resolve: s } = fT(),
            { promise: a, resolve: o } = fT(),
            c = !1,
            l = !1,
            u = null;
        const d = [],
            h = () => Math.max(2, d.length);
        (async () => {
            let u = e ?? (await this.getFirstPacket(n));
            for (; u && !l && !this._track.input._disposed && !(t && u.sequenceNumber >= t?.sequenceNumber); )
                r.length > h()
                    ? (({ promise: a, resolve: o } = fT()), await a)
                    : (r.push(u), s(), ({ promise: i, resolve: s } = fT()), (u = await this.getNextPacket(u, n)));
            (c = !0), s();
        })().catch((e) => {
            u || ((u = e), s());
        });
        const m = this._track;
        return {
            async next() {
                for (;;) {
                    if (m.input._disposed) throw new JE();
                    if (l) return { value: void 0, done: !0 };
                    if (u) throw u;
                    if (r.length > 0) {
                        const e = r.shift(),
                            t = performance.now();
                        for (d.push(t); d.length > 0 && t - d[0] >= 1e3; ) d.shift();
                        return o(), { value: e, done: !1 };
                    }
                    if (c) return { value: void 0, done: !0 };
                    await i;
                }
            },
            return: async () => ((l = !0), o(), s(), { value: void 0, done: !0 }),
            async throw(e) {
                throw e;
            },
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
}
class Ev {
    constructor(e, t) {
        (this.onSample = e), (this.onError = t);
    }
}
class Cv {
    mediaSamplesInRange(e = 0, t = 1 / 0) {
        _v(e), _v(t);
        const n = [];
        let r = !1,
            i = null,
            { promise: s, resolve: a } = fT(),
            { promise: o, resolve: c } = fT(),
            l = !1,
            u = !1,
            d = !1,
            h = null;
        (async () => {
            const m = new Error(),
                p = await this._createDecoder(
                    (o) => {
                        c(),
                            o.timestamp >= t && (u = !0),
                            u
                                ? o.close()
                                : (i && (o.timestamp > e ? (n.push(i), (r = !0)) : i.close()),
                                  o.timestamp >= e && (n.push(o), (r = !0)),
                                  (i = r ? null : o),
                                  n.length > 0 && (a(), ({ promise: s, resolve: a } = fT())));
                    },
                    (e) => {
                        h || ((e.stack = m.stack), (h = e), a());
                    }
                ),
                f = this._createPacketSink(),
                g = (await f.getKeyPacket(e, { verifyKeyPackets: !0 })) ?? (await f.getFirstPacket());
            if (!g) return;
            let b,
                y = g;
            if (t < 1 / 0) {
                const e = await f.getPacket(t),
                    n = e
                        ? "key" === e.type && e.timestamp === t
                            ? e
                            : await f.getNextKeyPacket(e, { verifyKeyPackets: !0 })
                        : null;
                n && (b = n);
            }
            const w = f.packets(g, b);
            for (await w.next(); y && !u && !this._track.input._disposed; ) {
                const e = Iv(n.length);
                if (n.length + p.getDecodeQueueSize() > e) {
                    ({ promise: o, resolve: c } = fT()), await o;
                    continue;
                }
                p.decode(y);
                const t = await w.next();
                if (t.done) break;
                y = t.value;
            }
            await w.return(),
                d || this._track.input._disposed || (await p.flush()),
                p.close(),
                !r && i && n.push(i),
                (l = !0),
                a();
        })().catch((e) => {
            h || ((h = e), a());
        });
        const m = this._track,
            p = () => {
                i?.close();
                for (const e of n) e.close();
            };
        return {
            async next() {
                for (;;) {
                    if (m.input._disposed) throw (p(), new JE());
                    if (d) return { value: void 0, done: !0 };
                    if (h) throw (p(), h);
                    if (n.length > 0) {
                        const e = n.shift();
                        return c(), { value: e, done: !1 };
                    }
                    if (l) return { value: void 0, done: !0 };
                    await s;
                }
            },
            return: async () => ((d = !0), (u = !0), c(), a(), p(), { value: void 0, done: !0 }),
            async throw(e) {
                throw e;
            },
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
    mediaSamplesAtTimestamps(e) {
        ((e) => {
            if (!(Symbol.iterator in e) && !(Symbol.asyncIterator in e))
                throw new TypeError("Argument must be an iterable or async iterable.");
        })(e);
        const t = (async function* (e) {
                Symbol.iterator in e ? yield* e[Symbol.iterator]() : yield* e[Symbol.asyncIterator]();
            })(e),
            n = [],
            r = [];
        let { promise: i, resolve: s } = fT(),
            { promise: a, resolve: o } = fT(),
            c = !1,
            l = !1,
            u = null;
        const d = (e) => {
            r.push(e), s(), ({ promise: i, resolve: s } = fT());
        };
        (async () => {
            const e = new Error(),
                i = await this._createDecoder(
                    (e) => {
                        if ((o(), l)) return void e.close();
                        let t = 0;
                        for (; n.length > 0 && e.timestamp - n[0] > -1e-10; ) t++, n.shift();
                        if (t > 0) for (let n = 0; n < t; n++) d(n < t - 1 ? e.clone() : e);
                        else e.close();
                    },
                    (t) => {
                        u || ((t.stack = e.stack), (u = t), s());
                    }
                ),
                h = this._createPacketSink();
            let m = null,
                p = null,
                f = -1;
            const g = async () => {
                    Vk(p);
                    let e = p;
                    for (i.decode(e); e.sequenceNumber < f; ) {
                        const t = Iv(r.length);
                        for (; r.length + i.getDecodeQueueSize() > t && !l; )
                            ({ promise: a, resolve: o } = fT()), await a;
                        if (l) break;
                        const n = await h.getNextPacket(e);
                        Vk(n), i.decode(n), (e = n);
                    }
                    f = -1;
                },
                b = async () => {
                    await i.flush();
                    for (let e = 0; e < n.length; e++) d(null);
                    n.length = 0;
                };
            for await (const r of t) {
                if ((_v(r), l || this._track.input._disposed)) break;
                const e = await h.getPacket(r),
                    t = e && (await h.getKeyPacket(r, { verifyKeyPackets: !0 }));
                t
                    ? (m &&
                          (t.sequenceNumber !== p.sequenceNumber || e.timestamp < m.timestamp) &&
                          (await g(), await b()),
                      n.push(e.timestamp),
                      (f = Math.max(e.sequenceNumber, f)),
                      (m = e),
                      (p = t))
                    : (-1 !== f && (await g(), await b()), d(null), (m = null));
            }
            l || this._track.input._disposed || (-1 !== f && (await g()), await b()), i.close(), (c = !0), s();
        })().catch((e) => {
            u || ((u = e), s());
        });
        const h = this._track,
            m = () => {
                for (const e of r) e?.close();
            };
        return {
            async next() {
                for (;;) {
                    if (h.input._disposed) throw (m(), new JE());
                    if (l) return { value: void 0, done: !0 };
                    if (u) throw (m(), u);
                    if (r.length > 0) {
                        const e = r.shift();
                        return Vk(void 0 !== e), o(), { value: e, done: !1 };
                    }
                    if (c) return { value: void 0, done: !0 };
                    await i;
                }
            },
            return: async () => ((l = !0), o(), s(), m(), { value: void 0, done: !0 }),
            async throw(e) {
                throw e;
            },
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    }
}
const Iv = (e) => (0 === e ? 40 : 8);
class xv extends Ev {
    constructor(e, t, n, r, i, s) {
        super(e, t),
            (this.codec = n),
            (this.decoderConfig = r),
            (this.rotation = i),
            (this.timeResolution = s),
            (this.decoder = null),
            (this.customDecoder = null),
            (this.customDecoderCallSerializer = new NT()),
            (this.customDecoderQueueSize = 0),
            (this.inputTimestamps = []),
            (this.sampleQueue = []),
            (this.currentPacketIndex = 0),
            (this.raslSkipped = !1),
            (this.alphaDecoder = null),
            (this.alphaHadKeyframe = !1),
            (this.colorQueue = []),
            (this.alphaQueue = []),
            (this.merger = null),
            (this.mergerCreationFailed = !1),
            (this.decodedAlphaChunkCount = 0),
            (this.alphaDecoderQueueSize = 0),
            (this.nullAlphaFrameQueue = []),
            (this.currentAlphaPacketIndex = 0),
            (this.alphaRaslSkipped = !1);
        const a = iv.find((e) => e.supports(n, r));
        if (a)
            (this.customDecoder = new a()),
                (this.customDecoder.codec = n),
                (this.customDecoder.config = r),
                (this.customDecoder.onSample = (e) => {
                    if (!(e instanceof uv))
                        throw new TypeError("The argument passed to onSample must be a VideoSample.");
                    this.finalizeAndEmitSample(e);
                }),
                this.customDecoderCallSerializer.call(() => this.customDecoder.init());
        else {
            const e = (e) => {
                if (this.alphaQueue.length > 0) {
                    const t = this.alphaQueue.shift();
                    Vk(void 0 !== t), this.mergeAlpha(e, t);
                } else this.colorQueue.push(e);
            };
            (this.decoder = new VideoDecoder({
                output: (t) => {
                    try {
                        e(t);
                    } catch (n) {
                        this.onError(n);
                    }
                },
                error: t,
            })),
                this.decoder.configure(r);
        }
    }
    getDecodeQueueSize() {
        return this.customDecoder
            ? this.customDecoderQueueSize
            : (Vk(this.decoder), Math.max(this.decoder.decodeQueueSize, this.alphaDecoder?.decodeQueueSize ?? 0));
    }
    decode(e) {
        if ("hevc" === this.codec && this.currentPacketIndex > 0 && !this.raslSkipped) {
            if (this.hasHevcRaslPicture(e.data)) return;
            this.raslSkipped = !0;
        }
        this.currentPacketIndex++,
            this.customDecoder
                ? (this.customDecoderQueueSize++,
                  this.customDecoderCallSerializer
                      .call(() => this.customDecoder.decode(e))
                      .then(() => this.customDecoderQueueSize--))
                : (Vk(this.decoder),
                  MT() || pT(this.inputTimestamps, e.timestamp, (e) => e),
                  this.decoder.decode(e.toEncodedVideoChunk()),
                  this.decodeAlphaData(e));
    }
    decodeAlphaData(e) {
        if (!e.sideData.alpha || this.mergerCreationFailed) return void this.pushNullAlphaFrame();
        if (!this.merger)
            try {
                this.merger = new Av();
            } catch (n) {
                return (this.mergerCreationFailed = !0), void this.decodeAlphaData(e);
            }
        if (!this.alphaDecoder) {
            const e = (e) => {
                if ((this.alphaDecoderQueueSize--, this.colorQueue.length > 0)) {
                    const t = this.colorQueue.shift();
                    Vk(void 0 !== t), this.mergeAlpha(t, e);
                } else this.alphaQueue.push(e);
                for (
                    this.decodedAlphaChunkCount++;
                    this.nullAlphaFrameQueue.length > 0 && this.nullAlphaFrameQueue[0] === this.decodedAlphaChunkCount;

                )
                    if ((this.nullAlphaFrameQueue.shift(), this.colorQueue.length > 0)) {
                        const e = this.colorQueue.shift();
                        Vk(void 0 !== e), this.mergeAlpha(e, null);
                    } else this.alphaQueue.push(null);
            };
            (this.alphaDecoder = new VideoDecoder({
                output: (t) => {
                    try {
                        e(t);
                    } catch (n) {
                        this.onError(n);
                    }
                },
                error: this.onError,
            })),
                this.alphaDecoder.configure(this.decoderConfig);
        }
        const t = Z_(this.codec, this.decoderConfig, e.sideData.alpha);
        if ((this.alphaHadKeyframe || (this.alphaHadKeyframe = "key" === t), this.alphaHadKeyframe)) {
            if ("hevc" === this.codec && this.currentAlphaPacketIndex > 0 && !this.alphaRaslSkipped) {
                if (this.hasHevcRaslPicture(e.sideData.alpha)) return void this.pushNullAlphaFrame();
                this.alphaRaslSkipped = !0;
            }
            this.currentAlphaPacketIndex++,
                this.alphaDecoder.decode(e.alphaToEncodedVideoChunk(t ?? e.type)),
                this.alphaDecoderQueueSize++;
        } else this.pushNullAlphaFrame();
    }
    pushNullAlphaFrame() {
        0 === this.alphaDecoderQueueSize
            ? this.alphaQueue.push(null)
            : this.nullAlphaFrameQueue.push(this.decodedAlphaChunkCount + this.alphaDecoderQueueSize);
    }
    hasHevcRaslPicture(e) {
        return L_(e, this.decoderConfig).some((e) => {
            const t = B_(e);
            return t === P_.RASL_N || t === P_.RASL_R;
        });
    }
    sampleHandler(e) {
        if (MT()) {
            if (this.sampleQueue.length > 0 && e.timestamp >= jk(this.sampleQueue).timestamp) {
                for (const e of this.sampleQueue) this.finalizeAndEmitSample(e);
                this.sampleQueue.length = 0;
            }
            pT(this.sampleQueue, e, (e) => e.timestamp);
        } else {
            const t = this.inputTimestamps.shift();
            Vk(void 0 !== t), e.setTimestamp(t), this.finalizeAndEmitSample(e);
        }
    }
    finalizeAndEmitSample(e) {
        e.setTimestamp(Math.round(e.timestamp * this.timeResolution) / this.timeResolution),
            e.setDuration(Math.round(e.duration * this.timeResolution) / this.timeResolution),
            e.setRotation(this.rotation),
            this.onSample(e);
    }
    mergeAlpha(e, t) {
        if (!t) {
            const t = new uv(e);
            return void this.sampleHandler(t);
        }
        Vk(this.merger), this.merger.update(e, t), e.close(), t.close();
        const n = new VideoFrame(this.merger.canvas, { timestamp: e.timestamp, duration: e.duration ?? void 0 }),
            r = new uv(n);
        this.sampleHandler(r);
    }
    async flush() {
        if (
            (this.customDecoder
                ? await this.customDecoderCallSerializer.call(() => this.customDecoder.flush())
                : (Vk(this.decoder),
                  await Promise.all([this.decoder.flush(), this.alphaDecoder?.flush()]),
                  this.colorQueue.forEach((e) => e.close()),
                  (this.colorQueue.length = 0),
                  this.alphaQueue.forEach((e) => e?.close()),
                  (this.alphaQueue.length = 0),
                  (this.alphaHadKeyframe = !1),
                  (this.decodedAlphaChunkCount = 0),
                  (this.alphaDecoderQueueSize = 0),
                  (this.nullAlphaFrameQueue.length = 0),
                  (this.currentAlphaPacketIndex = 0),
                  (this.alphaRaslSkipped = !1)),
            MT())
        ) {
            for (const e of this.sampleQueue) this.finalizeAndEmitSample(e);
            this.sampleQueue.length = 0;
        }
        (this.currentPacketIndex = 0), (this.raslSkipped = !1);
    }
    close() {
        this.customDecoder
            ? this.customDecoderCallSerializer.call(() => this.customDecoder.close())
            : (Vk(this.decoder),
              this.decoder.close(),
              this.alphaDecoder?.close(),
              this.colorQueue.forEach((e) => e.close()),
              (this.colorQueue.length = 0),
              this.alphaQueue.forEach((e) => e?.close()),
              (this.alphaQueue.length = 0),
              this.merger?.close());
        for (const e of this.sampleQueue) e.close();
        this.sampleQueue.length = 0;
    }
}
class Av {
    constructor() {
        "undefined" != typeof OffscreenCanvas
            ? (this.canvas = new OffscreenCanvas(300, 150))
            : (this.canvas = document.createElement("canvas"));
        const e = this.canvas.getContext("webgl2", { premultipliedAlpha: !1 });
        if (!e) throw new Error("Couldn't acquire WebGL 2 context.");
        (this.gl = e),
            (this.program = this.createProgram()),
            (this.vao = this.createVAO()),
            (this.colorTexture = this.createTexture()),
            (this.alphaTexture = this.createTexture()),
            this.gl.useProgram(this.program),
            this.gl.uniform1i(this.gl.getUniformLocation(this.program, "u_colorTexture"), 0),
            this.gl.uniform1i(this.gl.getUniformLocation(this.program, "u_alphaTexture"), 1);
    }
    createProgram() {
        const e = this.createShader(
                this.gl.VERTEX_SHADER,
                "#version 300 es\n\t\t\tin vec2 a_position;\n\t\t\tin vec2 a_texCoord;\n\t\t\tout vec2 v_texCoord;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tgl_Position = vec4(a_position, 0.0, 1.0);\n\t\t\t\tv_texCoord = a_texCoord;\n\t\t\t}\n\t\t"
            ),
            t = this.createShader(
                this.gl.FRAGMENT_SHADER,
                "#version 300 es\n\t\t\tprecision highp float;\n\t\t\t\n\t\t\tuniform sampler2D u_colorTexture;\n\t\t\tuniform sampler2D u_alphaTexture;\n\t\t\tin vec2 v_texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tvec3 color = texture(u_colorTexture, v_texCoord).rgb;\n\t\t\t\tfloat alpha = texture(u_alphaTexture, v_texCoord).r;\n\t\t\t\tfragColor = vec4(color, alpha);\n\t\t\t}\n\t\t"
            ),
            n = this.gl.createProgram();
        return this.gl.attachShader(n, e), this.gl.attachShader(n, t), this.gl.linkProgram(n), n;
    }
    createShader(e, t) {
        const n = this.gl.createShader(e);
        return this.gl.shaderSource(n, t), this.gl.compileShader(n), n;
    }
    createVAO() {
        const e = this.gl.createVertexArray();
        this.gl.bindVertexArray(e);
        const t = new Float32Array([-1, -1, 0, 1, 1, -1, 1, 1, -1, 1, 0, 0, 1, 1, 1, 0]),
            n = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, n), this.gl.bufferData(this.gl.ARRAY_BUFFER, t, this.gl.STATIC_DRAW);
        const r = this.gl.getAttribLocation(this.program, "a_position"),
            i = this.gl.getAttribLocation(this.program, "a_texCoord");
        return (
            this.gl.enableVertexAttribArray(r),
            this.gl.vertexAttribPointer(r, 2, this.gl.FLOAT, !1, 16, 0),
            this.gl.enableVertexAttribArray(i),
            this.gl.vertexAttribPointer(i, 2, this.gl.FLOAT, !1, 16, 8),
            e
        );
    }
    createTexture() {
        const e = this.gl.createTexture();
        return (
            this.gl.bindTexture(this.gl.TEXTURE_2D, e),
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE),
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE),
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR),
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR),
            e
        );
    }
    update(e, t) {
        (e.displayWidth === this.canvas.width && e.displayHeight === this.canvas.height) ||
            ((this.canvas.width = e.displayWidth), (this.canvas.height = e.displayHeight)),
            this.gl.activeTexture(this.gl.TEXTURE0),
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.colorTexture),
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, e),
            this.gl.activeTexture(this.gl.TEXTURE1),
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.alphaTexture),
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, t),
            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height),
            this.gl.clear(this.gl.COLOR_BUFFER_BIT),
            this.gl.bindVertexArray(this.vao),
            this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    }
    close() {
        this.gl.getExtension("WEBGL_lose_context")?.loseContext(), (this.gl = null);
    }
}
class Pv extends Cv {
    constructor(e) {
        if (!(e instanceof Lv)) throw new TypeError("videoTrack must be an InputVideoTrack.");
        super(), (this._track = e);
    }
    async _createDecoder(e, t) {
        if (!(await this._track.canDecode()))
            throw new Error(
                "This video track cannot be decoded by this browser. Make sure to check decodability before using a track."
            );
        const n = this._track.codec,
            r = this._track.rotation,
            i = await this._track.getDecoderConfig(),
            s = this._track.timeResolution;
        return Vk(n && i), new xv(e, t, n, i, r, s);
    }
    _createPacketSink() {
        return new Sv(this._track);
    }
    async getSample(e) {
        _v(e);
        for await (const t of this.mediaSamplesAtTimestamps([e])) return t;
        throw new Error("Internal error: Iterator returned nothing.");
    }
    samples(e = 0, t = 1 / 0) {
        return this.mediaSamplesInRange(e, t);
    }
    samplesAtTimestamps(e) {
        return this.mediaSamplesAtTimestamps(e);
    }
}
class Ov {
    constructor(e, t = {}) {
        if (((this._nextCanvasIndex = 0), !(e instanceof Lv)))
            throw new TypeError("videoTrack must be an InputVideoTrack.");
        if (t && "object" != typeof t) throw new TypeError("options must be an object.");
        if (void 0 !== t.alpha && "boolean" != typeof t.alpha)
            throw new TypeError("options.alpha, when provided, must be a boolean.");
        if (void 0 !== t.width && (!Number.isInteger(t.width) || t.width <= 0))
            throw new TypeError("options.width, when defined, must be a positive integer.");
        if (void 0 !== t.height && (!Number.isInteger(t.height) || t.height <= 0))
            throw new TypeError("options.height, when defined, must be a positive integer.");
        if (void 0 !== t.fit && !["fill", "contain", "cover"].includes(t.fit))
            throw new TypeError('options.fit, when provided, must be one of "fill", "contain", or "cover".');
        if (void 0 !== t.width && void 0 !== t.height && void 0 === t.fit)
            throw new TypeError(
                "When both options.width and options.height are provided, options.fit must also be provided."
            );
        if (void 0 !== t.rotation && ![0, 90, 180, 270].includes(t.rotation))
            throw new TypeError("options.rotation, when provided, must be 0, 90, 180 or 270.");
        if (
            (void 0 !== t.crop && mv(t.crop, "options."),
            void 0 !== t.poolSize && ("number" != typeof t.poolSize || !Number.isInteger(t.poolSize) || t.poolSize < 0))
        )
            throw new TypeError("poolSize must be a non-negative integer.");
        const n = t.rotation ?? e.rotation,
            [r, i] = n % 180 == 0 ? [e.codedWidth, e.codedHeight] : [e.codedHeight, e.codedWidth],
            s = t.crop;
        s && hv(s, r, i);
        let [a, o] = s ? [s.width, s.height] : [r, i];
        const c = a / o;
        void 0 !== t.width && void 0 === t.height
            ? ((a = t.width), (o = Math.round(a / c)))
            : void 0 === t.width && void 0 !== t.height
              ? ((o = t.height), (a = Math.round(o * c)))
              : void 0 !== t.width && void 0 !== t.height && ((a = t.width), (o = t.height)),
            (this._videoTrack = e),
            (this._alpha = t.alpha ?? !1),
            (this._width = a),
            (this._height = o),
            (this._rotation = n),
            (this._crop = s),
            (this._fit = t.fit ?? "fill"),
            (this._videoSampleSink = new Pv(e)),
            (this._canvasPool = Array.from({ length: t.poolSize ?? 0 }, () => null));
    }
    _videoSampleToWrappedCanvas(e) {
        let t = this._canvasPool[this._nextCanvasIndex],
            n = !1;
        t ||
            ("undefined" != typeof document
                ? ((t = document.createElement("canvas")), (t.width = this._width), (t.height = this._height))
                : (t = new OffscreenCanvas(this._width, this._height)),
            this._canvasPool.length > 0 && (this._canvasPool[this._nextCanvasIndex] = t),
            (n = !0)),
            this._canvasPool.length > 0 &&
                (this._nextCanvasIndex = (this._nextCanvasIndex + 1) % this._canvasPool.length);
        const r = t.getContext("2d", { alpha: this._alpha || FT() });
        Vk(r),
            r.resetTransform(),
            n ||
                (!this._alpha && FT()
                    ? ((r.fillStyle = "black"), r.fillRect(0, 0, this._width, this._height))
                    : r.clearRect(0, 0, this._width, this._height)),
            e.drawWithFit(r, { fit: this._fit, rotation: this._rotation, crop: this._crop });
        const i = { canvas: t, timestamp: e.timestamp, duration: e.duration };
        return e.close(), i;
    }
    async getCanvas(e) {
        _v(e);
        const t = await this._videoSampleSink.getSample(e);
        return t && this._videoSampleToWrappedCanvas(t);
    }
    canvases(e = 0, t = 1 / 0) {
        return TT(this._videoSampleSink.samples(e, t), (e) => this._videoSampleToWrappedCanvas(e));
    }
    canvasesAtTimestamps(e) {
        return TT(this._videoSampleSink.samplesAtTimestamps(e), (e) => e && this._videoSampleToWrappedCanvas(e));
    }
}
class Nv extends Ev {
    constructor(e, t, n, r) {
        super(e, t),
            (this.decoder = null),
            (this.customDecoder = null),
            (this.customDecoderCallSerializer = new NT()),
            (this.customDecoderQueueSize = 0),
            (this.currentTimestamp = null);
        const i = (t) => {
                (null === this.currentTimestamp || Math.abs(t.timestamp - this.currentTimestamp) >= t.duration) &&
                    (this.currentTimestamp = t.timestamp);
                const n = this.currentTimestamp;
                if (((this.currentTimestamp += t.duration), 0 === t.numberOfFrames)) return void t.close();
                const i = r.sampleRate;
                t.setTimestamp(Math.round(n * i) / i), e(t);
            },
            s = sv.find((e) => e.supports(n, r));
        s
            ? ((this.customDecoder = new s()),
              (this.customDecoder.codec = n),
              (this.customDecoder.config = r),
              (this.customDecoder.onSample = (e) => {
                  if (!(e instanceof fv))
                      throw new TypeError("The argument passed to onSample must be an AudioSample.");
                  i(e);
              }),
              this.customDecoderCallSerializer.call(() => this.customDecoder.init()))
            : ((this.decoder = new AudioDecoder({
                  output: (e) => {
                      try {
                          i(new fv(e));
                      } catch (t) {
                          this.onError(t);
                      }
                  },
                  error: t,
              })),
              this.decoder.configure(r));
    }
    getDecodeQueueSize() {
        return this.customDecoder ? this.customDecoderQueueSize : (Vk(this.decoder), this.decoder.decodeQueueSize);
    }
    decode(e) {
        this.customDecoder
            ? (this.customDecoderQueueSize++,
              this.customDecoderCallSerializer
                  .call(() => this.customDecoder.decode(e))
                  .then(() => this.customDecoderQueueSize--))
            : (Vk(this.decoder), this.decoder.decode(e.toEncodedAudioChunk()));
    }
    flush() {
        return this.customDecoder
            ? this.customDecoderCallSerializer.call(() => this.customDecoder.flush())
            : (Vk(this.decoder), this.decoder.flush());
    }
    close() {
        this.customDecoder
            ? this.customDecoderCallSerializer.call(() => this.customDecoder.close())
            : (Vk(this.decoder), this.decoder.close());
    }
}
class Rv extends Ev {
    constructor(e, t, n) {
        super(e, t),
            (this.decoderConfig = n),
            (this.currentTimestamp = null),
            Vk(KT.includes(n.codec)),
            (this.codec = n.codec);
        const { dataType: r, sampleSize: i, littleEndian: s } = g_(this.codec);
        switch (((this.inputSampleSize = i), i)) {
            case 1:
                "unsigned" === r
                    ? (this.readInputValue = (e, t) => e.getUint8(t) - 128)
                    : "signed" === r
                      ? (this.readInputValue = (e, t) => e.getInt8(t))
                      : "ulaw" === r
                        ? (this.readInputValue = (e, t) =>
                              ((e) => {
                                  let t = 0,
                                      n = 0,
                                      r = ~e;
                                  128 & r && ((r &= -129), (t = -1)), (n = 5 + ((240 & r) >> 4));
                                  const i = ((1 << n) | ((15 & r) << (n - 4)) | (1 << (n - 5))) - 33;
                                  return 0 === t ? i : -i;
                              })(e.getUint8(t)))
                        : "alaw" === r
                          ? (this.readInputValue = (e, t) =>
                                ((e) => {
                                    let t = 0,
                                        n = 0,
                                        r = 85 ^ e;
                                    128 & r && ((r &= -129), (t = -1)), (n = 4 + ((240 & r) >> 4));
                                    let i = 0;
                                    return (
                                        (i =
                                            4 !== n ? (1 << n) | ((15 & r) << (n - 4)) | (1 << (n - 5)) : (r << 1) | 1),
                                        0 === t ? i : -i
                                    );
                                })(e.getUint8(t)))
                          : Vk(!1);
                break;
            case 2:
                "unsigned" === r
                    ? (this.readInputValue = (e, t) => e.getUint16(t, s) - 32768)
                    : "signed" === r
                      ? (this.readInputValue = (e, t) => e.getInt16(t, s))
                      : Vk(!1);
                break;
            case 3:
                "unsigned" === r
                    ? (this.readInputValue = (e, t) => wT(e, t, s) - 2 ** 23)
                    : "signed" === r
                      ? (this.readInputValue = (e, t) => ((e, t, n) => (wT(e, t, n) << 8) >> 8)(e, t, s))
                      : Vk(!1);
                break;
            case 4:
                "unsigned" === r
                    ? (this.readInputValue = (e, t) => e.getUint32(t, s) - 2 ** 31)
                    : "signed" === r
                      ? (this.readInputValue = (e, t) => e.getInt32(t, s))
                      : "float" === r
                        ? (this.readInputValue = (e, t) => e.getFloat32(t, s))
                        : Vk(!1);
                break;
            case 8:
                "float" === r ? (this.readInputValue = (e, t) => e.getFloat64(t, s)) : Vk(!1);
                break;
            default:
                yT(i), Vk(!1);
        }
        switch (i) {
            case 1:
                "ulaw" === r || "alaw" === r
                    ? ((this.outputSampleSize = 2),
                      (this.outputFormat = "s16"),
                      (this.writeOutputValue = (e, t, n) => e.setInt16(t, n, !0)))
                    : ((this.outputSampleSize = 1),
                      (this.outputFormat = "u8"),
                      (this.writeOutputValue = (e, t, n) => e.setUint8(t, n + 128)));
                break;
            case 2:
                (this.outputSampleSize = 2),
                    (this.outputFormat = "s16"),
                    (this.writeOutputValue = (e, t, n) => e.setInt16(t, n, !0));
                break;
            case 3:
                (this.outputSampleSize = 4),
                    (this.outputFormat = "s32"),
                    (this.writeOutputValue = (e, t, n) => e.setInt32(t, n << 8, !0));
                break;
            case 4:
                (this.outputSampleSize = 4),
                    "float" === r
                        ? ((this.outputFormat = "f32"), (this.writeOutputValue = (e, t, n) => e.setFloat32(t, n, !0)))
                        : ((this.outputFormat = "s32"), (this.writeOutputValue = (e, t, n) => e.setInt32(t, n, !0)));
                break;
            case 8:
                (this.outputSampleSize = 4),
                    (this.outputFormat = "f32"),
                    (this.writeOutputValue = (e, t, n) => e.setFloat32(t, n, !0));
                break;
            default:
                yT(i), Vk(!1);
        }
    }
    getDecodeQueueSize() {
        return 0;
    }
    decode(e) {
        const t = Yk(e.data),
            n = e.byteLength / this.decoderConfig.numberOfChannels / this.inputSampleSize,
            r = n * this.decoderConfig.numberOfChannels * this.outputSampleSize,
            i = new ArrayBuffer(r),
            s = new DataView(i);
        for (let l = 0; l < n * this.decoderConfig.numberOfChannels; l++) {
            const e = l * this.inputSampleSize,
                n = l * this.outputSampleSize,
                r = this.readInputValue(t, e);
            this.writeOutputValue(s, n, r);
        }
        const a = n / this.decoderConfig.sampleRate;
        (null === this.currentTimestamp || Math.abs(e.timestamp - this.currentTimestamp) >= a) &&
            (this.currentTimestamp = e.timestamp);
        const o = this.currentTimestamp;
        this.currentTimestamp += a;
        const c = new fv({
            format: this.outputFormat,
            data: i,
            numberOfChannels: this.decoderConfig.numberOfChannels,
            sampleRate: this.decoderConfig.sampleRate,
            numberOfFrames: n,
            timestamp: o,
        });
        this.onSample(c);
    }
    async flush() {}
    close() {}
}
class Mv extends Cv {
    constructor(e) {
        if (!(e instanceof Bv)) throw new TypeError("audioTrack must be an InputAudioTrack.");
        super(), (this._track = e);
    }
    async _createDecoder(e, t) {
        if (!(await this._track.canDecode()))
            throw new Error(
                "This audio track cannot be decoded by this browser. Make sure to check decodability before using a track."
            );
        const n = this._track.codec,
            r = await this._track.getDecoderConfig();
        return Vk(n && r), KT.includes(r.codec) ? new Rv(e, t, r) : new Nv(e, t, n, r);
    }
    _createPacketSink() {
        return new Sv(this._track);
    }
    async getSample(e) {
        _v(e);
        for await (const t of this.mediaSamplesAtTimestamps([e])) return t;
        throw new Error("Internal error: Iterator returned nothing.");
    }
    samples(e = 0, t = 1 / 0) {
        return this.mediaSamplesInRange(e, t);
    }
    samplesAtTimestamps(e) {
        return this.mediaSamplesAtTimestamps(e);
    }
}
class Dv {
    constructor(e) {
        if (!(e instanceof Bv)) throw new TypeError("audioTrack must be an InputAudioTrack.");
        this._audioSampleSink = new Mv(e);
    }
    _audioSampleToWrappedArrayBuffer(e) {
        return { buffer: e.toAudioBuffer(), timestamp: e.timestamp, duration: e.duration };
    }
    async getBuffer(e) {
        _v(e);
        const t = await this._audioSampleSink.getSample(e);
        return t && this._audioSampleToWrappedArrayBuffer(t);
    }
    buffers(e = 0, t = 1 / 0) {
        return TT(this._audioSampleSink.samples(e, t), (e) => this._audioSampleToWrappedArrayBuffer(e));
    }
    buffersAtTimestamps(e) {
        return TT(this._audioSampleSink.samplesAtTimestamps(e), (e) => e && this._audioSampleToWrappedArrayBuffer(e));
    }
}
class Fv {
    constructor(e, t) {
        (this.input = e), (this._backing = t);
    }
    isVideoTrack() {
        return this instanceof Lv;
    }
    isAudioTrack() {
        return this instanceof Bv;
    }
    get id() {
        return this._backing.getId();
    }
    get internalCodecId() {
        return this._backing.getInternalCodecId();
    }
    get languageCode() {
        return this._backing.getLanguageCode();
    }
    get name() {
        return this._backing.getName();
    }
    get timeResolution() {
        return this._backing.getTimeResolution();
    }
    getFirstTimestamp() {
        return this._backing.getFirstTimestamp();
    }
    computeDuration() {
        return this._backing.computeDuration();
    }
    async computePacketStats(e = 1 / 0) {
        const t = new Sv(this);
        let n = 1 / 0,
            r = -1 / 0,
            i = 0,
            s = 0;
        for await (const a of t.packets(void 0, void 0, { metadataOnly: !0 })) {
            if (i >= e && a.timestamp >= r) break;
            (n = Math.min(n, a.timestamp)), (r = Math.max(r, a.timestamp + a.duration)), i++, (s += a.byteLength);
        }
        return {
            packetCount: i,
            averagePacketRate: i ? Number((i / (r - n)).toPrecision(16)) : 0,
            averageBitrate: i ? Number(((8 * s) / (r - n)).toPrecision(16)) : 0,
        };
    }
}
class Lv extends Fv {
    constructor(e, t) {
        super(e, t), (this._backing = t);
    }
    get type() {
        return "video";
    }
    get codec() {
        return this._backing.getCodec();
    }
    get codedWidth() {
        return this._backing.getCodedWidth();
    }
    get codedHeight() {
        return this._backing.getCodedHeight();
    }
    get rotation() {
        return this._backing.getRotation();
    }
    get displayWidth() {
        return this._backing.getRotation() % 180 == 0 ? this._backing.getCodedWidth() : this._backing.getCodedHeight();
    }
    get displayHeight() {
        return this._backing.getRotation() % 180 == 0 ? this._backing.getCodedHeight() : this._backing.getCodedWidth();
    }
    getColorSpace() {
        return this._backing.getColorSpace();
    }
    async hasHighDynamicRange() {
        const e = await this._backing.getColorSpace();
        return (
            "bt2020" === e.primaries ||
            "smpte432" === e.primaries ||
            "pg" === e.transfer ||
            "hlg" === e.transfer ||
            "bt2020-ncl" === e.matrix
        );
    }
    canBeTransparent() {
        return this._backing.canBeTransparent();
    }
    getDecoderConfig() {
        return this._backing.getDecoderConfig();
    }
    async getCodecParameterString() {
        const e = await this._backing.getDecoderConfig();
        return e?.codec ?? null;
    }
    async canDecode() {
        try {
            const e = await this._backing.getDecoderConfig();
            if (!e) return !1;
            const t = this._backing.getCodec();
            if ((Vk(null !== t), iv.some((n) => n.supports(t, e)))) return !0;
            if ("undefined" == typeof VideoDecoder) return !1;
            return !0 === (await VideoDecoder.isConfigSupported(e)).supported;
        } catch (e) {
            return !1;
        }
    }
    async determinePacketType(e) {
        if (!(e instanceof lv)) throw new TypeError("packet must be an EncodedPacket.");
        if (e.isMetadataOnly) throw new TypeError("packet must not be metadata-only to determine its type.");
        if (null === this.codec) return null;
        const t = await this.getDecoderConfig();
        return Vk(t), Z_(this.codec, t, e.data);
    }
}
class Bv extends Fv {
    constructor(e, t) {
        super(e, t), (this._backing = t);
    }
    get type() {
        return "audio";
    }
    get codec() {
        return this._backing.getCodec();
    }
    get numberOfChannels() {
        return this._backing.getNumberOfChannels();
    }
    get sampleRate() {
        return this._backing.getSampleRate();
    }
    getDecoderConfig() {
        return this._backing.getDecoderConfig();
    }
    async getCodecParameterString() {
        const e = await this._backing.getDecoderConfig();
        return e?.codec ?? null;
    }
    async canDecode() {
        try {
            const e = await this._backing.getDecoderConfig();
            if (!e) return !1;
            const t = this._backing.getCodec();
            if ((Vk(null !== t), sv.some((n) => n.supports(t, e)))) return !0;
            if (e.codec.startsWith("pcm-")) return !0;
            if ("undefined" == typeof AudioDecoder) return !1;
            return !0 === (await AudioDecoder.isConfigSupported(e)).supported;
        } catch (e) {
            return !1;
        }
    }
    async determinePacketType(e) {
        if (!(e instanceof lv)) throw new TypeError("packet must be an EncodedPacket.");
        return null === this.codec ? null : "key";
    }
}
const zv = (e) => {
        let t =
            (e.hasVideo ? "video/" : e.hasAudio ? "audio/" : "application/") + (e.isQuickTime ? "quicktime" : "mp4");
        if (e.codecStrings.length > 0) {
            t += `; codecs="${[...new Set(e.codecStrings)].join(", ")}"`;
        }
        return t;
    },
    Uv = 16,
    $v = (e) => {
        let t = lC(e);
        const n = yC(e, 4);
        let r = 8;
        1 === t && ((t = mC(e)), (r = 16));
        const i = t - r;
        return i < 0 ? null : { name: n, totalSize: t, headerSize: r, contentSize: i };
    },
    Vv = (e) => dC(e) / 65536,
    Wv = (e) => dC(e) / 1073741824,
    jv = (e) => {
        let t = 0;
        for (let n = 0; n < 4; n++) {
            t <<= 7;
            const n = rC(e);
            if (((t |= 127 & n), !(128 & n))) break;
        }
        return t;
    },
    Hv = (e) => {
        let t = sC(e);
        return e.skip(2), (t = Math.min(t, e.remainingLength)), Qk.decode(nC(e, t));
    },
    qv = (e) => {
        const t = $v(e);
        if (!t || "data" !== t.name) return null;
        const n = lC(e);
        e.skip(4);
        const r = nC(e, t.contentSize - 8);
        switch (n) {
            case 1:
                return Qk.decode(r);
            case 2:
                return new TextDecoder("utf-16be").decode(r);
            case 13:
                return new HT(r, "image/jpeg");
            case 14:
                return new HT(r, "image/png");
            case 27:
                return new HT(r, "image/bmp");
            default:
                return r;
        }
    };
class Xv extends rv {
    constructor(e) {
        super(e),
            (this.moovSlice = null),
            (this.currentTrack = null),
            (this.tracks = []),
            (this.metadataPromise = null),
            (this.movieTimescale = -1),
            (this.movieDurationInTimescale = -1),
            (this.isQuickTime = !1),
            (this.metadataTags = {}),
            (this.currentMetadataKeys = null),
            (this.isFragmented = !1),
            (this.fragmentTrackDefaults = []),
            (this.currentFragment = null),
            (this.lastReadFragment = null),
            (this.reader = e._reader);
    }
    async computeDuration() {
        const e = await this.getTracks(),
            t = await Promise.all(e.map((e) => e.computeDuration()));
        return Math.max(0, ...t);
    }
    async getTracks() {
        return await this.readMetadata(), this.tracks.map((e) => e.inputTrack);
    }
    async getMimeType() {
        await this.readMetadata();
        const e = await Promise.all(this.tracks.map((e) => e.inputTrack.getCodecParameterString()));
        return zv({
            isQuickTime: this.isQuickTime,
            hasVideo: this.tracks.some((e) => "video" === e.info?.type),
            hasAudio: this.tracks.some((e) => "audio" === e.info?.type),
            codecStrings: e.filter(Boolean),
        });
    }
    async getMetadataTags() {
        return await this.readMetadata(), this.metadataTags;
    }
    readMetadata() {
        return (this.metadataPromise ??= (async () => {
            let e = 0;
            for (;;) {
                let t = this.reader.requestSliceRange(e, 8, Uv);
                if ((t instanceof Promise && (t = await t), !t)) break;
                const n = e,
                    r = $v(t);
                if (!r) break;
                if ("ftyp" === r.name) {
                    const e = yC(t, 4);
                    this.isQuickTime = "qt  " === e;
                } else if ("moov" === r.name) {
                    let e = this.reader.requestSlice(t.filePos, r.contentSize);
                    if ((e instanceof Promise && (e = await e), !e)) break;
                    (this.moovSlice = e), this.readContiguousBoxes(this.moovSlice);
                    for (const t of this.tracks) {
                        const e = t.editListPreviousSegmentDurations / this.movieTimescale;
                        t.editListOffset -= Math.round(e * t.timescale);
                    }
                    break;
                }
                e = n + r.totalSize;
            }
            if (this.isFragmented && null !== this.reader.fileSize) {
                let e = this.reader.requestSlice(this.reader.fileSize - 4, 4);
                e instanceof Promise && (e = await e), Vk(e);
                const t = lC(e),
                    n = this.reader.fileSize - t;
                if (n >= 0 && n <= this.reader.fileSize - Uv) {
                    let e = this.reader.requestSliceRange(n, 8, Uv);
                    if ((e instanceof Promise && (e = await e), e)) {
                        const t = $v(e);
                        if (t && "mfra" === t.name) {
                            let n = this.reader.requestSlice(e.filePos, t.contentSize);
                            n instanceof Promise && (n = await n), n && this.readContiguousBoxes(n);
                        }
                    }
                }
            }
        })());
    }
    getSampleTableForTrack(e) {
        if (e.sampleTable) return e.sampleTable;
        const t = {
            sampleTimingEntries: [],
            sampleCompositionTimeOffsets: [],
            sampleSizes: [],
            keySampleIndices: null,
            chunkOffsets: [],
            sampleToChunk: [],
            presentationTimestamps: null,
            presentationTimestampIndexMap: null,
        };
        (e.sampleTable = t), Vk(this.moovSlice);
        const n = this.moovSlice.slice(e.sampleTableByteOffset);
        (this.currentTrack = e), this.traverseBox(n), (this.currentTrack = null);
        if (
            "audio" === e.info?.type &&
            e.info.codec &&
            KT.includes(e.info.codec) &&
            0 === t.sampleCompositionTimeOffsets.length
        ) {
            Vk("audio" === e.info?.type);
            const n = g_(e.info.codec),
                r = [],
                i = [];
            for (let s = 0; s < t.sampleToChunk.length; s++) {
                const a = t.sampleToChunk[s],
                    o = t.sampleToChunk[s + 1],
                    c = (o ? o.startChunkIndex : t.chunkOffsets.length) - a.startChunkIndex;
                for (let s = 0; s < c; s++) {
                    const o = a.startSampleIndex + s * a.samplesPerChunk,
                        c = o + a.samplesPerChunk,
                        l = mT(t.sampleTimingEntries, o, (e) => e.startIndex),
                        u = t.sampleTimingEntries[l],
                        d = mT(t.sampleTimingEntries, c, (e) => e.startIndex),
                        h = t.sampleTimingEntries[d],
                        m = u.startDecodeTimestamp + (o - u.startIndex) * u.delta,
                        p = h.startDecodeTimestamp + (c - h.startIndex) * h.delta - m,
                        f = jk(r);
                    f && f.delta === p
                        ? f.count++
                        : r.push({ startIndex: a.startChunkIndex + s, startDecodeTimestamp: m, count: 1, delta: p });
                    const g = a.samplesPerChunk * n.sampleSize * e.info.numberOfChannels;
                    i.push(g);
                }
                (a.startSampleIndex = a.startChunkIndex), (a.samplesPerChunk = 1);
            }
            (t.sampleTimingEntries = r), (t.sampleSizes = i);
        }
        if (t.sampleCompositionTimeOffsets.length > 0) {
            t.presentationTimestamps = [];
            for (const e of t.sampleTimingEntries)
                for (let n = 0; n < e.count; n++)
                    t.presentationTimestamps.push({
                        presentationTimestamp: e.startDecodeTimestamp + n * e.delta,
                        sampleIndex: e.startIndex + n,
                    });
            for (const e of t.sampleCompositionTimeOffsets)
                for (let n = 0; n < e.count; n++) {
                    const r = e.startIndex + n,
                        i = t.presentationTimestamps[r];
                    i && (i.presentationTimestamp += e.offset);
                }
            t.presentationTimestamps.sort((e, t) => e.presentationTimestamp - t.presentationTimestamp),
                (t.presentationTimestampIndexMap = Array(t.presentationTimestamps.length).fill(-1));
            for (let e = 0; e < t.presentationTimestamps.length; e++)
                t.presentationTimestampIndexMap[t.presentationTimestamps[e].sampleIndex] = e;
        }
        return t;
    }
    async readFragment(e) {
        if (this.lastReadFragment?.moofOffset === e) return this.lastReadFragment;
        let t = this.reader.requestSliceRange(e, 8, Uv);
        t instanceof Promise && (t = await t), Vk(t);
        const n = $v(t);
        Vk("moof" === n?.name);
        let r = this.reader.requestSlice(e, n.totalSize);
        r instanceof Promise && (r = await r), Vk(r), this.traverseBox(r);
        const i = this.lastReadFragment;
        Vk(i && i.moofOffset === e);
        for (const [, s] of i.trackData) {
            const e = s.track,
                { fragmentPositionCache: t } = e;
            if (!s.startTimestampIsFinal) {
                const n = e.fragmentLookupTable.find((e) => e.moofOffset === i.moofOffset);
                if (n) tS(s, n.timestamp);
                else {
                    const e = mT(t, i.moofOffset - 1, (e) => e.moofOffset);
                    if (-1 !== e) {
                        const n = t[e];
                        tS(s, n.endTimestamp);
                    }
                }
                s.startTimestampIsFinal = !0;
            }
            const n = mT(t, s.startTimestamp, (e) => e.startTimestamp);
            (-1 !== n && t[n].moofOffset === i.moofOffset) ||
                t.splice(n + 1, 0, {
                    moofOffset: i.moofOffset,
                    startTimestamp: s.startTimestamp,
                    endTimestamp: s.endTimestamp,
                });
        }
        return i;
    }
    readContiguousBoxes(e) {
        const t = e.filePos;
        for (; e.filePos - t <= e.length - 8; ) {
            if (!this.traverseBox(e)) break;
        }
    }
    *iterateContiguousBoxes(e) {
        const t = e.filePos;
        for (; e.filePos - t <= e.length - 8; ) {
            const t = e.filePos,
                n = $v(e);
            if (!n) break;
            yield { boxInfo: n, slice: e }, (e.filePos = t + n.totalSize);
        }
    }
    traverseBox(e) {
        const t = e.filePos,
            n = $v(e);
        if (!n) return !1;
        const r = e.filePos,
            i = t + n.totalSize;
        switch (n.name) {
            case "mdia":
            case "minf":
            case "dinf":
            case "mfra":
            case "edts":
            case "wave":
                this.readContiguousBoxes(e.slice(r, n.contentSize));
                break;
            case "mvhd":
                {
                    const t = rC(e);
                    e.skip(3),
                        1 === t
                            ? (e.skip(16), (this.movieTimescale = lC(e)), (this.movieDurationInTimescale = mC(e)))
                            : (e.skip(8), (this.movieTimescale = lC(e)), (this.movieDurationInTimescale = lC(e)));
                }
                break;
            case "trak":
                {
                    const t = {
                        id: -1,
                        demuxer: this,
                        inputTrack: null,
                        info: null,
                        timescale: -1,
                        durationInMovieTimescale: -1,
                        durationInMediaTimescale: -1,
                        rotation: 0,
                        internalCodecId: null,
                        name: null,
                        languageCode: vT,
                        sampleTableByteOffset: -1,
                        sampleTable: null,
                        fragmentLookupTable: [],
                        currentFragmentState: null,
                        fragmentPositionCache: [],
                        editListPreviousSegmentDurations: 0,
                        editListOffset: 0,
                    };
                    if (
                        ((this.currentTrack = t),
                        this.readContiguousBoxes(e.slice(r, n.contentSize)),
                        -1 !== t.id && -1 !== t.timescale && null !== t.info)
                    )
                        if ("video" === t.info.type && -1 !== t.info.width) {
                            const e = t;
                            (t.inputTrack = new Lv(this.input, new Kv(e))), this.tracks.push(t);
                        } else if ("audio" === t.info.type && -1 !== t.info.numberOfChannels) {
                            const e = t;
                            (t.inputTrack = new Bv(this.input, new Yv(e))), this.tracks.push(t);
                        }
                    this.currentTrack = null;
                }
                break;
            case "tkhd":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    const n = rC(e);
                    if (!!!(1 & aC(e))) break;
                    if (0 === n) e.skip(8), (t.id = lC(e)), e.skip(4), (t.durationInMovieTimescale = lC(e));
                    else {
                        if (1 !== n) throw new Error(`Incorrect track header version ${n}.`);
                        e.skip(16), (t.id = lC(e)), e.skip(4), (t.durationInMovieTimescale = mC(e));
                    }
                    e.skip(16);
                    const r = [Vv(e), Vv(e), Wv(e), Vv(e), Vv(e), Wv(e), Vv(e), Vv(e), Wv(e)],
                        i = Wk(ET(nS(r), 90));
                    Vk(0 === i || 90 === i || 180 === i || 270 === i), (t.rotation = i);
                }
                break;
            case "elst":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    const n = rC(e);
                    e.skip(3);
                    let r = !1,
                        i = 0;
                    const s = lC(e);
                    for (let a = 0; a < s; a++) {
                        const s = 1 === n ? mC(e) : lC(e),
                            a = 1 === n ? pC(e) : dC(e),
                            o = Vv(e);
                        if (0 !== s) {
                            if (r) break;
                            if (-1 !== a) {
                                if (1 !== o) break;
                                (t.editListPreviousSegmentDurations = i), (t.editListOffset = a), (r = !0);
                            } else i += s;
                        }
                    }
                }
                break;
            case "mdhd":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    const n = rC(e);
                    e.skip(3),
                        0 === n
                            ? (e.skip(8), (t.timescale = lC(e)), (t.durationInMediaTimescale = lC(e)))
                            : 1 === n && (e.skip(16), (t.timescale = lC(e)), (t.durationInMediaTimescale = mC(e)));
                    let r = sC(e);
                    if (r > 0) {
                        t.languageCode = "";
                        for (let e = 0; e < 3; e++)
                            (t.languageCode = String.fromCharCode(96 + (31 & r)) + t.languageCode), (r >>= 5);
                        IT(t.languageCode) || (t.languageCode = vT);
                    }
                }
                break;
            case "hdlr":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    e.skip(8);
                    const n = yC(e, 4);
                    "vide" === n
                        ? (t.info = {
                              type: "video",
                              width: -1,
                              height: -1,
                              codec: null,
                              codecDescription: null,
                              colorSpace: null,
                              avcCodecInfo: null,
                              hevcCodecInfo: null,
                              vp9CodecInfo: null,
                              av1CodecInfo: null,
                          })
                        : "soun" === n &&
                          (t.info = {
                              type: "audio",
                              numberOfChannels: -1,
                              sampleRate: -1,
                              codec: null,
                              codecDescription: null,
                              aacCodecInfo: null,
                          });
                }
                break;
            case "stbl":
                {
                    const i = this.currentTrack;
                    if (!i) break;
                    (i.sampleTableByteOffset = t), this.readContiguousBoxes(e.slice(r, n.contentSize));
                }
                break;
            case "stsd":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    if (null === t.info || t.sampleTable) break;
                    const n = rC(e);
                    e.skip(3);
                    const r = lC(e);
                    for (let i = 0; i < r; i++) {
                        const r = e.filePos,
                            i = $v(e);
                        if (!i) break;
                        t.internalCodecId = i.name;
                        const s = i.name.toLowerCase();
                        if ("video" === t.info.type)
                            "avc1" === s
                                ? (t.info.codec = "avc")
                                : "hvc1" === s || "hev1" === s
                                  ? (t.info.codec = "hevc")
                                  : "vp08" === s
                                    ? (t.info.codec = "vp8")
                                    : "vp09" === s
                                      ? (t.info.codec = "vp9")
                                      : "av01" === s && (t.info.codec = "av1"),
                                e.skip(24),
                                (t.info.width = sC(e)),
                                (t.info.height = sC(e)),
                                e.skip(50),
                                this.readContiguousBoxes(e.slice(e.filePos, r + i.totalSize - e.filePos));
                        else {
                            "mp4a" === s ||
                                ("opus" === s
                                    ? (t.info.codec = "opus")
                                    : "flac" === s
                                      ? (t.info.codec = "flac")
                                      : "twos" === s ||
                                        "sowt" === s ||
                                        "raw " === s ||
                                        "in24" === s ||
                                        "in32" === s ||
                                        "fl32" === s ||
                                        "fl64" === s ||
                                        "lpcm" === s ||
                                        "ipcm" === s ||
                                        "fpcm" === s ||
                                        ("ulaw" === s
                                            ? (t.info.codec = "ulaw")
                                            : "alaw" === s && (t.info.codec = "alaw"))),
                                e.skip(8);
                            const a = sC(e);
                            e.skip(6);
                            let o = sC(e),
                                c = sC(e);
                            e.skip(4);
                            let l = lC(e) / 65536;
                            if (0 === n && a > 0)
                                if (1 === a) e.skip(4), (c = 8 * lC(e)), e.skip(8);
                                else if (2 === a) {
                                    e.skip(4), (l = bC(e)), (o = lC(e)), e.skip(4), (c = lC(e));
                                    const n = lC(e);
                                    if ((e.skip(8), "lpcm" === s)) {
                                        const e = (c + 7) >> 3,
                                            r = Boolean(1 & n),
                                            i = Boolean(2 & n),
                                            s = 4 & n ? -1 : 0;
                                        c > 0 &&
                                            c <= 64 &&
                                            (r
                                                ? 32 === c && (t.info.codec = i ? "pcm-f32be" : "pcm-f32")
                                                : s & (1 << (e - 1))
                                                  ? 1 === e
                                                      ? (t.info.codec = "pcm-s8")
                                                      : 2 === e
                                                        ? (t.info.codec = i ? "pcm-s16be" : "pcm-s16")
                                                        : 3 === e
                                                          ? (t.info.codec = i ? "pcm-s24be" : "pcm-s24")
                                                          : 4 === e && (t.info.codec = i ? "pcm-s32be" : "pcm-s32")
                                                  : 1 === e && (t.info.codec = "pcm-u8")),
                                            t.info.codec;
                                    }
                                }
                            "opus" === t.info.codec && (l = p_),
                                (t.info.numberOfChannels = o),
                                (t.info.sampleRate = l),
                                "twos" === s
                                    ? (t.info.codec = 8 === c ? "pcm-s8" : 16 === c ? "pcm-s16be" : null)
                                    : "sowt" === s
                                      ? (t.info.codec = 8 === c ? "pcm-s8" : 16 === c ? "pcm-s16" : null)
                                      : "raw " === s
                                        ? (t.info.codec = "pcm-u8")
                                        : "in24" === s
                                          ? (t.info.codec = "pcm-s24be")
                                          : "in32" === s
                                            ? (t.info.codec = "pcm-s32be")
                                            : "fl32" === s
                                              ? (t.info.codec = "pcm-f32be")
                                              : "fl64" === s
                                                ? (t.info.codec = "pcm-f64be")
                                                : "ipcm" === s
                                                  ? (t.info.codec = "pcm-s16be")
                                                  : "fpcm" === s && (t.info.codec = "pcm-f32be"),
                                this.readContiguousBoxes(e.slice(e.filePos, r + i.totalSize - e.filePos));
                        }
                    }
                }
                break;
            case "avcC":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    Vk(t.info), (t.info.codecDescription = nC(e, n.contentSize));
                }
                break;
            case "hvcC":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    Vk(t.info), (t.info.codecDescription = nC(e, n.contentSize));
                }
                break;
            case "vpcC":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    Vk("video" === t.info?.type), e.skip(4);
                    const n = rC(e),
                        r = rC(e),
                        i = rC(e),
                        s = i >> 4,
                        a = (i >> 1) & 7,
                        o = 1 & i,
                        c = rC(e),
                        l = rC(e),
                        u = rC(e);
                    t.info.vp9CodecInfo = {
                        profile: n,
                        level: r,
                        bitDepth: s,
                        chromaSubsampling: a,
                        videoFullRangeFlag: o,
                        colourPrimaries: c,
                        transferCharacteristics: l,
                        matrixCoefficients: u,
                    };
                }
                break;
            case "av1C":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    Vk("video" === t.info?.type), e.skip(1);
                    const n = rC(e),
                        r = n >> 5,
                        i = 31 & n,
                        s = rC(e),
                        a = s >> 7,
                        o = (s >> 6) & 1,
                        c = (s >> 4) & 1,
                        l = (s >> 3) & 1,
                        u = (s >> 2) & 1,
                        d = 3 & s,
                        h = 2 === r && o ? ((s >> 5) & 1 ? 12 : 10) : o ? 10 : 8;
                    t.info.av1CodecInfo = {
                        profile: r,
                        level: i,
                        tier: a,
                        bitDepth: h,
                        monochrome: c,
                        chromaSubsamplingX: l,
                        chromaSubsamplingY: u,
                        chromaSamplePosition: d,
                    };
                }
                break;
            case "colr":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    Vk("video" === t.info?.type);
                    if ("nclx" !== yC(e, 4)) break;
                    const n = sC(e),
                        r = sC(e),
                        i = sC(e),
                        s = Boolean(128 & rC(e));
                    t.info.colorSpace = { primaries: nT[n], transfer: iT[r], matrix: aT[i], fullRange: s };
                }
                break;
            case "esds":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    Vk("audio" === t.info?.type), e.skip(4);
                    Vk(3 === rC(e)), jv(e), e.skip(2);
                    const n = rC(e),
                        r = !!(64 & n),
                        i = !!(32 & n);
                    if ((!!(128 & n) && e.skip(2), r)) {
                        const t = rC(e);
                        e.skip(t);
                    }
                    i && e.skip(2);
                    Vk(4 === rC(e));
                    const s = jv(e),
                        a = e.filePos,
                        o = rC(e);
                    if (
                        (64 === o || 103 === o
                            ? ((t.info.codec = "aac"), (t.info.aacCodecInfo = { isMpeg2: 103 === o }))
                            : 105 === o || 107 === o
                              ? (t.info.codec = "mp3")
                              : 221 === o && (t.info.codec = "vorbis"),
                        e.skip(12),
                        s > e.filePos - a)
                    ) {
                        Vk(5 === rC(e));
                        const n = jv(e);
                        if (((t.info.codecDescription = nC(e, n)), "aac" === t.info.codec)) {
                            const e = m_(t.info.codecDescription);
                            null !== e.numberOfChannels && (t.info.numberOfChannels = e.numberOfChannels),
                                null !== e.sampleRate && (t.info.sampleRate = e.sampleRate);
                        }
                    }
                }
                break;
            case "enda":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    Vk("audio" === t.info?.type);
                    255 & sC(e) &&
                        ("pcm-s16be" === t.info.codec
                            ? (t.info.codec = "pcm-s16")
                            : "pcm-s24be" === t.info.codec
                              ? (t.info.codec = "pcm-s24")
                              : "pcm-s32be" === t.info.codec
                                ? (t.info.codec = "pcm-s32")
                                : "pcm-f32be" === t.info.codec
                                  ? (t.info.codec = "pcm-f32")
                                  : "pcm-f64be" === t.info.codec && (t.info.codec = "pcm-f64"));
                }
                break;
            case "pcmC": {
                const t = this.currentTrack;
                if (!t) break;
                Vk("audio" === t.info?.type), e.skip(4);
                const n = rC(e),
                    r = Boolean(1 & n),
                    i = rC(e);
                "pcm-s16be" === t.info.codec
                    ? (t.info.codec = r
                          ? 16 === i
                              ? "pcm-s16"
                              : 24 === i
                                ? "pcm-s24"
                                : 32 === i
                                  ? "pcm-s32"
                                  : null
                          : 16 === i
                            ? "pcm-s16be"
                            : 24 === i
                              ? "pcm-s24be"
                              : 32 === i
                                ? "pcm-s32be"
                                : null)
                    : "pcm-f32be" === t.info.codec &&
                      (t.info.codec = r
                          ? 32 === i
                              ? "pcm-f32"
                              : 64 === i
                                ? "pcm-f64"
                                : null
                          : 32 === i
                            ? "pcm-f32be"
                            : 64 === i
                              ? "pcm-f64be"
                              : null);
                break;
            }
            case "dOps":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    Vk("audio" === t.info?.type), e.skip(1);
                    const n = rC(e),
                        r = sC(e),
                        i = lC(e),
                        s = oC(e),
                        a = rC(e);
                    let o;
                    o = 0 !== a ? nC(e, 2 + n) : new Uint8Array(0);
                    const c = new Uint8Array(19 + o.byteLength),
                        l = new DataView(c.buffer);
                    l.setUint32(0, 1332770163, !1),
                        l.setUint32(4, 1214603620, !1),
                        l.setUint8(8, 1),
                        l.setUint8(9, n),
                        l.setUint16(10, r, !0),
                        l.setUint32(12, i, !0),
                        l.setInt16(16, s, !0),
                        l.setUint8(18, a),
                        c.set(o, 19),
                        (t.info.codecDescription = c),
                        (t.info.numberOfChannels = n);
                }
                break;
            case "dfLa":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    Vk("audio" === t.info?.type), e.skip(4);
                    const n = 127,
                        r = 128,
                        s = e.filePos;
                    for (; e.filePos < i; ) {
                        const i = rC(e),
                            s = aC(e);
                        if ((i & n) === ev.STREAMINFO) {
                            e.skip(10);
                            const n = lC(e),
                                r = n >>> 12,
                                i = 1 + ((n >> 9) & 7);
                            (t.info.sampleRate = r), (t.info.numberOfChannels = i), e.skip(20);
                        } else e.skip(s);
                        if (i & r) break;
                    }
                    const a = e.filePos;
                    e.filePos = s;
                    const o = nC(e, a - s),
                        c = new Uint8Array(4 + o.byteLength);
                    new DataView(c.buffer).setUint32(0, 1716281667, !1), c.set(o, 4), (t.info.codecDescription = c);
                }
                break;
            case "stts":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    if (!t.sampleTable) break;
                    e.skip(4);
                    const n = lC(e);
                    let r = 0,
                        i = 0;
                    for (let s = 0; s < n; s++) {
                        const n = lC(e),
                            s = lC(e);
                        t.sampleTable.sampleTimingEntries.push({
                            startIndex: r,
                            startDecodeTimestamp: i,
                            count: n,
                            delta: s,
                        }),
                            (r += n),
                            (i += n * s);
                    }
                }
                break;
            case "ctts":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    if (!t.sampleTable) break;
                    e.skip(4);
                    const n = lC(e);
                    let r = 0;
                    for (let i = 0; i < n; i++) {
                        const n = lC(e),
                            i = dC(e);
                        t.sampleTable.sampleCompositionTimeOffsets.push({ startIndex: r, count: n, offset: i }),
                            (r += n);
                    }
                }
                break;
            case "stsz":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    if (!t.sampleTable) break;
                    e.skip(4);
                    const n = lC(e),
                        r = lC(e);
                    if (0 === n)
                        for (let i = 0; i < r; i++) {
                            const n = lC(e);
                            t.sampleTable.sampleSizes.push(n);
                        }
                    else t.sampleTable.sampleSizes.push(n);
                }
                break;
            case "stz2":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    if (!t.sampleTable) break;
                    e.skip(4), e.skip(3);
                    const n = rC(e),
                        r = lC(e),
                        i = nC(e, Math.ceil((r * n) / 8)),
                        s = new qk(i);
                    for (let e = 0; e < r; e++) {
                        const e = s.readBits(n);
                        t.sampleTable.sampleSizes.push(e);
                    }
                }
                break;
            case "stss":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    if (!t.sampleTable) break;
                    e.skip(4), (t.sampleTable.keySampleIndices = []);
                    const n = lC(e);
                    for (let r = 0; r < n; r++) {
                        const n = lC(e) - 1;
                        t.sampleTable.keySampleIndices.push(n);
                    }
                    0 !== t.sampleTable.keySampleIndices[0] && t.sampleTable.keySampleIndices.unshift(0);
                }
                break;
            case "stsc":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    if (!t.sampleTable) break;
                    e.skip(4);
                    const n = lC(e);
                    for (let i = 0; i < n; i++) {
                        const n = lC(e) - 1,
                            r = lC(e),
                            i = lC(e);
                        t.sampleTable.sampleToChunk.push({
                            startSampleIndex: -1,
                            startChunkIndex: n,
                            samplesPerChunk: r,
                            sampleDescriptionIndex: i,
                        });
                    }
                    let r = 0;
                    for (let e = 0; e < t.sampleTable.sampleToChunk.length; e++)
                        if (
                            ((t.sampleTable.sampleToChunk[e].startSampleIndex = r),
                            e < t.sampleTable.sampleToChunk.length - 1)
                        ) {
                            r +=
                                (t.sampleTable.sampleToChunk[e + 1].startChunkIndex -
                                    t.sampleTable.sampleToChunk[e].startChunkIndex) *
                                t.sampleTable.sampleToChunk[e].samplesPerChunk;
                        }
                }
                break;
            case "stco":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    if (!t.sampleTable) break;
                    e.skip(4);
                    const n = lC(e);
                    for (let r = 0; r < n; r++) {
                        const n = lC(e);
                        t.sampleTable.chunkOffsets.push(n);
                    }
                }
                break;
            case "co64":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    if (!t.sampleTable) break;
                    e.skip(4);
                    const n = lC(e);
                    for (let r = 0; r < n; r++) {
                        const n = mC(e);
                        t.sampleTable.chunkOffsets.push(n);
                    }
                }
                break;
            case "mvex":
                (this.isFragmented = !0), this.readContiguousBoxes(e.slice(r, n.contentSize));
                break;
            case "mehd":
                {
                    const t = rC(e);
                    e.skip(3);
                    const n = 1 === t ? mC(e) : lC(e);
                    this.movieDurationInTimescale = n;
                }
                break;
            case "trex":
                {
                    e.skip(4);
                    const t = lC(e),
                        n = lC(e),
                        r = lC(e),
                        i = lC(e),
                        s = lC(e);
                    this.fragmentTrackDefaults.push({
                        trackId: t,
                        defaultSampleDescriptionIndex: n,
                        defaultSampleDuration: r,
                        defaultSampleSize: i,
                        defaultSampleFlags: s,
                    });
                }
                break;
            case "tfra":
                {
                    const t = rC(e);
                    e.skip(3);
                    const n = lC(e),
                        r = this.tracks.find((e) => e.id === n);
                    if (!r) break;
                    const i = lC(e),
                        s = (12 & i) >> 2,
                        a = 3 & i,
                        o = [rC, sC, aC, lC],
                        c = o[(48 & i) >> 4],
                        l = o[s],
                        u = o[a],
                        d = lC(e);
                    for (let h = 0; h < d; h++) {
                        const n = 1 === t ? mC(e) : lC(e),
                            i = 1 === t ? mC(e) : lC(e);
                        c(e), l(e), u(e), r.fragmentLookupTable.push({ timestamp: n, moofOffset: i });
                    }
                    r.fragmentLookupTable.sort((e, t) => e.timestamp - t.timestamp);
                    for (let e = 0; e < r.fragmentLookupTable.length - 1; e++) {
                        const t = r.fragmentLookupTable[e],
                            n = r.fragmentLookupTable[e + 1];
                        t.timestamp === n.timestamp && (r.fragmentLookupTable.splice(e + 1, 1), e--);
                    }
                }
                break;
            case "moof":
                (this.currentFragment = {
                    moofOffset: t,
                    moofSize: n.totalSize,
                    implicitBaseDataOffset: t,
                    trackData: new Map(),
                }),
                    this.readContiguousBoxes(e.slice(r, n.contentSize)),
                    (this.lastReadFragment = this.currentFragment),
                    (this.currentFragment = null);
                break;
            case "traf":
                if (
                    (Vk(this.currentFragment), this.readContiguousBoxes(e.slice(r, n.contentSize)), this.currentTrack)
                ) {
                    const e = this.currentFragment.trackData.get(this.currentTrack.id);
                    if (e) {
                        const { currentFragmentState: t } = this.currentTrack;
                        Vk(t), null !== t.startTimestamp && (tS(e, t.startTimestamp), (e.startTimestampIsFinal = !0));
                    }
                    (this.currentTrack.currentFragmentState = null), (this.currentTrack = null);
                }
                break;
            case "tfhd":
                {
                    Vk(this.currentFragment), e.skip(1);
                    const t = aC(e),
                        n = Boolean(1 & t),
                        r = Boolean(2 & t),
                        i = Boolean(8 & t),
                        s = Boolean(16 & t),
                        a = Boolean(32 & t),
                        o = Boolean(65536 & t),
                        c = Boolean(131072 & t),
                        l = lC(e),
                        u = this.tracks.find((e) => e.id === l);
                    if (!u) break;
                    const d = this.fragmentTrackDefaults.find((e) => e.trackId === l);
                    (this.currentTrack = u),
                        (u.currentFragmentState = {
                            baseDataOffset: this.currentFragment.implicitBaseDataOffset,
                            sampleDescriptionIndex: d?.defaultSampleDescriptionIndex ?? null,
                            defaultSampleDuration: d?.defaultSampleDuration ?? null,
                            defaultSampleSize: d?.defaultSampleSize ?? null,
                            defaultSampleFlags: d?.defaultSampleFlags ?? null,
                            startTimestamp: null,
                        }),
                        n
                            ? (u.currentFragmentState.baseDataOffset = mC(e))
                            : c && (u.currentFragmentState.baseDataOffset = this.currentFragment.moofOffset),
                        r && (u.currentFragmentState.sampleDescriptionIndex = lC(e)),
                        i && (u.currentFragmentState.defaultSampleDuration = lC(e)),
                        s && (u.currentFragmentState.defaultSampleSize = lC(e)),
                        a && (u.currentFragmentState.defaultSampleFlags = lC(e)),
                        o && (u.currentFragmentState.defaultSampleDuration = 0);
                }
                break;
            case "tfdt":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    Vk(t.currentFragmentState);
                    const n = rC(e);
                    e.skip(3);
                    const r = 0 === n ? lC(e) : mC(e);
                    t.currentFragmentState.startTimestamp = r;
                }
                break;
            case "trun":
                {
                    const t = this.currentTrack;
                    if (!t) break;
                    if (
                        (Vk(this.currentFragment), Vk(t.currentFragmentState), this.currentFragment.trackData.has(t.id))
                    )
                        break;
                    const n = rC(e),
                        r = aC(e),
                        i = Boolean(1 & r),
                        s = Boolean(4 & r),
                        a = Boolean(256 & r),
                        o = Boolean(512 & r),
                        c = Boolean(1024 & r),
                        l = Boolean(2048 & r),
                        u = lC(e);
                    let d = t.currentFragmentState.baseDataOffset;
                    i && (d += dC(e));
                    let h = null;
                    s && (h = lC(e));
                    let m = d;
                    if (0 === u) {
                        this.currentFragment.implicitBaseDataOffset = m;
                        break;
                    }
                    let p = 0;
                    const f = {
                        track: t,
                        startTimestamp: 0,
                        endTimestamp: 0,
                        firstKeyFrameTimestamp: null,
                        samples: [],
                        presentationTimestamps: [],
                        startTimestampIsFinal: !1,
                    };
                    this.currentFragment.trackData.set(t.id, f);
                    for (let y = 0; y < u; y++) {
                        let r, i, s;
                        a
                            ? (r = lC(e))
                            : (Vk(null !== t.currentFragmentState.defaultSampleDuration),
                              (r = t.currentFragmentState.defaultSampleDuration)),
                            o
                                ? (i = lC(e))
                                : (Vk(null !== t.currentFragmentState.defaultSampleSize),
                                  (i = t.currentFragmentState.defaultSampleSize)),
                            c
                                ? (s = lC(e))
                                : (Vk(null !== t.currentFragmentState.defaultSampleFlags),
                                  (s = t.currentFragmentState.defaultSampleFlags)),
                            0 === y && null !== h && (s = h);
                        let u = 0;
                        l && (u = 0 === n ? lC(e) : dC(e));
                        const d = !(65536 & s);
                        f.samples.push({
                            presentationTimestamp: p + u,
                            duration: r,
                            byteOffset: m,
                            byteSize: i,
                            isKeyFrame: d,
                        }),
                            (m += i),
                            (p += r);
                    }
                    f.presentationTimestamps = f.samples
                        .map((e, t) => ({ presentationTimestamp: e.presentationTimestamp, sampleIndex: t }))
                        .sort((e, t) => e.presentationTimestamp - t.presentationTimestamp);
                    for (let e = 0; e < f.presentationTimestamps.length; e++) {
                        const t = f.presentationTimestamps[e],
                            n = f.samples[t.sampleIndex];
                        if (
                            (null === f.firstKeyFrameTimestamp &&
                                n.isKeyFrame &&
                                (f.firstKeyFrameTimestamp = n.presentationTimestamp),
                            e < f.presentationTimestamps.length - 1)
                        ) {
                            const r = f.presentationTimestamps[e + 1];
                            n.duration = r.presentationTimestamp - t.presentationTimestamp;
                        }
                    }
                    const g = f.samples[f.presentationTimestamps[0].sampleIndex],
                        b = f.samples[jk(f.presentationTimestamps).sampleIndex];
                    (f.startTimestamp = g.presentationTimestamp),
                        (f.endTimestamp = b.presentationTimestamp + b.duration),
                        (this.currentFragment.implicitBaseDataOffset = m);
                }
                break;
            case "udta":
                {
                    const t = this.iterateContiguousBoxes(e.slice(r, n.contentSize));
                    for (const { boxInfo: e, slice: n } of t) {
                        if ("meta" !== e.name && !this.currentTrack) {
                            const t = n.filePos;
                            (this.metadataTags.raw ??= {}),
                                "" === e.name[0]
                                    ? (this.metadataTags.raw[e.name] ??= Hv(n))
                                    : (this.metadataTags.raw[e.name] ??= nC(n, e.contentSize)),
                                (n.filePos = t);
                        }
                        switch (e.name) {
                            case "meta":
                                n.skip(-e.headerSize), this.traverseBox(n);
                                break;
                            case "nam":
                            case "name":
                                this.currentTrack
                                    ? (this.currentTrack.name = Qk.decode(nC(n, e.contentSize)))
                                    : (this.metadataTags.title ??= Hv(n));
                                break;
                            case "des":
                                this.currentTrack || (this.metadataTags.description ??= Hv(n));
                                break;
                            case "ART":
                                this.currentTrack || (this.metadataTags.artist ??= Hv(n));
                                break;
                            case "alb":
                                this.currentTrack || (this.metadataTags.album ??= Hv(n));
                                break;
                            case "albr":
                                this.currentTrack || (this.metadataTags.albumArtist ??= Hv(n));
                                break;
                            case "gen":
                                this.currentTrack || (this.metadataTags.genre ??= Hv(n));
                                break;
                            case "day":
                                if (!this.currentTrack) {
                                    const e = new Date(Hv(n));
                                    Number.isNaN(e.getTime()) || (this.metadataTags.date ??= e);
                                }
                                break;
                            case "cmt":
                                this.currentTrack || (this.metadataTags.comment ??= Hv(n));
                                break;
                            case "lyr":
                                this.currentTrack || (this.metadataTags.lyrics ??= Hv(n));
                        }
                    }
                }
                break;
            case "meta":
                {
                    if (this.currentTrack) break;
                    const t = 0 !== lC(e);
                    (this.currentMetadataKeys = new Map()),
                        t
                            ? this.readContiguousBoxes(e.slice(r, n.contentSize))
                            : this.readContiguousBoxes(e.slice(r + 4, n.contentSize - 4)),
                        (this.currentMetadataKeys = null);
                }
                break;
            case "keys":
                {
                    if (!this.currentMetadataKeys) break;
                    e.skip(4);
                    const t = lC(e);
                    for (let n = 0; n < t; n++) {
                        const t = lC(e);
                        e.skip(4);
                        const r = Qk.decode(nC(e, t - 8));
                        this.currentMetadataKeys.set(n + 1, r);
                    }
                }
                break;
            case "ilst": {
                if (!this.currentMetadataKeys) break;
                const t = this.iterateContiguousBoxes(e.slice(r, n.contentSize));
                for (const { boxInfo: e, slice: n } of t) {
                    let t = e.name;
                    const r =
                        (t.charCodeAt(0) << 24) + (t.charCodeAt(1) << 16) + (t.charCodeAt(2) << 8) + t.charCodeAt(3);
                    this.currentMetadataKeys.has(r) && (t = this.currentMetadataKeys.get(r));
                    const i = qv(n);
                    switch (((this.metadataTags.raw ??= {}), (this.metadataTags.raw[t] ??= i), t)) {
                        case "nam":
                        case "titl":
                        case "com.apple.quicktime.title":
                        case "title":
                            "string" == typeof i && (this.metadataTags.title ??= i);
                            break;
                        case "des":
                        case "desc":
                        case "dscp":
                        case "com.apple.quicktime.description":
                        case "description":
                            "string" == typeof i && (this.metadataTags.description ??= i);
                            break;
                        case "ART":
                        case "com.apple.quicktime.artist":
                        case "artist":
                            "string" == typeof i && (this.metadataTags.artist ??= i);
                            break;
                        case "alb":
                        case "albm":
                        case "com.apple.quicktime.album":
                        case "album":
                            "string" == typeof i && (this.metadataTags.album ??= i);
                            break;
                        case "aART":
                        case "album_artist":
                            "string" == typeof i && (this.metadataTags.albumArtist ??= i);
                            break;
                        case "cmt":
                        case "com.apple.quicktime.comment":
                        case "comment":
                            "string" == typeof i && (this.metadataTags.comment ??= i);
                            break;
                        case "gen":
                        case "gnre":
                        case "com.apple.quicktime.genre":
                        case "genre":
                            "string" == typeof i && (this.metadataTags.genre ??= i);
                            break;
                        case "lyr":
                        case "lyrics":
                            "string" == typeof i && (this.metadataTags.lyrics ??= i);
                            break;
                        case "day":
                        case "rldt":
                        case "com.apple.quicktime.creationdate":
                        case "date":
                            if ("string" == typeof i) {
                                const e = new Date(i);
                                Number.isNaN(e.getTime()) || (this.metadataTags.date ??= e);
                            }
                            break;
                        case "covr":
                        case "com.apple.quicktime.artwork":
                            i instanceof HT
                                ? ((this.metadataTags.images ??= []),
                                  this.metadataTags.images.push({
                                      data: i.data,
                                      kind: "coverFront",
                                      mimeType: i.mimeType,
                                  }))
                                : i instanceof Uint8Array &&
                                  ((this.metadataTags.images ??= []),
                                  this.metadataTags.images.push({ data: i, kind: "coverFront", mimeType: "image/*" }));
                            break;
                        case "track":
                            if ("string" == typeof i) {
                                const e = i.split("/"),
                                    t = Number.parseInt(e[0], 10),
                                    n = e[1] && Number.parseInt(e[1], 10);
                                Number.isInteger(t) && t > 0 && (this.metadataTags.trackNumber ??= t),
                                    n && Number.isInteger(n) && n > 0 && (this.metadataTags.tracksTotal ??= n);
                            }
                            break;
                        case "trkn":
                            if (i instanceof Uint8Array && i.length >= 6) {
                                const e = Yk(i),
                                    t = e.getUint16(2, !1),
                                    n = e.getUint16(4, !1);
                                t > 0 && (this.metadataTags.trackNumber ??= t),
                                    n > 0 && (this.metadataTags.tracksTotal ??= n);
                            }
                            break;
                        case "disc":
                        case "disk":
                            if (i instanceof Uint8Array && i.length >= 6) {
                                const e = Yk(i),
                                    t = e.getUint16(2, !1),
                                    n = e.getUint16(4, !1);
                                t > 0 && (this.metadataTags.discNumber ??= t),
                                    n > 0 && (this.metadataTags.discsTotal ??= n);
                            }
                    }
                }
            }
        }
        return (e.filePos = i), !0;
    }
}
class Gv {
    constructor(e) {
        (this.internalTrack = e),
            (this.packetToSampleIndex = new WeakMap()),
            (this.packetToFragmentLocation = new WeakMap());
    }
    getId() {
        return this.internalTrack.id;
    }
    getCodec() {
        throw new Error("Not implemented on base class.");
    }
    getInternalCodecId() {
        return this.internalTrack.internalCodecId;
    }
    getName() {
        return this.internalTrack.name;
    }
    getLanguageCode() {
        return this.internalTrack.languageCode;
    }
    getTimeResolution() {
        return this.internalTrack.timescale;
    }
    async computeDuration() {
        const e = await this.getPacket(1 / 0, { metadataOnly: !0 });
        return (e?.timestamp ?? 0) + (e?.duration ?? 0);
    }
    async getFirstTimestamp() {
        const e = await this.getFirstPacket({ metadataOnly: !0 });
        return e?.timestamp ?? 0;
    }
    async getFirstPacket(e) {
        const t = await this.fetchPacketForSampleIndex(0, e);
        return t || !this.internalTrack.demuxer.isFragmented
            ? t
            : this.performFragmentedLookup(
                  null,
                  (e) =>
                      e.trackData.get(this.internalTrack.id)
                          ? { sampleIndex: 0, correctSampleFound: !0 }
                          : { sampleIndex: -1, correctSampleFound: !1 },
                  -1 / 0,
                  1 / 0,
                  e
              );
    }
    mapTimestampIntoTimescale(e) {
        return ST(e * this.internalTrack.timescale, 14) + this.internalTrack.editListOffset;
    }
    async getPacket(e, t) {
        const n = this.mapTimestampIntoTimescale(e),
            r = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),
            i = Qv(r, n),
            s = await this.fetchPacketForSampleIndex(i, t);
        return rS(r) && this.internalTrack.demuxer.isFragmented
            ? this.performFragmentedLookup(
                  null,
                  (e) => {
                      const t = e.trackData.get(this.internalTrack.id);
                      if (!t) return { sampleIndex: -1, correctSampleFound: !1 };
                      const r = mT(t.presentationTimestamps, n, (e) => e.presentationTimestamp);
                      return {
                          sampleIndex: -1 !== r ? t.presentationTimestamps[r].sampleIndex : -1,
                          correctSampleFound: -1 !== r && n < t.endTimestamp,
                      };
                  },
                  n,
                  n,
                  t
              )
            : s;
    }
    async getNextPacket(e, t) {
        const n = this.packetToSampleIndex.get(e);
        if (void 0 !== n) return this.fetchPacketForSampleIndex(n + 1, t);
        const r = this.packetToFragmentLocation.get(e);
        if (void 0 === r) throw new Error("Packet was not created from this track.");
        return this.performFragmentedLookup(
            r.fragment,
            (e) => {
                if (e === r.fragment) {
                    const t = e.trackData.get(this.internalTrack.id);
                    if (r.sampleIndex + 1 < t.samples.length)
                        return { sampleIndex: r.sampleIndex + 1, correctSampleFound: !0 };
                } else {
                    if (e.trackData.get(this.internalTrack.id)) return { sampleIndex: 0, correctSampleFound: !0 };
                }
                return { sampleIndex: -1, correctSampleFound: !1 };
            },
            -1 / 0,
            1 / 0,
            t
        );
    }
    async getKeyPacket(e, t) {
        const n = this.mapTimestampIntoTimescale(e),
            r = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),
            i = Qv(r, n),
            s = -1 === i ? -1 : Zv(r, i),
            a = await this.fetchPacketForSampleIndex(s, t);
        return rS(r) && this.internalTrack.demuxer.isFragmented
            ? this.performFragmentedLookup(
                  null,
                  (e) => {
                      const t = e.trackData.get(this.internalTrack.id);
                      if (!t) return { sampleIndex: -1, correctSampleFound: !1 };
                      const r = bT(
                          t.presentationTimestamps,
                          (e) => t.samples[e.sampleIndex].isKeyFrame && e.presentationTimestamp <= n
                      );
                      return {
                          sampleIndex: -1 !== r ? t.presentationTimestamps[r].sampleIndex : -1,
                          correctSampleFound: -1 !== r && n < t.endTimestamp,
                      };
                  },
                  n,
                  n,
                  t
              )
            : a;
    }
    async getNextKeyPacket(e, t) {
        const n = this.packetToSampleIndex.get(e);
        if (void 0 !== n) {
            const e = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),
                r = eS(e, n);
            return this.fetchPacketForSampleIndex(r, t);
        }
        const r = this.packetToFragmentLocation.get(e);
        if (void 0 === r) throw new Error("Packet was not created from this track.");
        return this.performFragmentedLookup(
            r.fragment,
            (e) => {
                if (e === r.fragment) {
                    const t = e.trackData
                        .get(this.internalTrack.id)
                        .samples.findIndex((e, t) => e.isKeyFrame && t > r.sampleIndex);
                    if (-1 !== t) return { sampleIndex: t, correctSampleFound: !0 };
                } else {
                    const t = e.trackData.get(this.internalTrack.id);
                    if (t && null !== t.firstKeyFrameTimestamp) {
                        const e = t.samples.findIndex((e) => e.isKeyFrame);
                        return Vk(-1 !== e), { sampleIndex: e, correctSampleFound: !0 };
                    }
                }
                return { sampleIndex: -1, correctSampleFound: !1 };
            },
            -1 / 0,
            1 / 0,
            t
        );
    }
    async fetchPacketForSampleIndex(e, t) {
        if (-1 === e) return null;
        const n = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),
            r = Jv(n, e);
        if (!r) return null;
        let i;
        if (t.metadataOnly) i = cv;
        else {
            let e = this.internalTrack.demuxer.reader.requestSlice(r.sampleOffset, r.sampleSize);
            e instanceof Promise && (e = await e), Vk(e), (i = nC(e, r.sampleSize));
        }
        const s = (r.presentationTimestamp - this.internalTrack.editListOffset) / this.internalTrack.timescale,
            a = r.duration / this.internalTrack.timescale,
            o = new lv(i, r.isKeyFrame ? "key" : "delta", s, a, e, r.sampleSize);
        return this.packetToSampleIndex.set(o, e), o;
    }
    async fetchPacketInFragment(e, t, n) {
        if (-1 === t) return null;
        const r = e.trackData.get(this.internalTrack.id).samples[t];
        let i;
        if ((Vk(r), n.metadataOnly)) i = cv;
        else {
            let e = this.internalTrack.demuxer.reader.requestSlice(r.byteOffset, r.byteSize);
            e instanceof Promise && (e = await e), Vk(e), (i = nC(e, r.byteSize));
        }
        const s = (r.presentationTimestamp - this.internalTrack.editListOffset) / this.internalTrack.timescale,
            a = r.duration / this.internalTrack.timescale,
            o = new lv(i, r.isKeyFrame ? "key" : "delta", s, a, e.moofOffset + t, r.byteSize);
        return this.packetToFragmentLocation.set(o, { fragment: e, sampleIndex: t }), o;
    }
    async performFragmentedLookup(e, t, n, r, i) {
        const s = this.internalTrack.demuxer;
        let a = null,
            o = null,
            c = -1;
        if (e) {
            const { sampleIndex: n, correctSampleFound: r } = t(e);
            if (r) return this.fetchPacketInFragment(e, n, i);
            -1 !== n && ((o = e), (c = n));
        }
        const l = mT(this.internalTrack.fragmentLookupTable, n, (e) => e.timestamp),
            u = -1 !== l ? this.internalTrack.fragmentLookupTable[l] : null,
            d = mT(this.internalTrack.fragmentPositionCache, n, (e) => e.startTimestamp),
            h = -1 !== d ? this.internalTrack.fragmentPositionCache[d] : null,
            m = Math.max(u?.moofOffset ?? 0, h?.moofOffset ?? 0) || null;
        let p;
        for (
            e ? (null === m || e.moofOffset >= m ? ((p = e.moofOffset + e.moofSize), (a = e)) : (p = m)) : (p = m ?? 0);
            ;

        ) {
            if (a) {
                const e = a.trackData.get(this.internalTrack.id);
                if (e && e.startTimestamp > r) break;
            }
            let e = s.reader.requestSliceRange(p, 8, Uv);
            if ((e instanceof Promise && (e = await e), !e)) break;
            const n = p,
                l = $v(e);
            if (!l) break;
            if ("moof" === l.name) {
                a = await s.readFragment(n);
                const { sampleIndex: e, correctSampleFound: r } = t(a);
                if (r) return this.fetchPacketInFragment(a, e, i);
                -1 !== e && ((o = a), (c = e));
            }
            p = n + l.totalSize;
        }
        if (u && (!o || o.moofOffset < u.moofOffset)) {
            const e = this.internalTrack.fragmentLookupTable[l - 1];
            Vk(!e || e.timestamp < u.timestamp);
            const n = e?.timestamp ?? -1 / 0;
            return this.performFragmentedLookup(null, t, n, r, i);
        }
        return o ? this.fetchPacketInFragment(o, c, i) : null;
    }
}
class Kv extends Gv {
    constructor(e) {
        super(e), (this.decoderConfigPromise = null), (this.internalTrack = e);
    }
    getCodec() {
        return this.internalTrack.info.codec;
    }
    getCodedWidth() {
        return this.internalTrack.info.width;
    }
    getCodedHeight() {
        return this.internalTrack.info.height;
    }
    getRotation() {
        return this.internalTrack.rotation;
    }
    async getColorSpace() {
        return {
            primaries: this.internalTrack.info.colorSpace?.primaries,
            transfer: this.internalTrack.info.colorSpace?.transfer,
            matrix: this.internalTrack.info.colorSpace?.matrix,
            fullRange: this.internalTrack.info.colorSpace?.fullRange,
        };
    }
    async canBeTransparent() {
        return !1;
    }
    async getDecoderConfig() {
        return this.internalTrack.info.codec
            ? (this.decoderConfigPromise ??= (async () => {
                  if ("vp9" !== this.internalTrack.info.codec || this.internalTrack.info.vp9CodecInfo) {
                      if ("av1" === this.internalTrack.info.codec && !this.internalTrack.info.av1CodecInfo) {
                          const e = await this.getFirstPacket({});
                          this.internalTrack.info.av1CodecInfo = e && K_(e.data);
                      }
                  } else {
                      const e = await this.getFirstPacket({});
                      this.internalTrack.info.vp9CodecInfo = e && X_(e.data);
                  }
                  return {
                      codec: c_(this.internalTrack.info),
                      codedWidth: this.internalTrack.info.width,
                      codedHeight: this.internalTrack.info.height,
                      description: this.internalTrack.info.codecDescription ?? void 0,
                      colorSpace: this.internalTrack.info.colorSpace ?? void 0,
                  };
              })())
            : null;
    }
}
class Yv extends Gv {
    constructor(e) {
        super(e), (this.decoderConfig = null), (this.internalTrack = e);
    }
    getCodec() {
        return this.internalTrack.info.codec;
    }
    getNumberOfChannels() {
        return this.internalTrack.info.numberOfChannels;
    }
    getSampleRate() {
        return this.internalTrack.info.sampleRate;
    }
    async getDecoderConfig() {
        return this.internalTrack.info.codec
            ? (this.decoderConfig ??= {
                  codec: u_(this.internalTrack.info),
                  numberOfChannels: this.internalTrack.info.numberOfChannels,
                  sampleRate: this.internalTrack.info.sampleRate,
                  description: this.internalTrack.info.codecDescription ?? void 0,
              })
            : null;
    }
}
const Qv = (e, t) => {
        if (e.presentationTimestamps) {
            const n = mT(e.presentationTimestamps, t, (e) => e.presentationTimestamp);
            return -1 === n ? -1 : e.presentationTimestamps[n].sampleIndex;
        }
        {
            const n = mT(e.sampleTimingEntries, t, (e) => e.startDecodeTimestamp);
            if (-1 === n) return -1;
            const r = e.sampleTimingEntries[n];
            return r.startIndex + Math.min(Math.floor((t - r.startDecodeTimestamp) / r.delta), r.count - 1);
        }
    },
    Jv = (e, t) => {
        const n = mT(e.sampleTimingEntries, t, (e) => e.startIndex),
            r = e.sampleTimingEntries[n];
        if (!r || r.startIndex + r.count <= t) return null;
        let i = r.startDecodeTimestamp + (t - r.startIndex) * r.delta;
        const s = mT(e.sampleCompositionTimeOffsets, t, (e) => e.startIndex),
            a = e.sampleCompositionTimeOffsets[s];
        a && t - a.startIndex < a.count && (i += a.offset);
        const o = e.sampleSizes[Math.min(t, e.sampleSizes.length - 1)],
            c = mT(e.sampleToChunk, t, (e) => e.startSampleIndex),
            l = e.sampleToChunk[c];
        Vk(l);
        const u = l.startChunkIndex + Math.floor((t - l.startSampleIndex) / l.samplesPerChunk),
            d = e.chunkOffsets[u],
            h = l.startSampleIndex + (u - l.startChunkIndex) * l.samplesPerChunk;
        let m = 0,
            p = d;
        if (1 === e.sampleSizes.length) (p += o * (t - h)), (m += o * l.samplesPerChunk);
        else
            for (let g = h; g < h + l.samplesPerChunk; g++) {
                const n = e.sampleSizes[g];
                g < t && (p += n), (m += n);
            }
        let f = r.delta;
        if (e.presentationTimestamps) {
            const n = e.presentationTimestampIndexMap[t];
            if ((Vk(void 0 !== n), n < e.presentationTimestamps.length - 1)) {
                f = e.presentationTimestamps[n + 1].presentationTimestamp - i;
            }
        }
        return {
            presentationTimestamp: i,
            duration: f,
            sampleOffset: p,
            sampleSize: o,
            chunkOffset: d,
            chunkSize: m,
            isKeyFrame: !e.keySampleIndices || -1 !== hT(e.keySampleIndices, t, (e) => e),
        };
    },
    Zv = (e, t) => {
        if (!e.keySampleIndices) return t;
        const n = mT(e.keySampleIndices, t, (e) => e);
        return e.keySampleIndices[n] ?? -1;
    },
    eS = (e, t) => {
        if (!e.keySampleIndices) return t + 1;
        const n = mT(e.keySampleIndices, t, (e) => e);
        return e.keySampleIndices[n + 1] ?? -1;
    },
    tS = (e, t) => {
        (e.startTimestamp += t), (e.endTimestamp += t);
        for (const n of e.samples) n.presentationTimestamp += t;
        for (const n of e.presentationTimestamps) n.presentationTimestamp += t;
    },
    nS = (e) => {
        const [t, , , n] = e,
            r = Math.hypot(t, n),
            i = t / r,
            s = n / r,
            a = -Math.atan2(s, i) * (180 / Math.PI);
        return Number.isFinite(a) ? a : 0;
    },
    rS = (e) => 0 === e.sampleSizes.length;
class iS {
    constructor(e) {
        this.value = e;
    }
}
class sS {
    constructor(e) {
        this.value = e;
    }
}
class aS {
    constructor(e) {
        this.value = e;
    }
}
class oS {
    constructor(e) {
        this.value = e;
    }
}
var cS, lS;
((lS = cS || (cS = {}))[(lS.EBML = 440786851)] = "EBML"),
    (lS[(lS.EBMLVersion = 17030)] = "EBMLVersion"),
    (lS[(lS.EBMLReadVersion = 17143)] = "EBMLReadVersion"),
    (lS[(lS.EBMLMaxIDLength = 17138)] = "EBMLMaxIDLength"),
    (lS[(lS.EBMLMaxSizeLength = 17139)] = "EBMLMaxSizeLength"),
    (lS[(lS.DocType = 17026)] = "DocType"),
    (lS[(lS.DocTypeVersion = 17031)] = "DocTypeVersion"),
    (lS[(lS.DocTypeReadVersion = 17029)] = "DocTypeReadVersion"),
    (lS[(lS.Void = 236)] = "Void"),
    (lS[(lS.Segment = 408125543)] = "Segment"),
    (lS[(lS.SeekHead = 290298740)] = "SeekHead"),
    (lS[(lS.Seek = 19899)] = "Seek"),
    (lS[(lS.SeekID = 21419)] = "SeekID"),
    (lS[(lS.SeekPosition = 21420)] = "SeekPosition"),
    (lS[(lS.Duration = 17545)] = "Duration"),
    (lS[(lS.Info = 357149030)] = "Info"),
    (lS[(lS.TimestampScale = 2807729)] = "TimestampScale"),
    (lS[(lS.MuxingApp = 19840)] = "MuxingApp"),
    (lS[(lS.WritingApp = 22337)] = "WritingApp"),
    (lS[(lS.Tracks = 374648427)] = "Tracks"),
    (lS[(lS.TrackEntry = 174)] = "TrackEntry"),
    (lS[(lS.TrackNumber = 215)] = "TrackNumber"),
    (lS[(lS.TrackUID = 29637)] = "TrackUID"),
    (lS[(lS.TrackType = 131)] = "TrackType"),
    (lS[(lS.FlagEnabled = 185)] = "FlagEnabled"),
    (lS[(lS.FlagDefault = 136)] = "FlagDefault"),
    (lS[(lS.FlagForced = 21930)] = "FlagForced"),
    (lS[(lS.FlagLacing = 156)] = "FlagLacing"),
    (lS[(lS.Name = 21358)] = "Name"),
    (lS[(lS.Language = 2274716)] = "Language"),
    (lS[(lS.LanguageBCP47 = 2274717)] = "LanguageBCP47"),
    (lS[(lS.CodecID = 134)] = "CodecID"),
    (lS[(lS.CodecPrivate = 25506)] = "CodecPrivate"),
    (lS[(lS.CodecDelay = 22186)] = "CodecDelay"),
    (lS[(lS.SeekPreRoll = 22203)] = "SeekPreRoll"),
    (lS[(lS.DefaultDuration = 2352003)] = "DefaultDuration"),
    (lS[(lS.Video = 224)] = "Video"),
    (lS[(lS.PixelWidth = 176)] = "PixelWidth"),
    (lS[(lS.PixelHeight = 186)] = "PixelHeight"),
    (lS[(lS.AlphaMode = 21440)] = "AlphaMode"),
    (lS[(lS.Audio = 225)] = "Audio"),
    (lS[(lS.SamplingFrequency = 181)] = "SamplingFrequency"),
    (lS[(lS.Channels = 159)] = "Channels"),
    (lS[(lS.BitDepth = 25188)] = "BitDepth"),
    (lS[(lS.SimpleBlock = 163)] = "SimpleBlock"),
    (lS[(lS.BlockGroup = 160)] = "BlockGroup"),
    (lS[(lS.Block = 161)] = "Block"),
    (lS[(lS.BlockAdditions = 30113)] = "BlockAdditions"),
    (lS[(lS.BlockMore = 166)] = "BlockMore"),
    (lS[(lS.BlockAdditional = 165)] = "BlockAdditional"),
    (lS[(lS.BlockAddID = 238)] = "BlockAddID"),
    (lS[(lS.BlockDuration = 155)] = "BlockDuration"),
    (lS[(lS.ReferenceBlock = 251)] = "ReferenceBlock"),
    (lS[(lS.Cluster = 524531317)] = "Cluster"),
    (lS[(lS.Timestamp = 231)] = "Timestamp"),
    (lS[(lS.Cues = 475249515)] = "Cues"),
    (lS[(lS.CuePoint = 187)] = "CuePoint"),
    (lS[(lS.CueTime = 179)] = "CueTime"),
    (lS[(lS.CueTrackPositions = 183)] = "CueTrackPositions"),
    (lS[(lS.CueTrack = 247)] = "CueTrack"),
    (lS[(lS.CueClusterPosition = 241)] = "CueClusterPosition"),
    (lS[(lS.Colour = 21936)] = "Colour"),
    (lS[(lS.MatrixCoefficients = 21937)] = "MatrixCoefficients"),
    (lS[(lS.TransferCharacteristics = 21946)] = "TransferCharacteristics"),
    (lS[(lS.Primaries = 21947)] = "Primaries"),
    (lS[(lS.Range = 21945)] = "Range"),
    (lS[(lS.Projection = 30320)] = "Projection"),
    (lS[(lS.ProjectionType = 30321)] = "ProjectionType"),
    (lS[(lS.ProjectionPoseRoll = 30325)] = "ProjectionPoseRoll"),
    (lS[(lS.Attachments = 423732329)] = "Attachments"),
    (lS[(lS.AttachedFile = 24999)] = "AttachedFile"),
    (lS[(lS.FileDescription = 18046)] = "FileDescription"),
    (lS[(lS.FileName = 18030)] = "FileName"),
    (lS[(lS.FileMediaType = 18016)] = "FileMediaType"),
    (lS[(lS.FileData = 18012)] = "FileData"),
    (lS[(lS.FileUID = 18094)] = "FileUID"),
    (lS[(lS.Chapters = 272869232)] = "Chapters"),
    (lS[(lS.Tags = 307544935)] = "Tags"),
    (lS[(lS.Tag = 29555)] = "Tag"),
    (lS[(lS.Targets = 25536)] = "Targets"),
    (lS[(lS.TargetTypeValue = 26826)] = "TargetTypeValue"),
    (lS[(lS.TargetType = 25546)] = "TargetType"),
    (lS[(lS.TagTrackUID = 25541)] = "TagTrackUID"),
    (lS[(lS.TagEditionUID = 25545)] = "TagEditionUID"),
    (lS[(lS.TagChapterUID = 25540)] = "TagChapterUID"),
    (lS[(lS.TagAttachmentUID = 25542)] = "TagAttachmentUID"),
    (lS[(lS.SimpleTag = 26568)] = "SimpleTag"),
    (lS[(lS.TagName = 17827)] = "TagName"),
    (lS[(lS.TagLanguage = 17530)] = "TagLanguage"),
    (lS[(lS.TagString = 17543)] = "TagString"),
    (lS[(lS.TagBinary = 17541)] = "TagBinary"),
    (lS[(lS.ContentEncodings = 28032)] = "ContentEncodings"),
    (lS[(lS.ContentEncoding = 25152)] = "ContentEncoding"),
    (lS[(lS.ContentEncodingOrder = 20529)] = "ContentEncodingOrder"),
    (lS[(lS.ContentEncodingScope = 20530)] = "ContentEncodingScope"),
    (lS[(lS.ContentCompression = 20532)] = "ContentCompression"),
    (lS[(lS.ContentCompAlgo = 16980)] = "ContentCompAlgo"),
    (lS[(lS.ContentCompSettings = 16981)] = "ContentCompSettings"),
    (lS[(lS.ContentEncryption = 20533)] = "ContentEncryption");
const uS = [cS.EBML, cS.Segment],
    dS = [cS.SeekHead, cS.Info, cS.Cluster, cS.Tracks, cS.Cues, cS.Attachments, cS.Chapters, cS.Tags],
    hS = [...uS, ...dS],
    mS = (e) => (e < 256 ? 1 : e < 65536 ? 2 : e < 1 << 24 ? 3 : e < 2 ** 32 ? 4 : e < 2 ** 40 ? 5 : 6),
    pS = (e) =>
        e < 256n
            ? 1
            : e < 65536n
              ? 2
              : e < 1n << 24n
                ? 3
                : e < 1n << 32n
                  ? 4
                  : e < 1n << 40n
                    ? 5
                    : e < 1n << 48n
                      ? 6
                      : e < 1n << 56n
                        ? 7
                        : 8,
    fS = (e) =>
        e >= -64 && e < 64
            ? 1
            : e >= -8192 && e < 8192
              ? 2
              : e >= -1048576 && e < 1 << 20
                ? 3
                : e >= -134217728 && e < 1 << 27
                  ? 4
                  : e >= -17179869184 && e < 2 ** 34
                    ? 5
                    : 6;
class gS {
    constructor(e) {
        (this.writer = e),
            (this.helper = new Uint8Array(8)),
            (this.helperView = new DataView(this.helper.buffer)),
            (this.offsets = new WeakMap()),
            (this.dataOffsets = new WeakMap());
    }
    writeByte(e) {
        this.helperView.setUint8(0, e), this.writer.write(this.helper.subarray(0, 1));
    }
    writeFloat32(e) {
        this.helperView.setFloat32(0, e, !1), this.writer.write(this.helper.subarray(0, 4));
    }
    writeFloat64(e) {
        this.helperView.setFloat64(0, e, !1), this.writer.write(this.helper);
    }
    writeUnsignedInt(e, t = mS(e)) {
        let n = 0;
        switch (t) {
            case 6:
                this.helperView.setUint8(n++, (e / 2 ** 40) | 0);
            case 5:
                this.helperView.setUint8(n++, (e / 2 ** 32) | 0);
            case 4:
                this.helperView.setUint8(n++, e >> 24);
            case 3:
                this.helperView.setUint8(n++, e >> 16);
            case 2:
                this.helperView.setUint8(n++, e >> 8);
            case 1:
                this.helperView.setUint8(n++, e);
                break;
            default:
                throw new Error("Bad unsigned int size " + t);
        }
        this.writer.write(this.helper.subarray(0, n));
    }
    writeUnsignedBigInt(e, t = pS(e)) {
        let n = 0;
        for (let r = t - 1; r >= 0; r--) this.helperView.setUint8(n++, Number((e >> BigInt(8 * r)) & 0xffn));
        this.writer.write(this.helper.subarray(0, n));
    }
    writeSignedInt(e, t = fS(e)) {
        e < 0 && (e += 2 ** (8 * t)), this.writeUnsignedInt(e, t);
    }
    writeVarInt(
        e,
        t = ((e) => {
            if (e < 127) return 1;
            if (e < 16383) return 2;
            if (e < 2097151) return 3;
            if (e < 268435455) return 4;
            if (e < 2 ** 35 - 1) return 5;
            if (e < 2 ** 42 - 1) return 6;
            throw new Error("EBML varint size not supported " + e);
        })(e)
    ) {
        let n = 0;
        switch (t) {
            case 1:
                this.helperView.setUint8(n++, 128 | e);
                break;
            case 2:
                this.helperView.setUint8(n++, 64 | (e >> 8)), this.helperView.setUint8(n++, e);
                break;
            case 3:
                this.helperView.setUint8(n++, 32 | (e >> 16)),
                    this.helperView.setUint8(n++, e >> 8),
                    this.helperView.setUint8(n++, e);
                break;
            case 4:
                this.helperView.setUint8(n++, 16 | (e >> 24)),
                    this.helperView.setUint8(n++, e >> 16),
                    this.helperView.setUint8(n++, e >> 8),
                    this.helperView.setUint8(n++, e);
                break;
            case 5:
                this.helperView.setUint8(n++, 8 | ((e / 2 ** 32) & 7)),
                    this.helperView.setUint8(n++, e >> 24),
                    this.helperView.setUint8(n++, e >> 16),
                    this.helperView.setUint8(n++, e >> 8),
                    this.helperView.setUint8(n++, e);
                break;
            case 6:
                this.helperView.setUint8(n++, 4 | ((e / 2 ** 40) & 3)),
                    this.helperView.setUint8(n++, (e / 2 ** 32) | 0),
                    this.helperView.setUint8(n++, e >> 24),
                    this.helperView.setUint8(n++, e >> 16),
                    this.helperView.setUint8(n++, e >> 8),
                    this.helperView.setUint8(n++, e);
                break;
            default:
                throw new Error("Bad EBML varint size " + t);
        }
        this.writer.write(this.helper.subarray(0, n));
    }
    writeAsciiString(e) {
        this.writer.write(new Uint8Array(e.split("").map((e) => e.charCodeAt(0))));
    }
    writeEBML(e) {
        if (null !== e)
            if (e instanceof Uint8Array) this.writer.write(e);
            else if (Array.isArray(e)) for (const t of e) this.writeEBML(t);
            else if ((this.offsets.set(e, this.writer.getPos()), this.writeUnsignedInt(e.id), Array.isArray(e.data))) {
                const t = this.writer.getPos(),
                    n = -1 === e.size ? 1 : (e.size ?? 4);
                -1 === e.size ? this.writeByte(255) : this.writer.seek(this.writer.getPos() + n);
                const r = this.writer.getPos();
                if ((this.dataOffsets.set(e, r), this.writeEBML(e.data), -1 !== e.size)) {
                    const e = this.writer.getPos() - r,
                        i = this.writer.getPos();
                    this.writer.seek(t), this.writeVarInt(e, n), this.writer.seek(i);
                }
            } else if ("number" == typeof e.data) {
                const t = e.size ?? mS(e.data);
                this.writeVarInt(t), this.writeUnsignedInt(e.data, t);
            } else if ("bigint" == typeof e.data) {
                const t = e.size ?? pS(e.data);
                this.writeVarInt(t), this.writeUnsignedBigInt(e.data, t);
            } else if ("string" == typeof e.data) this.writeVarInt(e.data.length), this.writeAsciiString(e.data);
            else if (e.data instanceof Uint8Array)
                this.writeVarInt(e.data.byteLength, e.size), this.writer.write(e.data);
            else if (e.data instanceof iS) this.writeVarInt(4), this.writeFloat32(e.data.value);
            else if (e.data instanceof sS) this.writeVarInt(8), this.writeFloat64(e.data.value);
            else if (e.data instanceof aS) {
                const t = e.size ?? fS(e.data.value);
                this.writeVarInt(t), this.writeSignedInt(e.data.value, t);
            } else if (e.data instanceof oS) {
                const t = Jk.encode(e.data.value);
                this.writeVarInt(t.length), this.writer.write(t);
            } else yT(e.data);
    }
}
const bS = 16,
    yS = (e) => {
        const t = rC(e);
        if ((e.skip(-1), 0 === t)) return null;
        let n = 1,
            r = 128;
        for (; 0 === (t & r); ) n++, (r >>= 1);
        return n;
    },
    wS = (e) => {
        const t = rC(e);
        if (0 === t) return null;
        let n = 1,
            r = 128;
        for (; 0 === (t & r); ) n++, (r >>= 1);
        let i = t & (r - 1);
        for (let s = 1; s < n; s++) (i *= 256), (i += rC(e));
        return i;
    },
    kS = (e, t) => {
        if (t < 1 || t > 8) throw new Error("Bad unsigned int size " + t);
        let n = 0;
        for (let r = 0; r < t; r++) (n *= 256), (n += rC(e));
        return n;
    },
    TS = (e) => {
        const t = yS(e);
        if (null === t) return null;
        return kS(e, t);
    },
    _S = (e) => {
        let t = rC(e);
        return 255 === t ? (t = null) : (e.skip(-1), (t = wS(e)), 72057594037927940 === t && (t = null)), t;
    },
    vS = (e) => {
        const t = TS(e);
        if (null === t) return null;
        return { id: t, size: _S(e) };
    },
    SS = (e, t) => {
        const n = nC(e, t);
        let r = 0;
        for (; r < t && 0 !== n[r]; ) r += 1;
        return String.fromCharCode(...n.subarray(0, r));
    },
    ES = (e, t) => {
        const n = nC(e, t);
        let r = 0;
        for (; r < t && 0 !== n[r]; ) r += 1;
        return Qk.decode(n.subarray(0, r));
    },
    CS = (e, t) => {
        if (0 === t) return 0;
        if (4 !== t && 8 !== t) throw new Error("Bad float size " + t);
        return 4 === t ? gC(e) : bC(e);
    },
    IS = async (e, t, n, r) => {
        const i = new Set(n);
        let s = t;
        for (; null === r || s < r; ) {
            let t = e.requestSliceRange(s, 2, bS);
            if ((t instanceof Promise && (t = await t), !t)) break;
            const n = vS(t);
            if (!n) break;
            if (i.has(n.id)) return { pos: s, found: !0 };
            PS(n.size), (s = t.filePos + n.size);
        }
        return { pos: null !== r && r > s ? r : s, found: !1 };
    },
    xS = async (e, t, n, r) => {
        const i = new Set(n);
        let s = t;
        for (; s < r; ) {
            let t = e.requestSliceRange(s, 0, Math.min(65536, r - s));
            if ((t instanceof Promise && (t = await t), !t)) break;
            if (t.length < 8) break;
            for (let e = 0; e < t.length - 8; e++) {
                t.filePos = s;
                const e = TS(t);
                if (null !== e && i.has(e)) return s;
                s++;
            }
        }
        return null;
    },
    AS = {
        avc: "V_MPEG4/ISO/AVC",
        hevc: "V_MPEGH/ISO/HEVC",
        vp8: "V_VP8",
        vp9: "V_VP9",
        av1: "V_AV1",
        aac: "A_AAC",
        mp3: "A_MPEG/L3",
        opus: "A_OPUS",
        vorbis: "A_VORBIS",
        flac: "A_FLAC",
        "pcm-u8": "A_PCM/INT/LIT",
        "pcm-s16": "A_PCM/INT/LIT",
        "pcm-s16be": "A_PCM/INT/BIG",
        "pcm-s24": "A_PCM/INT/LIT",
        "pcm-s24be": "A_PCM/INT/BIG",
        "pcm-s32": "A_PCM/INT/LIT",
        "pcm-s32be": "A_PCM/INT/BIG",
        "pcm-f32": "A_PCM/FLOAT/IEEE",
        "pcm-f64": "A_PCM/FLOAT/IEEE",
        webvtt: "S_TEXT/WEBVTT",
    };
function PS(e) {
    if (null === e) throw new Error("Undefined element size is used in a place where it is not supported.");
}
const OS = (e) => {
    let t = (e.hasVideo ? "video/" : e.hasAudio ? "audio/" : "application/") + (e.isWebM ? "webm" : "x-matroska");
    if (e.codecStrings.length > 0) {
        t += `; codecs="${[...new Set(e.codecStrings.filter(Boolean))].join(", ")}"`;
    }
    return t;
};
var NS, RS, MS, DS, FS, LS;
((RS = NS || (NS = {}))[(RS.None = 0)] = "None"),
    (RS[(RS.Xiph = 1)] = "Xiph"),
    (RS[(RS.FixedSize = 2)] = "FixedSize"),
    (RS[(RS.Ebml = 3)] = "Ebml"),
    ((DS = MS || (MS = {}))[(DS.Block = 1)] = "Block"),
    (DS[(DS.Private = 2)] = "Private"),
    (DS[(DS.Next = 4)] = "Next"),
    ((LS = FS || (FS = {}))[(LS.Zlib = 0)] = "Zlib"),
    (LS[(LS.Bzlib = 1)] = "Bzlib"),
    (LS[(LS.lzo1x = 2)] = "lzo1x"),
    (LS[(LS.HeaderStripping = 3)] = "HeaderStripping");
const BS = [
        { id: cS.SeekHead, flag: "seekHeadSeen" },
        { id: cS.Info, flag: "infoSeen" },
        { id: cS.Tracks, flag: "tracksSeen" },
        { id: cS.Cues, flag: "cuesSeen" },
    ],
    zS = 10485760;
class US extends rv {
    constructor(e) {
        super(e),
            (this.readMetadataPromise = null),
            (this.segments = []),
            (this.currentSegment = null),
            (this.currentTrack = null),
            (this.currentCluster = null),
            (this.currentBlock = null),
            (this.currentBlockAdditional = null),
            (this.currentCueTime = null),
            (this.currentDecodingInstruction = null),
            (this.currentTagTargetIsMovie = !0),
            (this.currentSimpleTagName = null),
            (this.currentAttachedFile = null),
            (this.isWebM = !1),
            (this.reader = e._reader);
    }
    async computeDuration() {
        const e = await this.getTracks(),
            t = await Promise.all(e.map((e) => e.computeDuration()));
        return Math.max(0, ...t);
    }
    async getTracks() {
        return await this.readMetadata(), this.segments.flatMap((e) => e.tracks.map((e) => e.inputTrack));
    }
    async getMimeType() {
        await this.readMetadata();
        const e = await this.getTracks(),
            t = await Promise.all(e.map((e) => e.getCodecParameterString()));
        return OS({
            isWebM: this.isWebM,
            hasVideo: this.segments.some((e) => e.tracks.some((e) => "video" === e.info?.type)),
            hasAudio: this.segments.some((e) => e.tracks.some((e) => "audio" === e.info?.type)),
            codecStrings: t.filter(Boolean),
        });
    }
    async getMetadataTags() {
        await this.readMetadata();
        for (const t of this.segments)
            t.metadataTagsCollected ||
                (null !== this.reader.fileSize && (await this.loadSegmentMetadata(t)), (t.metadataTagsCollected = !0));
        let e = {};
        for (const t of this.segments) e = { ...e, ...t.metadataTags };
        return e;
    }
    readMetadata() {
        return (this.readMetadataPromise ??= (async () => {
            let e = 0;
            for (;;) {
                let t = this.reader.requestSliceRange(e, 2, bS);
                if ((t instanceof Promise && (t = await t), !t)) break;
                const n = vS(t);
                if (!n) break;
                const r = n.id;
                let i = n.size;
                const s = t.filePos;
                if (r === cS.EBML) {
                    PS(i);
                    let e = this.reader.requestSlice(s, i);
                    if ((e instanceof Promise && (e = await e), !e)) break;
                    this.readContiguousElements(e);
                } else if (r === cS.Segment) {
                    if ((await this.readSegment(s, i), null === i)) break;
                    if (null === this.reader.fileSize) break;
                } else if (r === cS.Cluster) {
                    if (null === this.reader.fileSize) break;
                    if (null === i) {
                        i = (await IS(this.reader, s, hS, this.reader.fileSize)).pos - s;
                    }
                    const e = jk(this.segments);
                    e && (e.elementEndPos = s + i);
                }
                PS(i), (e = s + i);
            }
        })());
    }
    async readSegment(e, t) {
        (this.currentSegment = {
            seekHeadSeen: !1,
            infoSeen: !1,
            tracksSeen: !1,
            cuesSeen: !1,
            tagsSeen: !1,
            attachmentsSeen: !1,
            timestampScale: -1,
            timestampFactor: -1,
            duration: -1,
            seekEntries: [],
            tracks: [],
            cuePoints: [],
            dataStartPos: e,
            elementEndPos: null === t ? null : e + t,
            clusterSeekStartPos: e,
            lastReadCluster: null,
            metadataTags: {},
            metadataTagsCollected: !1,
        }),
            this.segments.push(this.currentSegment);
        let n = e;
        for (; null === this.currentSegment.elementEndPos || n < this.currentSegment.elementEndPos; ) {
            let e = this.reader.requestSliceRange(n, 2, bS);
            if ((e instanceof Promise && (e = await e), !e)) break;
            const t = n,
                r = vS(e);
            if (!r || (!dS.includes(r.id) && r.id !== cS.Void)) {
                const e = await xS(this.reader, t, dS, Math.min(this.currentSegment.elementEndPos ?? 1 / 0, t + zS));
                if (e) {
                    n = e;
                    continue;
                }
                break;
            }
            const { id: i, size: s } = r,
                a = e.filePos,
                o = BS.findIndex((e) => e.id === i);
            if (-1 !== o) {
                const e = BS[o].flag;
                (this.currentSegment[e] = !0), PS(s);
                let t = this.reader.requestSlice(a, s);
                t instanceof Promise && (t = await t), t && this.readContiguousElements(t);
            } else if (i === cS.Tags || i === cS.Attachments) {
                i === cS.Tags ? (this.currentSegment.tagsSeen = !0) : (this.currentSegment.attachmentsSeen = !0), PS(s);
                let e = this.reader.requestSlice(a, s);
                e instanceof Promise && (e = await e), e && this.readContiguousElements(e);
            } else if (i === cS.Cluster) {
                this.currentSegment.clusterSeekStartPos = t;
                break;
            }
            if (null === s) break;
            n = a + s;
        }
        if (
            (this.currentSegment.seekEntries.sort((e, t) => e.segmentPosition - t.segmentPosition),
            null !== this.reader.fileSize)
        )
            for (const a of this.currentSegment.seekEntries) {
                const t = BS.find((e) => e.id === a.id);
                if (!t) continue;
                if (this.currentSegment[t.flag]) continue;
                let n = this.reader.requestSliceRange(e + a.segmentPosition, 2, bS);
                if ((n instanceof Promise && (n = await n), !n)) continue;
                const r = vS(n);
                if (!r) continue;
                const { id: i, size: s } = r;
                if (i !== t.id) continue;
                PS(s), (this.currentSegment[t.flag] = !0);
                let o = this.reader.requestSlice(n.filePos, s);
                o instanceof Promise && (o = await o), o && this.readContiguousElements(o);
            }
        -1 === this.currentSegment.timestampScale &&
            ((this.currentSegment.timestampScale = 1e6), (this.currentSegment.timestampFactor = 1e3)),
            this.currentSegment.tracks.sort((e, t) => Number(t.isDefault) - Number(e.isDefault));
        const r = new Map(this.currentSegment.tracks.map((e) => [e.id, e]));
        for (const a of this.currentSegment.cuePoints) {
            const e = r.get(a.trackId);
            e && e.cuePoints.push(a);
        }
        for (const a of this.currentSegment.tracks) {
            a.cuePoints.sort((e, t) => e.time - t.time);
            for (let e = 0; e < a.cuePoints.length - 1; e++) {
                const t = a.cuePoints[e],
                    n = a.cuePoints[e + 1];
                t.time === n.time && (a.cuePoints.splice(e + 1, 1), e--);
            }
        }
        let i = null,
            s = -1 / 0;
        for (const a of this.currentSegment.tracks) a.cuePoints.length > s && ((s = a.cuePoints.length), (i = a));
        for (const a of this.currentSegment.tracks) 0 === a.cuePoints.length && (a.cuePoints = i.cuePoints);
        this.currentSegment = null;
    }
    async readCluster(e, t) {
        if (t.lastReadCluster?.elementStartPos === e) return t.lastReadCluster;
        let n = this.reader.requestSliceRange(e, 2, bS);
        n instanceof Promise && (n = await n), Vk(n);
        const r = e,
            i = vS(n);
        Vk(i);
        Vk(i.id === cS.Cluster);
        let s = i.size;
        const a = n.filePos;
        if (null === s) {
            s = (await IS(this.reader, a, hS, t.elementEndPos)).pos - a;
        }
        let o = this.reader.requestSlice(a, s);
        o instanceof Promise && (o = await o);
        const c = {
            segment: t,
            elementStartPos: r,
            elementEndPos: a + s,
            dataStartPos: a,
            timestamp: -1,
            trackData: new Map(),
        };
        (this.currentCluster = c), o && this.readContiguousElements(o);
        for (const [, l] of c.trackData) {
            const e = l.track;
            Vk(l.blocks.length > 0);
            let t = !1,
                n = !1;
            for (let r = 0; r < l.blocks.length; r++) {
                const e = l.blocks[r];
                (e.timestamp += c.timestamp), (t ||= e.referencedTimestamps.length > 0), (n ||= e.lacing !== NS.None);
            }
            t && (l.blocks = jS(l.blocks)),
                (l.presentationTimestamps = l.blocks
                    .map((e, t) => ({ timestamp: e.timestamp, blockIndex: t }))
                    .sort((e, t) => e.timestamp - t.timestamp));
            for (let r = 0; r < l.presentationTimestamps.length; r++) {
                const t = l.presentationTimestamps[r],
                    n = l.blocks[t.blockIndex];
                if (
                    (null === l.firstKeyFrameTimestamp && n.isKeyFrame && (l.firstKeyFrameTimestamp = n.timestamp),
                    r < l.presentationTimestamps.length - 1)
                ) {
                    const e = l.presentationTimestamps[r + 1];
                    n.duration = e.timestamp - n.timestamp;
                } else
                    0 === n.duration &&
                        null != e.defaultDuration &&
                        n.lacing === NS.None &&
                        (n.duration = e.defaultDuration);
            }
            n &&
                (this.expandLacedBlocks(l.blocks, e),
                (l.presentationTimestamps = l.blocks
                    .map((e, t) => ({ timestamp: e.timestamp, blockIndex: t }))
                    .sort((e, t) => e.timestamp - t.timestamp)));
            const i = l.blocks[l.presentationTimestamps[0].blockIndex],
                s = l.blocks[jk(l.presentationTimestamps).blockIndex];
            (l.startTimestamp = i.timestamp), (l.endTimestamp = s.timestamp + s.duration);
            const a = mT(e.clusterPositionCache, l.startTimestamp, (e) => e.startTimestamp);
            (-1 !== a && e.clusterPositionCache[a].elementStartPos === r) ||
                e.clusterPositionCache.splice(a + 1, 0, {
                    elementStartPos: c.elementStartPos,
                    startTimestamp: l.startTimestamp,
                });
        }
        return (t.lastReadCluster = c), c;
    }
    getTrackDataInCluster(e, t) {
        let n = e.trackData.get(t);
        if (!n) {
            const r = e.segment.tracks.find((e) => e.id === t);
            if (!r) return null;
            (n = {
                track: r,
                startTimestamp: 0,
                endTimestamp: 0,
                firstKeyFrameTimestamp: null,
                blocks: [],
                presentationTimestamps: [],
            }),
                e.trackData.set(t, n);
        }
        return n;
    }
    expandLacedBlocks(e, t) {
        for (let n = 0; n < e.length; n++) {
            const r = e[n];
            if (r.lacing === NS.None) continue;
            r.decoded || ((r.data = this.decodeBlockData(t, r.data)), (r.decoded = !0));
            const i = eC.tempFromBytes(r.data),
                s = [],
                a = rC(i) + 1;
            switch (r.lacing) {
                case NS.Xiph:
                    {
                        let e = 0;
                        for (let t = 0; t < a - 1; t++) {
                            let t = 0;
                            for (; i.bufferPos < i.length; ) {
                                const n = rC(i);
                                if (((t += n), n < 255)) {
                                    s.push(t), (e += t);
                                    break;
                                }
                            }
                        }
                        s.push(i.length - (i.bufferPos + e));
                    }
                    break;
                case NS.FixedSize:
                    {
                        const e = i.length - 1,
                            t = Math.floor(e / a);
                        for (let n = 0; n < a; n++) s.push(t);
                    }
                    break;
                case NS.Ebml:
                    {
                        const e = wS(i);
                        Vk(null !== e);
                        let t = e;
                        s.push(t);
                        let n = t;
                        for (let r = 1; r < a - 1; r++) {
                            const e = i.bufferPos,
                                r = wS(i);
                            Vk(null !== r);
                            (t += r - ((1 << (7 * (i.bufferPos - e) - 1)) - 1)), s.push(t), (n += t);
                        }
                        s.push(i.length - (i.bufferPos + n));
                    }
                    break;
                default:
                    Vk(!1);
            }
            Vk(s.length === a), e.splice(n, 1);
            for (let o = 0; o < a; o++) {
                const c = s[o],
                    l = nC(i, c),
                    u = r.duration || a * (t.defaultDuration ?? 0),
                    d = r.timestamp + (u * o) / a,
                    h = u / a;
                e.splice(n + o, 0, {
                    timestamp: d,
                    duration: h,
                    isKeyFrame: r.isKeyFrame,
                    referencedTimestamps: r.referencedTimestamps,
                    data: l,
                    lacing: NS.None,
                    decoded: !0,
                    mainAdditional: r.mainAdditional,
                });
            }
            (n += a), n--;
        }
    }
    async loadSegmentMetadata(e) {
        for (const t of e.seekEntries) {
            if (t.id !== cS.Tags || e.tagsSeen) {
                if (t.id !== cS.Attachments || e.attachmentsSeen) continue;
            } else;
            let n = this.reader.requestSliceRange(e.dataStartPos + t.segmentPosition, 2, bS);
            if ((n instanceof Promise && (n = await n), !n)) continue;
            const r = vS(n);
            if (!r || r.id !== t.id) continue;
            const { size: i } = r;
            PS(i), Vk(!this.currentSegment), (this.currentSegment = e);
            let s = this.reader.requestSlice(n.filePos, i);
            s instanceof Promise && (s = await s),
                s && this.readContiguousElements(s),
                (this.currentSegment = null),
                t.id === cS.Tags ? (e.tagsSeen = !0) : t.id === cS.Attachments && (e.attachmentsSeen = !0);
        }
    }
    readContiguousElements(e) {
        const t = e.filePos;
        for (; e.filePos - t <= e.length - 2; ) {
            if (!this.traverseElement(e)) break;
        }
    }
    traverseElement(e) {
        const t = vS(e);
        if (!t) return !1;
        const { id: n, size: r } = t,
            i = e.filePos;
        switch ((PS(r), n)) {
            case cS.DocType:
                this.isWebM = "webm" === SS(e, r);
                break;
            case cS.Seek:
                {
                    if (!this.currentSegment) break;
                    const t = { id: -1, segmentPosition: -1 };
                    this.currentSegment.seekEntries.push(t),
                        this.readContiguousElements(e.slice(i, r)),
                        (-1 !== t.id && -1 !== t.segmentPosition) || this.currentSegment.seekEntries.pop();
                }
                break;
            case cS.SeekID:
                {
                    const t = this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length - 1];
                    if (!t) break;
                    t.id = kS(e, r);
                }
                break;
            case cS.SeekPosition:
                {
                    const t = this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length - 1];
                    if (!t) break;
                    t.segmentPosition = kS(e, r);
                }
                break;
            case cS.TimestampScale:
                if (!this.currentSegment) break;
                (this.currentSegment.timestampScale = kS(e, r)),
                    (this.currentSegment.timestampFactor = 1e9 / this.currentSegment.timestampScale);
                break;
            case cS.Duration:
                if (!this.currentSegment) break;
                this.currentSegment.duration = CS(e, r);
                break;
            case cS.TrackEntry:
                if (!this.currentSegment) break;
                if (
                    ((this.currentTrack = {
                        id: -1,
                        segment: this.currentSegment,
                        demuxer: this,
                        clusterPositionCache: [],
                        cuePoints: [],
                        isDefault: !1,
                        inputTrack: null,
                        codecId: null,
                        codecPrivate: null,
                        defaultDuration: null,
                        name: null,
                        languageCode: vT,
                        decodingInstructions: [],
                        info: null,
                    }),
                    this.readContiguousElements(e.slice(i, r)),
                    this.currentTrack.decodingInstructions.some(
                        (e) =>
                            "decompress" !== e.data?.type ||
                            e.scope !== MS.Block ||
                            e.data.algorithm !== FS.HeaderStripping
                    ) && (this.currentTrack = null),
                    this.currentTrack &&
                        -1 !== this.currentTrack.id &&
                        this.currentTrack.codecId &&
                        this.currentTrack.info)
                ) {
                    const e = this.currentTrack.codecId.indexOf("/"),
                        t = -1 === e ? this.currentTrack.codecId : this.currentTrack.codecId.slice(0, e);
                    if (
                        "video" === this.currentTrack.info.type &&
                        -1 !== this.currentTrack.info.width &&
                        -1 !== this.currentTrack.info.height
                    ) {
                        this.currentTrack.codecId === AS.avc
                            ? ((this.currentTrack.info.codec = "avc"),
                              (this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate))
                            : this.currentTrack.codecId === AS.hevc
                              ? ((this.currentTrack.info.codec = "hevc"),
                                (this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate))
                              : t === AS.vp8
                                ? (this.currentTrack.info.codec = "vp8")
                                : t === AS.vp9
                                  ? (this.currentTrack.info.codec = "vp9")
                                  : t === AS.av1 && (this.currentTrack.info.codec = "av1");
                        const e = this.currentTrack,
                            n = new Lv(this.input, new VS(e));
                        (this.currentTrack.inputTrack = n), this.currentSegment.tracks.push(this.currentTrack);
                    } else if (
                        "audio" === this.currentTrack.info.type &&
                        -1 !== this.currentTrack.info.numberOfChannels &&
                        -1 !== this.currentTrack.info.sampleRate
                    ) {
                        t === AS.aac
                            ? ((this.currentTrack.info.codec = "aac"),
                              (this.currentTrack.info.aacCodecInfo = {
                                  isMpeg2: this.currentTrack.codecId.includes("MPEG2"),
                              }),
                              (this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate))
                            : this.currentTrack.codecId === AS.mp3
                              ? (this.currentTrack.info.codec = "mp3")
                              : t === AS.opus
                                ? ((this.currentTrack.info.codec = "opus"),
                                  (this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate),
                                  (this.currentTrack.info.sampleRate = p_))
                                : t === AS.vorbis
                                  ? ((this.currentTrack.info.codec = "vorbis"),
                                    (this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate))
                                  : t === AS.flac
                                    ? ((this.currentTrack.info.codec = "flac"),
                                      (this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate))
                                    : "A_PCM/INT/LIT" === this.currentTrack.codecId
                                      ? 8 === this.currentTrack.info.bitDepth
                                          ? (this.currentTrack.info.codec = "pcm-u8")
                                          : 16 === this.currentTrack.info.bitDepth
                                            ? (this.currentTrack.info.codec = "pcm-s16")
                                            : 24 === this.currentTrack.info.bitDepth
                                              ? (this.currentTrack.info.codec = "pcm-s24")
                                              : 32 === this.currentTrack.info.bitDepth &&
                                                (this.currentTrack.info.codec = "pcm-s32")
                                      : "A_PCM/INT/BIG" === this.currentTrack.codecId
                                        ? 8 === this.currentTrack.info.bitDepth
                                            ? (this.currentTrack.info.codec = "pcm-u8")
                                            : 16 === this.currentTrack.info.bitDepth
                                              ? (this.currentTrack.info.codec = "pcm-s16be")
                                              : 24 === this.currentTrack.info.bitDepth
                                                ? (this.currentTrack.info.codec = "pcm-s24be")
                                                : 32 === this.currentTrack.info.bitDepth &&
                                                  (this.currentTrack.info.codec = "pcm-s32be")
                                        : "A_PCM/FLOAT/IEEE" === this.currentTrack.codecId &&
                                          (32 === this.currentTrack.info.bitDepth
                                              ? (this.currentTrack.info.codec = "pcm-f32")
                                              : 64 === this.currentTrack.info.bitDepth &&
                                                (this.currentTrack.info.codec = "pcm-f64"));
                        const e = this.currentTrack,
                            n = new Bv(this.input, new WS(e));
                        (this.currentTrack.inputTrack = n), this.currentSegment.tracks.push(this.currentTrack);
                    }
                }
                this.currentTrack = null;
                break;
            case cS.TrackNumber:
                if (!this.currentTrack) break;
                this.currentTrack.id = kS(e, r);
                break;
            case cS.TrackType:
                {
                    if (!this.currentTrack) break;
                    const t = kS(e, r);
                    1 === t
                        ? (this.currentTrack.info = {
                              type: "video",
                              width: -1,
                              height: -1,
                              rotation: 0,
                              codec: null,
                              codecDescription: null,
                              colorSpace: null,
                              alphaMode: !1,
                          })
                        : 2 === t &&
                          (this.currentTrack.info = {
                              type: "audio",
                              numberOfChannels: -1,
                              sampleRate: -1,
                              bitDepth: -1,
                              codec: null,
                              codecDescription: null,
                              aacCodecInfo: null,
                          });
                }
                break;
            case cS.FlagEnabled:
                if (!this.currentTrack) break;
                kS(e, r) || (this.currentSegment.tracks.pop(), (this.currentTrack = null));
                break;
            case cS.FlagDefault:
                if (!this.currentTrack) break;
                this.currentTrack.isDefault = !!kS(e, r);
                break;
            case cS.CodecID:
                if (!this.currentTrack) break;
                this.currentTrack.codecId = SS(e, r);
                break;
            case cS.CodecPrivate:
                if (!this.currentTrack) break;
                this.currentTrack.codecPrivate = nC(e, r);
                break;
            case cS.DefaultDuration:
                if (!this.currentTrack) break;
                this.currentTrack.defaultDuration = (this.currentTrack.segment.timestampFactor * kS(e, r)) / 1e9;
                break;
            case cS.Name:
                if (!this.currentTrack) break;
                this.currentTrack.name = ES(e, r);
                break;
            case cS.Language:
                if (!this.currentTrack) break;
                if (this.currentTrack.languageCode !== vT) break;
                (this.currentTrack.languageCode = SS(e, r)),
                    IT(this.currentTrack.languageCode) || (this.currentTrack.languageCode = vT);
                break;
            case cS.LanguageBCP47:
                {
                    if (!this.currentTrack) break;
                    const t = SS(e, r).split("-")[0];
                    this.currentTrack.languageCode = t || vT;
                }
                break;
            case cS.Video:
                if ("video" !== this.currentTrack?.info?.type) break;
                this.readContiguousElements(e.slice(i, r));
                break;
            case cS.PixelWidth:
                if ("video" !== this.currentTrack?.info?.type) break;
                this.currentTrack.info.width = kS(e, r);
                break;
            case cS.PixelHeight:
                if ("video" !== this.currentTrack?.info?.type) break;
                this.currentTrack.info.height = kS(e, r);
                break;
            case cS.AlphaMode:
                if ("video" !== this.currentTrack?.info?.type) break;
                this.currentTrack.info.alphaMode = 1 === kS(e, r);
                break;
            case cS.Colour:
                if ("video" !== this.currentTrack?.info?.type) break;
                (this.currentTrack.info.colorSpace = {}), this.readContiguousElements(e.slice(i, r));
                break;
            case cS.MatrixCoefficients:
                {
                    if ("video" !== this.currentTrack?.info?.type || !this.currentTrack.info.colorSpace) break;
                    const t = kS(e, r),
                        n = aT[t] ?? null;
                    this.currentTrack.info.colorSpace.matrix = n;
                }
                break;
            case cS.Range:
                if ("video" !== this.currentTrack?.info?.type || !this.currentTrack.info.colorSpace) break;
                this.currentTrack.info.colorSpace.fullRange = 2 === kS(e, r);
                break;
            case cS.TransferCharacteristics:
                {
                    if ("video" !== this.currentTrack?.info?.type || !this.currentTrack.info.colorSpace) break;
                    const t = kS(e, r),
                        n = iT[t] ?? null;
                    this.currentTrack.info.colorSpace.transfer = n;
                }
                break;
            case cS.Primaries:
                {
                    if ("video" !== this.currentTrack?.info?.type || !this.currentTrack.info.colorSpace) break;
                    const t = kS(e, r),
                        n = nT[t] ?? null;
                    this.currentTrack.info.colorSpace.primaries = n;
                }
                break;
            case cS.Projection:
                if ("video" !== this.currentTrack?.info?.type) break;
                this.readContiguousElements(e.slice(i, r));
                break;
            case cS.ProjectionPoseRoll:
                {
                    if ("video" !== this.currentTrack?.info?.type) break;
                    const t = -CS(e, r);
                    try {
                        this.currentTrack.info.rotation = Wk(t);
                    } catch {}
                }
                break;
            case cS.Audio:
                if ("audio" !== this.currentTrack?.info?.type) break;
                this.readContiguousElements(e.slice(i, r));
                break;
            case cS.SamplingFrequency:
                if ("audio" !== this.currentTrack?.info?.type) break;
                this.currentTrack.info.sampleRate = CS(e, r);
                break;
            case cS.Channels:
                if ("audio" !== this.currentTrack?.info?.type) break;
                this.currentTrack.info.numberOfChannels = kS(e, r);
                break;
            case cS.BitDepth:
                if ("audio" !== this.currentTrack?.info?.type) break;
                this.currentTrack.info.bitDepth = kS(e, r);
                break;
            case cS.CuePoint:
                if (!this.currentSegment) break;
                this.readContiguousElements(e.slice(i, r)), (this.currentCueTime = null);
                break;
            case cS.CueTime:
                this.currentCueTime = kS(e, r);
                break;
            case cS.CueTrackPositions:
                {
                    if (null === this.currentCueTime) break;
                    Vk(this.currentSegment);
                    const t = { time: this.currentCueTime, trackId: -1, clusterPosition: -1 };
                    this.currentSegment.cuePoints.push(t),
                        this.readContiguousElements(e.slice(i, r)),
                        (-1 !== t.trackId && -1 !== t.clusterPosition) || this.currentSegment.cuePoints.pop();
                }
                break;
            case cS.CueTrack:
                {
                    const t = this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length - 1];
                    if (!t) break;
                    t.trackId = kS(e, r);
                }
                break;
            case cS.CueClusterPosition:
                {
                    const t = this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length - 1];
                    if (!t) break;
                    Vk(this.currentSegment), (t.clusterPosition = this.currentSegment.dataStartPos + kS(e, r));
                }
                break;
            case cS.Timestamp:
                if (!this.currentCluster) break;
                this.currentCluster.timestamp = kS(e, r);
                break;
            case cS.SimpleBlock:
                {
                    if (!this.currentCluster) break;
                    const t = wS(e);
                    if (null === t) break;
                    const n = this.getTrackDataInCluster(this.currentCluster, t);
                    if (!n) break;
                    const s = oC(e),
                        a = rC(e),
                        o = !!(128 & a),
                        c = (a >> 1) & 3,
                        l = nC(e, r - (e.filePos - i)),
                        u = n.track.decodingInstructions.length > 0;
                    n.blocks.push({
                        timestamp: s,
                        duration: 0,
                        isKeyFrame: o,
                        referencedTimestamps: [],
                        data: l,
                        lacing: c,
                        decoded: !u,
                        mainAdditional: null,
                    });
                }
                break;
            case cS.BlockGroup:
                if (!this.currentCluster) break;
                if ((this.readContiguousElements(e.slice(i, r)), this.currentBlock)) {
                    for (let e = 0; e < this.currentBlock.referencedTimestamps.length; e++)
                        this.currentBlock.referencedTimestamps[e] += this.currentBlock.timestamp;
                    this.currentBlock = null;
                }
                break;
            case cS.Block:
                {
                    if (!this.currentCluster) break;
                    const t = wS(e);
                    if (null === t) break;
                    const n = this.getTrackDataInCluster(this.currentCluster, t);
                    if (!n) break;
                    const s = oC(e),
                        a = (rC(e) >> 1) & 3,
                        o = nC(e, r - (e.filePos - i)),
                        c = n.track.decodingInstructions.length > 0;
                    (this.currentBlock = {
                        timestamp: s,
                        duration: 0,
                        isKeyFrame: !0,
                        referencedTimestamps: [],
                        data: o,
                        lacing: a,
                        decoded: !c,
                        mainAdditional: null,
                    }),
                        n.blocks.push(this.currentBlock);
                }
                break;
            case cS.BlockAdditions:
                this.readContiguousElements(e.slice(i, r));
                break;
            case cS.BlockMore:
                if (!this.currentBlock) break;
                (this.currentBlockAdditional = { addId: 1, data: null }),
                    this.readContiguousElements(e.slice(i, r)),
                    this.currentBlockAdditional.data &&
                        1 === this.currentBlockAdditional.addId &&
                        (this.currentBlock.mainAdditional = this.currentBlockAdditional.data),
                    (this.currentBlockAdditional = null);
                break;
            case cS.BlockAdditional:
                if (!this.currentBlockAdditional) break;
                this.currentBlockAdditional.data = nC(e, r);
                break;
            case cS.BlockAddID:
                if (!this.currentBlockAdditional) break;
                this.currentBlockAdditional.addId = kS(e, r);
                break;
            case cS.BlockDuration:
                if (!this.currentBlock) break;
                this.currentBlock.duration = kS(e, r);
                break;
            case cS.ReferenceBlock:
                {
                    if (!this.currentBlock) break;
                    this.currentBlock.isKeyFrame = !1;
                    const t = ((e, t) => {
                        let n = kS(e, t);
                        return n & (1 << (8 * t - 1)) && (n -= 2 ** (8 * t)), n;
                    })(e, r);
                    this.currentBlock.referencedTimestamps.push(t);
                }
                break;
            case cS.Tag:
                (this.currentTagTargetIsMovie = !0), this.readContiguousElements(e.slice(i, r));
                break;
            case cS.Targets:
                this.readContiguousElements(e.slice(i, r));
                break;
            case cS.TargetTypeValue:
                50 !== kS(e, r) && (this.currentTagTargetIsMovie = !1);
                break;
            case cS.TagTrackUID:
            case cS.TagEditionUID:
            case cS.TagChapterUID:
            case cS.TagAttachmentUID:
                this.currentTagTargetIsMovie = !1;
                break;
            case cS.SimpleTag:
                if (!this.currentTagTargetIsMovie) break;
                (this.currentSimpleTagName = null), this.readContiguousElements(e.slice(i, r));
                break;
            case cS.TagName:
                this.currentSimpleTagName = ES(e, r);
                break;
            case cS.TagString:
                {
                    if (!this.currentSimpleTagName) break;
                    const t = ES(e, r);
                    this.processTagValue(this.currentSimpleTagName, t);
                }
                break;
            case cS.TagBinary:
                {
                    if (!this.currentSimpleTagName) break;
                    const t = nC(e, r);
                    this.processTagValue(this.currentSimpleTagName, t);
                }
                break;
            case cS.AttachedFile:
                {
                    if (!this.currentSegment) break;
                    (this.currentAttachedFile = {
                        fileUid: null,
                        fileName: null,
                        fileMediaType: null,
                        fileData: null,
                        fileDescription: null,
                    }),
                        this.readContiguousElements(e.slice(i, r));
                    const t = this.currentSegment.metadataTags;
                    if (
                        (this.currentAttachedFile.fileUid &&
                            this.currentAttachedFile.fileData &&
                            ((t.raw ??= {}),
                            (t.raw[this.currentAttachedFile.fileUid.toString()] = new qT(
                                this.currentAttachedFile.fileData,
                                this.currentAttachedFile.fileMediaType ?? void 0,
                                this.currentAttachedFile.fileName ?? void 0,
                                this.currentAttachedFile.fileDescription ?? void 0
                            ))),
                        this.currentAttachedFile.fileMediaType?.startsWith("image/") &&
                            this.currentAttachedFile.fileData)
                    ) {
                        const e = this.currentAttachedFile.fileName;
                        let n = "unknown";
                        if (e) {
                            const t = e.toLowerCase();
                            t.startsWith("cover.") ? (n = "coverFront") : t.startsWith("back.") && (n = "coverBack");
                        }
                        (t.images ??= []),
                            t.images.push({
                                data: this.currentAttachedFile.fileData,
                                mimeType: this.currentAttachedFile.fileMediaType,
                                kind: n,
                                name: this.currentAttachedFile.fileName ?? void 0,
                                description: this.currentAttachedFile.fileDescription ?? void 0,
                            });
                    }
                    this.currentAttachedFile = null;
                }
                break;
            case cS.FileUID:
                if (!this.currentAttachedFile) break;
                this.currentAttachedFile.fileUid = ((e, t) => {
                    if (t < 1) throw new Error("Bad unsigned int size " + t);
                    let n = 0n;
                    for (let r = 0; r < t; r++) (n <<= 8n), (n += BigInt(rC(e)));
                    return n;
                })(e, r);
                break;
            case cS.FileName:
                if (!this.currentAttachedFile) break;
                this.currentAttachedFile.fileName = ES(e, r);
                break;
            case cS.FileMediaType:
                if (!this.currentAttachedFile) break;
                this.currentAttachedFile.fileMediaType = SS(e, r);
                break;
            case cS.FileData:
                if (!this.currentAttachedFile) break;
                this.currentAttachedFile.fileData = nC(e, r);
                break;
            case cS.FileDescription:
                if (!this.currentAttachedFile) break;
                this.currentAttachedFile.fileDescription = ES(e, r);
                break;
            case cS.ContentEncodings:
                if (!this.currentTrack) break;
                this.readContiguousElements(e.slice(i, r)),
                    this.currentTrack.decodingInstructions.sort((e, t) => t.order - e.order);
                break;
            case cS.ContentEncoding:
                (this.currentDecodingInstruction = { order: 0, scope: MS.Block, data: null }),
                    this.readContiguousElements(e.slice(i, r)),
                    this.currentDecodingInstruction.data &&
                        this.currentTrack.decodingInstructions.push(this.currentDecodingInstruction),
                    (this.currentDecodingInstruction = null);
                break;
            case cS.ContentEncodingOrder:
                if (!this.currentDecodingInstruction) break;
                this.currentDecodingInstruction.order = kS(e, r);
                break;
            case cS.ContentEncodingScope:
                if (!this.currentDecodingInstruction) break;
                this.currentDecodingInstruction.scope = kS(e, r);
                break;
            case cS.ContentCompression:
                if (!this.currentDecodingInstruction) break;
                (this.currentDecodingInstruction.data = { type: "decompress", algorithm: FS.Zlib, settings: null }),
                    this.readContiguousElements(e.slice(i, r));
                break;
            case cS.ContentCompAlgo:
                if ("decompress" !== this.currentDecodingInstruction?.data?.type) break;
                this.currentDecodingInstruction.data.algorithm = kS(e, r);
                break;
            case cS.ContentCompSettings:
                if ("decompress" !== this.currentDecodingInstruction?.data?.type) break;
                this.currentDecodingInstruction.data.settings = nC(e, r);
                break;
            case cS.ContentEncryption:
                if (!this.currentDecodingInstruction) break;
                this.currentDecodingInstruction.data = { type: "decrypt" };
        }
        return (e.filePos = i + r), !0;
    }
    decodeBlockData(e, t) {
        Vk(e.decodingInstructions.length > 0);
        let n = t;
        for (const r of e.decodingInstructions)
            if ((Vk(r.data), "decompress" === r.data.type))
                if (r.data.algorithm === FS.HeaderStripping)
                    if (r.data.settings && r.data.settings.length > 0) {
                        const e = r.data.settings,
                            t = new Uint8Array(e.length + n.length);
                        t.set(e, 0), t.set(n, e.length), (n = t);
                    }
        return n;
    }
    processTagValue(e, t) {
        if (!this.currentSegment?.metadataTags) return;
        const n = this.currentSegment.metadataTags;
        if (((n.raw ??= {}), (n.raw[e] ??= t), "string" == typeof t))
            switch (e.toLowerCase()) {
                case "title":
                    n.title ??= t;
                    break;
                case "description":
                    n.description ??= t;
                    break;
                case "artist":
                    n.artist ??= t;
                    break;
                case "album":
                    n.album ??= t;
                    break;
                case "album_artist":
                    n.albumArtist ??= t;
                    break;
                case "genre":
                    n.genre ??= t;
                    break;
                case "comment":
                    n.comment ??= t;
                    break;
                case "lyrics":
                    n.lyrics ??= t;
                    break;
                case "date":
                    {
                        const e = new Date(t);
                        Number.isNaN(e.getTime()) || (n.date ??= e);
                    }
                    break;
                case "track_number":
                case "part_number":
                    {
                        const e = t.split("/"),
                            r = Number.parseInt(e[0], 10),
                            i = e[1] && Number.parseInt(e[1], 10);
                        Number.isInteger(r) && r > 0 && (n.trackNumber ??= r),
                            i && Number.isInteger(i) && i > 0 && (n.tracksTotal ??= i);
                    }
                    break;
                case "disc_number":
                case "disc": {
                    const e = t.split("/"),
                        r = Number.parseInt(e[0], 10),
                        i = e[1] && Number.parseInt(e[1], 10);
                    Number.isInteger(r) && r > 0 && (n.discNumber ??= r),
                        i && Number.isInteger(i) && i > 0 && (n.discsTotal ??= i);
                }
            }
    }
}
class $S {
    constructor(e) {
        (this.internalTrack = e), (this.packetToClusterLocation = new WeakMap());
    }
    getId() {
        return this.internalTrack.id;
    }
    getCodec() {
        throw new Error("Not implemented on base class.");
    }
    getInternalCodecId() {
        return this.internalTrack.codecId;
    }
    async computeDuration() {
        const e = await this.getPacket(1 / 0, { metadataOnly: !0 });
        return (e?.timestamp ?? 0) + (e?.duration ?? 0);
    }
    getName() {
        return this.internalTrack.name;
    }
    getLanguageCode() {
        return this.internalTrack.languageCode;
    }
    async getFirstTimestamp() {
        const e = await this.getFirstPacket({ metadataOnly: !0 });
        return e?.timestamp ?? 0;
    }
    getTimeResolution() {
        return this.internalTrack.segment.timestampFactor;
    }
    async getFirstPacket(e) {
        return this.performClusterLookup(
            null,
            (e) =>
                e.trackData.get(this.internalTrack.id)
                    ? { blockIndex: 0, correctBlockFound: !0 }
                    : { blockIndex: -1, correctBlockFound: !1 },
            -1 / 0,
            1 / 0,
            e
        );
    }
    intoTimescale(e) {
        return ST(e * this.internalTrack.segment.timestampFactor, 14);
    }
    async getPacket(e, t) {
        const n = this.intoTimescale(e);
        return this.performClusterLookup(
            null,
            (e) => {
                const t = e.trackData.get(this.internalTrack.id);
                if (!t) return { blockIndex: -1, correctBlockFound: !1 };
                const r = mT(t.presentationTimestamps, n, (e) => e.timestamp);
                return {
                    blockIndex: -1 !== r ? t.presentationTimestamps[r].blockIndex : -1,
                    correctBlockFound: -1 !== r && n < t.endTimestamp,
                };
            },
            n,
            n,
            t
        );
    }
    async getNextPacket(e, t) {
        const n = this.packetToClusterLocation.get(e);
        if (void 0 === n) throw new Error("Packet was not created from this track.");
        return this.performClusterLookup(
            n.cluster,
            (e) => {
                if (e === n.cluster) {
                    const t = e.trackData.get(this.internalTrack.id);
                    if (n.blockIndex + 1 < t.blocks.length)
                        return { blockIndex: n.blockIndex + 1, correctBlockFound: !0 };
                } else {
                    if (e.trackData.get(this.internalTrack.id)) return { blockIndex: 0, correctBlockFound: !0 };
                }
                return { blockIndex: -1, correctBlockFound: !1 };
            },
            -1 / 0,
            1 / 0,
            t
        );
    }
    async getKeyPacket(e, t) {
        const n = this.intoTimescale(e);
        return this.performClusterLookup(
            null,
            (e) => {
                const t = e.trackData.get(this.internalTrack.id);
                if (!t) return { blockIndex: -1, correctBlockFound: !1 };
                const r = bT(t.presentationTimestamps, (e) => t.blocks[e.blockIndex].isKeyFrame && e.timestamp <= n);
                return {
                    blockIndex: -1 !== r ? t.presentationTimestamps[r].blockIndex : -1,
                    correctBlockFound: -1 !== r && n < t.endTimestamp,
                };
            },
            n,
            n,
            t
        );
    }
    async getNextKeyPacket(e, t) {
        const n = this.packetToClusterLocation.get(e);
        if (void 0 === n) throw new Error("Packet was not created from this track.");
        return this.performClusterLookup(
            n.cluster,
            (e) => {
                if (e === n.cluster) {
                    const t = e.trackData
                        .get(this.internalTrack.id)
                        .blocks.findIndex((e, t) => e.isKeyFrame && t > n.blockIndex);
                    if (-1 !== t) return { blockIndex: t, correctBlockFound: !0 };
                } else {
                    const t = e.trackData.get(this.internalTrack.id);
                    if (t && null !== t.firstKeyFrameTimestamp) {
                        const e = t.blocks.findIndex((e) => e.isKeyFrame);
                        return Vk(-1 !== e), { blockIndex: e, correctBlockFound: !0 };
                    }
                }
                return { blockIndex: -1, correctBlockFound: !1 };
            },
            -1 / 0,
            1 / 0,
            t
        );
    }
    async fetchPacketInCluster(e, t, n) {
        if (-1 === t) return null;
        const r = e.trackData.get(this.internalTrack.id).blocks[t];
        Vk(r),
            r.decoded ||
                ((r.data = this.internalTrack.demuxer.decodeBlockData(this.internalTrack, r.data)), (r.decoded = !0));
        const i = n.metadataOnly ? cv : r.data,
            s = r.timestamp / this.internalTrack.segment.timestampFactor,
            a = r.duration / this.internalTrack.segment.timestampFactor,
            o = {};
        r.mainAdditional &&
            "video" === this.internalTrack.info?.type &&
            this.internalTrack.info.alphaMode &&
            ((o.alpha = n.metadataOnly ? cv : r.mainAdditional), (o.alphaByteLength = r.mainAdditional.byteLength));
        const c = new lv(i, r.isKeyFrame ? "key" : "delta", s, a, e.dataStartPos + t, r.data.byteLength, o);
        return this.packetToClusterLocation.set(c, { cluster: e, blockIndex: t }), c;
    }
    async performClusterLookup(e, t, n, r, i) {
        const { demuxer: s, segment: a } = this.internalTrack;
        let o = null,
            c = null,
            l = -1;
        if (e) {
            const { blockIndex: n, correctBlockFound: r } = t(e);
            if (r) return this.fetchPacketInCluster(e, n, i);
            -1 !== n && ((c = e), (l = n));
        }
        const u = mT(this.internalTrack.cuePoints, n, (e) => e.time),
            d = -1 !== u ? this.internalTrack.cuePoints[u] : null,
            h = mT(this.internalTrack.clusterPositionCache, n, (e) => e.startTimestamp),
            m = -1 !== h ? this.internalTrack.clusterPositionCache[h] : null,
            p = Math.max(d?.clusterPosition ?? 0, m?.elementStartPos ?? 0) || null;
        let f;
        for (
            e
                ? null === p || e.elementStartPos >= p
                    ? ((f = e.elementEndPos), (o = e))
                    : (f = p)
                : (f = p ?? a.clusterSeekStartPos);
            null === a.elementEndPos || f <= a.elementEndPos - 2;

        ) {
            if (o) {
                const e = o.trackData.get(this.internalTrack.id);
                if (e && e.startTimestamp > r) break;
            }
            let e = s.reader.requestSliceRange(f, 2, bS);
            if ((e instanceof Promise && (e = await e), !e)) break;
            const n = f,
                u = vS(e);
            if (!u || (!dS.includes(u.id) && u.id !== cS.Void)) {
                const e = await xS(s.reader, n, dS, Math.min(a.elementEndPos ?? 1 / 0, n + zS));
                if (e) {
                    f = e;
                    continue;
                }
                break;
            }
            const d = u.id;
            let h = u.size;
            const m = e.filePos;
            if (d === cS.Cluster) {
                o = await s.readCluster(n, a);
                const { blockIndex: e, correctBlockFound: r } = t(o);
                if (r) return this.fetchPacketInCluster(o, e, i);
                -1 !== e && ((c = o), (l = e));
            }
            if (null === h) {
                if (d === cS.Cluster) Vk(o), (h = o.elementEndPos - m);
                else {
                    h = (await IS(s.reader, m, hS, a.elementEndPos)).pos - m;
                }
                const e = m + h;
                if (null !== a.elementEndPos && e > a.elementEndPos - 2) break;
                {
                    let t = s.reader.requestSliceRange(e, 2, bS);
                    if ((t instanceof Promise && (t = await t), !t)) break;
                    if (TS(t) === cS.Segment) {
                        a.elementEndPos = e;
                        break;
                    }
                }
            }
            f = m + h;
        }
        if (d && (!c || c.elementStartPos < d.clusterPosition)) {
            const e = this.internalTrack.cuePoints[u - 1];
            Vk(!e || e.time < d.time);
            const n = e?.time ?? -1 / 0;
            return this.performClusterLookup(null, t, n, r, i);
        }
        return c ? this.fetchPacketInCluster(c, l, i) : null;
    }
}
class VS extends $S {
    constructor(e) {
        super(e), (this.decoderConfigPromise = null), (this.internalTrack = e);
    }
    getCodec() {
        return this.internalTrack.info.codec;
    }
    getCodedWidth() {
        return this.internalTrack.info.width;
    }
    getCodedHeight() {
        return this.internalTrack.info.height;
    }
    getRotation() {
        return this.internalTrack.info.rotation;
    }
    async getColorSpace() {
        return {
            primaries: this.internalTrack.info.colorSpace?.primaries,
            transfer: this.internalTrack.info.colorSpace?.transfer,
            matrix: this.internalTrack.info.colorSpace?.matrix,
            fullRange: this.internalTrack.info.colorSpace?.fullRange,
        };
    }
    async canBeTransparent() {
        return this.internalTrack.info.alphaMode;
    }
    async getDecoderConfig() {
        return this.internalTrack.info.codec
            ? (this.decoderConfigPromise ??= (async () => {
                  let e = null;
                  return (
                      ("vp9" === this.internalTrack.info.codec ||
                          "av1" === this.internalTrack.info.codec ||
                          ("avc" === this.internalTrack.info.codec && !this.internalTrack.info.codecDescription) ||
                          ("hevc" === this.internalTrack.info.codec && !this.internalTrack.info.codecDescription)) &&
                          (e = await this.getFirstPacket({})),
                      {
                          codec: c_({
                              width: this.internalTrack.info.width,
                              height: this.internalTrack.info.height,
                              codec: this.internalTrack.info.codec,
                              codecDescription: this.internalTrack.info.codecDescription,
                              colorSpace: this.internalTrack.info.colorSpace,
                              avcCodecInfo: "avc" === this.internalTrack.info.codec && e ? F_(e.data) : null,
                              hevcCodecInfo: "hevc" === this.internalTrack.info.codec && e ? z_(e.data) : null,
                              vp9CodecInfo: "vp9" === this.internalTrack.info.codec && e ? X_(e.data) : null,
                              av1CodecInfo: "av1" === this.internalTrack.info.codec && e ? K_(e.data) : null,
                          }),
                          codedWidth: this.internalTrack.info.width,
                          codedHeight: this.internalTrack.info.height,
                          description: this.internalTrack.info.codecDescription ?? void 0,
                          colorSpace: this.internalTrack.info.colorSpace ?? void 0,
                      }
                  );
              })())
            : null;
    }
}
class WS extends $S {
    constructor(e) {
        super(e), (this.decoderConfig = null), (this.internalTrack = e);
    }
    getCodec() {
        return this.internalTrack.info.codec;
    }
    getNumberOfChannels() {
        return this.internalTrack.info.numberOfChannels;
    }
    getSampleRate() {
        return this.internalTrack.info.sampleRate;
    }
    async getDecoderConfig() {
        return this.internalTrack.info.codec
            ? (this.decoderConfig ??= {
                  codec: u_({
                      codec: this.internalTrack.info.codec,
                      codecDescription: this.internalTrack.info.codecDescription,
                      aacCodecInfo: this.internalTrack.info.aacCodecInfo,
                  }),
                  numberOfChannels: this.internalTrack.info.numberOfChannels,
                  sampleRate: this.internalTrack.info.sampleRate,
                  description: this.internalTrack.info.codecDescription ?? void 0,
              })
            : null;
    }
}
const jS = (e) => {
        const t = new Map();
        for (let s = 0; s < e.length; s++) {
            const n = e[s];
            t.set(n.timestamp, n);
        }
        const n = new Set(),
            r = [],
            i = (e) => {
                if (!n.has(e)) {
                    n.add(e);
                    for (let n = 0; n < e.referencedTimestamps.length; n++) {
                        const r = e.referencedTimestamps[n],
                            s = t.get(r);
                        s && i(s);
                    }
                    r.push(e);
                }
            };
        for (let s = 0; s < e.length; s++) i(e[s]);
        return r;
    },
    HS = [44100, 48e3, 32e3],
    qS = [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160,
        192, 224, 256, 320, -1, -1, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1, -1, 32, 64, 96,
        128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1, -1, 8, 16, 24, 32, 40, 48, 56,
        64, 80, 96, 112, 128, 144, 160, -1, -1, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, -1,
    ],
    XS = (e, t) => {
        const n = e >>> 24,
            r = (e >>> 16) & 255,
            i = (e >>> 8) & 255,
            s = 255 & e;
        if (255 !== n && 255 !== r && 255 !== i && 255 !== s) return { header: null, bytesAdvanced: 4 };
        if (255 !== n) return { header: null, bytesAdvanced: 1 };
        if (224 & ~r) return { header: null, bytesAdvanced: 1 };
        let a = 0,
            o = 0;
        16 & r ? (a = 8 & r ? 0 : 1) : ((a = 1), (o = 1));
        const c = (r >> 3) & 3,
            l = (r >> 1) & 3,
            u = ((i >> 2) & 3) % 3,
            d = (s >> 6) & 3,
            h = (s >> 4) & 3,
            m = (s >> 3) & 1,
            p = (s >> 2) & 1,
            f = 3 & s,
            g = qS[16 * a * 4 + 16 * l + ((i >> 4) & 15)];
        if (-1 === g) return { header: null, bytesAdvanced: 1 };
        const b = 1e3 * g,
            y = HS[u] >> (a + o),
            w = ((e, t, n, r, i) =>
                0 === t
                    ? 0
                    : 1 === t
                      ? Math.floor((144 * n) / (r << e)) + i
                      : 2 === t
                        ? Math.floor((144 * n) / r) + i
                        : 4 * (Math.floor((12 * n) / r) + i))(a, l, b, y, (i >> 1) & 1);
        if (null !== t && t < w) return { header: null, bytesAdvanced: 1 };
        let k;
        return (
            (k = 3 === c ? (3 === l ? 384 : 1152) : 3 === l ? 384 : 2 === l ? 1152 : 576),
            {
                header: {
                    totalSize: w,
                    mpegVersionId: c,
                    layer: l,
                    bitrate: b,
                    frequencyIndex: u,
                    sampleRate: y,
                    channel: d,
                    modeExtension: h,
                    copyright: m,
                    original: p,
                    emphasis: f,
                    audioSamplesInFrame: k,
                },
                bytesAdvanced: 1,
            }
        );
    },
    GS = (e) => {
        let t = 2130706432,
            n = 0;
        for (; 0 !== t; ) (n >>= 1), (n |= e & t), (t >>= 8);
        return n;
    };
var KS, YS, QS, JS;
((YS = KS || (KS = {}))[(YS.Unsynchronisation = 128)] = "Unsynchronisation"),
    (YS[(YS.ExtendedHeader = 64)] = "ExtendedHeader"),
    (YS[(YS.ExperimentalIndicator = 32)] = "ExperimentalIndicator"),
    (YS[(YS.Footer = 16)] = "Footer"),
    ((JS = QS || (QS = {}))[(JS.ISO_8859_1 = 0)] = "ISO_8859_1"),
    (JS[(JS.UTF_16_WITH_BOM = 1)] = "UTF_16_WITH_BOM"),
    (JS[(JS.UTF_16_BE_NO_BOM = 2)] = "UTF_16_BE_NO_BOM"),
    (JS[(JS.UTF_8 = 3)] = "UTF_8");
const ZS = 128,
    eE = [
        "Blues",
        "Classic rock",
        "Country",
        "Dance",
        "Disco",
        "Funk",
        "Grunge",
        "Hip-hop",
        "Jazz",
        "Metal",
        "New age",
        "Oldies",
        "Other",
        "Pop",
        "Rhythm and blues",
        "Rap",
        "Reggae",
        "Rock",
        "Techno",
        "Industrial",
        "Alternative",
        "Ska",
        "Death metal",
        "Pranks",
        "Soundtrack",
        "Euro-techno",
        "Ambient",
        "Trip-hop",
        "Vocal",
        "Jazz & funk",
        "Fusion",
        "Trance",
        "Classical",
        "Instrumental",
        "Acid",
        "House",
        "Game",
        "Sound clip",
        "Gospel",
        "Noise",
        "Alternative rock",
        "Bass",
        "Soul",
        "Punk",
        "Space",
        "Meditative",
        "Instrumental pop",
        "Instrumental rock",
        "Ethnic",
        "Gothic",
        "Darkwave",
        "Techno-industrial",
        "Electronic",
        "Pop-folk",
        "Eurodance",
        "Dream",
        "Southern rock",
        "Comedy",
        "Cult",
        "Gangsta",
        "Top 40",
        "Christian rap",
        "Pop/funk",
        "Jungle music",
        "Native US",
        "Cabaret",
        "New wave",
        "Psychedelic",
        "Rave",
        "Showtunes",
        "Trailer",
        "Lo-fi",
        "Tribal",
        "Acid punk",
        "Acid jazz",
        "Polka",
        "Retro",
        "Musical",
        "Rock 'n' roll",
        "Hard rock",
        "Folk",
        "Folk rock",
        "National folk",
        "Swing",
        "Fast fusion",
        "Bebop",
        "Latin",
        "Revival",
        "Celtic",
        "Bluegrass",
        "Avantgarde",
        "Gothic rock",
        "Progressive rock",
        "Psychedelic rock",
        "Symphonic rock",
        "Slow rock",
        "Big band",
        "Chorus",
        "Easy listening",
        "Acoustic",
        "Humour",
        "Speech",
        "Chanson",
        "Opera",
        "Chamber music",
        "Sonata",
        "Symphony",
        "Booty bass",
        "Primus",
        "Porn groove",
        "Satire",
        "Slow jam",
        "Club",
        "Tango",
        "Samba",
        "Folklore",
        "Ballad",
        "Power ballad",
        "Rhythmic Soul",
        "Freestyle",
        "Duet",
        "Punk rock",
        "Drum solo",
        "A cappella",
        "Euro-house",
        "Dance hall",
        "Goa music",
        "Drum & bass",
        "Club-house",
        "Hardcore techno",
        "Terror",
        "Indie",
        "Britpop",
        "Negerpunk",
        "Polsk punk",
        "Beat",
        "Christian gangsta rap",
        "Heavy metal",
        "Black metal",
        "Crossover",
        "Contemporary Christian",
        "Christian rock",
        "Merengue",
        "Salsa",
        "Thrash metal",
        "Anime",
        "Jpop",
        "Synthpop",
        "Christmas",
        "Art rock",
        "Baroque",
        "Bhangra",
        "Big beat",
        "Breakbeat",
        "Chillout",
        "Downtempo",
        "Dub",
        "EBM",
        "Eclectic",
        "Electro",
        "Electroclash",
        "Emo",
        "Experimental",
        "Garage",
        "Global",
        "IDM",
        "Illbient",
        "Industro-Goth",
        "Jam Band",
        "Krautrock",
        "Leftfield",
        "Lounge",
        "Math rock",
        "New romantic",
        "Nu-breakz",
        "Post-punk",
        "Post-rock",
        "Psytrance",
        "Shoegaze",
        "Space rock",
        "Trop rock",
        "World music",
        "Neoclassical",
        "Audiobook",
        "Audio theatre",
        "Neue Deutsche Welle",
        "Podcast",
        "Indie rock",
        "G-Funk",
        "Dubstep",
        "Garage rock",
        "Psybient",
    ],
    tE = (e, t) => {
        const n = nC(e, t),
            r = LT(n.indexOf(0), n.length),
            i = n.subarray(0, r);
        let s = "";
        for (let a = 0; a < i.length; a++) s += String.fromCharCode(i[a]);
        return s.trimEnd();
    },
    nE = (e) => {
        const t = e.filePos,
            n = yC(e, 3),
            r = rC(e),
            i = rC(e),
            s = rC(e),
            a = lC(e);
        if ("ID3" !== n || 255 === r || 255 === i || 2155905152 & a) return (e.filePos = t), null;
        return { majorVersion: r, revision: i, flags: s, size: GS(a) };
    },
    rE = (e, t, n) => {
        if (![2, 3, 4].includes(t.majorVersion)) return;
        const r = nC(e, t.size),
            i = new iE(t, r);
        if (
            (t.flags & KS.Footer && i.removeFooter(),
            t.flags & KS.Unsynchronisation && 3 === t.majorVersion && i.ununsynchronizeAll(),
            t.flags & KS.ExtendedHeader)
        ) {
            const e = i.readU32();
            3 === t.majorVersion ? (i.pos += e) : (i.pos += e - 4);
        }
        for (; i.pos <= i.bytes.length - i.frameHeaderSize(); ) {
            const e = i.readId3V2Frame();
            if (!e) break;
            const r = i.pos,
                s = i.pos + e.size;
            let a = !1,
                o = !1,
                c = !1;
            if (
                (3 === t.majorVersion
                    ? ((a = !!(64 & e.flags)), (o = !!(128 & e.flags)))
                    : 4 === t.majorVersion &&
                      ((a = !!(4 & e.flags)),
                      (o = !!(8 & e.flags)),
                      (c = !!(2 & e.flags) || !!(t.flags & KS.Unsynchronisation))),
                a)
            )
                i.pos = s;
            else if (o) i.pos = s;
            else {
                switch (
                    (c && i.ununsynchronizeRegion(i.pos, s),
                    (n.raw ??= {}),
                    "T" === e.id[0]
                        ? (n.raw[e.id] ??= i.readId3V2EncodingAndText(s))
                        : (n.raw[e.id] ??= i.readBytes(e.size)),
                    (i.pos = r),
                    e.id)
                ) {
                    case "TIT2":
                    case "TT2":
                        n.title ??= i.readId3V2EncodingAndText(s);
                        break;
                    case "TIT3":
                    case "TT3":
                        n.description ??= i.readId3V2EncodingAndText(s);
                        break;
                    case "TPE1":
                    case "TP1":
                        n.artist ??= i.readId3V2EncodingAndText(s);
                        break;
                    case "TALB":
                    case "TAL":
                        n.album ??= i.readId3V2EncodingAndText(s);
                        break;
                    case "TPE2":
                    case "TP2":
                        n.albumArtist ??= i.readId3V2EncodingAndText(s);
                        break;
                    case "TRCK":
                    case "TRK":
                        {
                            const e = i.readId3V2EncodingAndText(s).split("/"),
                                t = Number.parseInt(e[0], 10),
                                r = e[1] && Number.parseInt(e[1], 10);
                            Number.isInteger(t) && t > 0 && (n.trackNumber ??= t),
                                r && Number.isInteger(r) && r > 0 && (n.tracksTotal ??= r);
                        }
                        break;
                    case "TPOS":
                    case "TPA":
                        {
                            const e = i.readId3V2EncodingAndText(s).split("/"),
                                t = Number.parseInt(e[0], 10),
                                r = e[1] && Number.parseInt(e[1], 10);
                            Number.isInteger(t) && t > 0 && (n.discNumber ??= t),
                                r && Number.isInteger(r) && r > 0 && (n.discsTotal ??= r);
                        }
                        break;
                    case "TCON":
                    case "TCO":
                        {
                            const e = i.readId3V2EncodingAndText(s);
                            let t = /^\((\d+)\)/.exec(e);
                            if (t) {
                                const e = Number.parseInt(t[1]);
                                if (void 0 !== eE[e]) {
                                    n.genre ??= eE[e];
                                    break;
                                }
                            }
                            if (((t = /^\d+$/.exec(e)), t)) {
                                const e = Number.parseInt(t[0]);
                                if (void 0 !== eE[e]) {
                                    n.genre ??= eE[e];
                                    break;
                                }
                            }
                            n.genre ??= e;
                        }
                        break;
                    case "TDRC":
                    case "TDAT":
                        {
                            const e = i.readId3V2EncodingAndText(s),
                                t = new Date(e);
                            Number.isNaN(t.getTime()) || (n.date ??= t);
                        }
                        break;
                    case "TYER":
                    case "TYE":
                        {
                            const e = i.readId3V2EncodingAndText(s),
                                t = Number.parseInt(e, 10);
                            Number.isInteger(t) && (n.date ??= new Date(t, 0, 1));
                        }
                        break;
                    case "USLT":
                    case "ULT":
                        {
                            const e = i.readU8();
                            (i.pos += 3), i.readId3V2Text(e, s), (n.lyrics ??= i.readId3V2Text(e, s));
                        }
                        break;
                    case "COMM":
                    case "COM":
                        {
                            const e = i.readU8();
                            (i.pos += 3), i.readId3V2Text(e, s), (n.comment ??= i.readId3V2Text(e, s));
                        }
                        break;
                    case "APIC":
                    case "PIC":
                        {
                            const e = i.readId3V2TextEncoding();
                            let r;
                            if (2 === t.majorVersion) {
                                const e = i.readAscii(3);
                                r = "PNG" === e ? "image/png" : "JPG" === e ? "image/jpeg" : "image/*";
                            } else r = i.readId3V2Text(e, s);
                            const a = i.readU8(),
                                o = i.readId3V2Text(e, s).trimEnd(),
                                c = s - i.pos;
                            if (c >= 0) {
                                const e = i.readBytes(c);
                                n.images || (n.images = []),
                                    n.images.push({
                                        data: e,
                                        mimeType: r,
                                        kind: 3 === a ? "coverFront" : 4 === a ? "coverBack" : "unknown",
                                        description: o,
                                    });
                            }
                        }
                        break;
                    default:
                        i.pos += e.size;
                }
                i.pos = s;
            }
        }
    };
class iE {
    constructor(e, t) {
        (this.header = e),
            (this.bytes = t),
            (this.pos = 0),
            (this.view = new DataView(t.buffer, t.byteOffset, t.byteLength));
    }
    frameHeaderSize() {
        return 2 === this.header.majorVersion ? 6 : 10;
    }
    ununsynchronizeAll() {
        const e = [];
        for (let t = 0; t < this.bytes.length; t++) {
            const n = this.bytes[t];
            if ((e.push(n), 255 === n && t !== this.bytes.length - 1)) {
                0 === this.bytes[t] && t++;
            }
        }
        (this.bytes = new Uint8Array(e)), (this.view = new DataView(this.bytes.buffer));
    }
    ununsynchronizeRegion(e, t) {
        const n = [];
        for (let s = e; s < t; s++) {
            const e = this.bytes[s];
            if ((n.push(e), 255 === e && s !== t - 1)) {
                0 === this.bytes[s + 1] && s++;
            }
        }
        const r = this.bytes.subarray(0, e),
            i = this.bytes.subarray(t);
        (this.bytes = new Uint8Array(r.length + n.length + i.length)),
            this.bytes.set(r, 0),
            this.bytes.set(n, r.length),
            this.bytes.set(i, r.length + n.length),
            (this.view = new DataView(this.bytes.buffer));
    }
    removeFooter() {
        (this.bytes = this.bytes.subarray(0, this.bytes.length - 10)), (this.view = new DataView(this.bytes.buffer));
    }
    readBytes(e) {
        const t = this.bytes.subarray(this.pos, this.pos + e);
        return (this.pos += e), t;
    }
    readU8() {
        const e = this.view.getUint8(this.pos);
        return (this.pos += 1), e;
    }
    readU16() {
        const e = this.view.getUint16(this.pos, !1);
        return (this.pos += 2), e;
    }
    readU24() {
        const e = this.view.getUint16(this.pos, !1),
            t = this.view.getUint8(this.pos + 1);
        return (this.pos += 3), 256 * e + t;
    }
    readU32() {
        const e = this.view.getUint32(this.pos, !1);
        return (this.pos += 4), e;
    }
    readAscii(e) {
        let t = "";
        for (let n = 0; n < e; n++) t += String.fromCharCode(this.view.getUint8(this.pos + n));
        return (this.pos += e), t;
    }
    readId3V2Frame() {
        if (2 === this.header.majorVersion) {
            const e = this.readAscii(3);
            if ("\0\0\0" === e) return null;
            return { id: e, size: this.readU24(), flags: 0 };
        }
        {
            const e = this.readAscii(4);
            if ("\0\0\0\0" === e) return null;
            const t = this.readU32();
            let n = 4 === this.header.majorVersion ? GS(t) : t;
            const r = this.readU16(),
                i = this.pos,
                s = (e) => {
                    const t = this.pos + e;
                    if (t > this.bytes.length) return !1;
                    if (t <= this.bytes.length - this.frameHeaderSize()) {
                        this.pos += e;
                        const t = this.readAscii(4);
                        if ("\0\0\0\0" !== t && !/[0-9A-Z]{4}/.test(t)) return !1;
                    }
                    return !0;
                };
            if (!s(n)) {
                const e = 4 === this.header.majorVersion ? t : GS(t);
                s(e) && (n = e);
            }
            return (this.pos = i), { id: e, size: n, flags: r };
        }
    }
    readId3V2TextEncoding() {
        const e = this.readU8();
        if (e > 3) throw new Error(`Unsupported text encoding: ${e}`);
        return e;
    }
    readId3V2Text(e, t) {
        const n = this.pos,
            r = this.readBytes(t - this.pos);
        switch (e) {
            case QS.ISO_8859_1: {
                let e = "";
                for (let t = 0; t < r.length; t++) {
                    const i = r[t];
                    if (0 === i) {
                        this.pos = n + t + 1;
                        break;
                    }
                    e += String.fromCharCode(i);
                }
                return e;
            }
            case QS.UTF_16_WITH_BOM:
                if (255 === r[0] && 254 === r[1]) {
                    const e = new TextDecoder("utf-16le"),
                        t = LT(
                            r.findIndex((e, t) => 0 === e && 0 === r[t + 1] && t % 2 == 0),
                            r.length
                        );
                    return (this.pos = n + Math.min(t + 2, r.length)), e.decode(r.subarray(2, t));
                }
                if (254 === r[0] && 255 === r[1]) {
                    const e = new TextDecoder("utf-16be"),
                        t = LT(
                            r.findIndex((e, t) => 0 === e && 0 === r[t + 1] && t % 2 == 0),
                            r.length
                        );
                    return (this.pos = n + Math.min(t + 2, r.length)), e.decode(r.subarray(2, t));
                }
                {
                    const e = LT(
                        r.findIndex((e) => 0 === e),
                        r.length
                    );
                    return (this.pos = n + Math.min(e + 1, r.length)), Qk.decode(r.subarray(0, e));
                }
            case QS.UTF_16_BE_NO_BOM: {
                const e = new TextDecoder("utf-16be"),
                    t = LT(
                        r.findIndex((e, t) => 0 === e && 0 === r[t + 1] && t % 2 == 0),
                        r.length
                    );
                return (this.pos = n + Math.min(t + 2, r.length)), e.decode(r.subarray(0, t));
            }
            case QS.UTF_8: {
                const e = LT(
                    r.findIndex((e) => 0 === e),
                    r.length
                );
                return (this.pos = n + Math.min(e + 1, r.length)), Qk.decode(r.subarray(0, e));
            }
        }
    }
    readId3V2EncodingAndText(e) {
        if (this.pos >= e) return "";
        const t = this.readId3V2TextEncoding();
        return this.readId3V2Text(t, e);
    }
}
class sE {
    constructor(e) {
        (this.helper = new Uint8Array(8)), (this.helperView = Yk(this.helper)), (this.writer = e);
    }
    writeId3V2Tag(e) {
        const t = this.writer.getPos();
        this.writeAscii("ID3"), this.writeU8(4), this.writeU8(0), this.writeU8(0), this.writeSynchsafeU32(0);
        const n = this.writer.getPos(),
            r = new Set();
        for (const { key: a, value: o } of zT(e))
            switch (a) {
                case "title":
                    this.writeId3V2TextFrame("TIT2", o), r.add("TIT2");
                    break;
                case "description":
                    this.writeId3V2TextFrame("TIT3", o), r.add("TIT3");
                    break;
                case "artist":
                    this.writeId3V2TextFrame("TPE1", o), r.add("TPE1");
                    break;
                case "album":
                    this.writeId3V2TextFrame("TALB", o), r.add("TALB");
                    break;
                case "albumArtist":
                    this.writeId3V2TextFrame("TPE2", o), r.add("TPE2");
                    break;
                case "trackNumber":
                    {
                        const t = void 0 !== e.tracksTotal ? `${o}/${e.tracksTotal}` : o.toString();
                        this.writeId3V2TextFrame("TRCK", t), r.add("TRCK");
                    }
                    break;
                case "discNumber":
                    {
                        const t = void 0 !== e.discsTotal ? `${o}/${e.discsTotal}` : o.toString();
                        this.writeId3V2TextFrame("TPOS", t), r.add("TPOS");
                    }
                    break;
                case "genre":
                    this.writeId3V2TextFrame("TCON", o), r.add("TCON");
                    break;
                case "date":
                    this.writeId3V2TextFrame("TDRC", o.toISOString().slice(0, 10)), r.add("TDRC");
                    break;
                case "lyrics":
                    this.writeId3V2LyricsFrame(o), r.add("USLT");
                    break;
                case "comment":
                    this.writeId3V2CommentFrame(o), r.add("COMM");
                    break;
                case "images":
                    {
                        const e = { coverFront: 3, coverBack: 4, unknown: 0 };
                        for (const t of o) {
                            const n = e[t.kind] ?? 0,
                                r = t.description ?? "";
                            this.writeId3V2ApicFrame(t.mimeType, n, r, t.data);
                        }
                    }
                    break;
                case "tracksTotal":
                case "discsTotal":
                case "raw":
                    break;
                default:
                    yT(a);
            }
        if (e.raw)
            for (const a in e.raw) {
                const t = e.raw[a];
                if (null == t || 4 !== a.length || r.has(a)) continue;
                let n;
                if ("string" == typeof t) {
                    const e = Jk.encode(t);
                    (n = new Uint8Array(e.byteLength + 2)), (n[0] = QS.UTF_8), n.set(e, 1);
                } else {
                    if (!(t instanceof Uint8Array)) continue;
                    n = t;
                }
                this.writeAscii(a), this.writeSynchsafeU32(n.byteLength), this.writeU16(0), this.writer.write(n);
            }
        const i = this.writer.getPos(),
            s = i - n;
        return this.writer.seek(t + 6), this.writeSynchsafeU32(s), this.writer.seek(i), s + 10;
    }
    writeU8(e) {
        (this.helper[0] = e), this.writer.write(this.helper.subarray(0, 1));
    }
    writeU16(e) {
        this.helperView.setUint16(0, e, !1), this.writer.write(this.helper.subarray(0, 2));
    }
    writeU32(e) {
        this.helperView.setUint32(0, e, !1), this.writer.write(this.helper.subarray(0, 4));
    }
    writeAscii(e) {
        for (let t = 0; t < e.length; t++) this.helper[t] = e.charCodeAt(t);
        this.writer.write(this.helper.subarray(0, e.length));
    }
    writeSynchsafeU32(e) {
        this.writeU32(
            ((e) => {
                let t = 127,
                    n = 0,
                    r = e;
                for (; 2147483647 ^ t; ) (n = r & ~t), (n <<= 1), (n |= r & t), (t = ((t + 1) << 8) - 1), (r = n);
                return n;
            })(e)
        );
    }
    writeIsoString(e) {
        const t = new Uint8Array(e.length + 1);
        for (let n = 0; n < e.length; n++) t[n] = e.charCodeAt(n);
        (t[e.length] = 0), this.writer.write(t);
    }
    writeUtf8String(e) {
        const t = Jk.encode(e);
        this.writer.write(t), this.writeU8(0);
    }
    writeId3V2TextFrame(e, t) {
        const n = Zk(t),
            r = 1 + (n ? t.length : Jk.encode(t).byteLength) + 1;
        this.writeAscii(e),
            this.writeSynchsafeU32(r),
            this.writeU16(0),
            this.writeU8(n ? QS.ISO_8859_1 : QS.UTF_8),
            n ? this.writeIsoString(t) : this.writeUtf8String(t);
    }
    writeId3V2LyricsFrame(e) {
        const t = Zk(e),
            n = 5 + e.length + 1;
        this.writeAscii("USLT"),
            this.writeSynchsafeU32(n),
            this.writeU16(0),
            this.writeU8(t ? QS.ISO_8859_1 : QS.UTF_8),
            this.writeAscii("und"),
            t ? (this.writeIsoString(""), this.writeIsoString(e)) : (this.writeUtf8String(""), this.writeUtf8String(e));
    }
    writeId3V2CommentFrame(e) {
        const t = Zk(e),
            n = 5 + (t ? e.length : Jk.encode(e).byteLength) + 1;
        this.writeAscii("COMM"),
            this.writeSynchsafeU32(n),
            this.writeU16(0),
            this.writeU8(t ? QS.ISO_8859_1 : QS.UTF_8),
            this.writeU8(117),
            this.writeU8(110),
            this.writeU8(100),
            t ? (this.writeIsoString(""), this.writeIsoString(e)) : (this.writeUtf8String(""), this.writeUtf8String(e));
    }
    writeId3V2ApicFrame(e, t, n, r) {
        const i = Zk(e) && Zk(n),
            s = i ? n.length : Jk.encode(n).byteLength,
            a = 1 + e.length + 1 + 1 + s + 1 + r.byteLength;
        this.writeAscii("APIC"),
            this.writeSynchsafeU32(a),
            this.writeU16(0),
            this.writeU8(i ? QS.ISO_8859_1 : QS.UTF_8),
            i ? this.writeIsoString(e) : this.writeUtf8String(e),
            this.writeU8(t),
            i ? this.writeIsoString(n) : this.writeUtf8String(n),
            this.writer.write(r);
    }
}
const aE = async (e, t, n) => {
    let r = t;
    for (; null === n || r < n; ) {
        let t = e.requestSlice(r, 4);
        if ((t instanceof Promise && (t = await t), !t)) break;
        const n = lC(t),
            i = XS(n, null !== e.fileSize ? e.fileSize - r : null);
        if (i.header) return { header: i.header, startPos: r };
        r += i.bytesAdvanced;
    }
    return null;
};
class oE extends rv {
    constructor(e) {
        super(e),
            (this.metadataPromise = null),
            (this.firstFrameHeader = null),
            (this.loadedSamples = []),
            (this.metadataTags = null),
            (this.tracks = []),
            (this.readingMutex = new lT()),
            (this.lastSampleLoaded = !1),
            (this.lastLoadedPos = 0),
            (this.nextTimestampInSamples = 0),
            (this.reader = e._reader);
    }
    async readMetadata() {
        return (this.metadataPromise ??= (async () => {
            for (; !this.firstFrameHeader && !this.lastSampleLoaded; ) await this.advanceReader();
            if (!this.firstFrameHeader) throw new Error("No valid MP3 frame found.");
            this.tracks = [new Bv(this.input, new cE(this))];
        })());
    }
    async advanceReader() {
        if (0 === this.lastLoadedPos)
            for (;;) {
                let e = this.reader.requestSlice(this.lastLoadedPos, 10);
                if ((e instanceof Promise && (e = await e), !e)) return void (this.lastSampleLoaded = !0);
                const t = nE(e);
                if (!t) break;
                this.lastLoadedPos = e.filePos + t.size;
            }
        const e = await aE(this.reader, this.lastLoadedPos, this.reader.fileSize);
        if (!e) return void (this.lastSampleLoaded = !0);
        const t = e.header;
        this.lastLoadedPos = e.startPos + t.totalSize - 1;
        const n = ((r = t.mpegVersionId), (i = t.channel), 3 === r ? (3 === i ? 21 : 36) : 3 === i ? 13 : 21);
        var r, i;
        let s = this.reader.requestSlice(e.startPos + n, 4);
        if ((s instanceof Promise && (s = await s), s)) {
            const e = lC(s);
            if (1483304551 === e || 1231971951 === e) return;
        }
        this.firstFrameHeader || (this.firstFrameHeader = t), t.sampleRate, this.firstFrameHeader.sampleRate;
        const a = t.audioSamplesInFrame / this.firstFrameHeader.sampleRate,
            o = {
                timestamp: this.nextTimestampInSamples / this.firstFrameHeader.sampleRate,
                duration: a,
                dataStart: e.startPos,
                dataSize: t.totalSize,
            };
        this.loadedSamples.push(o), (this.nextTimestampInSamples += t.audioSamplesInFrame);
    }
    async getMimeType() {
        return "audio/mpeg";
    }
    async getTracks() {
        return await this.readMetadata(), this.tracks;
    }
    async computeDuration() {
        await this.readMetadata();
        const e = this.tracks[0];
        return Vk(e), e.computeDuration();
    }
    async getMetadataTags() {
        const e = await this.readingMutex.acquire();
        try {
            if ((await this.readMetadata(), this.metadataTags)) return this.metadataTags;
            this.metadataTags = {};
            let e = 0,
                t = !1;
            for (;;) {
                let n = this.reader.requestSlice(e, 10);
                if ((n instanceof Promise && (n = await n), !n)) break;
                const r = nE(n);
                if (!r) break;
                t = !0;
                let i = this.reader.requestSlice(n.filePos, r.size);
                if ((i instanceof Promise && (i = await i), !i)) break;
                rE(i, r, this.metadataTags), (e = n.filePos + r.size);
            }
            if (!t && null !== this.reader.fileSize && this.reader.fileSize >= ZS) {
                let e = this.reader.requestSlice(this.reader.fileSize - ZS, ZS);
                e instanceof Promise && (e = await e), Vk(e);
                "TAG" === yC(e, 3) &&
                    ((e, t) => {
                        const n = e.filePos;
                        (t.raw ??= {}), (t.raw.TAG ??= nC(e, 125)), (e.filePos = n);
                        const r = tE(e, 30);
                        r && (t.title ??= r);
                        const i = tE(e, 30);
                        i && (t.artist ??= i);
                        const s = tE(e, 30);
                        s && (t.album ??= s);
                        const a = tE(e, 4),
                            o = Number.parseInt(a, 10);
                        Number.isInteger(o) && o > 0 && (t.date ??= new Date(o, 0, 1));
                        const c = nC(e, 30);
                        let l;
                        if (0 === c[28] && 0 !== c[29]) {
                            const n = c[29];
                            n > 0 && (t.trackNumber ??= n), e.skip(-30), (l = tE(e, 28)), e.skip(2);
                        } else e.skip(-30), (l = tE(e, 30));
                        l && (t.comment ??= l);
                        const u = rC(e);
                        u < eE.length && (t.genre ??= eE[u]);
                    })(e, this.metadataTags);
            }
            return this.metadataTags;
        } finally {
            e();
        }
    }
}
class cE {
    constructor(e) {
        this.demuxer = e;
    }
    getId() {
        return 1;
    }
    async getFirstTimestamp() {
        return 0;
    }
    getTimeResolution() {
        return (
            Vk(this.demuxer.firstFrameHeader),
            this.demuxer.firstFrameHeader.sampleRate / this.demuxer.firstFrameHeader.audioSamplesInFrame
        );
    }
    async computeDuration() {
        const e = await this.getPacket(1 / 0, { metadataOnly: !0 });
        return (e?.timestamp ?? 0) + (e?.duration ?? 0);
    }
    getName() {
        return null;
    }
    getLanguageCode() {
        return vT;
    }
    getCodec() {
        return "mp3";
    }
    getInternalCodecId() {
        return null;
    }
    getNumberOfChannels() {
        return Vk(this.demuxer.firstFrameHeader), 3 === this.demuxer.firstFrameHeader.channel ? 1 : 2;
    }
    getSampleRate() {
        return Vk(this.demuxer.firstFrameHeader), this.demuxer.firstFrameHeader.sampleRate;
    }
    async getDecoderConfig() {
        return (
            Vk(this.demuxer.firstFrameHeader),
            {
                codec: "mp3",
                numberOfChannels: 3 === this.demuxer.firstFrameHeader.channel ? 1 : 2,
                sampleRate: this.demuxer.firstFrameHeader.sampleRate,
            }
        );
    }
    async getPacketAtIndex(e, t) {
        if (-1 === e) return null;
        const n = this.demuxer.loadedSamples[e];
        if (!n) return null;
        let r;
        if (t.metadataOnly) r = cv;
        else {
            let e = this.demuxer.reader.requestSlice(n.dataStart, n.dataSize);
            if ((e instanceof Promise && (e = await e), !e)) return null;
            r = nC(e, n.dataSize);
        }
        return new lv(r, "key", n.timestamp, n.duration, e, n.dataSize);
    }
    getFirstPacket(e) {
        return this.getPacketAtIndex(0, e);
    }
    async getNextPacket(e, t) {
        const n = await this.demuxer.readingMutex.acquire();
        try {
            const n = hT(this.demuxer.loadedSamples, e.timestamp, (e) => e.timestamp);
            if (-1 === n) throw new Error("Packet was not created from this track.");
            const r = n + 1;
            for (; r >= this.demuxer.loadedSamples.length && !this.demuxer.lastSampleLoaded; )
                await this.demuxer.advanceReader();
            return this.getPacketAtIndex(r, t);
        } finally {
            n();
        }
    }
    async getPacket(e, t) {
        const n = await this.demuxer.readingMutex.acquire();
        try {
            for (;;) {
                const n = mT(this.demuxer.loadedSamples, e, (e) => e.timestamp);
                if (-1 === n && this.demuxer.loadedSamples.length > 0) return null;
                if (this.demuxer.lastSampleLoaded) return this.getPacketAtIndex(n, t);
                if (n >= 0 && n + 1 < this.demuxer.loadedSamples.length) return this.getPacketAtIndex(n, t);
                await this.demuxer.advanceReader();
            }
        } finally {
            n();
        }
    }
    getKeyPacket(e, t) {
        return this.getPacket(e, t);
    }
    getNextKeyPacket(e, t) {
        return this.getNextPacket(e, t);
    }
}
const lE = 1399285583,
    uE = new Uint32Array(256);
for (let tz = 0; tz < 256; tz++) {
    let e = tz << 24;
    for (let t = 0; t < 8; t++) e = 2147483648 & e ? (e << 1) ^ 79764919 : e << 1;
    uE[tz] = (e >>> 0) & 4294967295;
}
const dE = (e) => {
        const t = Yk(e),
            n = t.getUint32(22, !0);
        t.setUint32(22, 0, !0);
        let r = 0;
        for (let i = 0; i < e.length; i++) {
            const t = e[i];
            r = ((r << 8) ^ uE[(r >>> 24) ^ t]) >>> 0;
        }
        return t.setUint32(22, n, !0), r;
    },
    hE = (e, t, n) => {
        let r = 0,
            i = null;
        if (e.length > 0)
            if ("vorbis" === t.codec) {
                Vk(t.vorbisInfo);
                const s = ((e) => {
                        let t = 0;
                        for (; e; ) t++, (e >>= 1);
                        return t;
                    })(t.vorbisInfo.modeBlockflags.length - 1),
                    a = ((1 << s) - 1) << 1,
                    o = (e[0] & a) >> 1;
                if (o >= t.vorbisInfo.modeBlockflags.length) throw new Error("Invalid mode number.");
                let c = n;
                const l = t.vorbisInfo.modeBlockflags[o];
                if (((i = t.vorbisInfo.blocksizes[l]), 1 === l)) {
                    const n = 1 + (1 | a),
                        r = e[0] & n ? 1 : 0;
                    c = t.vorbisInfo.blocksizes[r];
                }
                r = null !== c ? (c + i) >> 2 : 0;
            } else if ("opus" === t.codec) {
                r = ((e) => {
                    const t = e[0] >> 3;
                    return { durationInSamples: Q_[t] };
                })(e).durationInSamples;
            }
        return { durationInSamples: r, vorbisBlockSize: i };
    },
    mE = 27,
    pE = 282,
    fE = (e) => {
        const t = e.filePos;
        if (uC(e) !== lE) return null;
        e.skip(1);
        const n = rC(e),
            r = fC(e),
            i = uC(e),
            s = uC(e),
            a = uC(e),
            o = rC(e),
            c = new Uint8Array(o);
        for (let d = 0; d < o; d++) c[d] = rC(e);
        const l = 27 + o,
            u = c.reduce((e, t) => e + t, 0);
        return {
            headerStartPos: t,
            totalSize: l + u,
            dataStartPos: t + l,
            dataSize: u,
            headerType: n,
            granulePosition: r,
            serialNumber: i,
            sequenceNumber: s,
            checksum: a,
            lacingValues: c,
        };
    },
    gE = (e, t) => {
        for (; e.filePos < t - 3; ) {
            const t = uC(e),
                n = 79;
            if ((255 & t) === n || ((t >>> 8) & 255) === n || ((t >>> 16) & 255) === n || ((t >>> 24) & 255) === n) {
                if ((e.skip(-4), t === lE)) return !0;
                e.skip(1);
            }
        }
        return !1;
    };
class bE extends rv {
    constructor(e) {
        super(e),
            (this.metadataPromise = null),
            (this.bitstreams = []),
            (this.tracks = []),
            (this.metadataTags = {}),
            (this.reader = e._reader);
    }
    async readMetadata() {
        return (this.metadataPromise ??= (async () => {
            let e = 0;
            for (;;) {
                let t = this.reader.requestSliceRange(e, mE, pE);
                if ((t instanceof Promise && (t = await t), !t)) break;
                const n = fE(t);
                if (!n) break;
                if (!!!(2 & n.headerType)) break;
                this.bitstreams.push({
                    serialNumber: n.serialNumber,
                    bosPage: n,
                    description: null,
                    numberOfChannels: -1,
                    sampleRate: -1,
                    codecInfo: { codec: null, vorbisInfo: null, opusInfo: null },
                    lastMetadataPacket: null,
                }),
                    (e = n.headerStartPos + n.totalSize);
            }
            for (const t of this.bitstreams) {
                const e = await this.readPacket(t.bosPage, 0);
                e &&
                    (e.data.byteLength >= 7 &&
                    1 === e.data[0] &&
                    118 === e.data[1] &&
                    111 === e.data[2] &&
                    114 === e.data[3] &&
                    98 === e.data[4] &&
                    105 === e.data[5] &&
                    115 === e.data[6]
                        ? await this.readVorbisMetadata(e, t)
                        : e.data.byteLength >= 8 &&
                          79 === e.data[0] &&
                          112 === e.data[1] &&
                          117 === e.data[2] &&
                          115 === e.data[3] &&
                          72 === e.data[4] &&
                          101 === e.data[5] &&
                          97 === e.data[6] &&
                          100 === e.data[7] &&
                          (await this.readOpusMetadata(e, t)),
                    null !== t.codecInfo.codec && this.tracks.push(new Bv(this.input, new yE(t, this))));
            }
        })());
    }
    async readVorbisMetadata(e, t) {
        let n = await this.findNextPacketStart(e);
        if (!n) return;
        const r = await this.readPacket(n.startPage, n.startSegmentIndex);
        if (!r) return;
        if (((n = await this.findNextPacketStart(r)), !n)) return;
        const i = await this.readPacket(n.startPage, n.startSegmentIndex);
        if (!i) return;
        if (3 !== r.data[0] || 5 !== i.data[0]) return;
        const s = [],
            a = (e) => {
                for (; s.push(Math.min(255, e)), !(e < 255); ) e -= 255;
            };
        a(e.data.length), a(r.data.length);
        const o = new Uint8Array(1 + s.length + e.data.length + r.data.length + i.data.length);
        (o[0] = 2),
            o.set(s, 1),
            o.set(e.data, 1 + s.length),
            o.set(r.data, 1 + s.length + e.data.length),
            o.set(i.data, 1 + s.length + e.data.length + r.data.length),
            (t.codecInfo.codec = "vorbis"),
            (t.description = o),
            (t.lastMetadataPacket = i);
        const c = Yk(e.data);
        (t.numberOfChannels = c.getUint8(11)), (t.sampleRate = c.getUint32(12, !0));
        const l = c.getUint8(28);
        (t.codecInfo.vorbisInfo = {
            blocksizes: [1 << (15 & l), 1 << (l >> 4)],
            modeBlockflags: J_(i.data).modeBlockflags,
        }),
            nv(r.data.subarray(7), this.metadataTags);
    }
    async readOpusMetadata(e, t) {
        const n = await this.findNextPacketStart(e);
        if (!n) return;
        const r = await this.readPacket(n.startPage, n.startSegmentIndex);
        if (!r) return;
        (t.codecInfo.codec = "opus"), (t.description = e.data), (t.lastMetadataPacket = r);
        const i = Y_(e.data);
        (t.numberOfChannels = i.outputChannelCount),
            (t.sampleRate = p_),
            (t.codecInfo.opusInfo = { preSkip: i.preSkip }),
            nv(r.data.subarray(8), this.metadataTags);
    }
    async readPacket(e, t) {
        Vk(t < e.lacingValues.length);
        let n = 0;
        for (let u = 0; u < t; u++) n += e.lacingValues[u];
        let r = e,
            i = n,
            s = t;
        const a = [];
        e: for (;;) {
            let t = this.reader.requestSlice(r.dataStartPos, r.dataSize);
            t instanceof Promise && (t = await t), Vk(t);
            const o = nC(t, r.dataSize);
            for (;;) {
                if (s === r.lacingValues.length) {
                    a.push(o.subarray(n, i));
                    break;
                }
                const e = r.lacingValues[s];
                if (((i += e), e < 255)) {
                    a.push(o.subarray(n, i));
                    break e;
                }
                s++;
            }
            let c = r.headerStartPos + r.totalSize;
            for (;;) {
                let t = this.reader.requestSliceRange(c, mE, pE);
                if ((t instanceof Promise && (t = await t), !t)) return null;
                const n = fE(t);
                if (!n) return null;
                if (((r = n), r.serialNumber === e.serialNumber)) break;
                c = r.headerStartPos + r.totalSize;
            }
            (n = 0), (i = 0), (s = 0);
        }
        const o = a.reduce((e, t) => e + t.length, 0),
            c = new Uint8Array(o);
        let l = 0;
        for (let u = 0; u < a.length; u++) {
            const e = a[u];
            c.set(e, l), (l += e.length);
        }
        return { data: c, endPage: r, endSegmentIndex: s };
    }
    async findNextPacketStart(e) {
        if (e.endSegmentIndex < e.endPage.lacingValues.length - 1)
            return { startPage: e.endPage, startSegmentIndex: e.endSegmentIndex + 1 };
        if (!!(4 & e.endPage.headerType)) return null;
        let t = e.endPage.headerStartPos + e.endPage.totalSize;
        for (;;) {
            let n = this.reader.requestSliceRange(t, mE, pE);
            if ((n instanceof Promise && (n = await n), !n)) return null;
            const r = fE(n);
            if (!r) return null;
            if (r.serialNumber === e.endPage.serialNumber) return { startPage: r, startSegmentIndex: 0 };
            t = r.headerStartPos + r.totalSize;
        }
    }
    async getMimeType() {
        await this.readMetadata();
        const e = await Promise.all(this.tracks.map((e) => e.getCodecParameterString()));
        return ((e) => {
            let t = "audio/ogg";
            e.codecStrings && (t += `; codecs="${[...new Set(e.codecStrings)].join(", ")}"`);
            return t;
        })({ codecStrings: e.filter(Boolean) });
    }
    async getTracks() {
        return await this.readMetadata(), this.tracks;
    }
    async computeDuration() {
        const e = await this.getTracks(),
            t = await Promise.all(e.map((e) => e.computeDuration()));
        return Math.max(0, ...t);
    }
    async getMetadataTags() {
        return await this.readMetadata(), this.metadataTags;
    }
}
class yE {
    constructor(e, t) {
        (this.bitstream = e),
            (this.demuxer = t),
            (this.encodedPacketToMetadata = new WeakMap()),
            (this.sequentialScanCache = []),
            (this.sequentialScanMutex = new lT()),
            (this.internalSampleRate = "opus" === e.codecInfo.codec ? p_ : e.sampleRate);
    }
    getId() {
        return this.bitstream.serialNumber;
    }
    getNumberOfChannels() {
        return this.bitstream.numberOfChannels;
    }
    getSampleRate() {
        return this.bitstream.sampleRate;
    }
    getTimeResolution() {
        return this.bitstream.sampleRate;
    }
    getCodec() {
        return this.bitstream.codecInfo.codec;
    }
    getInternalCodecId() {
        return null;
    }
    async getDecoderConfig() {
        return (
            Vk(this.bitstream.codecInfo.codec),
            {
                codec: this.bitstream.codecInfo.codec,
                numberOfChannels: this.bitstream.numberOfChannels,
                sampleRate: this.bitstream.sampleRate,
                description: this.bitstream.description ?? void 0,
            }
        );
    }
    getName() {
        return null;
    }
    getLanguageCode() {
        return vT;
    }
    async getFirstTimestamp() {
        return 0;
    }
    async computeDuration() {
        const e = await this.getPacket(1 / 0, { metadataOnly: !0 });
        return (e?.timestamp ?? 0) + (e?.duration ?? 0);
    }
    granulePositionToTimestampInSamples(e) {
        return "opus" === this.bitstream.codecInfo.codec
            ? (Vk(this.bitstream.codecInfo.opusInfo), e - this.bitstream.codecInfo.opusInfo.preSkip)
            : e;
    }
    createEncodedPacketFromOggPacket(e, t, n) {
        if (!e) return null;
        const { durationInSamples: r, vorbisBlockSize: i } = hE(
                e.data,
                this.bitstream.codecInfo,
                t.vorbisLastBlocksize
            ),
            s = new lv(
                n.metadataOnly ? cv : e.data,
                "key",
                Math.max(0, t.timestampInSamples) / this.internalSampleRate,
                r / this.internalSampleRate,
                e.endPage.headerStartPos + e.endSegmentIndex,
                e.data.byteLength
            );
        return (
            this.encodedPacketToMetadata.set(s, {
                packet: e,
                timestampInSamples: t.timestampInSamples,
                durationInSamples: r,
                vorbisLastBlockSize: t.vorbisLastBlocksize,
                vorbisBlockSize: i,
            }),
            s
        );
    }
    async getFirstPacket(e) {
        Vk(this.bitstream.lastMetadataPacket);
        const t = await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);
        if (!t) return null;
        let n = 0;
        "opus" === this.bitstream.codecInfo.codec &&
            (Vk(this.bitstream.codecInfo.opusInfo), (n -= this.bitstream.codecInfo.opusInfo.preSkip));
        const r = await this.demuxer.readPacket(t.startPage, t.startSegmentIndex);
        return this.createEncodedPacketFromOggPacket(r, { timestampInSamples: n, vorbisLastBlocksize: null }, e);
    }
    async getNextPacket(e, t) {
        const n = this.encodedPacketToMetadata.get(e);
        if (!n) throw new Error("Packet was not created from this track.");
        const r = await this.demuxer.findNextPacketStart(n.packet);
        if (!r) return null;
        const i = n.timestampInSamples + n.durationInSamples,
            s = await this.demuxer.readPacket(r.startPage, r.startSegmentIndex);
        return this.createEncodedPacketFromOggPacket(
            s,
            { timestampInSamples: i, vorbisLastBlocksize: n.vorbisBlockSize },
            t
        );
    }
    async getPacket(e, t) {
        if (null === this.demuxer.reader.fileSize) return this.getPacketSequential(e, t);
        const n = ST(e * this.internalSampleRate, 14);
        if (0 === n) return this.getFirstPacket(t);
        if (n < 0) return null;
        Vk(this.bitstream.lastMetadataPacket);
        const r = await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);
        if (!r) return null;
        let i = r.startPage,
            s = this.demuxer.reader.fileSize;
        const a = [i];
        e: for (; i.headerStartPos + i.totalSize < s; ) {
            const e = i.headerStartPos,
                t = Math.floor((e + s) / 2);
            let r = t;
            for (;;) {
                const e = Math.min(r + 65307, s - mE);
                let o = this.demuxer.reader.requestSlice(r, e - r);
                o instanceof Promise && (o = await o), Vk(o);
                if (!gE(o, e)) {
                    s = t + mE;
                    continue e;
                }
                let c = this.demuxer.reader.requestSliceRange(o.filePos, mE, pE);
                c instanceof Promise && (c = await c), Vk(c);
                const l = fE(c);
                Vk(l);
                let u = !1;
                if (l.serialNumber === this.bitstream.serialNumber) u = !0;
                else {
                    let e = this.demuxer.reader.requestSlice(l.headerStartPos, l.totalSize);
                    e instanceof Promise && (e = await e), Vk(e);
                    const t = nC(e, l.totalSize);
                    u = dE(t) === l.checksum;
                }
                if (!u) {
                    r = l.headerStartPos + 4;
                    continue;
                }
                if (u && l.serialNumber !== this.bitstream.serialNumber) {
                    r = l.headerStartPos + l.totalSize;
                    continue;
                }
                if (!(-1 === l.granulePosition)) {
                    this.granulePositionToTimestampInSamples(l.granulePosition) > n
                        ? (s = l.headerStartPos)
                        : ((i = l), a.push(l));
                    continue e;
                }
                r = l.headerStartPos + l.totalSize;
            }
        }
        let o = r.startPage;
        for (const b of a) {
            if (b.granulePosition === i.granulePosition) break;
            (!o || b.headerStartPos > o.headerStartPos) && (o = b);
        }
        let c = o;
        const l = [c];
        for (; c.serialNumber !== this.bitstream.serialNumber || c.granulePosition !== i.granulePosition; ) {
            const e = c.headerStartPos + c.totalSize;
            let t = this.demuxer.reader.requestSliceRange(e, mE, pE);
            t instanceof Promise && (t = await t), Vk(t);
            const n = fE(t);
            Vk(n), (c = n), c.serialNumber === this.bitstream.serialNumber && l.push(c);
        }
        Vk(-1 !== c.granulePosition);
        let u,
            d,
            h = null,
            m = c,
            p = 0;
        if (c.headerStartPos === r.startPage.headerStartPos)
            (u = this.granulePositionToTimestampInSamples(0)), (d = !0), (h = 0);
        else {
            (u = 0), (d = !1);
            for (let t = c.lacingValues.length - 1; t >= 0; t--) {
                if (c.lacingValues[t] < 255) {
                    h = t + 1;
                    break;
                }
            }
            if (null === h) throw new Error("Invalid page with granule position: no packets end on this page.");
            p = h - 1;
            const e = { data: cv, endPage: m, endSegmentIndex: p };
            if (await this.demuxer.findNextPacketStart(e)) {
                const e = kE(l, c, h);
                Vk(e);
                const t = wE(l, e.page, e.segmentIndex);
                t && ((c = t.page), (h = t.segmentIndex));
            } else
                for (;;) {
                    const e = kE(l, c, h);
                    if (!e) break;
                    const t = wE(l, e.page, e.segmentIndex);
                    if (!t) break;
                    if (((c = t.page), (h = t.segmentIndex), e.page.headerStartPos !== m.headerStartPos)) {
                        (m = e.page), (p = e.segmentIndex);
                        break;
                    }
                }
        }
        let f = null,
            g = null;
        for (; null !== c; ) {
            Vk(null !== h);
            const e = await this.demuxer.readPacket(c, h);
            if (!e) break;
            if (!(c.headerStartPos === r.startPage.headerStartPos && h < r.startSegmentIndex)) {
                let r = this.createEncodedPacketFromOggPacket(
                    e,
                    { timestampInSamples: u, vorbisLastBlocksize: g?.vorbisBlockSize ?? null },
                    t
                );
                Vk(r);
                let i = this.encodedPacketToMetadata.get(r);
                if (
                    (Vk(i),
                    d || e.endPage.headerStartPos !== m.headerStartPos || e.endSegmentIndex !== p
                        ? (u += i.durationInSamples)
                        : ((u = this.granulePositionToTimestampInSamples(c.granulePosition)),
                          (d = !0),
                          (r = this.createEncodedPacketFromOggPacket(
                              e,
                              {
                                  timestampInSamples: u - i.durationInSamples,
                                  vorbisLastBlocksize: g?.vorbisBlockSize ?? null,
                              },
                              t
                          )),
                          Vk(r),
                          (i = this.encodedPacketToMetadata.get(r)),
                          Vk(i)),
                    (f = r),
                    (g = i),
                    d && (Math.max(u, 0) > n || Math.max(i.timestampInSamples, 0) === n))
                )
                    break;
            }
            const i = await this.demuxer.findNextPacketStart(e);
            if (!i) break;
            (c = i.startPage), (h = i.startSegmentIndex);
        }
        return f;
    }
    async getPacketSequential(e, t) {
        const n = await this.sequentialScanMutex.acquire();
        try {
            const n = ST(e * this.internalSampleRate, 14);
            e = n / this.internalSampleRate;
            const r = mT(this.sequentialScanCache, n, (e) => e.timestampInSamples);
            let i;
            if (-1 !== r) {
                const e = this.sequentialScanCache[r];
                i = this.createEncodedPacketFromOggPacket(
                    e.packet,
                    { timestampInSamples: e.timestampInSamples, vorbisLastBlocksize: e.vorbisLastBlockSize },
                    t
                );
            } else i = await this.getFirstPacket(t);
            let s = 0;
            for (; i && i.timestamp < e; ) {
                const n = await this.getNextPacket(i, t);
                if (!n || n.timestamp > e) break;
                if (((i = n), s++, 100 === s)) {
                    s = 0;
                    const e = this.encodedPacketToMetadata.get(i);
                    Vk(e),
                        this.sequentialScanCache.length > 0 &&
                            Vk(jk(this.sequentialScanCache).timestampInSamples <= e.timestampInSamples),
                        this.sequentialScanCache.push(e);
                }
            }
            return i;
        } finally {
            n();
        }
    }
    getKeyPacket(e, t) {
        return this.getPacket(e, t);
    }
    getNextKeyPacket(e, t) {
        return this.getNextPacket(e, t);
    }
}
const wE = (e, t, n) => {
        let r = t,
            i = n;
        e: for (;;) {
            for (i--; i >= 0; i--) {
                if (r.lacingValues[i] < 255) {
                    i++;
                    break e;
                }
            }
            Vk(-1 === i);
            if (!(1 & r.headerType)) {
                i = 0;
                break;
            }
            const t = gT(e, (e) => e.headerStartPos < r.headerStartPos);
            if (!t) return null;
            (r = t), (i = r.lacingValues.length);
        }
        if ((Vk(-1 !== i), i === r.lacingValues.length)) {
            const t = e[e.indexOf(r) + 1];
            Vk(t), (r = t), (i = 0);
        }
        return { page: r, segmentIndex: i };
    },
    kE = (e, t, n) => {
        if (n > 0) return { page: t, segmentIndex: n - 1 };
        const r = gT(e, (e) => e.headerStartPos < t.headerStartPos);
        return r ? { page: r, segmentIndex: r.lacingValues.length - 1 } : null;
    };
var TE, _E;
((_E = TE || (TE = {}))[(_E.PCM = 1)] = "PCM"),
    (_E[(_E.IEEE_FLOAT = 3)] = "IEEE_FLOAT"),
    (_E[(_E.ALAW = 6)] = "ALAW"),
    (_E[(_E.MULAW = 7)] = "MULAW"),
    (_E[(_E.EXTENSIBLE = 65534)] = "EXTENSIBLE");
class vE extends rv {
    constructor(e) {
        super(e),
            (this.metadataPromise = null),
            (this.dataStart = -1),
            (this.dataSize = -1),
            (this.audioInfo = null),
            (this.tracks = []),
            (this.lastKnownPacketIndex = 0),
            (this.metadataTags = {}),
            (this.reader = e._reader);
    }
    async readMetadata() {
        return (this.metadataPromise ??= (async () => {
            let e = this.reader.requestSlice(0, 12);
            e instanceof Promise && (e = await e), Vk(e);
            const t = yC(e, 4),
                n = "RIFX" !== t,
                r = "RF64" === t,
                i = cC(e, n);
            let s = r ? this.reader.fileSize : Math.min(i + 8, this.reader.fileSize ?? 1 / 0);
            if ("WAVE" !== yC(e, 4)) throw new Error("Invalid WAVE file - wrong format");
            let a = 0,
                o = null,
                c = e.filePos;
            for (; null === s || c < s; ) {
                let e = this.reader.requestSlice(c, 8);
                if ((e instanceof Promise && (e = await e), !e)) break;
                const t = yC(e, 4),
                    i = cC(e, n),
                    l = e.filePos;
                if (r && 0 === a && "ds64" !== t) throw new Error('Invalid RF64 file: First chunk must be "ds64".');
                if ("fmt " === t) await this.parseFmtChunk(l, i, n);
                else if ("data" === t) {
                    if (
                        ((o ??= i),
                        (this.dataStart = e.filePos),
                        (this.dataSize = Math.min(o, (s ?? 1 / 0) - this.dataStart)),
                        null === this.reader.fileSize)
                    )
                        break;
                } else if ("ds64" === t) {
                    let e = this.reader.requestSlice(l, i);
                    if ((e instanceof Promise && (e = await e), !e)) break;
                    const t = hC(e, n);
                    (o = hC(e, n)), (s = Math.min(t + 8, this.reader.fileSize ?? 1 / 0));
                } else
                    "LIST" === t
                        ? await this.parseListChunk(l, i, n)
                        : ("ID3 " !== t && "id3 " !== t) || (await this.parseId3Chunk(l, i));
                (c = l + i + (1 & i)), a++;
            }
            if (!this.audioInfo) throw new Error('Invalid WAVE file - missing "fmt " chunk');
            if (-1 === this.dataStart) throw new Error('Invalid WAVE file - missing "data" chunk');
            const l = this.audioInfo.blockSizeInBytes;
            (this.dataSize = Math.floor(this.dataSize / l) * l), this.tracks.push(new Bv(this.input, new EE(this)));
        })());
    }
    async parseFmtChunk(e, t, n) {
        let r = this.reader.requestSlice(e, t);
        if ((r instanceof Promise && (r = await r), !r)) return;
        let i = iC(r, n);
        const s = iC(r, n),
            a = cC(r, n);
        r.skip(4);
        const o = iC(r, n);
        let c;
        if (((c = 14 === t ? 8 : iC(r, n)), t >= 18 && 357 !== i)) {
            const e = iC(r, n),
                s = t - 18;
            if (Math.min(s, e) >= 22 && i === TE.EXTENSIBLE) {
                r.skip(6);
                const e = nC(r, 16);
                i = e[0] | (e[1] << 8);
            }
        }
        (i !== TE.MULAW && i !== TE.ALAW) || (c = 8),
            (this.audioInfo = {
                format: i,
                numberOfChannels: s,
                sampleRate: a,
                sampleSizeInBytes: Math.ceil(c / 8),
                blockSizeInBytes: o,
            });
    }
    async parseListChunk(e, t, n) {
        let r = this.reader.requestSlice(e, t);
        if ((r instanceof Promise && (r = await r), !r)) return;
        const i = yC(r, 4);
        if ("INFO" !== i && "INF0" !== i) return;
        let s = r.filePos;
        for (; s <= e + t - 8; ) {
            r.filePos = s;
            const e = yC(r, 4),
                t = cC(r, n),
                i = nC(r, t);
            let a = 0;
            for (let n = 0; n < i.length && 0 !== i[n]; n++) a++;
            const o = String.fromCharCode(...i.subarray(0, a));
            switch (((this.metadataTags.raw ??= {}), (this.metadataTags.raw[e] = o), e)) {
                case "INAM":
                case "TITL":
                    this.metadataTags.title ??= o;
                    break;
                case "TIT3":
                    this.metadataTags.description ??= o;
                    break;
                case "IART":
                    this.metadataTags.artist ??= o;
                    break;
                case "IPRD":
                    this.metadataTags.album ??= o;
                    break;
                case "IPRT":
                case "ITRK":
                case "TRCK":
                    {
                        const e = o.split("/"),
                            t = Number.parseInt(e[0], 10),
                            n = e[1] && Number.parseInt(e[1], 10);
                        Number.isInteger(t) && t > 0 && (this.metadataTags.trackNumber ??= t),
                            n && Number.isInteger(n) && n > 0 && (this.metadataTags.tracksTotal ??= n);
                    }
                    break;
                case "ICRD":
                case "IDIT":
                    {
                        const e = new Date(o);
                        Number.isNaN(e.getTime()) || (this.metadataTags.date ??= e);
                    }
                    break;
                case "YEAR":
                    {
                        const e = Number.parseInt(o, 10);
                        Number.isInteger(e) && e > 0 && (this.metadataTags.date ??= new Date(e, 0, 1));
                    }
                    break;
                case "IGNR":
                case "GENR":
                    this.metadataTags.genre ??= o;
                    break;
                case "ICMT":
                case "CMNT":
                case "COMM":
                    this.metadataTags.comment ??= o;
            }
            s += 8 + t + (1 & t);
        }
    }
    async parseId3Chunk(e, t) {
        let n = this.reader.requestSlice(e, t);
        if ((n instanceof Promise && (n = await n), !n)) return;
        const r = nE(n);
        if (r) {
            const t = n.slice(e + 10, r.size);
            rE(t, r, this.metadataTags);
        }
    }
    getCodec() {
        if ((Vk(this.audioInfo), this.audioInfo.format === TE.MULAW)) return "ulaw";
        if (this.audioInfo.format === TE.ALAW) return "alaw";
        if (this.audioInfo.format === TE.PCM) {
            if (1 === this.audioInfo.sampleSizeInBytes) return "pcm-u8";
            if (2 === this.audioInfo.sampleSizeInBytes) return "pcm-s16";
            if (3 === this.audioInfo.sampleSizeInBytes) return "pcm-s24";
            if (4 === this.audioInfo.sampleSizeInBytes) return "pcm-s32";
        }
        return this.audioInfo.format === TE.IEEE_FLOAT && 4 === this.audioInfo.sampleSizeInBytes ? "pcm-f32" : null;
    }
    async getMimeType() {
        return "audio/wav";
    }
    async computeDuration() {
        await this.readMetadata();
        const e = this.tracks[0];
        return Vk(e), e.computeDuration();
    }
    async getTracks() {
        return await this.readMetadata(), this.tracks;
    }
    async getMetadataTags() {
        return await this.readMetadata(), this.metadataTags;
    }
}
const SE = 2048;
class EE {
    constructor(e) {
        this.demuxer = e;
    }
    getId() {
        return 1;
    }
    getCodec() {
        return this.demuxer.getCodec();
    }
    getInternalCodecId() {
        return Vk(this.demuxer.audioInfo), this.demuxer.audioInfo.format;
    }
    async getDecoderConfig() {
        const e = this.demuxer.getCodec();
        return e
            ? (Vk(this.demuxer.audioInfo),
              {
                  codec: e,
                  numberOfChannels: this.demuxer.audioInfo.numberOfChannels,
                  sampleRate: this.demuxer.audioInfo.sampleRate,
              })
            : null;
    }
    async computeDuration() {
        const e = await this.getPacket(1 / 0, { metadataOnly: !0 });
        return (e?.timestamp ?? 0) + (e?.duration ?? 0);
    }
    getNumberOfChannels() {
        return Vk(this.demuxer.audioInfo), this.demuxer.audioInfo.numberOfChannels;
    }
    getSampleRate() {
        return Vk(this.demuxer.audioInfo), this.demuxer.audioInfo.sampleRate;
    }
    getTimeResolution() {
        return Vk(this.demuxer.audioInfo), this.demuxer.audioInfo.sampleRate;
    }
    getName() {
        return null;
    }
    getLanguageCode() {
        return vT;
    }
    async getFirstTimestamp() {
        return 0;
    }
    async getPacketAtIndex(e, t) {
        Vk(this.demuxer.audioInfo);
        const n = e * SE * this.demuxer.audioInfo.blockSizeInBytes;
        if (n >= this.demuxer.dataSize) return null;
        const r = Math.min(SE * this.demuxer.audioInfo.blockSizeInBytes, this.demuxer.dataSize - n);
        if (null === this.demuxer.reader.fileSize) {
            let e = this.demuxer.reader.requestSlice(this.demuxer.dataStart + n, r);
            if ((e instanceof Promise && (e = await e), !e)) return null;
        }
        let i;
        if (t.metadataOnly) i = cv;
        else {
            let e = this.demuxer.reader.requestSlice(this.demuxer.dataStart + n, r);
            e instanceof Promise && (e = await e), Vk(e), (i = nC(e, r));
        }
        const s = (e * SE) / this.demuxer.audioInfo.sampleRate,
            a = r / this.demuxer.audioInfo.blockSizeInBytes / this.demuxer.audioInfo.sampleRate;
        return (this.demuxer.lastKnownPacketIndex = Math.max(e, s)), new lv(i, "key", s, a, e, r);
    }
    getFirstPacket(e) {
        return this.getPacketAtIndex(0, e);
    }
    async getPacket(e, t) {
        Vk(this.demuxer.audioInfo);
        const n = Math.floor(
                Math.min(
                    (e * this.demuxer.audioInfo.sampleRate) / SE,
                    (this.demuxer.dataSize - 1) / (SE * this.demuxer.audioInfo.blockSizeInBytes)
                )
            ),
            r = await this.getPacketAtIndex(n, t);
        if (r) return r;
        if (0 === n) return null;
        Vk(null === this.demuxer.reader.fileSize);
        let i = await this.getPacketAtIndex(this.demuxer.lastKnownPacketIndex, t);
        for (; i; ) {
            const e = await this.getNextPacket(i, t);
            if (!e) break;
            i = e;
        }
        return i;
    }
    getNextPacket(e, t) {
        Vk(this.demuxer.audioInfo);
        const n = Math.round((e.timestamp * this.demuxer.audioInfo.sampleRate) / SE);
        return this.getPacketAtIndex(n + 1, t);
    }
    getKeyPacket(e, t) {
        return this.getPacket(e, t);
    }
    getNextKeyPacket(e, t) {
        return this.getNextPacket(e, t);
    }
}
const CE = (e) => {
        const t = e.filePos,
            n = nC(e, 9),
            r = new qk(n);
        if (4095 !== r.readBits(12)) return null;
        r.skipBits(1);
        if (0 !== r.readBits(2)) return null;
        const i = r.readBits(1),
            s = r.readBits(2) + 1,
            a = r.readBits(4);
        if (15 === a) return null;
        r.skipBits(1);
        const o = r.readBits(3);
        if (0 === o) throw new Error("ADTS frames with channel configuration 0 are not supported.");
        r.skipBits(1), r.skipBits(1), r.skipBits(1), r.skipBits(1);
        const c = r.readBits(13);
        r.skipBits(11);
        const l = r.readBits(2) + 1;
        if (1 !== l) throw new Error("ADTS frames with more than one AAC frame are not supported.");
        let u = null;
        return (
            1 === i ? (e.filePos -= 2) : (u = r.readBits(16)),
            {
                objectType: s,
                samplingFrequencyIndex: a,
                channelConfiguration: o,
                frameLength: c,
                numberOfAacFrames: l,
                crcCheck: u,
                startPos: t,
            }
        );
    },
    IE = 1024;
class xE extends rv {
    constructor(e) {
        super(e),
            (this.metadataPromise = null),
            (this.firstFrameHeader = null),
            (this.loadedSamples = []),
            (this.tracks = []),
            (this.readingMutex = new lT()),
            (this.lastSampleLoaded = !1),
            (this.lastLoadedPos = 0),
            (this.nextTimestampInSamples = 0),
            (this.reader = e._reader);
    }
    async readMetadata() {
        return (this.metadataPromise ??= (async () => {
            for (; !this.firstFrameHeader && !this.lastSampleLoaded; ) await this.advanceReader();
            Vk(this.firstFrameHeader), (this.tracks = [new Bv(this.input, new AE(this))]);
        })());
    }
    async advanceReader() {
        let e = this.reader.requestSliceRange(this.lastLoadedPos, 7, 9);
        if ((e instanceof Promise && (e = await e), !e)) return void (this.lastSampleLoaded = !0);
        const t = CE(e);
        if (!t) return void (this.lastSampleLoaded = !0);
        if (null !== this.reader.fileSize && t.startPos + t.frameLength > this.reader.fileSize)
            return void (this.lastSampleLoaded = !0);
        this.firstFrameHeader || (this.firstFrameHeader = t);
        const n = d_[t.samplingFrequencyIndex];
        Vk(void 0 !== n);
        const r = IE / n,
            i = t.crcCheck ? 9 : 7,
            s = {
                timestamp: this.nextTimestampInSamples / n,
                duration: r,
                dataStart: t.startPos + i,
                dataSize: t.frameLength - i,
            };
        this.loadedSamples.push(s),
            (this.nextTimestampInSamples += IE),
            (this.lastLoadedPos = t.startPos + t.frameLength);
    }
    async getMimeType() {
        return "audio/aac";
    }
    async getTracks() {
        return await this.readMetadata(), this.tracks;
    }
    async computeDuration() {
        await this.readMetadata();
        const e = this.tracks[0];
        return Vk(e), e.computeDuration();
    }
    async getMetadataTags() {
        return {};
    }
}
class AE {
    constructor(e) {
        this.demuxer = e;
    }
    getId() {
        return 1;
    }
    async getFirstTimestamp() {
        return 0;
    }
    getTimeResolution() {
        return this.getSampleRate() / IE;
    }
    async computeDuration() {
        const e = await this.getPacket(1 / 0, { metadataOnly: !0 });
        return (e?.timestamp ?? 0) + (e?.duration ?? 0);
    }
    getName() {
        return null;
    }
    getLanguageCode() {
        return vT;
    }
    getCodec() {
        return "aac";
    }
    getInternalCodecId() {
        return Vk(this.demuxer.firstFrameHeader), this.demuxer.firstFrameHeader.objectType;
    }
    getNumberOfChannels() {
        Vk(this.demuxer.firstFrameHeader);
        const e = h_[this.demuxer.firstFrameHeader.channelConfiguration];
        return Vk(void 0 !== e), e;
    }
    getSampleRate() {
        Vk(this.demuxer.firstFrameHeader);
        const e = d_[this.demuxer.firstFrameHeader.samplingFrequencyIndex];
        return Vk(void 0 !== e), e;
    }
    async getDecoderConfig() {
        Vk(this.demuxer.firstFrameHeader);
        const e = new Uint8Array(3),
            t = new qk(e),
            { objectType: n, samplingFrequencyIndex: r, channelConfiguration: i } = this.demuxer.firstFrameHeader;
        return (
            n > 31 ? (t.writeBits(5, 31), t.writeBits(6, n - 32)) : t.writeBits(5, n),
            t.writeBits(4, r),
            t.writeBits(4, i),
            {
                codec: `mp4a.40.${this.demuxer.firstFrameHeader.objectType}`,
                numberOfChannels: this.getNumberOfChannels(),
                sampleRate: this.getSampleRate(),
                description: e.subarray(0, Math.ceil((t.pos - 1) / 8)),
            }
        );
    }
    async getPacketAtIndex(e, t) {
        if (-1 === e) return null;
        const n = this.demuxer.loadedSamples[e];
        if (!n) return null;
        let r;
        if (t.metadataOnly) r = cv;
        else {
            let e = this.demuxer.reader.requestSlice(n.dataStart, n.dataSize);
            if ((e instanceof Promise && (e = await e), !e)) return null;
            r = nC(e, n.dataSize);
        }
        return new lv(r, "key", n.timestamp, n.duration, e, n.dataSize);
    }
    getFirstPacket(e) {
        return this.getPacketAtIndex(0, e);
    }
    async getNextPacket(e, t) {
        const n = await this.demuxer.readingMutex.acquire();
        try {
            const n = hT(this.demuxer.loadedSamples, e.timestamp, (e) => e.timestamp);
            if (-1 === n) throw new Error("Packet was not created from this track.");
            const r = n + 1;
            for (; r >= this.demuxer.loadedSamples.length && !this.demuxer.lastSampleLoaded; )
                await this.demuxer.advanceReader();
            return this.getPacketAtIndex(r, t);
        } finally {
            n();
        }
    }
    async getPacket(e, t) {
        const n = await this.demuxer.readingMutex.acquire();
        try {
            for (;;) {
                const n = mT(this.demuxer.loadedSamples, e, (e) => e.timestamp);
                if (-1 === n && this.demuxer.loadedSamples.length > 0) return null;
                if (this.demuxer.lastSampleLoaded) return this.getPacketAtIndex(n, t);
                if (n >= 0 && n + 1 < this.demuxer.loadedSamples.length) return this.getPacketAtIndex(n, t);
                await this.demuxer.advanceReader();
            }
        } finally {
            n();
        }
    }
    getKeyPacket(e, t) {
        return this.getPacket(e, t);
    }
    getNextKeyPacket(e, t) {
        return this.getNextPacket(e, t);
    }
}
class PE extends rv {
    constructor(e) {
        super(e),
            (this.loadedSamples = []),
            (this.metadataPromise = null),
            (this.track = null),
            (this.metadataTags = {}),
            (this.audioInfo = null),
            (this.lastLoadedPos = null),
            (this.blockingBit = null),
            (this.readingMutex = new lT()),
            (this.lastSampleLoaded = !1),
            (this.reader = e._reader);
    }
    async computeDuration() {
        return await this.readMetadata(), Vk(this.track), this.track.computeDuration();
    }
    async getMetadataTags() {
        return await this.readMetadata(), this.metadataTags;
    }
    async getTracks() {
        return await this.readMetadata(), Vk(this.track), [this.track];
    }
    async getMimeType() {
        return "audio/flac";
    }
    async readMetadata() {
        let e = 4;
        return (this.metadataPromise ??= (async () => {
            for (; null === this.reader.fileSize || e < this.reader.fileSize; ) {
                let t = this.reader.requestSlice(e, 4);
                if ((t instanceof Promise && (t = await t), (e += 4), null === t))
                    throw new Error(`Metadata block at position ${e} is too small! Corrupted file.`);
                Vk(t);
                const n = rC(t),
                    r = aC(t),
                    i = !!(128 & n);
                switch (127 & n) {
                    case ev.STREAMINFO: {
                        let t = this.reader.requestSlice(e, r);
                        if ((t instanceof Promise && (t = await t), Vk(t), null === t))
                            throw new Error(`StreamInfo block at position ${e} is too small! Corrupted file.`);
                        const n = nC(t, 34),
                            i = new qk(n),
                            s = i.readBits(16),
                            a = i.readBits(16),
                            o = i.readBits(24),
                            c = i.readBits(24),
                            l = i.readBits(20),
                            u = i.readBits(3) + 1;
                        i.readBits(5);
                        const d = i.readBits(36);
                        i.skipBits(128);
                        const h = new Uint8Array(42);
                        h.set(new Uint8Array([102, 76, 97, 67]), 0),
                            h.set(new Uint8Array([128, 0, 0, 34]), 4),
                            h.set(n, 8),
                            (this.audioInfo = {
                                numberOfChannels: u,
                                sampleRate: l,
                                totalSamples: d,
                                minimumBlockSize: s,
                                maximumBlockSize: a,
                                minimumFrameSize: o,
                                maximumFrameSize: c,
                                description: h,
                            }),
                            (this.track = new Bv(this.input, new OE(this)));
                        break;
                    }
                    case ev.VORBIS_COMMENT: {
                        let t = this.reader.requestSlice(e, r);
                        t instanceof Promise && (t = await t), Vk(t), nv(nC(t, r), this.metadataTags);
                        break;
                    }
                    case ev.PICTURE: {
                        let t = this.reader.requestSlice(e, r);
                        t instanceof Promise && (t = await t), Vk(t);
                        const n = lC(t),
                            i = lC(t),
                            s = Qk.decode(nC(t, i)),
                            a = lC(t),
                            o = Qk.decode(nC(t, a));
                        t.skip(16);
                        const c = lC(t),
                            l = nC(t, c);
                        (this.metadataTags.images ??= []),
                            this.metadataTags.images.push({
                                data: l,
                                mimeType: s,
                                kind: 3 === n ? "coverFront" : 4 === n ? "coverBack" : "unknown",
                                description: o,
                            });
                        break;
                    }
                }
                if (((e += r), i)) {
                    this.lastLoadedPos = e;
                    break;
                }
            }
        })());
    }
    async readNextFlacFrame({ startPos: e, isFirstPacket: t }) {
        Vk(this.audioInfo);
        const n = this.audioInfo.maximumFrameSize + 16,
            r = await this.reader.requestSliceRange(e, this.audioInfo.minimumFrameSize, n);
        if (!r) return null;
        const i = this.readFlacFrameHeader({ slice: r, isFirstPacket: t });
        if (!i) return null;
        for (r.filePos = e + this.audioInfo.minimumFrameSize; ; ) {
            if (r.filePos > r.end - 6)
                return {
                    num: i.num,
                    blockSize: i.blockSize,
                    sampleRate: i.sampleRate,
                    size: r.end - e,
                    isLastFrame: !0,
                };
            if (255 === rC(r)) {
                if (rC(r) !== (1 === this.blockingBit ? 249 : 248)) {
                    r.skip(-1);
                    continue;
                }
                r.skip(-2);
                const t = r.filePos - e;
                if (!this.readFlacFrameHeader({ slice: r, isFirstPacket: !1 })) {
                    r.skip(-1);
                    continue;
                }
                return { num: i.num, blockSize: i.blockSize, sampleRate: i.sampleRate, size: t, isLastFrame: !1 };
            }
        }
    }
    readFlacFrameHeader({ slice: e, isFirstPacket: t }) {
        const n = e.filePos,
            r = nC(e, 4),
            i = new qk(r);
        if (32764 !== i.readBits(15)) return null;
        if (null === this.blockingBit) {
            Vk(t);
            const e = i.readBits(1);
            this.blockingBit = e;
        } else if (1 === this.blockingBit) {
            Vk(!t);
            if (1 !== i.readBits(1)) return null;
        } else {
            if (0 !== this.blockingBit) throw new Error("Invalid blocking bit");
            Vk(!t);
            if (0 !== i.readBits(1)) return null;
        }
        const s = ((e) =>
            0 === e
                ? null
                : 1 === e
                  ? 192
                  : e >= 2 && e <= 5
                    ? 144 * 2 ** e
                    : 6 === e
                      ? "uncommon-u8"
                      : 7 === e
                        ? "uncommon-u16"
                        : e >= 8 && e <= 15
                          ? 2 ** e
                          : null)(i.readBits(4));
        if (!s) return null;
        Vk(this.audioInfo);
        const a = ((e, t) => {
            switch (e) {
                case 0:
                    return t;
                case 1:
                    return 88200;
                case 2:
                    return 176400;
                case 3:
                    return 192e3;
                case 4:
                    return 8e3;
                case 5:
                    return 16e3;
                case 6:
                    return 22050;
                case 7:
                    return 24e3;
                case 8:
                    return 32e3;
                case 9:
                    return 44100;
                case 10:
                    return 48e3;
                case 11:
                    return 96e3;
                case 12:
                    return "uncommon-u8";
                case 13:
                    return "uncommon-u16";
                case 14:
                    return "uncommon-u16-10";
                default:
                    return null;
            }
        })(i.readBits(4), this.audioInfo.sampleRate);
        if (!a) return null;
        i.readBits(4), i.readBits(3);
        if (0 !== i.readBits(1)) return null;
        const o = ((e) => {
                let t = 0;
                const n = new qk(nC(e, 1));
                for (; 1 === n.readBits(1); ) t++;
                if (0 === t) return n.readBits(7);
                const r = [],
                    i = t - 1,
                    s = new qk(nC(e, i)),
                    a = 8 - t - 1;
                for (let o = 0; o < a; o++) r.unshift(n.readBits(1));
                for (let o = 0; o < i; o++)
                    for (let e = 0; e < 8; e++) {
                        const t = s.readBits(1);
                        e < 2 || r.unshift(t);
                    }
                return r.reduce((e, t, n) => e | (t << n), 0);
            })(e),
            c = ((e, t) =>
                "uncommon-u16" === t
                    ? sC(e) + 1
                    : "uncommon-u8" === t
                      ? rC(e) + 1
                      : "number" == typeof t
                        ? t
                        : (yT(t), void Vk(!1)))(e, s),
            l = ((e, t) =>
                "uncommon-u16" === t
                    ? sC(e)
                    : "uncommon-u16-10" === t
                      ? 10 * sC(e)
                      : "uncommon-u8" === t
                        ? rC(e)
                        : "number" == typeof t
                          ? t
                          : null)(e, a);
        if (null === l) return null;
        const u = e.filePos - n,
            d = rC(e);
        e.skip(-u), e.skip(-1);
        const h = ((e) => {
            let t = 0;
            for (const n of e) {
                t ^= n;
                for (let e = 0; e < 8; e++) 128 & t ? (t = (t << 1) ^ 7) : (t <<= 1), (t &= 255);
            }
            return t;
        })(nC(e, u));
        return d !== h ? null : { num: o, blockSize: c, sampleRate: l };
    }
    async advanceReader() {
        await this.readMetadata(), Vk(null !== this.lastLoadedPos), Vk(this.audioInfo);
        const e = this.lastLoadedPos,
            t = await this.readNextFlacFrame({ startPos: e, isFirstPacket: 0 === this.loadedSamples.length });
        if (!t) return void (this.lastSampleLoaded = !0);
        const n = this.loadedSamples[this.loadedSamples.length - 1],
            r = {
                blockOffset: n ? n.blockOffset + n.blockSize : 0,
                blockSize: t.blockSize,
                byteOffset: e,
                byteSize: t.size,
            };
        (this.lastLoadedPos = this.lastLoadedPos + t.size),
            this.loadedSamples.push(r),
            t.isLastFrame && (this.lastSampleLoaded = !0);
    }
}
class OE {
    constructor(e) {
        this.demuxer = e;
    }
    getId() {
        return 1;
    }
    getCodec() {
        return "flac";
    }
    getInternalCodecId() {
        return null;
    }
    getNumberOfChannels() {
        return Vk(this.demuxer.audioInfo), this.demuxer.audioInfo.numberOfChannels;
    }
    async computeDuration() {
        const e = await this.getPacket(1 / 0, { metadataOnly: !0 });
        return (e?.timestamp ?? 0) + (e?.duration ?? 0);
    }
    getSampleRate() {
        return Vk(this.demuxer.audioInfo), this.demuxer.audioInfo.sampleRate;
    }
    getName() {
        return null;
    }
    getLanguageCode() {
        return vT;
    }
    getTimeResolution() {
        return Vk(this.demuxer.audioInfo), this.demuxer.audioInfo.sampleRate;
    }
    async getFirstTimestamp() {
        return 0;
    }
    async getDecoderConfig() {
        return (
            Vk(this.demuxer.audioInfo),
            {
                codec: "flac",
                numberOfChannels: this.demuxer.audioInfo.numberOfChannels,
                sampleRate: this.demuxer.audioInfo.sampleRate,
                description: this.demuxer.audioInfo.description,
            }
        );
    }
    async getPacket(e, t) {
        if ((Vk(this.demuxer.audioInfo), e < 0)) throw new Error("Timestamp cannot be negative");
        const n = await this.demuxer.readingMutex.acquire();
        try {
            for (;;) {
                const n = mT(this.demuxer.loadedSamples, e, (e) => e.blockOffset / this.demuxer.audioInfo.sampleRate);
                if (-1 === n) {
                    await this.demuxer.advanceReader();
                    continue;
                }
                const r = this.demuxer.loadedSamples[n],
                    i = r.blockOffset / this.demuxer.audioInfo.sampleRate;
                if (!(i + r.blockSize / this.demuxer.audioInfo.sampleRate <= e)) return this.getPacketAtIndex(n, t);
                if (this.demuxer.lastSampleLoaded)
                    return this.getPacketAtIndex(this.demuxer.loadedSamples.length - 1, t);
                await this.demuxer.advanceReader();
            }
        } finally {
            n();
        }
    }
    async getNextPacket(e, t) {
        const n = await this.demuxer.readingMutex.acquire();
        try {
            const n = e.sequenceNumber + 1;
            if (this.demuxer.lastSampleLoaded && n >= this.demuxer.loadedSamples.length) return null;
            for (; n >= this.demuxer.loadedSamples.length && !this.demuxer.lastSampleLoaded; )
                await this.demuxer.advanceReader();
            return this.getPacketAtIndex(n, t);
        } finally {
            n();
        }
    }
    getKeyPacket(e, t) {
        return this.getPacket(e, t);
    }
    getNextKeyPacket(e, t) {
        return this.getNextPacket(e, t);
    }
    async getPacketAtIndex(e, t) {
        const n = this.demuxer.loadedSamples[e];
        if (!n) return null;
        let r;
        if (t.metadataOnly) r = cv;
        else {
            let e = this.demuxer.reader.requestSlice(n.byteOffset, n.byteSize);
            if ((e instanceof Promise && (e = await e), !e)) return null;
            r = nC(e, n.byteSize);
        }
        Vk(this.demuxer.audioInfo);
        const i = n.blockOffset / this.demuxer.audioInfo.sampleRate,
            s = n.blockSize / this.demuxer.audioInfo.sampleRate;
        return new lv(r, "key", i, s, e, n.byteSize);
    }
    async getFirstPacket(e) {
        for (; 0 === this.demuxer.loadedSamples.length && !this.demuxer.lastSampleLoaded; )
            await this.demuxer.advanceReader();
        return this.getPacketAtIndex(0, e);
    }
}
class NE {}
class RE extends NE {
    async _getMajorBrand(e) {
        let t = e._reader.requestSlice(0, 12);
        if ((t instanceof Promise && (t = await t), !t)) return null;
        t.skip(4);
        return "ftyp" !== yC(t, 4) ? null : yC(t, 4);
    }
    _createDemuxer(e) {
        return new Xv(e);
    }
}
class ME extends NE {
    async isSupportedEBMLOfDocType(e, t) {
        let n = e._reader.requestSlice(0, bS);
        if ((n instanceof Promise && (n = await n), !n)) return !1;
        const r = yS(n);
        if (null === r) return !1;
        if (r < 1 || r > 8) return !1;
        if (kS(n, r) !== cS.EBML) return !1;
        const i = _S(n);
        if (null === i) return !1;
        let s = e._reader.requestSlice(n.filePos, i);
        if ((s instanceof Promise && (s = await s), !s)) return !1;
        const a = n.filePos;
        for (; s.filePos <= a + i - 2; ) {
            const e = vS(s);
            if (!e) break;
            const { id: n, size: r } = e,
                i = s.filePos;
            if (null === r) return !1;
            switch (n) {
                case cS.EBMLVersion:
                    if (1 !== kS(s, r)) return !1;
                    break;
                case cS.EBMLReadVersion:
                    if (1 !== kS(s, r)) return !1;
                    break;
                case cS.DocType:
                    if (SS(s, r) !== t) return !1;
                    break;
                case cS.DocTypeVersion:
                    if (kS(s, r) > 4) return !1;
            }
            s.filePos = i + r;
        }
        return !0;
    }
    _canReadInput(e) {
        return this.isSupportedEBMLOfDocType(e, "matroska");
    }
    _createDemuxer(e) {
        return new US(e);
    }
    get name() {
        return "Matroska";
    }
    get mimeType() {
        return "video/x-matroska";
    }
}
const DE = new (class extends RE {
        async _canReadInput(e) {
            const t = await this._getMajorBrand(e);
            return !!t && "qt  " !== t;
        }
        get name() {
            return "MP4";
        }
        get mimeType() {
            return "video/mp4";
        }
    })(),
    FE = new (class extends RE {
        async _canReadInput(e) {
            return "qt  " === (await this._getMajorBrand(e));
        }
        get name() {
            return "QuickTime File Format";
        }
        get mimeType() {
            return "video/quicktime";
        }
    })(),
    LE = new ME(),
    BE = new (class extends ME {
        _canReadInput(e) {
            return this.isSupportedEBMLOfDocType(e, "webm");
        }
        get name() {
            return "WebM";
        }
        get mimeType() {
            return "video/webm";
        }
    })(),
    zE = new (class extends NE {
        async _canReadInput(e) {
            let t = e._reader.requestSlice(0, 10);
            if ((t instanceof Promise && (t = await t), !t)) return !1;
            let n = 0,
                r = !1;
            for (;;) {
                let t = e._reader.requestSlice(n, 10);
                if ((t instanceof Promise && (t = await t), !t)) break;
                const i = nE(t);
                if (!i) break;
                (r = !0), (n = t.filePos + i.size);
            }
            const i = await aE(e._reader, n, n + 4096);
            if (!i) return !1;
            if (r) return !0;
            n = i.startPos + i.header.totalSize;
            const s = await aE(e._reader, n, n + 4);
            if (!s) return !1;
            const a = i.header,
                o = s.header;
            return a.channel === o.channel && a.sampleRate === o.sampleRate;
        }
        _createDemuxer(e) {
            return new oE(e);
        }
        get name() {
            return "MP3";
        }
        get mimeType() {
            return "audio/mpeg";
        }
    })(),
    UE = new (class extends NE {
        async _canReadInput(e) {
            let t = e._reader.requestSlice(0, 12);
            if ((t instanceof Promise && (t = await t), !t)) return !1;
            const n = yC(t, 4);
            if ("RIFF" !== n && "RIFX" !== n && "RF64" !== n) return !1;
            t.skip(4);
            return "WAVE" === yC(t, 4);
        }
        _createDemuxer(e) {
            return new vE(e);
        }
        get name() {
            return "WAVE";
        }
        get mimeType() {
            return "audio/wav";
        }
    })(),
    $E = new (class extends NE {
        async _canReadInput(e) {
            let t = e._reader.requestSlice(0, 4);
            return t instanceof Promise && (t = await t), !!t && "OggS" === yC(t, 4);
        }
        _createDemuxer(e) {
            return new bE(e);
        }
        get name() {
            return "Ogg";
        }
        get mimeType() {
            return "application/ogg";
        }
    })(),
    VE = new (class extends NE {
        async _canReadInput(e) {
            let t = e._reader.requestSliceRange(0, 7, 9);
            if ((t instanceof Promise && (t = await t), !t)) return !1;
            const n = CE(t);
            if (!n) return !1;
            if (((t = e._reader.requestSliceRange(n.frameLength, 7, 9)), t instanceof Promise && (t = await t), !t))
                return !1;
            const r = CE(t);
            return (
                !!r &&
                n.objectType === r.objectType &&
                n.samplingFrequencyIndex === r.samplingFrequencyIndex &&
                n.channelConfiguration === r.channelConfiguration
            );
        }
        _createDemuxer(e) {
            return new xE(e);
        }
        get name() {
            return "ADTS";
        }
        get mimeType() {
            return "audio/aac";
        }
    })(),
    WE = [
        DE,
        FE,
        LE,
        BE,
        UE,
        $E,
        new (class extends NE {
            async _canReadInput(e) {
                let t = e._reader.requestSlice(0, 4);
                return t instanceof Promise && (t = await t), !!t && "fLaC" === yC(t, 4);
            }
            get name() {
                return "FLAC";
            }
            get mimeType() {
                return "audio/flac";
            }
            _createDemuxer(e) {
                return new PE(e);
            }
        })(),
        zE,
        VE,
    ];
class jE {
    constructor() {
        (this._disposed = !1), (this._sizePromise = null), (this.onread = null);
    }
    async getSizeOrNull() {
        if (this._disposed) throw new JE();
        return (this._sizePromise ??= Promise.resolve(this._retrieveSize()));
    }
    async getSize() {
        if (this._disposed) throw new JE();
        const e = await this.getSizeOrNull();
        if (null === e) throw new Error("Cannot determine the size of an unsized source.");
        return e;
    }
}
class HE extends jE {
    constructor(e, t = {}) {
        if (!(e instanceof Blob)) throw new TypeError("blob must be a Blob.");
        if (!t || "object" != typeof t) throw new TypeError("options must be an object.");
        if (void 0 !== t.maxCacheSize && (!jT(t.maxCacheSize) || t.maxCacheSize < 0))
            throw new TypeError("options.maxCacheSize, when provided, must be a non-negative number.");
        super(),
            (this._readers = new WeakMap()),
            (this._blob = e),
            (this._orchestrator = new YE({
                maxCacheSize: t.maxCacheSize ?? 8388608,
                maxWorkerCount: 4,
                runWorker: this._runWorker.bind(this),
                prefetchProfile: KE.fileSystem,
            }));
    }
    _retrieveSize() {
        const e = this._blob.size;
        return (this._orchestrator.fileSize = e), e;
    }
    _read(e, t) {
        return this._orchestrator.read(e, t);
    }
    async _runWorker(e) {
        let t = this._readers.get(e);
        if (void 0 === t) {
            if ("stream" in this._blob) {
                t = this._blob.slice(e.currentPos).stream().getReader();
            } else t = null;
            this._readers.set(e, t);
        }
        for (; e.currentPos < e.targetPos && !e.aborted; )
            if (t) {
                const { done: n, value: r } = await t.read();
                if (n) {
                    if ((this._orchestrator.forgetWorker(e), e.currentPos < e.targetPos))
                        throw new Error("Blob reader stopped unexpectedly before all requested data was read.");
                    break;
                }
                this.onread?.(e.currentPos, e.currentPos + r.length), this._orchestrator.supplyWorkerData(e, r);
            } else {
                const t = await this._blob.slice(e.currentPos, e.targetPos).arrayBuffer();
                this.onread?.(e.currentPos, e.currentPos + t.byteLength),
                    this._orchestrator.supplyWorkerData(e, new Uint8Array(t));
            }
        e.running = !1;
    }
    _dispose() {
        this._orchestrator.dispose();
    }
}
const qE = 524288,
    XE = (e, t, n) => {
        if (
            t instanceof Error &&
            (t.message.includes("Failed to fetch") ||
                t.message.includes("Load failed") ||
                t.message.includes("NetworkError when attempting to fetch resource"))
        ) {
            let e = null;
            try {
                "undefined" != typeof window &&
                    void 0 !== window.location &&
                    (e = new URL(n instanceof Request ? n.url : n, window.location.href).origin);
            } catch {}
            if (
                ("undefined" == typeof navigator || "boolean" != typeof navigator.onLine || navigator.onLine) &&
                null !== e &&
                e !== window.location.origin
            )
                return null;
        }
        return Math.min(2 ** (e - 2), 16);
    };
class GE extends jE {
    constructor(e, t = {}) {
        if (!("string" == typeof e || e instanceof URL || ("undefined" != typeof Request && e instanceof Request)))
            throw new TypeError("url must be a string, URL or Request.");
        if (!t || "object" != typeof t) throw new TypeError("options must be an object.");
        if (void 0 !== t.requestInit && (!t.requestInit || "object" != typeof t.requestInit))
            throw new TypeError("options.requestInit, when provided, must be an object.");
        if (void 0 !== t.getRetryDelay && "function" != typeof t.getRetryDelay)
            throw new TypeError("options.getRetryDelay, when provided, must be a function.");
        if (void 0 !== t.maxCacheSize && (!jT(t.maxCacheSize) || t.maxCacheSize < 0))
            throw new TypeError("options.maxCacheSize, when provided, must be a non-negative number.");
        if (void 0 !== t.fetchFn && "function" != typeof t.fetchFn)
            throw new TypeError("options.fetchFn, when provided, must be a function.");
        super(),
            (this._existingResponses = new WeakMap()),
            (this._url = e),
            (this._options = t),
            (this._getRetryDelay = t.getRetryDelay ?? XE),
            (this._orchestrator = new YE({
                maxCacheSize: t.maxCacheSize ?? 67108864,
                maxWorkerCount: 2,
                runWorker: this._runWorker.bind(this),
                prefetchProfile: KE.network,
            }));
    }
    async _retrieveSize() {
        const e = new AbortController(),
            t = await OT(
                this._options.fetchFn ?? fetch,
                this._url,
                AT(this._options.requestInit ?? {}, { headers: { Range: "bytes=0-" }, signal: e.signal }),
                this._getRetryDelay
            );
        if (!t.ok) throw new Error(`Error fetching ${String(this._url)}: ${t.status} ${t.statusText}`);
        let n, r;
        if (206 === t.status)
            (r = this._getPartialLengthFromRangeResponse(t)), (n = this._orchestrator.createWorker(0, Math.min(r, qE)));
        else {
            const e = t.headers.get("Content-Length");
            if (!e) throw new Error(`HTTP response (status ${t.status}) must surface Content-Length header.`);
            (r = Number(e)),
                (n = this._orchestrator.createWorker(0, r)),
                (this._orchestrator.options.maxCacheSize = 1 / 0);
        }
        return (
            (this._orchestrator.fileSize = r),
            this._existingResponses.set(n, { response: t, abortController: e }),
            this._orchestrator.runWorker(n),
            r
        );
    }
    _read(e, t) {
        return this._orchestrator.read(e, t);
    }
    async _runWorker(e) {
        for (; !e.aborted; ) {
            const n = this._existingResponses.get(e);
            this._existingResponses.delete(e);
            let r = n?.abortController,
                i = n?.response;
            if (
                (r ||
                    ((r = new AbortController()),
                    (i = await OT(
                        this._options.fetchFn ?? fetch,
                        this._url,
                        AT(this._options.requestInit ?? {}, {
                            headers: { Range: `bytes=${e.currentPos}-` },
                            signal: r.signal,
                        }),
                        this._getRetryDelay
                    ))),
                Vk(i),
                !i.ok)
            )
                throw new Error(`Error fetching ${String(this._url)}: ${i.status} ${i.statusText}`);
            if (e.currentPos > 0 && 206 !== i.status)
                throw new Error(
                    "HTTP server did not respond with 206 Partial Content to a range request. To enable efficient media file streaming across a network, please make sure your server supports range requests."
                );
            const s = this._getPartialLengthFromRangeResponse(i),
                a = e.targetPos - e.currentPos;
            if (s < a)
                throw new Error(`HTTP response unexpectedly too short: Needed at least ${a} bytes, got only ${s}.`);
            if (!i.body)
                throw new Error(
                    "Missing HTTP response body stream. The used fetch function must provide the response body as a ReadableStream."
                );
            const o = i.body.getReader();
            for (;;) {
                if (e.currentPos >= e.targetPos || e.aborted) return r.abort(), void (e.running = !1);
                let n;
                try {
                    n = await o.read();
                } catch (t) {
                    const e = this._getRetryDelay(1, t, this._url);
                    if (null !== e) {
                        await new Promise((t) => setTimeout(t, 1e3 * e));
                        break;
                    }
                    throw t;
                }
                const { done: i, value: s } = n;
                if (i) {
                    if ((this._orchestrator.forgetWorker(e), e.currentPos < e.targetPos))
                        throw new Error(
                            "Response stream reader stopped unexpectedly before all requested data was read."
                        );
                    return void (e.running = !1);
                }
                this.onread?.(e.currentPos, e.currentPos + s.length), this._orchestrator.supplyWorkerData(e, s);
            }
        }
        e.running = !1;
    }
    _getPartialLengthFromRangeResponse(e) {
        const t = e.headers.get("Content-Range");
        if (t) {
            const e = /\/(\d+)/.exec(t);
            if (e) return Number(e[1]);
            throw new Error(`Invalid Content-Range header: ${t}`);
        }
        {
            const t = e.headers.get("Content-Length");
            if (t) return Number(t);
            throw new Error(
                "Partial HTTP response (status 206) must surface either Content-Range or Content-Length header."
            );
        }
    }
    _dispose() {
        this._orchestrator.dispose();
    }
}
const KE = {
    fileSystem: (e, t) => {
        const n = 65536;
        return { start: (e = Math.floor((e - n) / n) * n), end: (t = Math.ceil((t + n) / n) * n) };
    },
    network: (e, t, n) => {
        const r = 65536;
        e = Math.max(0, Math.floor((e - r) / r) * r);
        for (const i of n) {
            const n = 8388608,
                r = Math.max((i.startPos + i.targetPos) / 2, i.targetPos - n);
            if (BT(e, t, r, i.targetPos)) {
                const e = i.targetPos - i.startPos,
                    r = Math.ceil((e + 1) / n) * n,
                    s = 2 ** Math.ceil(Math.log2(e + 1)),
                    a = Math.min(s, r);
                t = Math.max(t, i.startPos + a);
            }
        }
        return { start: e, end: (t = Math.max(t, e + qE)) };
    },
};
class YE {
    constructor(e) {
        (this.options = e),
            (this.fileSize = null),
            (this.nextAge = 0),
            (this.workers = []),
            (this.cache = []),
            (this.currentCacheSize = 0),
            (this.disposed = !1);
    }
    read(e, t) {
        Vk(null !== this.fileSize);
        const n = this.options.prefetchProfile(e, t, this.workers),
            r = Math.max(n.start, 0),
            i = Math.min(n.end, this.fileSize);
        Vk(r <= e && t <= i);
        let s = null;
        const a = mT(this.cache, e, (e) => e.start),
            o = -1 !== a ? this.cache[a] : null;
        o &&
            o.start <= e &&
            t <= o.end &&
            ((o.age = this.nextAge++), (s = { bytes: o.bytes, view: o.view, offset: o.start }));
        const c = mT(this.cache, r, (e) => e.start),
            l = s ? null : new Uint8Array(t - e);
        let u = 0,
            d = r;
        const h = [];
        if (-1 !== c) {
            for (let n = c; n < this.cache.length; n++) {
                const s = this.cache[n];
                if (s.start >= i) break;
                if (s.end <= r) continue;
                const a = Math.max(r, s.start),
                    o = Math.min(i, s.end);
                if ((Vk(a <= o), d < a && h.push({ start: d, end: a }), (d = o), l)) {
                    const n = Math.max(e, s.start),
                        r = Math.min(t, s.end);
                    if (n < r) {
                        const t = n - e;
                        l.set(s.bytes.subarray(n - s.start, r - s.start), t), t === u && (u = r - e);
                    }
                }
                s.age = this.nextAge++;
            }
            d < i && h.push({ start: d, end: i });
        } else h.push({ start: r, end: i });
        if ((l && u >= l.length && (s = { bytes: l, view: Yk(l), offset: e }), 0 === h.length)) return Vk(s), s;
        const { promise: m, resolve: p, reject: f } = fT(),
            g = [];
        for (const b of h) {
            const n = Math.max(e, b.start),
                r = Math.min(t, b.end);
            n === b.start && r === b.end ? g.push(b) : n < r && g.push({ start: n, end: r });
        }
        for (const b of h) {
            const t = l && { start: e, bytes: l, holes: g, resolve: p, reject: f };
            let n = !1;
            for (const e of this.workers) {
                const r = 2 ** 17;
                if (BT(b.start - r, b.start, e.currentPos, e.targetPos)) {
                    (e.targetPos = Math.max(e.targetPos, b.end)),
                        (n = !0),
                        t && !e.pendingSlices.includes(t) && e.pendingSlices.push(t),
                        e.running || this.runWorker(e);
                    break;
                }
            }
            if (!n) {
                const e = this.createWorker(b.start, b.end);
                t && (e.pendingSlices = [t]), this.runWorker(e);
            }
        }
        return s || (Vk(l), (s = m.then((t) => ({ bytes: t, view: Yk(t), offset: e })))), s;
    }
    createWorker(e, t) {
        const n = {
            startPos: e,
            currentPos: e,
            targetPos: t,
            running: !1,
            aborted: !1,
            pendingSlices: [],
            age: this.nextAge++,
        };
        for (this.workers.push(n); this.workers.length > this.options.maxWorkerCount; ) {
            let e = 0,
                t = this.workers[0];
            for (let n = 1; n < this.workers.length; n++) {
                const r = this.workers[n];
                r.age < t.age && ((e = n), (t = r));
            }
            if (t.running && t.pendingSlices.length > 0) break;
            (t.aborted = !0), this.workers.splice(e, 1);
        }
        return n;
    }
    runWorker(e) {
        Vk(!e.running),
            Vk(e.currentPos < e.targetPos),
            (e.running = !0),
            (e.age = this.nextAge++),
            this.options.runWorker(e).catch((t) => {
                if (((e.running = !1), !(e.pendingSlices.length > 0))) throw t;
                e.pendingSlices.forEach((e) => e.reject(t)), (e.pendingSlices.length = 0);
            });
    }
    supplyWorkerData(e, t) {
        if (this.disposed) return;
        const n = e.currentPos,
            r = n + t.length;
        this.insertIntoCache({ start: n, end: r, bytes: t, view: Yk(t), age: this.nextAge++ }),
            (e.currentPos += t.length),
            (e.targetPos = Math.max(e.targetPos, e.currentPos));
        for (let i = 0; i < e.pendingSlices.length; i++) {
            const s = e.pendingSlices[i],
                a = Math.max(n, s.start),
                o = Math.min(r, s.start + s.bytes.length);
            a < o && s.bytes.set(t.subarray(a - n, o - n), a - s.start);
            for (let e = 0; e < s.holes.length; e++) {
                const t = s.holes[e];
                n <= t.start && r > t.start && (t.start = r), t.end <= t.start && (s.holes.splice(e, 1), e--);
            }
            0 === s.holes.length && (s.resolve(s.bytes), e.pendingSlices.splice(i, 1), i--);
        }
        for (let i = 0; i < this.workers.length; i++) {
            const t = this.workers[i];
            e === t || t.running || (BT(n, r, t.currentPos, t.targetPos) && (this.workers.splice(i, 1), i--));
        }
    }
    forgetWorker(e) {
        const t = this.workers.indexOf(e);
        Vk(-1 !== t), this.workers.splice(t, 1);
    }
    insertIntoCache(e) {
        if (0 === this.options.maxCacheSize) return;
        let t = mT(this.cache, e.start, (e) => e.start) + 1;
        if (t > 0) {
            const n = this.cache[t - 1];
            if (n.end >= e.end) return;
            if (n.end > e.start) {
                const r = new Uint8Array(e.end - n.start);
                r.set(n.bytes, 0),
                    r.set(e.bytes, e.start - n.start),
                    (this.currentCacheSize += e.end - n.end),
                    (n.bytes = r),
                    (n.view = Yk(r)),
                    (n.end = e.end),
                    t--,
                    (e = n);
            } else this.cache.splice(t, 0, e), (this.currentCacheSize += e.bytes.length);
        } else this.cache.splice(t, 0, e), (this.currentCacheSize += e.bytes.length);
        for (let n = t + 1; n < this.cache.length; n++) {
            const t = this.cache[n];
            if (e.end <= t.start) break;
            if (e.end >= t.end) {
                this.cache.splice(n, 1), (this.currentCacheSize -= t.bytes.length), n--;
                continue;
            }
            const r = new Uint8Array(t.end - e.start);
            r.set(e.bytes, 0),
                r.set(t.bytes, t.start - e.start),
                (this.currentCacheSize -= e.end - t.start),
                (e.bytes = r),
                (e.view = Yk(r)),
                (e.end = t.end),
                this.cache.splice(n, 1);
            break;
        }
        for (; this.currentCacheSize > this.options.maxCacheSize; ) {
            let e = 0,
                t = this.cache[0];
            for (let n = 1; n < this.cache.length; n++) {
                const r = this.cache[n];
                r.age < t.age && ((e = n), (t = r));
            }
            if (this.currentCacheSize - t.bytes.length <= this.options.maxCacheSize) break;
            this.cache.splice(e, 1), (this.currentCacheSize -= t.bytes.length);
        }
    }
    dispose() {
        for (const e of this.workers) e.aborted = !0;
        (this.workers.length = 0), (this.cache.length = 0), (this.disposed = !0);
    }
}
WT();
class QE {
    get disposed() {
        return this._disposed;
    }
    constructor(e) {
        if (((this._demuxerPromise = null), (this._format = null), (this._disposed = !1), !e || "object" != typeof e))
            throw new TypeError("options must be an object.");
        if (!Array.isArray(e.formats) || e.formats.some((e) => !(e instanceof NE)))
            throw new TypeError("options.formats must be an array of InputFormat.");
        if (!(e.source instanceof jE)) throw new TypeError("options.source must be a Source.");
        if (e.source._disposed) throw new Error("options.source must not be disposed.");
        (this._formats = e.formats), (this._source = e.source), (this._reader = new ZE(e.source));
    }
    _getDemuxer() {
        return (this._demuxerPromise ??= (async () => {
            this._reader.fileSize = await this._source.getSizeOrNull();
            for (const e of this._formats) {
                if (await e._canReadInput(this)) return (this._format = e), e._createDemuxer(this);
            }
            throw new Error("Input has an unsupported or unrecognizable format.");
        })());
    }
    get source() {
        return this._source;
    }
    async getFormat() {
        return await this._getDemuxer(), Vk(this._format), this._format;
    }
    async computeDuration() {
        return (await this._getDemuxer()).computeDuration();
    }
    async getTracks() {
        return (await this._getDemuxer()).getTracks();
    }
    async getVideoTracks() {
        return (await this.getTracks()).filter((e) => e.isVideoTrack());
    }
    async getAudioTracks() {
        return (await this.getTracks()).filter((e) => e.isAudioTrack());
    }
    async getPrimaryVideoTrack() {
        return (await this.getTracks()).find((e) => e.isVideoTrack()) ?? null;
    }
    async getPrimaryAudioTrack() {
        return (await this.getTracks()).find((e) => e.isAudioTrack()) ?? null;
    }
    async getMimeType() {
        return (await this._getDemuxer()).getMimeType();
    }
    async getMetadataTags() {
        return (await this._getDemuxer()).getMetadataTags();
    }
    dispose() {
        this._disposed || ((this._disposed = !0), (this._source._disposed = !0), this._source._dispose());
    }
    [Symbol.dispose]() {
        this.dispose();
    }
}
class JE extends Error {
    constructor(e = "Input has been disposed.") {
        super(e), (this.name = "InputDisposedError");
    }
}
class ZE {
    constructor(e) {
        this.source = e;
    }
    requestSlice(e, t) {
        if (this.source._disposed) throw new JE();
        if (null !== this.fileSize && e + t > this.fileSize) return null;
        const n = e + t,
            r = this.source._read(e, n);
        return r instanceof Promise
            ? r.then((t) => (t ? new eC(t.bytes, t.view, t.offset, e, n) : null))
            : r
              ? new eC(r.bytes, r.view, r.offset, e, n)
              : null;
    }
    requestSliceRange(e, t, n) {
        if (this.source._disposed) throw new JE();
        if (null !== this.fileSize) return this.requestSlice(e, _T(this.fileSize - e, t, n));
        {
            const r = this.requestSlice(e, n),
                i = (r) => {
                    if (r) return r;
                    const i = (r) => (Vk(null !== r), this.requestSlice(e, _T(r - e, t, n))),
                        s = this.source._retrieveSize();
                    return s instanceof Promise ? s.then(i) : i(s);
                };
            return r instanceof Promise ? r.then(i) : i(r);
        }
    }
}
class eC {
    constructor(e, t, n, r, i) {
        (this.bytes = e),
            (this.view = t),
            (this.offset = n),
            (this.start = r),
            (this.end = i),
            (this.bufferPos = r - n);
    }
    static tempFromBytes(e) {
        return new eC(e, Yk(e), 0, 0, e.length);
    }
    get length() {
        return this.end - this.start;
    }
    get filePos() {
        return this.offset + this.bufferPos;
    }
    set filePos(e) {
        this.bufferPos = e - this.offset;
    }
    get remainingLength() {
        return Math.max(this.end - this.filePos, 0);
    }
    skip(e) {
        this.bufferPos += e;
    }
    slice(e, t = this.end - e) {
        if (e < this.start || e + t > this.end) throw new RangeError("Slicing outside of original slice.");
        return new eC(this.bytes, this.view, this.offset, e, e + t);
    }
}
const tC = (e, t) => {
        if (e.filePos < e.start || e.filePos + t > e.end)
            throw new RangeError(
                `Tried reading [${e.filePos}, ${e.filePos + t}), but slice is [${e.start}, ${e.end}). This is likely an internal error, please report it alongside the file that caused it.`
            );
    },
    nC = (e, t) => {
        tC(e, t);
        const n = e.bytes.subarray(e.bufferPos, e.bufferPos + t);
        return (e.bufferPos += t), n;
    },
    rC = (e) => (tC(e, 1), e.view.getUint8(e.bufferPos++)),
    iC = (e, t) => {
        tC(e, 2);
        const n = e.view.getUint16(e.bufferPos, t);
        return (e.bufferPos += 2), n;
    },
    sC = (e) => {
        tC(e, 2);
        const t = e.view.getUint16(e.bufferPos, !1);
        return (e.bufferPos += 2), t;
    },
    aC = (e) => {
        tC(e, 3);
        const t = wT(e.view, e.bufferPos, !1);
        return (e.bufferPos += 3), t;
    },
    oC = (e) => {
        tC(e, 2);
        const t = e.view.getInt16(e.bufferPos, !1);
        return (e.bufferPos += 2), t;
    },
    cC = (e, t) => {
        tC(e, 4);
        const n = e.view.getUint32(e.bufferPos, t);
        return (e.bufferPos += 4), n;
    },
    lC = (e) => {
        tC(e, 4);
        const t = e.view.getUint32(e.bufferPos, !1);
        return (e.bufferPos += 4), t;
    },
    uC = (e) => {
        tC(e, 4);
        const t = e.view.getUint32(e.bufferPos, !0);
        return (e.bufferPos += 4), t;
    },
    dC = (e) => {
        tC(e, 4);
        const t = e.view.getInt32(e.bufferPos, !1);
        return (e.bufferPos += 4), t;
    },
    hC = (e, t) => {
        let n, r;
        return t ? ((n = cC(e, !0)), (r = cC(e, !0))) : ((r = cC(e, !1)), (n = cC(e, !1))), 4294967296 * r + n;
    },
    mC = (e) => 4294967296 * lC(e) + lC(e),
    pC = (e) => 4294967296 * dC(e) + lC(e),
    fC = (e) => {
        const t = uC(e),
            n = ((e) => {
                tC(e, 4);
                const t = e.view.getInt32(e.bufferPos, !0);
                return (e.bufferPos += 4), t;
            })(e);
        return 4294967296 * n + t;
    },
    gC = (e) => {
        tC(e, 4);
        const t = e.view.getFloat32(e.bufferPos, !1);
        return (e.bufferPos += 4), t;
    },
    bC = (e) => {
        tC(e, 8);
        const t = e.view.getFloat64(e.bufferPos, !1);
        return (e.bufferPos += 8), t;
    },
    yC = (e, t) => {
        tC(e, t);
        let n = "";
        for (let r = 0; r < t; r++) n += String.fromCharCode(e.bytes[e.bufferPos++]);
        return n;
    },
    wC = /<(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})>/g,
    kC = /(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})/,
    TC = (e) => {
        const t = Math.floor(e / 36e5),
            n = Math.floor((e % 36e5) / 6e4),
            r = Math.floor((e % 6e4) / 1e3),
            i = e % 1e3;
        return (
            t.toString().padStart(2, "0") +
            ":" +
            n.toString().padStart(2, "0") +
            ":" +
            r.toString().padStart(2, "0") +
            "." +
            i.toString().padStart(3, "0")
        );
    };
class _C {
    constructor(e) {
        (this.writer = e),
            (this.helper = new Uint8Array(8)),
            (this.helperView = new DataView(this.helper.buffer)),
            (this.offsets = new WeakMap());
    }
    writeU32(e) {
        this.helperView.setUint32(0, e, !1), this.writer.write(this.helper.subarray(0, 4));
    }
    writeU64(e) {
        this.helperView.setUint32(0, Math.floor(e / 2 ** 32), !1),
            this.helperView.setUint32(4, e, !1),
            this.writer.write(this.helper.subarray(0, 8));
    }
    writeAscii(e) {
        for (let t = 0; t < e.length; t++)
            this.helperView.setUint8(t % 8, e.charCodeAt(t)), t % 8 == 7 && this.writer.write(this.helper);
        e.length % 8 != 0 && this.writer.write(this.helper.subarray(0, e.length % 8));
    }
    writeBox(e) {
        if ((this.offsets.set(e, this.writer.getPos()), e.contents && !e.children))
            this.writeBoxHeader(e, e.size ?? e.contents.byteLength + 8), this.writer.write(e.contents);
        else {
            const t = this.writer.getPos();
            if ((this.writeBoxHeader(e, 0), e.contents && this.writer.write(e.contents), e.children))
                for (const i of e.children) i && this.writeBox(i);
            const n = this.writer.getPos(),
                r = e.size ?? n - t;
            this.writer.seek(t), this.writeBoxHeader(e, r), this.writer.seek(n);
        }
    }
    writeBoxHeader(e, t) {
        this.writeU32(e.largeSize ? 1 : t), this.writeAscii(e.type), e.largeSize && this.writeU64(t);
    }
    measureBoxHeader(e) {
        return 8 + (e.largeSize ? 8 : 0);
    }
    patchBox(e) {
        const t = this.offsets.get(e);
        Vk(void 0 !== t);
        const n = this.writer.getPos();
        this.writer.seek(t), this.writeBox(e), this.writer.seek(n);
    }
    measureBox(e) {
        if (e.contents && !e.children) {
            return this.measureBoxHeader(e) + e.contents.byteLength;
        }
        {
            let t = this.measureBoxHeader(e);
            if ((e.contents && (t += e.contents.byteLength), e.children))
                for (const n of e.children) n && (t += this.measureBox(n));
            return t;
        }
    }
}
const vC = new Uint8Array(8),
    SC = new DataView(vC.buffer),
    EC = (e) => [((e % 256) + 256) % 256],
    CC = (e) => (SC.setUint16(0, e, !1), [vC[0], vC[1]]),
    IC = (e) => (SC.setInt16(0, e, !1), [vC[0], vC[1]]),
    xC = (e) => (SC.setUint32(0, e, !1), [vC[1], vC[2], vC[3]]),
    AC = (e) => (SC.setUint32(0, e, !1), [vC[0], vC[1], vC[2], vC[3]]),
    PC = (e) => (SC.setInt32(0, e, !1), [vC[0], vC[1], vC[2], vC[3]]),
    OC = (e) => (
        SC.setUint32(0, Math.floor(e / 2 ** 32), !1),
        SC.setUint32(4, e, !1),
        [vC[0], vC[1], vC[2], vC[3], vC[4], vC[5], vC[6], vC[7]]
    ),
    NC = (e) => (SC.setInt16(0, 256 * e, !1), [vC[0], vC[1]]),
    RC = (e) => (SC.setInt32(0, 65536 * e, !1), [vC[0], vC[1], vC[2], vC[3]]),
    MC = (e) => (SC.setInt32(0, 2 ** 30 * e, !1), [vC[0], vC[1], vC[2], vC[3]]),
    DC = (e, t) => {
        const n = [];
        let r = e;
        do {
            let e = 127 & r;
            (r >>= 7), n.length > 0 && (e |= 128), n.push(e);
        } while (r > 0 || t);
        return n.reverse();
    },
    FC = (e, t = !1) => {
        const n = Array(e.length)
            .fill(null)
            .map((t, n) => e.charCodeAt(n));
        return t && n.push(0), n;
    },
    LC = (e) => {
        let t = null;
        for (const n of e) (!t || n.timestamp > t.timestamp) && (t = n);
        return t;
    },
    BC = (e) => {
        const t = e * (Math.PI / 180),
            n = Math.round(Math.cos(t)),
            r = Math.round(Math.sin(t));
        return [n, r, 0, -r, n, 0, 0, 0, 1];
    },
    zC = BC(0),
    UC = (e) => [RC(e[0]), RC(e[1]), MC(e[2]), RC(e[3]), RC(e[4]), MC(e[5]), RC(e[6]), RC(e[7]), MC(e[8])],
    $C = (e, t, n) => ({ type: e, contents: t && new Uint8Array(t.flat(10)), children: n }),
    VC = (e, t, n, r, i) => $C(e, [EC(t), xC(n), r ?? []], i),
    WC = (e) => ({ type: "mdat", largeSize: e }),
    jC = (e) =>
        $C("moov", void 0, [
            HC(e.creationTime, e.trackDatas),
            ...e.trackDatas.map((t) => qC(t, e.creationTime)),
            e.isFragmented ? EI(e.trackDatas) : null,
            zI(e),
        ]),
    HC = (e, t) => {
        const n = ux(
                Math.max(
                    0,
                    ...t
                        .filter((e) => e.samples.length > 0)
                        .map((e) => {
                            const t = LC(e.samples);
                            return t.timestamp + t.duration;
                        })
                ),
                cx
            ),
            r = Math.max(0, ...t.map((e) => e.track.id)) + 1,
            i = !Hk(e) || !Hk(n),
            s = i ? OC : AC;
        return VC("mvhd", +i, 0, [
            s(e),
            s(e),
            AC(cx),
            s(n),
            RC(1),
            NC(1),
            Array(10).fill(0),
            UC(zC),
            Array(24).fill(0),
            AC(r),
        ]);
    },
    qC = (e, t) => {
        const n = lx(e);
        return $C("trak", void 0, [
            XC(e, t),
            GC(e, t),
            void 0 !== n.name ? $C("udta", void 0, [$C("name", [...Jk.encode(n.name)])]) : null,
        ]);
    },
    XC = (e, t) => {
        const n = LC(e.samples),
            r = ux(n ? n.timestamp + n.duration : 0, cx),
            i = !Hk(t) || !Hk(r),
            s = i ? OC : AC;
        let a;
        if ("video" === e.type) {
            const t = e.track.metadata.rotation;
            a = BC(t ?? 0);
        } else a = zC;
        return VC("tkhd", +i, 3, [
            s(t),
            s(t),
            AC(e.track.id),
            AC(0),
            s(r),
            Array(8).fill(0),
            CC(0),
            CC(e.track.id),
            NC("audio" === e.type ? 1 : 0),
            CC(0),
            UC(a),
            RC("video" === e.type ? e.info.width : 0),
            RC("video" === e.type ? e.info.height : 0),
        ]);
    },
    GC = (e, t) => $C("mdia", void 0, [KC(e, t), JC(!0, YC[e.type], QC[e.type]), ZC(e)]),
    KC = (e, t) => {
        const n = LC(e.samples),
            r = ux(n ? n.timestamp + n.duration : 0, e.timescale),
            i = !Hk(t) || !Hk(r),
            s = i ? OC : AC;
        return VC("mdhd", +i, 0, [
            s(t),
            s(t),
            AC(e.timescale),
            s(r),
            CC(ZI(e.track.metadata.languageCode ?? vT)),
            CC(0),
        ]);
    },
    YC = { video: "vide", audio: "soun", subtitle: "text" },
    QC = { video: "MediabunnyVideoHandler", audio: "MediabunnySoundHandler", subtitle: "MediabunnyTextHandler" },
    JC = (e, t, n, r = "\0\0\0\0") => VC("hdlr", 0, 0, [e ? FC("mhlr") : AC(0), FC(t), FC(r), AC(0), AC(0), FC(n, !0)]),
    ZC = (e) => $C("minf", void 0, [eI[e.type](), tI(), iI(e)]),
    eI = {
        video: () => VC("vmhd", 0, 1, [CC(0), CC(0), CC(0), CC(0)]),
        audio: () => VC("smhd", 0, 0, [CC(0), CC(0)]),
        subtitle: () => VC("nmhd", 0, 0),
    },
    tI = () => $C("dinf", void 0, [nI()]),
    nI = () => VC("dref", 0, 0, [AC(1)], [rI()]),
    rI = () => VC("url ", 0, 1),
    iI = (e) => {
        const t =
            e.compositionTimeOffsetTable.length > 1 ||
            e.compositionTimeOffsetTable.some((e) => 0 !== e.sampleCompositionTimeOffset);
        return $C("stbl", void 0, [sI(e), yI(e), t ? vI(e) : null, t ? SI(e) : null, kI(e), TI(e), _I(e), wI(e)]);
    },
    sI = (e) => {
        let t;
        if ("video" === e.type) t = aI(XI[e.track.source._codec], e);
        else if ("audio" === e.type) {
            const n = KI(e.track.source._codec, e.muxer.isQuickTime);
            Vk(n), (t = lI(n, e));
        } else "subtitle" === e.type && (t = bI(QI[e.track.source._codec], e));
        return Vk(t), VC("stsd", 0, 0, [AC(1)], [t]);
    },
    aI = (e, t) =>
        $C(
            e,
            [
                Array(6).fill(0),
                CC(1),
                CC(0),
                CC(0),
                Array(12).fill(0),
                CC(t.info.width),
                CC(t.info.height),
                AC(4718592),
                AC(4718592),
                AC(0),
                CC(1),
                Array(32).fill(0),
                CC(24),
                IC(65535),
            ],
            [GI[t.track.source._codec](t), oT(t.info.decoderConfig.colorSpace) ? oI(t) : null]
        ),
    oI = (e) =>
        $C("colr", [
            FC("nclx"),
            CC(tT[e.info.decoderConfig.colorSpace.primaries]),
            CC(rT[e.info.decoderConfig.colorSpace.transfer]),
            CC(sT[e.info.decoderConfig.colorSpace.matrix]),
            EC((e.info.decoderConfig.colorSpace.fullRange ? 1 : 0) << 7),
        ]),
    cI = (e) => {
        if (!e.info.decoderConfig) return null;
        const t = e.info.decoderConfig,
            n = t.codec.split("."),
            r = Number(n[1]),
            i = Number(n[2]),
            s =
                (Number(n[3]) << 4) +
                ((n[4] ? Number(n[4]) : 1) << 1) +
                (n[8] ? Number(n[8]) : Number(t.colorSpace?.fullRange ?? 0)),
            a = n[5] ? Number(n[5]) : t.colorSpace?.primaries ? tT[t.colorSpace.primaries] : 2,
            o = n[6] ? Number(n[6]) : t.colorSpace?.transfer ? rT[t.colorSpace.transfer] : 2,
            c = n[7] ? Number(n[7]) : t.colorSpace?.matrix ? sT[t.colorSpace.matrix] : 2;
        return VC("vpcC", 1, 0, [EC(r), EC(i), EC(s), EC(a), EC(o), EC(c), CC(0)]);
    },
    lI = (e, t) => {
        let n,
            r = 0,
            i = 16;
        if (KT.includes(t.track.source._codec)) {
            const e = t.track.source._codec,
                { sampleSize: n } = g_(e);
            (i = 8 * n), i > 16 && (r = 1);
        }
        return (
            (n =
                0 === r
                    ? [
                          Array(6).fill(0),
                          CC(1),
                          CC(r),
                          CC(0),
                          AC(0),
                          CC(t.info.numberOfChannels),
                          CC(i),
                          CC(0),
                          CC(0),
                          CC(t.info.sampleRate < 65536 ? t.info.sampleRate : 0),
                          CC(0),
                      ]
                    : [
                          Array(6).fill(0),
                          CC(1),
                          CC(r),
                          CC(0),
                          AC(0),
                          CC(t.info.numberOfChannels),
                          CC(Math.min(i, 16)),
                          CC(0),
                          CC(0),
                          CC(t.info.sampleRate < 65536 ? t.info.sampleRate : 0),
                          CC(0),
                          AC(1),
                          AC(i / 8),
                          AC((t.info.numberOfChannels * i) / 8),
                          AC(2),
                      ]),
            $C(e, n, [YI(t.track.source._codec, t.muxer.isQuickTime)?.(t) ?? null])
        );
    },
    uI = (e) => {
        let t;
        switch (e.track.source._codec) {
            case "aac":
                t = 64;
                break;
            case "mp3":
                t = 107;
                break;
            case "vorbis":
                t = 221;
                break;
            default:
                throw new Error(`Unhandled audio codec: ${e.track.source._codec}`);
        }
        let n = [...EC(t), ...EC(21), ...xC(0), ...AC(0), ...AC(0)];
        if (e.info.decoderConfig.description) {
            const t = Kk(e.info.decoderConfig.description);
            n = [...n, ...EC(5), ...DC(t.byteLength), ...t];
        }
        return (
            (n = [...CC(1), ...EC(0), ...EC(4), ...DC(n.length), ...n, ...EC(6), ...EC(1), ...EC(2)]),
            (n = [...EC(3), ...DC(n.length), ...n]),
            VC("esds", 0, 0, n)
        );
    },
    dI = (e) => $C("wave", void 0, [hI(e), mI(e), $C("\0\0\0\0")]),
    hI = (e) => $C("frma", [FC(KI(e.track.source._codec, e.muxer.isQuickTime))]),
    mI = (e) => {
        const { littleEndian: t } = g_(e.track.source._codec);
        return $C("enda", [CC(+t)]);
    },
    pI = (e) => {
        let t = e.info.numberOfChannels,
            n = 3840,
            r = e.info.sampleRate,
            i = 0,
            s = 0,
            a = new Uint8Array(0);
        const o = e.info.decoderConfig?.description;
        if (o) {
            Vk(o.byteLength >= 18);
            const e = Kk(o),
                c = Y_(e);
            (t = c.outputChannelCount),
                (n = c.preSkip),
                (r = c.inputSampleRate),
                (i = c.outputGain),
                (s = c.channelMappingFamily),
                c.channelMappingTable && (a = c.channelMappingTable);
        }
        return $C("dOps", [EC(0), EC(t), CC(n), AC(r), IC(i), EC(s), ...a]);
    },
    fI = (e) => {
        const t = e.info.decoderConfig?.description;
        Vk(t);
        const n = Kk(t);
        return VC("dfLa", 0, 0, [...n.subarray(4)]);
    },
    gI = (e) => {
        const { littleEndian: t, sampleSize: n } = g_(e.track.source._codec);
        return VC("pcmC", 0, 0, [EC(+t), EC(8 * n)]);
    },
    bI = (e, t) => $C(e, [Array(6).fill(0), CC(1)], [JI[t.track.source._codec](t)]),
    yI = (e) =>
        VC("stts", 0, 0, [
            AC(e.timeToSampleTable.length),
            e.timeToSampleTable.map((e) => [AC(e.sampleCount), AC(e.sampleDelta)]),
        ]),
    wI = (e) => {
        if (e.samples.every((e) => "key" === e.type)) return null;
        const t = [...e.samples.entries()].filter(([, e]) => "key" === e.type);
        return VC("stss", 0, 0, [AC(t.length), t.map(([e]) => AC(e + 1))]);
    },
    kI = (e) =>
        VC("stsc", 0, 0, [
            AC(e.compactlyCodedChunkTable.length),
            e.compactlyCodedChunkTable.map((e) => [AC(e.firstChunk), AC(e.samplesPerChunk), AC(1)]),
        ]),
    TI = (e) => {
        if ("audio" === e.type && e.info.requiresPcmTransformation) {
            const { sampleSize: t } = g_(e.track.source._codec);
            return VC("stsz", 0, 0, [
                AC(t * e.info.numberOfChannels),
                AC(e.samples.reduce((t, n) => t + ux(n.duration, e.timescale), 0)),
            ]);
        }
        return VC("stsz", 0, 0, [AC(0), AC(e.samples.length), e.samples.map((e) => AC(e.size))]);
    },
    _I = (e) =>
        e.finalizedChunks.length > 0 && jk(e.finalizedChunks).offset >= 2 ** 32
            ? VC("co64", 0, 0, [AC(e.finalizedChunks.length), e.finalizedChunks.map((e) => OC(e.offset))])
            : VC("stco", 0, 0, [AC(e.finalizedChunks.length), e.finalizedChunks.map((e) => AC(e.offset))]),
    vI = (e) =>
        VC("ctts", 1, 0, [
            AC(e.compositionTimeOffsetTable.length),
            e.compositionTimeOffsetTable.map((e) => [AC(e.sampleCount), PC(e.sampleCompositionTimeOffset)]),
        ]),
    SI = (e) => {
        let t = 1 / 0,
            n = -1 / 0,
            r = 1 / 0,
            i = -1 / 0;
        Vk(e.compositionTimeOffsetTable.length > 0), Vk(e.samples.length > 0);
        for (let a = 0; a < e.compositionTimeOffsetTable.length; a++) {
            const r = e.compositionTimeOffsetTable[a];
            (t = Math.min(t, r.sampleCompositionTimeOffset)), (n = Math.max(n, r.sampleCompositionTimeOffset));
        }
        for (let a = 0; a < e.samples.length; a++) {
            const t = e.samples[a];
            (r = Math.min(r, ux(t.timestamp, e.timescale))),
                (i = Math.max(i, ux(t.timestamp + t.duration, e.timescale)));
        }
        const s = Math.max(-t, 0);
        return i >= 2 ** 31 ? null : VC("cslg", 0, 0, [PC(s), PC(t), PC(n), PC(r), PC(i)]);
    },
    EI = (e) => $C("mvex", void 0, e.map(CI)),
    CI = (e) => VC("trex", 0, 0, [AC(e.track.id), AC(1), AC(0), AC(0), AC(0)]),
    II = (e, t) => $C("moof", void 0, [xI(e), ...t.map(PI)]),
    xI = (e) => VC("mfhd", 0, 0, [AC(e)]),
    AI = (e) => {
        let t = 0,
            n = 0;
        const r = "delta" === e.type;
        return (n |= +r), (t |= r ? 1 : 2), (t << 24) | (n << 16);
    },
    PI = (e) => $C("traf", void 0, [OI(e), NI(e), RI(e)]),
    OI = (e) => {
        Vk(e.currentChunk);
        let t = 0;
        (t |= 8), (t |= 16), (t |= 32), (t |= 131072);
        const n = e.currentChunk.samples[1] ?? e.currentChunk.samples[0],
            r = { duration: n.timescaleUnitsToNextSample, size: n.size, flags: AI(n) };
        return VC("tfhd", 0, 131128, [AC(e.track.id), AC(r.duration), AC(r.size), AC(r.flags)]);
    },
    NI = (e) => (Vk(e.currentChunk), VC("tfdt", 1, 0, [OC(ux(e.currentChunk.startTimestamp, e.timescale))])),
    RI = (e) => {
        Vk(e.currentChunk);
        const t = e.currentChunk.samples.map((e) => e.timescaleUnitsToNextSample),
            n = e.currentChunk.samples.map((e) => e.size),
            r = e.currentChunk.samples.map(AI),
            i = e.currentChunk.samples.map((t) => ux(t.timestamp - t.decodeTimestamp, e.timescale)),
            s = new Set(t),
            a = new Set(n),
            o = new Set(r),
            c = new Set(i),
            l = 2 === o.size && r[0] !== r[1],
            u = s.size > 1,
            d = a.size > 1,
            h = !l && o.size > 1,
            m = c.size > 1 || [...c].some((e) => 0 !== e);
        let p = 0;
        return (
            (p |= 1),
            (p |= 4 * +l),
            (p |= 256 * +u),
            (p |= 512 * +d),
            (p |= 1024 * +h),
            (p |= 2048 * +m),
            VC("trun", 1, p, [
                AC(e.currentChunk.samples.length),
                AC(e.currentChunk.offset - e.currentChunk.moofOffset || 0),
                l ? AC(r[0]) : [],
                e.currentChunk.samples.map((e, s) => [
                    u ? AC(t[s]) : [],
                    d ? AC(n[s]) : [],
                    h ? AC(r[s]) : [],
                    m ? PC(i[s]) : [],
                ]),
            ])
        );
    },
    MI = (e, t) =>
        VC("tfra", 1, 0, [
            AC(e.track.id),
            AC(63),
            AC(e.finalizedChunks.length),
            e.finalizedChunks.map((n) => [
                OC(ux(n.samples[0].timestamp, e.timescale)),
                OC(n.moofOffset),
                AC(t + 1),
                AC(1),
                AC(1),
            ]),
        ]),
    DI = () => VC("mfro", 0, 0, [AC(0)]),
    FI = () => $C("vtte"),
    LI = (e, t, n, r, i) =>
        $C("vttc", void 0, [
            null !== i ? $C("vsid", [PC(i)]) : null,
            null !== n ? $C("iden", [...Jk.encode(n)]) : null,
            null !== t ? $C("ctim", [...Jk.encode(TC(t))]) : null,
            null !== r ? $C("sttg", [...Jk.encode(r)]) : null,
            $C("payl", [...Jk.encode(e)]),
        ]),
    BI = (e) => $C("vtta", [...Jk.encode(e)]),
    zI = (e) => {
        const t = [],
            n = e.format._options.metadataFormat ?? "auto",
            r = e.output._metadataTags;
        if ("mdir" === n || ("auto" === n && !e.isQuickTime)) {
            const e = jI(r);
            e && t.push(e);
        } else if ("mdta" === n) {
            const e = HI(r);
            e && t.push(e);
        } else ("udta" === n || ("auto" === n && e.isQuickTime)) && UI(t, e.output._metadataTags);
        return 0 === t.length ? null : $C("udta", void 0, t);
    },
    UI = (e, t) => {
        for (const { key: n, value: r } of zT(t))
            switch (n) {
                case "title":
                    e.push($I("nam", r));
                    break;
                case "description":
                    e.push($I("des", r));
                    break;
                case "artist":
                    e.push($I("ART", r));
                    break;
                case "album":
                    e.push($I("alb", r));
                    break;
                case "albumArtist":
                    e.push($I("albr", r));
                    break;
                case "genre":
                    e.push($I("gen", r));
                    break;
                case "date":
                    e.push($I("day", r.toISOString().slice(0, 10)));
                    break;
                case "comment":
                    e.push($I("cmt", r));
                    break;
                case "lyrics":
                    e.push($I("lyr", r));
                    break;
                case "raw":
                case "discNumber":
                case "discsTotal":
                case "trackNumber":
                case "tracksTotal":
                case "images":
                    break;
                default:
                    yT(n);
            }
        if (t.raw)
            for (const n in t.raw) {
                const r = t.raw[n];
                null == r ||
                    4 !== n.length ||
                    e.some((e) => e.type === n) ||
                    ("string" == typeof r ? e.push($I(n, r)) : r instanceof Uint8Array && e.push($C(n, Array.from(r))));
            }
    },
    $I = (e, t) => {
        const n = Jk.encode(t);
        return $C(e, [CC(n.length), CC(ZI("und")), Array.from(n)]);
    },
    VI = { "image/jpeg": 13, "image/png": 14, "image/bmp": 27 },
    WI = (e, t) => {
        const n = [];
        for (const { key: r, value: i } of zT(e))
            switch (r) {
                case "title":
                    n.push({ key: t ? "title" : "nam", value: qI(i) });
                    break;
                case "description":
                    n.push({ key: t ? "description" : "des", value: qI(i) });
                    break;
                case "artist":
                    n.push({ key: t ? "artist" : "ART", value: qI(i) });
                    break;
                case "album":
                    n.push({ key: t ? "album" : "alb", value: qI(i) });
                    break;
                case "albumArtist":
                    n.push({ key: t ? "album_artist" : "aART", value: qI(i) });
                    break;
                case "comment":
                    n.push({ key: t ? "comment" : "cmt", value: qI(i) });
                    break;
                case "genre":
                    n.push({ key: t ? "genre" : "gen", value: qI(i) });
                    break;
                case "lyrics":
                    n.push({ key: t ? "lyrics" : "lyr", value: qI(i) });
                    break;
                case "date":
                    n.push({ key: t ? "date" : "day", value: qI(i.toISOString().slice(0, 10)) });
                    break;
                case "images":
                    for (const e of i)
                        "coverFront" === e.kind &&
                            n.push({
                                key: "covr",
                                value: $C("data", [AC(VI[e.mimeType] ?? 0), AC(0), Array.from(e.data)]),
                            });
                    break;
                case "trackNumber":
                    if (t) {
                        const t = void 0 !== e.tracksTotal ? `${i}/${e.tracksTotal}` : i.toString();
                        n.push({ key: "track", value: qI(t) });
                    } else
                        n.push({
                            key: "trkn",
                            value: $C("data", [AC(0), AC(0), CC(0), CC(i), CC(e.tracksTotal ?? 0), CC(0)]),
                        });
                    break;
                case "discNumber":
                    t ||
                        n.push({
                            key: "disc",
                            value: $C("data", [AC(0), AC(0), CC(0), CC(i), CC(e.discsTotal ?? 0), CC(0)]),
                        });
                    break;
                case "tracksTotal":
                case "discsTotal":
                case "raw":
                    break;
                default:
                    yT(r);
            }
        if (e.raw)
            for (const r in e.raw) {
                const i = e.raw[r];
                null == i ||
                    (!t && 4 !== r.length) ||
                    n.some((e) => e.key === r) ||
                    ("string" == typeof i
                        ? n.push({ key: r, value: qI(i) })
                        : i instanceof Uint8Array
                          ? n.push({ key: r, value: $C("data", [AC(0), AC(0), Array.from(i)]) })
                          : i instanceof HT &&
                            n.push({
                                key: r,
                                value: $C("data", [AC(VI[i.mimeType] ?? 0), AC(0), Array.from(i.data)]),
                            }));
            }
        return n;
    },
    jI = (e) => {
        const t = WI(e, !1);
        return 0 === t.length
            ? null
            : VC("meta", 0, 0, void 0, [
                  JC(!1, "mdir", "", "appl"),
                  $C(
                      "ilst",
                      void 0,
                      t.map((e) => $C(e.key, void 0, [e.value]))
                  ),
              ]);
    },
    HI = (e) => {
        const t = WI(e, !0);
        return 0 === t.length
            ? null
            : $C("meta", void 0, [
                  JC(!1, "mdta", ""),
                  VC(
                      "keys",
                      0,
                      0,
                      [AC(t.length)],
                      t.map((e) => $C("mdta", [...Jk.encode(e.key)]))
                  ),
                  $C(
                      "ilst",
                      void 0,
                      t.map((e, t) => {
                          const n = String.fromCharCode(...AC(t + 1));
                          return $C(n, void 0, [e.value]);
                      })
                  ),
              ]);
    },
    qI = (e) => $C("data", [AC(1), AC(0), ...Jk.encode(e)]),
    XI = { avc: "avc1", hevc: "hvc1", vp8: "vp08", vp9: "vp09", av1: "av01" },
    GI = {
        avc: (e) => e.info.decoderConfig && $C("avcC", [...Kk(e.info.decoderConfig.description)]),
        hevc: (e) => e.info.decoderConfig && $C("hvcC", [...Kk(e.info.decoderConfig.description)]),
        vp8: cI,
        vp9: cI,
        av1: (e) => $C("av1C", o_(e.info.decoderConfig.codec)),
    },
    KI = (e, t) => {
        switch (e) {
            case "aac":
            case "mp3":
            case "vorbis":
                return "mp4a";
            case "opus":
                return "Opus";
            case "flac":
                return "fLaC";
            case "ulaw":
                return "ulaw";
            case "alaw":
                return "alaw";
            case "pcm-u8":
                return "raw ";
            case "pcm-s8":
                return "sowt";
        }
        if (t)
            switch (e) {
                case "pcm-s16":
                    return "sowt";
                case "pcm-s16be":
                    return "twos";
                case "pcm-s24":
                case "pcm-s24be":
                    return "in24";
                case "pcm-s32":
                case "pcm-s32be":
                    return "in32";
                case "pcm-f32":
                case "pcm-f32be":
                    return "fl32";
                case "pcm-f64":
                case "pcm-f64be":
                    return "fl64";
            }
        else
            switch (e) {
                case "pcm-s16":
                case "pcm-s16be":
                case "pcm-s24":
                case "pcm-s24be":
                case "pcm-s32":
                case "pcm-s32be":
                    return "ipcm";
                case "pcm-f32":
                case "pcm-f32be":
                case "pcm-f64":
                case "pcm-f64be":
                    return "fpcm";
            }
    },
    YI = (e, t) => {
        switch (e) {
            case "aac":
            case "mp3":
            case "vorbis":
                return uI;
            case "opus":
                return pI;
            case "flac":
                return fI;
        }
        if (t)
            switch (e) {
                case "pcm-s24":
                case "pcm-s24be":
                case "pcm-s32":
                case "pcm-s32be":
                case "pcm-f32":
                case "pcm-f32be":
                case "pcm-f64":
                case "pcm-f64be":
                    return dI;
            }
        else
            switch (e) {
                case "pcm-s16":
                case "pcm-s16be":
                case "pcm-s24":
                case "pcm-s24be":
                case "pcm-s32":
                case "pcm-s32be":
                case "pcm-f32":
                case "pcm-f32be":
                case "pcm-f64":
                case "pcm-f64be":
                    return gI;
            }
        return null;
    },
    QI = { webvtt: "wvtt" },
    JI = { webvtt: (e) => $C("vttC", [...Jk.encode(e.info.config.description)]) },
    ZI = (e) => {
        Vk(3 === e.length);
        let t = 0;
        for (let n = 0; n < 3; n++) (t <<= 5), (t += e.charCodeAt(n) - 96);
        return t;
    };
class ex {
    constructor() {
        (this.ensureMonotonicity = !1), (this.trackedWrites = null), (this.trackedStart = -1), (this.trackedEnd = -1);
    }
    start() {}
    maybeTrackWrites(e) {
        if (!this.trackedWrites) return;
        let t = this.getPos();
        if (t < this.trackedStart) {
            if (t + e.byteLength <= this.trackedStart) return;
            (e = e.subarray(this.trackedStart - t)), (t = 0);
        }
        const n = t + e.byteLength - this.trackedStart;
        let r = this.trackedWrites.byteLength;
        for (; r < n; ) r *= 2;
        if (r !== this.trackedWrites.byteLength) {
            const e = new Uint8Array(r);
            e.set(this.trackedWrites, 0), (this.trackedWrites = e);
        }
        this.trackedWrites.set(e, t - this.trackedStart),
            (this.trackedEnd = Math.max(this.trackedEnd, t + e.byteLength));
    }
    startTrackingWrites() {
        (this.trackedWrites = new Uint8Array(1024)),
            (this.trackedStart = this.getPos()),
            (this.trackedEnd = this.trackedStart);
    }
    stopTrackingWrites() {
        if (!this.trackedWrites) throw new Error("Internal error: Can't get tracked writes since nothing was tracked.");
        const e = {
            data: this.trackedWrites.subarray(0, this.trackedEnd - this.trackedStart),
            start: this.trackedStart,
            end: this.trackedEnd,
        };
        return (this.trackedWrites = null), e;
    }
}
const tx = 65536,
    nx = 2 ** 32;
class rx extends ex {
    constructor(e) {
        if (
            (super(),
            (this.pos = 0),
            (this.maxPos = 0),
            (this.target = e),
            (this.supportsResize = "resize" in new ArrayBuffer(0)),
            this.supportsResize)
        )
            try {
                this.buffer = new ArrayBuffer(tx, { maxByteLength: nx });
            } catch {
                (this.buffer = new ArrayBuffer(tx)), (this.supportsResize = !1);
            }
        else this.buffer = new ArrayBuffer(tx);
        this.bytes = new Uint8Array(this.buffer);
    }
    ensureSize(e) {
        let t = this.buffer.byteLength;
        for (; t < e; ) t *= 2;
        if (t !== this.buffer.byteLength) {
            if (t > nx)
                throw new Error(
                    "ArrayBuffer exceeded maximum size of 4294967296 bytes. Please consider using another target."
                );
            if (this.supportsResize) this.buffer.resize(t);
            else {
                const e = new ArrayBuffer(t),
                    n = new Uint8Array(e);
                n.set(this.bytes, 0), (this.buffer = e), (this.bytes = n);
            }
        }
    }
    write(e) {
        this.maybeTrackWrites(e),
            this.ensureSize(this.pos + e.byteLength),
            this.bytes.set(e, this.pos),
            this.target.onwrite?.(this.pos, this.pos + e.byteLength),
            (this.pos += e.byteLength),
            (this.maxPos = Math.max(this.maxPos, this.pos));
    }
    seek(e) {
        this.pos = e;
    }
    getPos() {
        return this.pos;
    }
    async flush() {}
    async finalize() {
        this.ensureSize(this.pos), (this.target.buffer = this.buffer.slice(0, Math.max(this.maxPos, this.pos)));
    }
    async close() {}
    getSlice(e, t) {
        return this.bytes.slice(e, t);
    }
}
class ix extends ex {
    constructor(e) {
        super(), (this.target = e), (this.pos = 0);
    }
    write(e) {
        this.maybeTrackWrites(e), this.target.onwrite?.(this.pos, this.pos + e.byteLength), (this.pos += e.byteLength);
    }
    getPos() {
        return this.pos;
    }
    seek(e) {
        this.pos = e;
    }
    async flush() {}
    async finalize() {}
    async close() {}
}
class sx {
    constructor() {
        (this._output = null), (this.onwrite = null);
    }
}
class ax extends sx {
    constructor() {
        super(...arguments), (this.buffer = null);
    }
    _createWriter() {
        return new rx(this);
    }
}
class ox extends sx {
    _createWriter() {
        return new ix(this);
    }
}
const cx = 1e3,
    lx = (e) => {
        const t = {},
            n = e.track;
        return void 0 !== n.metadata.name && (t.name = n.metadata.name), t;
    },
    ux = (e, t, n = !0) => {
        const r = e * t;
        return n ? Math.round(r) : r;
    };
class dx extends I_ {
    constructor(e, t) {
        super(e),
            (this.auxTarget = new ax()),
            (this.auxWriter = this.auxTarget._createWriter()),
            (this.auxBoxWriter = new _C(this.auxWriter)),
            (this.mdat = null),
            (this.ftypSize = null),
            (this.trackDatas = []),
            (this.allTracksKnown = fT()),
            (this.creationTime = Math.floor(Date.now() / 1e3) + 2082844800),
            (this.finalizedChunks = []),
            (this.nextFragmentNumber = 1),
            (this.maxWrittenTimestamp = -1 / 0),
            (this.format = t),
            (this.writer = e._writer),
            (this.boxWriter = new _C(this.writer)),
            (this.isQuickTime = t instanceof kx);
        const n = this.writer instanceof rx && "in-memory";
        (this.fastStart = t._options.fastStart ?? n),
            (this.isFragmented = "fragmented" === this.fastStart),
            ("in-memory" === this.fastStart || this.isFragmented) && (this.writer.ensureMonotonicity = !0),
            (this.minimumFragmentDuration = t._options.minimumFragmentDuration ?? 1);
    }
    async start() {
        const e = await this.mutex.acquire(),
            t = this.output._tracks.some((e) => "video" === e.type && "avc" === e.source._codec);
        if (
            (this.format._options.onFtyp && this.writer.startTrackingWrites(),
            this.boxWriter.writeBox(
                (n = { isQuickTime: this.isQuickTime, holdsAvc: t, fragmented: this.isFragmented }).isQuickTime
                    ? $C("ftyp", [FC("qt  "), AC(512), FC("qt  ")])
                    : n.fragmented
                      ? $C("ftyp", [FC("iso5"), AC(512), FC("iso5"), FC("iso6"), FC("mp41")])
                      : $C("ftyp", [FC("isom"), AC(512), FC("isom"), n.holdsAvc ? FC("avc1") : [], FC("mp41")])
            ),
            this.format._options.onFtyp)
        ) {
            const { data: e, start: t } = this.writer.stopTrackingWrites();
            this.format._options.onFtyp(e, t);
        }
        var n;
        if (((this.ftypSize = this.writer.getPos()), "in-memory" === this.fastStart));
        else if ("reserve" === this.fastStart) {
            for (const r of this.output._tracks)
                if (void 0 === r.metadata.maximumPacketCount)
                    throw new Error(
                        "All tracks must specify maximumPacketCount in their metadata when using fastStart: 'reserve'."
                    );
        } else
            this.isFragmented ||
                (this.format._options.onMdat && this.writer.startTrackingWrites(),
                (this.mdat = WC(!0)),
                this.boxWriter.writeBox(this.mdat));
        await this.writer.flush(), e();
    }
    allTracksAreKnown() {
        for (const e of this.output._tracks)
            if (!e.source._closed && !this.trackDatas.some((t) => t.track === e)) return !1;
        return !0;
    }
    async getMimeType() {
        await this.allTracksKnown.promise;
        const e = this.trackDatas.map((e) => {
            if ("video" === e.type) return e.info.decoderConfig.codec;
            if ("audio" === e.type) return e.info.decoderConfig.codec;
            return { webvtt: "wvtt" }[e.track.source._codec];
        });
        return zv({
            isQuickTime: this.isQuickTime,
            hasVideo: this.trackDatas.some((e) => "video" === e.type),
            hasAudio: this.trackDatas.some((e) => "audio" === e.type),
            codecStrings: e,
        });
    }
    getVideoTrackData(e, t, n) {
        const r = this.trackDatas.find((t) => t.track === e);
        if (r) return r;
        v_(n), Vk(n), Vk(n.decoderConfig);
        const i = { ...n.decoderConfig };
        Vk(void 0 !== i.codedWidth), Vk(void 0 !== i.codedHeight);
        let s = !1;
        if ("avc" !== e.source._codec || i.description) {
            if ("hevc" === e.source._codec && !i.description) {
                const e = z_(t.data);
                if (!e)
                    throw new Error(
                        "Couldn't extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in HEVC format."
                    );
                (i.description = ((e) => {
                    const t = [];
                    t.push(e.configurationVersion),
                        t.push(
                            ((3 & e.generalProfileSpace) << 6) |
                                ((1 & e.generalTierFlag) << 5) |
                                (31 & e.generalProfileIdc)
                        ),
                        t.push((e.generalProfileCompatibilityFlags >>> 24) & 255),
                        t.push((e.generalProfileCompatibilityFlags >>> 16) & 255),
                        t.push((e.generalProfileCompatibilityFlags >>> 8) & 255),
                        t.push(255 & e.generalProfileCompatibilityFlags),
                        t.push(...e.generalConstraintIndicatorFlags),
                        t.push(255 & e.generalLevelIdc),
                        t.push(240 | ((e.minSpatialSegmentationIdc >> 8) & 15)),
                        t.push(255 & e.minSpatialSegmentationIdc),
                        t.push(252 | (3 & e.parallelismType)),
                        t.push(252 | (3 & e.chromaFormatIdc)),
                        t.push(248 | (7 & e.bitDepthLumaMinus8)),
                        t.push(248 | (7 & e.bitDepthChromaMinus8)),
                        t.push((e.avgFrameRate >> 8) & 255),
                        t.push(255 & e.avgFrameRate),
                        t.push(
                            ((3 & e.constantFrameRate) << 6) |
                                ((7 & e.numTemporalLayers) << 3) |
                                ((1 & e.temporalIdNested) << 2) |
                                (3 & e.lengthSizeMinusOne)
                        ),
                        t.push(255 & e.arrays.length);
                    for (const n of e.arrays) {
                        t.push(((1 & n.arrayCompleteness) << 7) | (63 & n.nalUnitType)),
                            t.push((n.nalUnits.length >> 8) & 255),
                            t.push(255 & n.nalUnits.length);
                        for (const e of n.nalUnits) {
                            t.push((e.length >> 8) & 255), t.push(255 & e.length);
                            for (let n = 0; n < e.length; n++) t.push(e[n]);
                        }
                    }
                    return new Uint8Array(t);
                })(e)),
                    (s = !0);
            }
        } else {
            const e = F_(t.data);
            if (!e)
                throw new Error(
                    "Couldn't extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in AVCC format."
                );
            (i.description = ((e) => {
                const t = [];
                t.push(e.configurationVersion),
                    t.push(e.avcProfileIndication),
                    t.push(e.profileCompatibility),
                    t.push(e.avcLevelIndication),
                    t.push(252 | (3 & e.lengthSizeMinusOne)),
                    t.push(224 | (31 & e.sequenceParameterSets.length));
                for (const n of e.sequenceParameterSets) {
                    const e = n.byteLength;
                    t.push(e >> 8), t.push(255 & e);
                    for (let r = 0; r < e; r++) t.push(n[r]);
                }
                t.push(e.pictureParameterSets.length);
                for (const n of e.pictureParameterSets) {
                    const e = n.byteLength;
                    t.push(e >> 8), t.push(255 & e);
                    for (let r = 0; r < e; r++) t.push(n[r]);
                }
                if (
                    100 === e.avcProfileIndication ||
                    110 === e.avcProfileIndication ||
                    122 === e.avcProfileIndication ||
                    144 === e.avcProfileIndication
                ) {
                    Vk(null !== e.chromaFormat),
                        Vk(null !== e.bitDepthLumaMinus8),
                        Vk(null !== e.bitDepthChromaMinus8),
                        Vk(null !== e.sequenceParameterSetExt),
                        t.push(252 | (3 & e.chromaFormat)),
                        t.push(248 | (7 & e.bitDepthLumaMinus8)),
                        t.push(248 | (7 & e.bitDepthChromaMinus8)),
                        t.push(e.sequenceParameterSetExt.length);
                    for (const n of e.sequenceParameterSetExt) {
                        const e = n.byteLength;
                        t.push(e >> 8), t.push(255 & e);
                        for (let r = 0; r < e; r++) t.push(n[r]);
                    }
                }
                return new Uint8Array(t);
            })(e)),
                (s = !0);
        }
        const a = ((e, t) => {
                const n = e < 0 ? -1 : 1;
                let r = 0,
                    i = 1,
                    s = 1,
                    a = 0,
                    o = (e = Math.abs(e));
                for (;;) {
                    const e = Math.floor(o),
                        c = e * s + r,
                        l = e * a + i;
                    if (l > t) return { numerator: n * s, denominator: a };
                    if (((r = s), (i = a), (s = c), (a = l), (o = 1 / (o - e)), !isFinite(o))) break;
                }
                return { numerator: n * s, denominator: a };
            })(1 / (e.metadata.frameRate ?? 57600), 1e6).denominator,
            o = {
                muxer: this,
                track: e,
                type: "video",
                info: { width: i.codedWidth, height: i.codedHeight, decoderConfig: i, requiresAnnexBTransformation: s },
                timescale: a,
                samples: [],
                sampleQueue: [],
                timestampProcessingQueue: [],
                timeToSampleTable: [],
                compositionTimeOffsetTable: [],
                lastTimescaleUnits: null,
                lastSample: null,
                finalizedChunks: [],
                currentChunk: null,
                compactlyCodedChunkTable: [],
            };
        return (
            this.trackDatas.push(o),
            this.trackDatas.sort((e, t) => e.track.id - t.track.id),
            this.allTracksAreKnown() && this.allTracksKnown.resolve(),
            o
        );
    }
    getAudioTrackData(e, t) {
        const n = this.trackDatas.find((t) => t.track === e);
        if (n) return n;
        E_(t), Vk(t), Vk(t.decoderConfig);
        const r = {
            muxer: this,
            track: e,
            type: "audio",
            info: {
                numberOfChannels: t.decoderConfig.numberOfChannels,
                sampleRate: t.decoderConfig.sampleRate,
                decoderConfig: t.decoderConfig,
                requiresPcmTransformation: !this.isFragmented && KT.includes(e.source._codec),
            },
            timescale: t.decoderConfig.sampleRate,
            samples: [],
            sampleQueue: [],
            timestampProcessingQueue: [],
            timeToSampleTable: [],
            compositionTimeOffsetTable: [],
            lastTimescaleUnits: null,
            lastSample: null,
            finalizedChunks: [],
            currentChunk: null,
            compactlyCodedChunkTable: [],
        };
        return (
            this.trackDatas.push(r),
            this.trackDatas.sort((e, t) => e.track.id - t.track.id),
            this.allTracksAreKnown() && this.allTracksKnown.resolve(),
            r
        );
    }
    getSubtitleTrackData(e, t) {
        const n = this.trackDatas.find((t) => t.track === e);
        if (n) return n;
        C_(t), Vk(t), Vk(t.config);
        const r = {
            muxer: this,
            track: e,
            type: "subtitle",
            info: { config: t.config },
            timescale: 1e3,
            samples: [],
            sampleQueue: [],
            timestampProcessingQueue: [],
            timeToSampleTable: [],
            compositionTimeOffsetTable: [],
            lastTimescaleUnits: null,
            lastSample: null,
            finalizedChunks: [],
            currentChunk: null,
            compactlyCodedChunkTable: [],
            lastCueEndTimestamp: 0,
            cueQueue: [],
            nextSourceId: 0,
            cueToSourceId: new WeakMap(),
        };
        return (
            this.trackDatas.push(r),
            this.trackDatas.sort((e, t) => e.track.id - t.track.id),
            this.allTracksAreKnown() && this.allTracksKnown.resolve(),
            r
        );
    }
    async addEncodedVideoPacket(e, t, n) {
        const r = await this.mutex.acquire();
        try {
            const r = this.getVideoTrackData(e, t, n);
            let i = t.data;
            if (r.info.requiresAnnexBTransformation) {
                const e = ((e) => {
                    const t = N_(e);
                    if (0 === t.length) return null;
                    let n = 0;
                    for (const a of t) n += 4 + a.byteLength;
                    const r = new Uint8Array(n),
                        i = new DataView(r.buffer);
                    let s = 0;
                    for (const a of t) {
                        const e = a.byteLength;
                        i.setUint32(s, e, !1), (s += 4), r.set(a, s), (s += a.byteLength);
                    }
                    return r;
                })(i);
                if (!e)
                    throw new Error(
                        "Failed to transform packet data. Make sure all packets are provided in Annex B format, as specified in ITU-T-REC-H.264 and ITU-T-REC-H.265."
                    );
                i = e;
            }
            const s = this.validateAndNormalizeTimestamp(r.track, t.timestamp, "key" === t.type),
                a = this.createSampleForTrack(r, i, s, t.duration, t.type);
            await this.registerSample(r, a);
        } finally {
            r();
        }
    }
    async addEncodedAudioPacket(e, t, n) {
        const r = await this.mutex.acquire();
        try {
            const r = this.getAudioTrackData(e, n),
                i = this.validateAndNormalizeTimestamp(r.track, t.timestamp, "key" === t.type),
                s = this.createSampleForTrack(r, t.data, i, t.duration, t.type);
            r.info.requiresPcmTransformation && (await this.maybePadWithSilence(r, i)), await this.registerSample(r, s);
        } finally {
            r();
        }
    }
    async maybePadWithSilence(e, t) {
        const n = jk(e.samples),
            r = n ? n.timestamp + n.duration : 0,
            i = t - r,
            s = ux(i, e.timescale);
        if (s > 0) {
            const { sampleSize: t, silentValue: n } = g_(e.info.decoderConfig.codec),
                a = s * e.info.numberOfChannels,
                o = new Uint8Array(t * a).fill(n),
                c = this.createSampleForTrack(e, new Uint8Array(o.buffer), r, i, "key");
            await this.registerSample(e, c);
        }
    }
    async addSubtitleCue(e, t, n) {
        const r = await this.mutex.acquire();
        try {
            const r = this.getSubtitleTrackData(e, n);
            this.validateAndNormalizeTimestamp(r.track, t.timestamp, !0),
                "webvtt" === e.source._codec && (r.cueQueue.push(t), await this.processWebVTTCues(r, t.timestamp));
        } finally {
            r();
        }
    }
    async processWebVTTCues(e, t) {
        for (; e.cueQueue.length > 0; ) {
            const n = new Set([]);
            for (const c of e.cueQueue)
                Vk(c.timestamp <= t),
                    Vk(e.lastCueEndTimestamp <= c.timestamp + c.duration),
                    n.add(Math.max(c.timestamp, e.lastCueEndTimestamp)),
                    n.add(c.timestamp + c.duration);
            const r = [...n].sort((e, t) => e - t),
                i = r[0],
                s = r[1] ?? i;
            if (t < s) break;
            if (e.lastCueEndTimestamp < i) {
                this.auxWriter.seek(0);
                const t = FI();
                this.auxBoxWriter.writeBox(t);
                const n = this.auxWriter.getSlice(0, this.auxWriter.getPos()),
                    r = this.createSampleForTrack(e, n, e.lastCueEndTimestamp, i - e.lastCueEndTimestamp, "key");
                await this.registerSample(e, r), (e.lastCueEndTimestamp = i);
            }
            this.auxWriter.seek(0);
            for (let t = 0; t < e.cueQueue.length; t++) {
                const n = e.cueQueue[t];
                if (n.timestamp >= s) break;
                wC.lastIndex = 0;
                const r = wC.test(n.text),
                    a = n.timestamp + n.duration;
                let o = e.cueToSourceId.get(n);
                if ((void 0 === o && s < a && ((o = e.nextSourceId++), e.cueToSourceId.set(n, o)), n.notes)) {
                    const e = BI(n.notes);
                    this.auxBoxWriter.writeBox(e);
                }
                const c = LI(n.text, r ? i : null, n.identifier ?? null, n.settings ?? null, o ?? null);
                this.auxBoxWriter.writeBox(c), a === s && e.cueQueue.splice(t--, 1);
            }
            const a = this.auxWriter.getSlice(0, this.auxWriter.getPos()),
                o = this.createSampleForTrack(e, a, i, s - i, "key");
            await this.registerSample(e, o), (e.lastCueEndTimestamp = s);
        }
    }
    createSampleForTrack(e, t, n, r, i) {
        return {
            timestamp: n,
            decodeTimestamp: n,
            duration: r,
            data: t,
            size: t.byteLength,
            type: i,
            timescaleUnitsToNextSample: ux(r, e.timescale),
        };
    }
    processTimestamps(e, t) {
        if (0 === e.timestampProcessingQueue.length) return;
        if ("audio" === e.type && e.info.requiresPcmTransformation) {
            let t = 0;
            for (let n = 0; n < e.timestampProcessingQueue.length; n++) {
                const r = e.timestampProcessingQueue[n];
                t += ux(r.duration, e.timescale);
            }
            if (0 === e.timeToSampleTable.length) e.timeToSampleTable.push({ sampleCount: t, sampleDelta: 1 });
            else {
                jk(e.timeToSampleTable).sampleCount += t;
            }
            return void (e.timestampProcessingQueue.length = 0);
        }
        const n = e.timestampProcessingQueue.map((e) => e.timestamp).sort((e, t) => e - t);
        for (let r = 0; r < e.timestampProcessingQueue.length; r++) {
            const t = e.timestampProcessingQueue[r];
            (t.decodeTimestamp = n[r]), this.isFragmented || null !== e.lastTimescaleUnits || (t.decodeTimestamp = 0);
            const i = ux(t.timestamp - t.decodeTimestamp, e.timescale),
                s = ux(t.duration, e.timescale);
            if (null !== e.lastTimescaleUnits) {
                Vk(e.lastSample);
                const n = ux(t.decodeTimestamp, e.timescale, !1),
                    r = Math.round(n - e.lastTimescaleUnits);
                if (
                    (Vk(r >= 0),
                    (e.lastTimescaleUnits += r),
                    (e.lastSample.timescaleUnitsToNextSample = r),
                    !this.isFragmented)
                ) {
                    let t = jk(e.timeToSampleTable);
                    if ((Vk(t), 1 === t.sampleCount)) {
                        t.sampleDelta = r;
                        const n = e.timeToSampleTable[e.timeToSampleTable.length - 2];
                        n && n.sampleDelta === r && (n.sampleCount++, e.timeToSampleTable.pop(), (t = n));
                    } else
                        t.sampleDelta !== r &&
                            (t.sampleCount--, e.timeToSampleTable.push((t = { sampleCount: 1, sampleDelta: r })));
                    t.sampleDelta === s
                        ? t.sampleCount++
                        : e.timeToSampleTable.push({ sampleCount: 1, sampleDelta: s });
                    const n = jk(e.compositionTimeOffsetTable);
                    Vk(n),
                        n.sampleCompositionTimeOffset === i
                            ? n.sampleCount++
                            : e.compositionTimeOffsetTable.push({ sampleCount: 1, sampleCompositionTimeOffset: i });
                }
            } else
                (e.lastTimescaleUnits = ux(t.decodeTimestamp, e.timescale, !1)),
                    this.isFragmented ||
                        (e.timeToSampleTable.push({ sampleCount: 1, sampleDelta: s }),
                        e.compositionTimeOffsetTable.push({ sampleCount: 1, sampleCompositionTimeOffset: i }));
            e.lastSample = t;
        }
        if (
            ((e.timestampProcessingQueue.length = 0),
            Vk(e.lastSample),
            Vk(null !== e.lastTimescaleUnits),
            void 0 !== t && 0 === e.lastSample.timescaleUnitsToNextSample)
        ) {
            Vk("key" === t.type);
            const n = ux(t.timestamp, e.timescale, !1),
                r = Math.round(n - e.lastTimescaleUnits);
            e.lastSample.timescaleUnitsToNextSample = r;
        }
    }
    async registerSample(e, t) {
        "key" === t.type && this.processTimestamps(e, t),
            e.timestampProcessingQueue.push(t),
            this.isFragmented
                ? (e.sampleQueue.push(t), await this.interleaveSamples())
                : "reserve" === this.fastStart
                  ? await this.registerSampleFastStartReserve(e, t)
                  : await this.addSampleToTrack(e, t);
    }
    async addSampleToTrack(e, t) {
        if (!this.isFragmented && (e.samples.push(t), "reserve" === this.fastStart)) {
            const t = e.track.metadata.maximumPacketCount;
            if ((Vk(void 0 !== t), e.samples.length > t))
                throw new Error(
                    `Track #${e.track.id} has already reached the maximum packet count (${t}). Either add less packets or increase the maximum packet count.`
                );
        }
        let n = !1;
        if (e.currentChunk) {
            e.currentChunk.startTimestamp = Math.min(e.currentChunk.startTimestamp, t.timestamp);
            const r = t.timestamp - e.currentChunk.startTimestamp;
            if (this.isFragmented) {
                const i = this.trackDatas.every((n) => {
                    if (e === n) return "key" === t.type;
                    const r = n.sampleQueue[0];
                    return r ? "key" === r.type : n.track.source._closed;
                });
                r >= this.minimumFragmentDuration &&
                    i &&
                    t.timestamp > this.maxWrittenTimestamp &&
                    ((n = !0), await this.finalizeFragment());
            } else n = r >= 0.5;
        } else n = !0;
        n &&
            (e.currentChunk && (await this.finalizeCurrentChunk(e)),
            (e.currentChunk = { startTimestamp: t.timestamp, samples: [], offset: null, moofOffset: null })),
            Vk(e.currentChunk),
            e.currentChunk.samples.push(t),
            this.isFragmented && (this.maxWrittenTimestamp = Math.max(this.maxWrittenTimestamp, t.timestamp));
    }
    async finalizeCurrentChunk(e) {
        if ((Vk(!this.isFragmented), !e.currentChunk)) return;
        e.finalizedChunks.push(e.currentChunk), this.finalizedChunks.push(e.currentChunk);
        let t = e.currentChunk.samples.length;
        if (
            ("audio" === e.type &&
                e.info.requiresPcmTransformation &&
                (t = e.currentChunk.samples.reduce((t, n) => t + ux(n.duration, e.timescale), 0)),
            (0 !== e.compactlyCodedChunkTable.length && jk(e.compactlyCodedChunkTable).samplesPerChunk === t) ||
                e.compactlyCodedChunkTable.push({ firstChunk: e.finalizedChunks.length, samplesPerChunk: t }),
            "in-memory" !== this.fastStart)
        ) {
            e.currentChunk.offset = this.writer.getPos();
            for (const t of e.currentChunk.samples) Vk(t.data), this.writer.write(t.data), (t.data = null);
            await this.writer.flush();
        } else e.currentChunk.offset = 0;
    }
    async interleaveSamples(e = !1) {
        if ((Vk(this.isFragmented), e || this.allTracksAreKnown()))
            e: for (;;) {
                let t = null,
                    n = 1 / 0;
                for (const i of this.trackDatas) {
                    if (!e && 0 === i.sampleQueue.length && !i.track.source._closed) break e;
                    i.sampleQueue.length > 0 &&
                        i.sampleQueue[0].timestamp < n &&
                        ((t = i), (n = i.sampleQueue[0].timestamp));
                }
                if (!t) break;
                const r = t.sampleQueue.shift();
                await this.addSampleToTrack(t, r);
            }
    }
    async finalizeFragment(e = !0) {
        Vk(this.isFragmented);
        const t = this.nextFragmentNumber++;
        if (1 === t) {
            this.format._options.onMoov && this.writer.startTrackingWrites();
            const e = jC(this);
            if ((this.boxWriter.writeBox(e), this.format._options.onMoov)) {
                const { data: e, start: t } = this.writer.stopTrackingWrites();
                this.format._options.onMoov(e, t);
            }
        }
        const n = this.trackDatas.filter((e) => e.currentChunk),
            r = II(t, n),
            i = this.writer.getPos(),
            s = i + this.boxWriter.measureBox(r);
        let a = s + 8,
            o = 1 / 0;
        for (const h of n) {
            (h.currentChunk.offset = a), (h.currentChunk.moofOffset = i);
            for (const e of h.currentChunk.samples) a += e.size;
            o = Math.min(o, h.currentChunk.startTimestamp);
        }
        const c = a - s,
            l = c >= 2 ** 32;
        if (l) for (const h of n) h.currentChunk.offset += 8;
        this.format._options.onMoof && this.writer.startTrackingWrites();
        const u = II(t, n);
        if ((this.boxWriter.writeBox(u), this.format._options.onMoof)) {
            const { data: e, start: t } = this.writer.stopTrackingWrites();
            this.format._options.onMoof(e, t, o);
        }
        Vk(this.writer.getPos() === s), this.format._options.onMdat && this.writer.startTrackingWrites();
        const d = WC(l);
        (d.size = c), this.boxWriter.writeBox(d), this.writer.seek(s + (l ? Uv : 8));
        for (const h of n) for (const e of h.currentChunk.samples) this.writer.write(e.data), (e.data = null);
        if (this.format._options.onMdat) {
            const { data: e, start: t } = this.writer.stopTrackingWrites();
            this.format._options.onMdat(e, t);
        }
        for (const h of n)
            h.finalizedChunks.push(h.currentChunk), this.finalizedChunks.push(h.currentChunk), (h.currentChunk = null);
        e && (await this.writer.flush());
    }
    async registerSampleFastStartReserve(e, t) {
        if (this.allTracksAreKnown()) {
            if (!this.mdat) {
                const e = jC(this),
                    t = this.boxWriter.measureBox(e) + this.computeSampleTableSizeUpperBound() + 4096;
                Vk(null !== this.ftypSize),
                    this.writer.seek(this.ftypSize + t),
                    this.format._options.onMdat && this.writer.startTrackingWrites(),
                    (this.mdat = WC(!0)),
                    this.boxWriter.writeBox(this.mdat);
                for (const n of this.trackDatas) {
                    for (const e of n.sampleQueue) await this.addSampleToTrack(n, e);
                    n.sampleQueue.length = 0;
                }
            }
            await this.addSampleToTrack(e, t);
        } else e.sampleQueue.push(t);
    }
    computeSampleTableSizeUpperBound() {
        Vk("reserve" === this.fastStart);
        let e = 0;
        for (const t of this.trackDatas) {
            const n = t.track.metadata.maximumPacketCount;
            Vk(void 0 !== n),
                (e += 8 * Math.ceil((2 / 3) * n)),
                (e += 4 * n),
                (e += 8 * Math.ceil((2 / 3) * n)),
                (e += 12 * Math.ceil((2 / 3) * n)),
                (e += 4 * n),
                (e += 8 * n);
        }
        return e;
    }
    async onTrackClose(e) {
        const t = await this.mutex.acquire();
        if ("subtitle" === e.type && "webvtt" === e.source._codec) {
            const t = this.trackDatas.find((t) => t.track === e);
            t && (await this.processWebVTTCues(t, 1 / 0));
        }
        this.allTracksAreKnown() && this.allTracksKnown.resolve(),
            this.isFragmented && (await this.interleaveSamples()),
            t();
    }
    async finalize() {
        const e = await this.mutex.acquire();
        this.allTracksKnown.resolve();
        for (const n of this.trackDatas)
            "subtitle" === n.type && "webvtt" === n.track.source._codec && (await this.processWebVTTCues(n, 1 / 0));
        if (this.isFragmented) {
            await this.interleaveSamples(!0);
            for (const e of this.trackDatas) this.processTimestamps(e);
            await this.finalizeFragment(!1);
        } else for (const n of this.trackDatas) this.processTimestamps(n), await this.finalizeCurrentChunk(n);
        if ("in-memory" === this.fastStart) {
            let e;
            this.mdat = WC(!1);
            for (let n = 0; n < 2; n++) {
                const t = jC(this),
                    n = this.boxWriter.measureBox(t);
                e = this.boxWriter.measureBox(this.mdat);
                let r = this.writer.getPos() + n + e;
                for (const i of this.finalizedChunks) {
                    i.offset = r;
                    for (const { data: t } of i.samples) Vk(t), (r += t.byteLength), (e += t.byteLength);
                }
                if (r < 2 ** 32) break;
                e >= 2 ** 32 && (this.mdat.largeSize = !0);
            }
            this.format._options.onMoov && this.writer.startTrackingWrites();
            const t = jC(this);
            if ((this.boxWriter.writeBox(t), this.format._options.onMoov)) {
                const { data: e, start: t } = this.writer.stopTrackingWrites();
                this.format._options.onMoov(e, t);
            }
            this.format._options.onMdat && this.writer.startTrackingWrites(),
                (this.mdat.size = e),
                this.boxWriter.writeBox(this.mdat);
            for (const n of this.finalizedChunks)
                for (const e of n.samples) Vk(e.data), this.writer.write(e.data), (e.data = null);
            if (this.format._options.onMdat) {
                const { data: e, start: t } = this.writer.stopTrackingWrites();
                this.format._options.onMdat(e, t);
            }
        } else if (this.isFragmented) {
            const e = this.writer.getPos(),
                n = ((t = this.trackDatas), $C("mfra", void 0, [...t.map(MI), DI()]));
            this.boxWriter.writeBox(n);
            const r = this.writer.getPos() - e;
            this.writer.seek(this.writer.getPos() - 4), this.boxWriter.writeU32(r);
        } else {
            Vk(this.mdat);
            const e = this.boxWriter.offsets.get(this.mdat);
            Vk(void 0 !== e);
            const t = this.writer.getPos() - e;
            if (
                ((this.mdat.size = t),
                (this.mdat.largeSize = t >= 2 ** 32),
                this.boxWriter.patchBox(this.mdat),
                this.format._options.onMdat)
            ) {
                const { data: e, start: t } = this.writer.stopTrackingWrites();
                this.format._options.onMdat(e, t);
            }
            const n = jC(this);
            if ("reserve" === this.fastStart) {
                Vk(null !== this.ftypSize),
                    this.writer.seek(this.ftypSize),
                    this.format._options.onMoov && this.writer.startTrackingWrites(),
                    this.boxWriter.writeBox(n);
                const e = this.boxWriter.offsets.get(this.mdat) - this.writer.getPos();
                this.boxWriter.writeBox({ type: "free", size: e });
            } else this.format._options.onMoov && this.writer.startTrackingWrites(), this.boxWriter.writeBox(n);
            if (this.format._options.onMoov) {
                const { data: e, start: t } = this.writer.stopTrackingWrites();
                this.format._options.onMoov(e, t);
            }
        }
        var t;
        e();
    }
}
const hx = "Mediabunny",
    mx = { video: 1, audio: 2, subtitle: 17 };
class px extends I_ {
    constructor(e, t) {
        super(e),
            (this.trackDatas = []),
            (this.allTracksKnown = fT()),
            (this.segment = null),
            (this.segmentInfo = null),
            (this.seekHead = null),
            (this.tracksElement = null),
            (this.tagsElement = null),
            (this.attachmentsElement = null),
            (this.segmentDuration = null),
            (this.cues = null),
            (this.currentCluster = null),
            (this.currentClusterStartMsTimestamp = null),
            (this.currentClusterMaxMsTimestamp = null),
            (this.trackDatasInCurrentCluster = new Map()),
            (this.duration = 0),
            (this.writer = e._writer),
            (this.format = t),
            (this.ebmlWriter = new gS(this.writer)),
            this.format._options.appendOnly && (this.writer.ensureMonotonicity = !0);
    }
    async start() {
        const e = await this.mutex.acquire();
        this.writeEBMLHeader(), this.createSegmentInfo(), this.createCues(), await this.writer.flush(), e();
    }
    writeEBMLHeader() {
        this.format._options.onEbmlHeader && this.writer.startTrackingWrites();
        const e = {
            id: cS.EBML,
            data: [
                { id: cS.EBMLVersion, data: 1 },
                { id: cS.EBMLReadVersion, data: 1 },
                { id: cS.EBMLMaxIDLength, data: 4 },
                { id: cS.EBMLMaxSizeLength, data: 8 },
                { id: cS.DocType, data: this.format instanceof _x ? "webm" : "matroska" },
                { id: cS.DocTypeVersion, data: 2 },
                { id: cS.DocTypeReadVersion, data: 2 },
            ],
        };
        if ((this.ebmlWriter.writeEBML(e), this.format._options.onEbmlHeader)) {
            const { data: e, start: t } = this.writer.stopTrackingWrites();
            this.format._options.onEbmlHeader(e, t);
        }
    }
    maybeCreateSeekHead(e) {
        if (this.format._options.appendOnly) return;
        const t = new Uint8Array([28, 83, 187, 107]),
            n = new Uint8Array([21, 73, 169, 102]),
            r = new Uint8Array([22, 84, 174, 107]),
            i = new Uint8Array([25, 65, 164, 105]),
            s = new Uint8Array([18, 84, 195, 103]),
            a = {
                id: cS.SeekHead,
                data: [
                    {
                        id: cS.Seek,
                        data: [
                            { id: cS.SeekID, data: t },
                            {
                                id: cS.SeekPosition,
                                size: 5,
                                data: e ? this.ebmlWriter.offsets.get(this.cues) - this.segmentDataOffset : 0,
                            },
                        ],
                    },
                    {
                        id: cS.Seek,
                        data: [
                            { id: cS.SeekID, data: n },
                            {
                                id: cS.SeekPosition,
                                size: 5,
                                data: e ? this.ebmlWriter.offsets.get(this.segmentInfo) - this.segmentDataOffset : 0,
                            },
                        ],
                    },
                    {
                        id: cS.Seek,
                        data: [
                            { id: cS.SeekID, data: r },
                            {
                                id: cS.SeekPosition,
                                size: 5,
                                data: e ? this.ebmlWriter.offsets.get(this.tracksElement) - this.segmentDataOffset : 0,
                            },
                        ],
                    },
                    this.attachmentsElement
                        ? {
                              id: cS.Seek,
                              data: [
                                  { id: cS.SeekID, data: i },
                                  {
                                      id: cS.SeekPosition,
                                      size: 5,
                                      data: e
                                          ? this.ebmlWriter.offsets.get(this.attachmentsElement) -
                                            this.segmentDataOffset
                                          : 0,
                                  },
                              ],
                          }
                        : null,
                    this.tagsElement
                        ? {
                              id: cS.Seek,
                              data: [
                                  { id: cS.SeekID, data: s },
                                  {
                                      id: cS.SeekPosition,
                                      size: 5,
                                      data: e
                                          ? this.ebmlWriter.offsets.get(this.tagsElement) - this.segmentDataOffset
                                          : 0,
                                  },
                              ],
                          }
                        : null,
                ],
            };
        this.seekHead = a;
    }
    createSegmentInfo() {
        const e = { id: cS.Duration, data: new sS(0) };
        this.segmentDuration = e;
        const t = {
            id: cS.Info,
            data: [
                { id: cS.TimestampScale, data: 1e6 },
                { id: cS.MuxingApp, data: hx },
                { id: cS.WritingApp, data: hx },
                this.format._options.appendOnly ? null : e,
            ],
        };
        this.segmentInfo = t;
    }
    createTracks() {
        const e = { id: cS.Tracks, data: [] };
        this.tracksElement = e;
        for (const t of this.trackDatas) {
            const n = AS[t.track.source._codec];
            Vk(n);
            let r = 0;
            if ("audio" === t.type && "opus" === t.track.source._codec) {
                r = 8e7;
                const e = t.info.decoderConfig.description;
                if (e) {
                    const t = Kk(e),
                        n = Y_(t);
                    r = Math.round((n.preSkip / p_) * 1e9);
                }
            }
            e.data.push({
                id: cS.TrackEntry,
                data: [
                    { id: cS.TrackNumber, data: t.track.id },
                    { id: cS.TrackUID, data: t.track.id },
                    { id: cS.TrackType, data: mx[t.type] },
                    { id: cS.FlagLacing, data: 0 },
                    { id: cS.Language, data: t.track.metadata.languageCode ?? vT },
                    { id: cS.CodecID, data: n },
                    { id: cS.CodecDelay, data: 0 },
                    { id: cS.SeekPreRoll, data: r },
                    void 0 !== t.track.metadata.name ? { id: cS.Name, data: new oS(t.track.metadata.name) } : null,
                    "video" === t.type ? this.videoSpecificTrackInfo(t) : null,
                    "audio" === t.type ? this.audioSpecificTrackInfo(t) : null,
                    "subtitle" === t.type ? this.subtitleSpecificTrackInfo(t) : null,
                ],
            });
        }
    }
    videoSpecificTrackInfo(e) {
        const { frameRate: t, rotation: n } = e.track.metadata,
            r = [
                e.info.decoderConfig.description
                    ? { id: cS.CodecPrivate, data: Kk(e.info.decoderConfig.description) }
                    : null,
                t ? { id: cS.DefaultDuration, data: 1e9 / t } : null,
            ],
            i = n ? Wk(-n) : 0,
            s = e.info.decoderConfig.colorSpace,
            a = {
                id: cS.Video,
                data: [
                    { id: cS.PixelWidth, data: e.info.width },
                    { id: cS.PixelHeight, data: e.info.height },
                    e.info.alphaMode ? { id: cS.AlphaMode, data: 1 } : null,
                    oT(s)
                        ? {
                              id: cS.Colour,
                              data: [
                                  { id: cS.MatrixCoefficients, data: sT[s.matrix] },
                                  { id: cS.TransferCharacteristics, data: rT[s.transfer] },
                                  { id: cS.Primaries, data: tT[s.primaries] },
                                  { id: cS.Range, data: s.fullRange ? 2 : 1 },
                              ],
                          }
                        : null,
                    i
                        ? {
                              id: cS.Projection,
                              data: [
                                  { id: cS.ProjectionType, data: 0 },
                                  { id: cS.ProjectionPoseRoll, data: new iS(((i + 180) % 360) - 180) },
                              ],
                          }
                        : null,
                ],
            };
        return r.push(a), r;
    }
    audioSpecificTrackInfo(e) {
        const t = KT.includes(e.track.source._codec) ? g_(e.track.source._codec) : null;
        return [
            e.info.decoderConfig.description
                ? { id: cS.CodecPrivate, data: Kk(e.info.decoderConfig.description) }
                : null,
            {
                id: cS.Audio,
                data: [
                    { id: cS.SamplingFrequency, data: new iS(e.info.sampleRate) },
                    { id: cS.Channels, data: e.info.numberOfChannels },
                    t ? { id: cS.BitDepth, data: 8 * t.sampleSize } : null,
                ],
            },
        ];
    }
    subtitleSpecificTrackInfo(e) {
        return [{ id: cS.CodecPrivate, data: Jk.encode(e.info.config.description) }];
    }
    maybeCreateTags() {
        const e = [],
            t = (t, n) => {
                e.push({
                    id: cS.SimpleTag,
                    data: [
                        { id: cS.TagName, data: new oS(t) },
                        "string" == typeof n ? { id: cS.TagString, data: new oS(n) } : { id: cS.TagBinary, data: n },
                    ],
                });
            },
            n = this.output._metadataTags,
            r = new Set();
        for (const { key: i, value: s } of zT(n))
            switch (i) {
                case "title":
                    t("TITLE", s), r.add("TITLE");
                    break;
                case "description":
                    t("DESCRIPTION", s), r.add("DESCRIPTION");
                    break;
                case "artist":
                    t("ARTIST", s), r.add("ARTIST");
                    break;
                case "album":
                    t("ALBUM", s), r.add("ALBUM");
                    break;
                case "albumArtist":
                    t("ALBUM_ARTIST", s), r.add("ALBUM_ARTIST");
                    break;
                case "genre":
                    t("GENRE", s), r.add("GENRE");
                    break;
                case "comment":
                    t("COMMENT", s), r.add("COMMENT");
                    break;
                case "lyrics":
                    t("LYRICS", s), r.add("LYRICS");
                    break;
                case "date":
                    t("DATE", s.toISOString().slice(0, 10)), r.add("DATE");
                    break;
                case "trackNumber":
                    t("PART_NUMBER", void 0 !== n.tracksTotal ? `${s}/${n.tracksTotal}` : s.toString()),
                        r.add("PART_NUMBER");
                    break;
                case "discNumber":
                    t("DISC", void 0 !== n.discsTotal ? `${s}/${n.discsTotal}` : s.toString()), r.add("DISC");
                    break;
                case "tracksTotal":
                case "discsTotal":
                case "images":
                case "raw":
                    break;
                default:
                    yT(i);
            }
        if (n.raw)
            for (const i in n.raw) {
                const e = n.raw[i];
                null == e || r.has(i) || (("string" == typeof e || e instanceof Uint8Array) && t(i, e));
            }
        0 !== e.length &&
            (this.tagsElement = {
                id: cS.Tags,
                data: [
                    {
                        id: cS.Tag,
                        data: [
                            {
                                id: cS.Targets,
                                data: [
                                    { id: cS.TargetTypeValue, data: 50 },
                                    { id: cS.TargetType, data: "MOVIE" },
                                ],
                            },
                            ...e,
                        ],
                    },
                ],
            });
    }
    maybeCreateAttachments() {
        const e = this.output._metadataTags,
            t = [],
            n = new Set(),
            r = e.images ?? [];
        for (const i of r) {
            let e,
                r = i.name;
            if (void 0 === r) {
                r =
                    ("coverFront" === i.kind ? "cover" : "coverBack" === i.kind ? "back" : "image") +
                    (UT(i.mimeType) ?? "");
            }
            for (;;) {
                e = 0n;
                for (let t = 0; t < 8; t++) (e <<= 8n), (e |= BigInt(Math.floor(256 * Math.random())));
                if (0n !== e && !n.has(e)) break;
            }
            n.add(e),
                t.push({
                    id: cS.AttachedFile,
                    data: [
                        void 0 !== i.description ? { id: cS.FileDescription, data: new oS(i.description) } : null,
                        { id: cS.FileName, data: new oS(r) },
                        { id: cS.FileMediaType, data: i.mimeType },
                        { id: cS.FileData, data: i.data },
                        { id: cS.FileUID, data: e },
                    ],
                });
        }
        for (const [i, s] of Object.entries(e.raw ?? {})) {
            if (!(s instanceof qT)) continue;
            /^\d+$/.test(i) &&
                (r.find((e) => e.mimeType === s.mimeType && VT(e.data, s.data)) ||
                    t.push({
                        id: cS.AttachedFile,
                        data: [
                            void 0 !== s.description ? { id: cS.FileDescription, data: new oS(s.description) } : null,
                            { id: cS.FileName, data: new oS(s.name ?? "") },
                            { id: cS.FileMediaType, data: s.mimeType ?? "" },
                            { id: cS.FileData, data: s.data },
                            { id: cS.FileUID, data: BigInt(i) },
                        ],
                    }));
        }
        0 !== t.length && (this.attachmentsElement = { id: cS.Attachments, data: t });
    }
    createSegment() {
        this.createTracks(), this.maybeCreateTags(), this.maybeCreateAttachments(), this.maybeCreateSeekHead(!1);
        const e = {
            id: cS.Segment,
            size: this.format._options.appendOnly ? -1 : 6,
            data: [this.seekHead, this.segmentInfo, this.tracksElement, this.attachmentsElement, this.tagsElement],
        };
        if (
            ((this.segment = e),
            this.format._options.onSegmentHeader && this.writer.startTrackingWrites(),
            this.ebmlWriter.writeEBML(e),
            this.format._options.onSegmentHeader)
        ) {
            const { data: e, start: t } = this.writer.stopTrackingWrites();
            this.format._options.onSegmentHeader(e, t);
        }
    }
    createCues() {
        this.cues = { id: cS.Cues, data: [] };
    }
    get segmentDataOffset() {
        return Vk(this.segment), this.ebmlWriter.dataOffsets.get(this.segment);
    }
    allTracksAreKnown() {
        for (const e of this.output._tracks)
            if (!e.source._closed && !this.trackDatas.some((t) => t.track === e)) return !1;
        return !0;
    }
    async getMimeType() {
        await this.allTracksKnown.promise;
        const e = this.trackDatas.map((e) => {
            if ("video" === e.type) return e.info.decoderConfig.codec;
            if ("audio" === e.type) return e.info.decoderConfig.codec;
            return { webvtt: "wvtt" }[e.track.source._codec];
        });
        return OS({
            isWebM: this.format instanceof _x,
            hasVideo: this.trackDatas.some((e) => "video" === e.type),
            hasAudio: this.trackDatas.some((e) => "audio" === e.type),
            codecStrings: e,
        });
    }
    getVideoTrackData(e, t, n) {
        const r = this.trackDatas.find((t) => t.track === e);
        if (r) return r;
        v_(n),
            Vk(n),
            Vk(n.decoderConfig),
            Vk(void 0 !== n.decoderConfig.codedWidth),
            Vk(void 0 !== n.decoderConfig.codedHeight);
        const i = {
            track: e,
            type: "video",
            info: {
                width: n.decoderConfig.codedWidth,
                height: n.decoderConfig.codedHeight,
                decoderConfig: n.decoderConfig,
                alphaMode: !!t.sideData.alpha,
            },
            chunkQueue: [],
            lastWrittenMsTimestamp: null,
        };
        return (
            "vp9" === e.source._codec
                ? (i.info.decoderConfig = {
                      ...i.info.decoderConfig,
                      description: new Uint8Array(a_(i.info.decoderConfig.codec)),
                  })
                : "av1" === e.source._codec &&
                  (i.info.decoderConfig = {
                      ...i.info.decoderConfig,
                      description: new Uint8Array(o_(i.info.decoderConfig.codec)),
                  }),
            this.trackDatas.push(i),
            this.trackDatas.sort((e, t) => e.track.id - t.track.id),
            this.allTracksAreKnown() && this.allTracksKnown.resolve(),
            i
        );
    }
    getAudioTrackData(e, t) {
        const n = this.trackDatas.find((t) => t.track === e);
        if (n) return n;
        E_(t), Vk(t), Vk(t.decoderConfig);
        const r = {
            track: e,
            type: "audio",
            info: {
                numberOfChannels: t.decoderConfig.numberOfChannels,
                sampleRate: t.decoderConfig.sampleRate,
                decoderConfig: t.decoderConfig,
            },
            chunkQueue: [],
            lastWrittenMsTimestamp: null,
        };
        return (
            this.trackDatas.push(r),
            this.trackDatas.sort((e, t) => e.track.id - t.track.id),
            this.allTracksAreKnown() && this.allTracksKnown.resolve(),
            r
        );
    }
    getSubtitleTrackData(e, t) {
        const n = this.trackDatas.find((t) => t.track === e);
        if (n) return n;
        C_(t), Vk(t), Vk(t.config);
        const r = {
            track: e,
            type: "subtitle",
            info: { config: t.config },
            chunkQueue: [],
            lastWrittenMsTimestamp: null,
        };
        return (
            this.trackDatas.push(r),
            this.trackDatas.sort((e, t) => e.track.id - t.track.id),
            this.allTracksAreKnown() && this.allTracksKnown.resolve(),
            r
        );
    }
    async addEncodedVideoPacket(e, t, n) {
        const r = await this.mutex.acquire();
        try {
            const r = this.getVideoTrackData(e, t, n),
                i = "key" === t.type;
            let s = this.validateAndNormalizeTimestamp(r.track, t.timestamp, i),
                a = t.duration;
            void 0 !== e.metadata.frameRate &&
                ((s = ET(s, 1 / e.metadata.frameRate)), (a = ET(a, 1 / e.metadata.frameRate)));
            const o = r.info.alphaMode ? (t.sideData.alpha ?? null) : null,
                c = this.createInternalChunk(t.data, s, a, t.type, o);
            "vp9" === e.source._codec && this.fixVP9ColorSpace(r, c),
                r.chunkQueue.push(c),
                await this.interleaveChunks();
        } finally {
            r();
        }
    }
    async addEncodedAudioPacket(e, t, n) {
        const r = await this.mutex.acquire();
        try {
            const r = this.getAudioTrackData(e, n),
                i = "key" === t.type,
                s = this.validateAndNormalizeTimestamp(r.track, t.timestamp, i),
                a = this.createInternalChunk(t.data, s, t.duration, t.type);
            r.chunkQueue.push(a), await this.interleaveChunks();
        } finally {
            r();
        }
    }
    async addSubtitleCue(e, t, n) {
        const r = await this.mutex.acquire();
        try {
            const r = this.getSubtitleTrackData(e, n),
                i = this.validateAndNormalizeTimestamp(r.track, t.timestamp, !0);
            let s = t.text;
            const a = Math.round(1e3 * i);
            (wC.lastIndex = 0),
                (s = s.replace(wC, (e) => {
                    const t = ((e) => {
                        const t = kC.exec(e);
                        if (!t) throw new Error("Expected match.");
                        return 36e5 * Number(t[1] || "0") + 6e4 * Number(t[2]) + 1e3 * Number(t[3]) + Number(t[4]);
                    })(e.slice(1, -1));
                    return `<${TC(t - a)}>`;
                }));
            const o = Jk.encode(s),
                c = `${t.settings ?? ""}\n${t.identifier ?? ""}\n${t.notes ?? ""}`,
                l = this.createInternalChunk(o, i, t.duration, "key", c.trim() ? Jk.encode(c) : null);
            r.chunkQueue.push(l), await this.interleaveChunks();
        } finally {
            r();
        }
    }
    async interleaveChunks(e = !1) {
        if (e || this.allTracksAreKnown()) {
            e: for (;;) {
                let t = null,
                    n = 1 / 0;
                for (const i of this.trackDatas) {
                    if (!e && 0 === i.chunkQueue.length && !i.track.source._closed) break e;
                    i.chunkQueue.length > 0 &&
                        i.chunkQueue[0].timestamp < n &&
                        ((t = i), (n = i.chunkQueue[0].timestamp));
                }
                if (!t) break;
                const r = t.chunkQueue.shift();
                this.writeBlock(t, r);
            }
            e || (await this.writer.flush());
        }
    }
    fixVP9ColorSpace(e, t) {
        if ("key" !== t.type) return;
        if (!e.info.decoderConfig.colorSpace || !e.info.decoderConfig.colorSpace.matrix) return;
        const n = new qk(t.data);
        n.skipBits(2);
        const r = n.readBits(1),
            i = (n.readBits(1) << 1) + r;
        3 === i && n.skipBits(1);
        if (n.readBits(1)) return;
        if (0 !== n.readBits(1)) return;
        n.skipBits(2);
        if (4817730 !== n.readBits(24)) return;
        i >= 2 && n.skipBits(1);
        const s = { rgb: 7, bt709: 2, bt470bg: 1, smpte170m: 3 }[e.info.decoderConfig.colorSpace.matrix];
        ((e, t, n, r) => {
            for (let i = t; i < n; i++) {
                const t = Math.floor(i / 8);
                let s = e[t];
                const a = 7 - (7 & i);
                (s &= ~(1 << a)), (s |= ((r & (1 << (n - i - 1))) >> (n - i - 1)) << a), (e[t] = s);
            }
        })(t.data, n.pos, n.pos + 3, s);
    }
    createInternalChunk(e, t, n, r, i = null) {
        return { data: e, type: r, timestamp: t, duration: n, additions: i };
    }
    writeBlock(e, t) {
        this.segment || this.createSegment();
        const n = Math.round(1e3 * t.timestamp),
            r = this.trackDatas.every((n) => {
                if (e === n) return "key" === t.type;
                const r = n.chunkQueue[0];
                return r ? "key" === r.type : n.track.source._closed;
            });
        let i = !1;
        if (this.currentCluster) {
            Vk(null !== this.currentClusterStartMsTimestamp), Vk(null !== this.currentClusterMaxMsTimestamp);
            const e = n - this.currentClusterStartMsTimestamp;
            i =
                (r &&
                    n > this.currentClusterMaxMsTimestamp &&
                    e >= 1e3 * (this.format._options.minimumClusterDuration ?? 1)) ||
                e > 32767;
        } else i = !0;
        i && this.createNewCluster(n);
        const s = n - this.currentClusterStartMsTimestamp;
        if (s < -32768) return;
        const a = new Uint8Array(4),
            o = new DataView(a.buffer);
        o.setUint8(0, 128 | e.track.id), o.setInt16(1, s, !1);
        const c = Math.round(1e3 * t.duration);
        if (t.additions) {
            const r = {
                id: cS.BlockGroup,
                data: [
                    { id: cS.Block, data: [a, t.data] },
                    "delta" === t.type ? { id: cS.ReferenceBlock, data: new aS(e.lastWrittenMsTimestamp - n) } : null,
                    t.additions
                        ? {
                              id: cS.BlockAdditions,
                              data: [
                                  {
                                      id: cS.BlockMore,
                                      data: [
                                          { id: cS.BlockAddID, data: 1 },
                                          { id: cS.BlockAdditional, data: t.additions },
                                      ],
                                  },
                              ],
                          }
                        : null,
                    c > 0 ? { id: cS.BlockDuration, data: c } : null,
                ],
            };
            this.ebmlWriter.writeEBML(r);
        } else {
            o.setUint8(3, Number("key" === t.type) << 7);
            const e = { id: cS.SimpleBlock, data: [a, t.data] };
            this.ebmlWriter.writeEBML(e);
        }
        (this.duration = Math.max(this.duration, n + c)),
            (e.lastWrittenMsTimestamp = n),
            this.trackDatasInCurrentCluster.has(e) || this.trackDatasInCurrentCluster.set(e, { firstMsTimestamp: n }),
            (this.currentClusterMaxMsTimestamp = Math.max(this.currentClusterMaxMsTimestamp, n));
    }
    createNewCluster(e) {
        this.currentCluster && this.finalizeCurrentCluster(),
            this.format._options.onCluster && this.writer.startTrackingWrites(),
            (this.currentCluster = {
                id: cS.Cluster,
                size: this.format._options.appendOnly ? -1 : 5,
                data: [{ id: cS.Timestamp, data: e }],
            }),
            this.ebmlWriter.writeEBML(this.currentCluster),
            (this.currentClusterStartMsTimestamp = e),
            (this.currentClusterMaxMsTimestamp = e),
            this.trackDatasInCurrentCluster.clear();
    }
    finalizeCurrentCluster() {
        if ((Vk(this.currentCluster), !this.format._options.appendOnly)) {
            const e = this.writer.getPos() - this.ebmlWriter.dataOffsets.get(this.currentCluster),
                t = this.writer.getPos();
            this.writer.seek(this.ebmlWriter.offsets.get(this.currentCluster) + 4),
                this.ebmlWriter.writeVarInt(e, 5),
                this.writer.seek(t);
        }
        if (this.format._options.onCluster) {
            Vk(null !== this.currentClusterStartMsTimestamp);
            const { data: e, start: t } = this.writer.stopTrackingWrites();
            this.format._options.onCluster(e, t, this.currentClusterStartMsTimestamp / 1e3);
        }
        const e = this.ebmlWriter.offsets.get(this.currentCluster) - this.segmentDataOffset,
            t = new Map();
        for (const [r, { firstMsTimestamp: i }] of this.trackDatasInCurrentCluster)
            t.has(i) || t.set(i, []), t.get(i).push(r);
        const n = [...t.entries()].sort((e, t) => e[0] - t[0]);
        for (const [r, i] of n)
            Vk(this.cues),
                this.cues.data.push({
                    id: cS.CuePoint,
                    data: [
                        { id: cS.CueTime, data: r },
                        ...i.map((t) => ({
                            id: cS.CueTrackPositions,
                            data: [
                                { id: cS.CueTrack, data: t.track.id },
                                { id: cS.CueClusterPosition, data: e },
                            ],
                        })),
                    ],
                });
    }
    async onTrackClose() {
        const e = await this.mutex.acquire();
        this.allTracksAreKnown() && this.allTracksKnown.resolve(), await this.interleaveChunks(), e();
    }
    async finalize() {
        const e = await this.mutex.acquire();
        if (
            (this.allTracksKnown.resolve(),
            this.segment || this.createSegment(),
            await this.interleaveChunks(!0),
            this.currentCluster && this.finalizeCurrentCluster(),
            Vk(this.cues),
            this.ebmlWriter.writeEBML(this.cues),
            !this.format._options.appendOnly)
        ) {
            const e = this.writer.getPos(),
                t = this.writer.getPos() - this.segmentDataOffset;
            this.writer.seek(this.ebmlWriter.offsets.get(this.segment) + 4),
                this.ebmlWriter.writeVarInt(t, 6),
                (this.segmentDuration.data = new sS(this.duration)),
                this.writer.seek(this.ebmlWriter.offsets.get(this.segmentDuration)),
                this.ebmlWriter.writeEBML(this.segmentDuration),
                Vk(this.seekHead),
                this.writer.seek(this.ebmlWriter.offsets.get(this.seekHead)),
                this.maybeCreateSeekHead(!0),
                this.ebmlWriter.writeEBML(this.seekHead),
                this.writer.seek(e);
        }
        e();
    }
}
class fx {
    constructor(e) {
        (this.writer = e), (this.helper = new Uint8Array(8)), (this.helperView = new DataView(this.helper.buffer));
    }
    writeU16(e) {
        this.helperView.setUint16(0, e, !0), this.writer.write(this.helper.subarray(0, 2));
    }
    writeU32(e) {
        this.helperView.setUint32(0, e, !0), this.writer.write(this.helper.subarray(0, 4));
    }
    writeU64(e) {
        this.helperView.setUint32(0, e, !0),
            this.helperView.setUint32(4, Math.floor(e / 2 ** 32), !0),
            this.writer.write(this.helper);
    }
    writeAscii(e) {
        this.writer.write(new TextEncoder().encode(e));
    }
}
class gx extends I_ {
    constructor(e, t) {
        super(e),
            (this.headerWritten = !1),
            (this.dataSize = 0),
            (this.sampleRate = null),
            (this.sampleCount = 0),
            (this.riffSizePos = null),
            (this.dataSizePos = null),
            (this.ds64RiffSizePos = null),
            (this.ds64DataSizePos = null),
            (this.ds64SampleCountPos = null),
            (this.format = t),
            (this.writer = e._writer),
            (this.riffWriter = new fx(e._writer)),
            (this.isRf64 = !!t._options.large);
    }
    async start() {}
    async getMimeType() {
        return "audio/wav";
    }
    async addEncodedVideoPacket() {
        throw new Error("WAVE does not support video.");
    }
    async addEncodedAudioPacket(e, t, n) {
        const r = await this.mutex.acquire();
        try {
            if (
                (this.headerWritten ||
                    (E_(n),
                    Vk(n),
                    Vk(n.decoderConfig),
                    this.writeHeader(e, n.decoderConfig),
                    (this.sampleRate = n.decoderConfig.sampleRate),
                    (this.headerWritten = !0)),
                this.validateAndNormalizeTimestamp(e, t.timestamp, "key" === t.type),
                !this.isRf64 && this.writer.getPos() + t.data.byteLength >= 2 ** 32)
            )
                throw new Error(
                    "Adding more audio data would exceed the maximum RIFF size of 4 GiB. To write larger files, use RF64 by setting `large: true` in the WavOutputFormatOptions."
                );
            this.writer.write(t.data),
                (this.dataSize += t.data.byteLength),
                (this.sampleCount += Math.round(t.duration * this.sampleRate)),
                await this.writer.flush();
        } finally {
            r();
        }
    }
    async addSubtitleCue() {
        throw new Error("WAVE does not support subtitles.");
    }
    writeHeader(e, t) {
        let n;
        this.format._options.onHeader && this.writer.startTrackingWrites();
        const r = e.source._codec,
            i = g_(r);
        n =
            "ulaw" === i.dataType
                ? TE.MULAW
                : "alaw" === i.dataType
                  ? TE.ALAW
                  : "float" === i.dataType
                    ? TE.IEEE_FLOAT
                    : TE.PCM;
        const s = t.numberOfChannels,
            a = t.sampleRate,
            o = i.sampleSize * s;
        if (
            (this.riffWriter.writeAscii(this.isRf64 ? "RF64" : "RIFF"),
            this.isRf64
                ? this.riffWriter.writeU32(4294967295)
                : ((this.riffSizePos = this.writer.getPos()), this.riffWriter.writeU32(0)),
            this.riffWriter.writeAscii("WAVE"),
            this.isRf64 &&
                (this.riffWriter.writeAscii("ds64"),
                this.riffWriter.writeU32(28),
                (this.ds64RiffSizePos = this.writer.getPos()),
                this.riffWriter.writeU64(0),
                (this.ds64DataSizePos = this.writer.getPos()),
                this.riffWriter.writeU64(0),
                (this.ds64SampleCountPos = this.writer.getPos()),
                this.riffWriter.writeU64(0),
                this.riffWriter.writeU32(0)),
            this.riffWriter.writeAscii("fmt "),
            this.riffWriter.writeU32(16),
            this.riffWriter.writeU16(n),
            this.riffWriter.writeU16(s),
            this.riffWriter.writeU32(a),
            this.riffWriter.writeU32(a * o),
            this.riffWriter.writeU16(o),
            this.riffWriter.writeU16(8 * i.sampleSize),
            void 0 !== (c = this.output._metadataTags).title ||
                void 0 !== c.description ||
                void 0 !== c.artist ||
                void 0 !== c.album ||
                void 0 !== c.albumArtist ||
                void 0 !== c.trackNumber ||
                void 0 !== c.tracksTotal ||
                void 0 !== c.discNumber ||
                void 0 !== c.discsTotal ||
                void 0 !== c.genre ||
                void 0 !== c.date ||
                void 0 !== c.lyrics ||
                (c.images && 0 !== c.images.length) ||
                void 0 !== c.comment ||
                (void 0 !== c.raw && 0 !== Object.keys(c.raw).length))
        ) {
            const e = this.format._options.metadataFormat ?? "info";
            "info" === e
                ? this.writeInfoChunk(this.output._metadataTags)
                : "id3" === e
                  ? this.writeId3Chunk(this.output._metadataTags)
                  : yT(e);
        }
        var c;
        if (
            (this.riffWriter.writeAscii("data"),
            this.isRf64
                ? this.riffWriter.writeU32(4294967295)
                : ((this.dataSizePos = this.writer.getPos()), this.riffWriter.writeU32(0)),
            this.format._options.onHeader)
        ) {
            const { data: e, start: t } = this.writer.stopTrackingWrites();
            this.format._options.onHeader(e, t);
        }
    }
    writeInfoChunk(e) {
        const t = this.writer.getPos();
        this.riffWriter.writeAscii("LIST"), this.riffWriter.writeU32(0), this.riffWriter.writeAscii("INFO");
        const n = new Set(),
            r = (e, t) => {
                if (!Zk(t)) return;
                const r = t.length + 1,
                    i = new Uint8Array(r);
                for (let n = 0; n < t.length; n++) i[n] = t.charCodeAt(n);
                this.riffWriter.writeAscii(e),
                    this.riffWriter.writeU32(r),
                    this.writer.write(i),
                    1 & r && this.writer.write(new Uint8Array(1)),
                    n.add(e);
            };
        for (const { key: a, value: o } of zT(e))
            switch (a) {
                case "title":
                    r("INAM", o), n.add("INAM");
                    break;
                case "artist":
                    r("IART", o), n.add("IART");
                    break;
                case "album":
                    r("IPRD", o), n.add("IPRD");
                    break;
                case "trackNumber":
                    r("ITRK", void 0 !== e.tracksTotal ? `${o}/${e.tracksTotal}` : o.toString()), n.add("ITRK");
                    break;
                case "genre":
                    r("IGNR", o), n.add("IGNR");
                    break;
                case "date":
                    r("ICRD", o.toISOString().slice(0, 10)), n.add("ICRD");
                    break;
                case "comment":
                    r("ICMT", o), n.add("ICMT");
                    break;
                case "albumArtist":
                case "discNumber":
                case "tracksTotal":
                case "discsTotal":
                case "description":
                case "lyrics":
                case "images":
                case "raw":
                    break;
                default:
                    yT(a);
            }
        if (e.raw)
            for (const a in e.raw) {
                const t = e.raw[a];
                null == t || 4 !== a.length || n.has(a) || ("string" == typeof t && r(a, t));
            }
        const i = this.writer.getPos(),
            s = i - t - 8;
        this.writer.seek(t + 4),
            this.riffWriter.writeU32(s),
            this.writer.seek(i),
            1 & s && this.writer.write(new Uint8Array(1));
    }
    writeId3Chunk(e) {
        const t = this.writer.getPos();
        this.riffWriter.writeAscii("ID3 "), this.riffWriter.writeU32(0);
        const n = new sE(this.writer).writeId3V2Tag(e),
            r = this.writer.getPos();
        this.writer.seek(t + 4),
            this.riffWriter.writeU32(n),
            this.writer.seek(r),
            1 & n && this.writer.write(new Uint8Array(1));
    }
    async finalize() {
        const e = await this.mutex.acquire(),
            t = this.writer.getPos();
        this.isRf64
            ? (Vk(null !== this.ds64RiffSizePos),
              this.writer.seek(this.ds64RiffSizePos),
              this.riffWriter.writeU64(t - 8),
              Vk(null !== this.ds64DataSizePos),
              this.writer.seek(this.ds64DataSizePos),
              this.riffWriter.writeU64(this.dataSize),
              Vk(null !== this.ds64SampleCountPos),
              this.writer.seek(this.ds64SampleCountPos),
              this.riffWriter.writeU64(this.sampleCount))
            : (Vk(null !== this.riffSizePos),
              this.writer.seek(this.riffSizePos),
              this.riffWriter.writeU32(t - 8),
              Vk(null !== this.dataSizePos),
              this.writer.seek(this.dataSizePos),
              this.riffWriter.writeU32(this.dataSize)),
            this.writer.seek(t),
            e();
    }
}
class bx {
    getSupportedVideoCodecs() {
        return this.getSupportedCodecs().filter((e) => GT.includes(e));
    }
    getSupportedAudioCodecs() {
        return this.getSupportedCodecs().filter((e) => QT.includes(e));
    }
    getSupportedSubtitleCodecs() {
        return this.getSupportedCodecs().filter((e) => JT.includes(e));
    }
    _codecUnsupportedHint(e) {
        return "";
    }
}
class yx extends bx {
    constructor(e = {}) {
        if (!e || "object" != typeof e) throw new TypeError("options must be an object.");
        if (void 0 !== e.fastStart && ![!1, "in-memory", "reserve", "fragmented"].includes(e.fastStart))
            throw new TypeError(
                "options.fastStart, when provided, must be false, 'in-memory', 'reserve', or 'fragmented'."
            );
        if (
            void 0 !== e.minimumFragmentDuration &&
            (!Number.isFinite(e.minimumFragmentDuration) || e.minimumFragmentDuration < 0)
        )
            throw new TypeError("options.minimumFragmentDuration, when provided, must be a non-negative number.");
        if (void 0 !== e.onFtyp && "function" != typeof e.onFtyp)
            throw new TypeError("options.onFtyp, when provided, must be a function.");
        if (void 0 !== e.onMoov && "function" != typeof e.onMoov)
            throw new TypeError("options.onMoov, when provided, must be a function.");
        if (void 0 !== e.onMdat && "function" != typeof e.onMdat)
            throw new TypeError("options.onMdat, when provided, must be a function.");
        if (void 0 !== e.onMoof && "function" != typeof e.onMoof)
            throw new TypeError("options.onMoof, when provided, must be a function.");
        if (void 0 !== e.metadataFormat && !["mdir", "mdta", "udta", "auto"].includes(e.metadataFormat))
            throw new TypeError(
                "options.metadataFormat, when provided, must be either 'auto', 'mdir', 'mdta', or 'udta'."
            );
        super(), (this._options = e);
    }
    getSupportedTrackCounts() {
        return {
            video: { min: 0, max: 1 / 0 },
            audio: { min: 0, max: 1 / 0 },
            subtitle: { min: 0, max: 1 / 0 },
            total: { min: 1, max: 2 ** 32 - 1 },
        };
    }
    get supportsVideoRotationMetadata() {
        return !0;
    }
    _createMuxer(e) {
        return new dx(e, this);
    }
}
class wx extends yx {
    constructor(e) {
        super(e);
    }
    get _name() {
        return "MP4";
    }
    get fileExtension() {
        return ".mp4";
    }
    get mimeType() {
        return "video/mp4";
    }
    getSupportedCodecs() {
        return [
            ...GT,
            ...YT,
            "pcm-s16",
            "pcm-s16be",
            "pcm-s24",
            "pcm-s24be",
            "pcm-s32",
            "pcm-s32be",
            "pcm-f32",
            "pcm-f32be",
            "pcm-f64",
            "pcm-f64be",
            ...JT,
        ];
    }
    _codecUnsupportedHint(e) {
        return new kx().getSupportedCodecs().includes(e) ? " Switching to MOV will grant support for this codec." : "";
    }
}
class kx extends yx {
    constructor(e) {
        super(e);
    }
    get _name() {
        return "MOV";
    }
    get fileExtension() {
        return ".mov";
    }
    get mimeType() {
        return "video/quicktime";
    }
    getSupportedCodecs() {
        return [...GT, ...QT];
    }
    _codecUnsupportedHint(e) {
        return new wx().getSupportedCodecs().includes(e) ? " Switching to MP4 will grant support for this codec." : "";
    }
}
class Tx extends bx {
    constructor(e = {}) {
        if (!e || "object" != typeof e) throw new TypeError("options must be an object.");
        if (void 0 !== e.appendOnly && "boolean" != typeof e.appendOnly)
            throw new TypeError("options.appendOnly, when provided, must be a boolean.");
        if (
            void 0 !== e.minimumClusterDuration &&
            (!Number.isFinite(e.minimumClusterDuration) || e.minimumClusterDuration < 0)
        )
            throw new TypeError("options.minimumClusterDuration, when provided, must be a non-negative number.");
        if (void 0 !== e.onEbmlHeader && "function" != typeof e.onEbmlHeader)
            throw new TypeError("options.onEbmlHeader, when provided, must be a function.");
        if (void 0 !== e.onSegmentHeader && "function" != typeof e.onSegmentHeader)
            throw new TypeError("options.onHeader, when provided, must be a function.");
        if (void 0 !== e.onCluster && "function" != typeof e.onCluster)
            throw new TypeError("options.onCluster, when provided, must be a function.");
        super(), (this._options = e);
    }
    _createMuxer(e) {
        return new px(e, this);
    }
    get _name() {
        return "Matroska";
    }
    getSupportedTrackCounts() {
        return {
            video: { min: 0, max: 1 / 0 },
            audio: { min: 0, max: 1 / 0 },
            subtitle: { min: 0, max: 1 / 0 },
            total: { min: 1, max: 127 },
        };
    }
    get fileExtension() {
        return ".mkv";
    }
    get mimeType() {
        return "video/x-matroska";
    }
    getSupportedCodecs() {
        return [
            ...GT,
            ...YT,
            ...KT.filter((e) => !["pcm-s8", "pcm-f32be", "pcm-f64be", "ulaw", "alaw"].includes(e)),
            ...JT,
        ];
    }
    get supportsVideoRotationMetadata() {
        return !1;
    }
}
class _x extends Tx {
    constructor(e) {
        super(e);
    }
    getSupportedCodecs() {
        return [
            ...GT.filter((e) => ["vp8", "vp9", "av1"].includes(e)),
            ...QT.filter((e) => ["opus", "vorbis"].includes(e)),
            ...JT,
        ];
    }
    get _name() {
        return "WebM";
    }
    get fileExtension() {
        return ".webm";
    }
    get mimeType() {
        return "video/webm";
    }
    _codecUnsupportedHint(e) {
        return new Tx().getSupportedCodecs().includes(e) ? " Switching to MKV will grant support for this codec." : "";
    }
}
class vx extends bx {
    constructor(e = {}) {
        if (!e || "object" != typeof e) throw new TypeError("options must be an object.");
        if (void 0 !== e.large && "boolean" != typeof e.large)
            throw new TypeError("options.large, when provided, must be a boolean.");
        if (void 0 !== e.metadataFormat && !["info", "id3"].includes(e.metadataFormat))
            throw new TypeError("options.metadataFormat, when provided, must be either 'info' or 'id3'.");
        if (void 0 !== e.onHeader && "function" != typeof e.onHeader)
            throw new TypeError("options.onHeader, when provided, must be a function.");
        super(), (this._options = e);
    }
    _createMuxer(e) {
        return new gx(e, this);
    }
    get _name() {
        return "WAVE";
    }
    getSupportedTrackCounts() {
        return {
            video: { min: 0, max: 0 },
            audio: { min: 1, max: 1 },
            subtitle: { min: 0, max: 0 },
            total: { min: 1, max: 1 },
        };
    }
    get fileExtension() {
        return ".wav";
    }
    get mimeType() {
        return "audio/wav";
    }
    getSupportedCodecs() {
        return [
            ...KT.filter((e) => ["pcm-s16", "pcm-s24", "pcm-s32", "pcm-f32", "pcm-u8", "ulaw", "alaw"].includes(e)),
        ];
    }
    get supportsVideoRotationMetadata() {
        return !1;
    }
}
const Sx = (e) => {
        if (!e || "object" != typeof e) throw new TypeError("Encoding config must be an object.");
        if (!GT.includes(e.codec))
            throw new TypeError(`Invalid video codec '${e.codec}'. Must be one of: ${GT.join(", ")}.`);
        if (!(e.bitrate instanceof Px) && (!Number.isInteger(e.bitrate) || e.bitrate <= 0))
            throw new TypeError("config.bitrate must be a positive integer or a quality.");
        if (void 0 !== e.keyFrameInterval && (!Number.isFinite(e.keyFrameInterval) || e.keyFrameInterval < 0))
            throw new TypeError("config.keyFrameInterval, when provided, must be a non-negative number.");
        if (
            void 0 !== e.sizeChangeBehavior &&
            !["deny", "passThrough", "fill", "contain", "cover"].includes(e.sizeChangeBehavior)
        )
            throw new TypeError(
                "config.sizeChangeBehavior, when provided, must be 'deny', 'passThrough', 'fill', 'contain' or 'cover'."
            );
        if (void 0 !== e.onEncodedPacket && "function" != typeof e.onEncodedPacket)
            throw new TypeError("config.onEncodedChunk, when provided, must be a function.");
        if (void 0 !== e.onEncoderConfig && "function" != typeof e.onEncoderConfig)
            throw new TypeError("config.onEncoderConfig, when provided, must be a function.");
        Ex(e.codec, e);
    },
    Ex = (e, t) => {
        if (!t || "object" != typeof t) throw new TypeError("Encoding options must be an object.");
        if (void 0 !== t.alpha && !["discard", "keep"].includes(t.alpha))
            throw new TypeError("options.alpha, when provided, must be 'discard' or 'keep'.");
        if (void 0 !== t.bitrateMode && !["constant", "variable"].includes(t.bitrateMode))
            throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");
        if (void 0 !== t.latencyMode && !["quality", "realtime"].includes(t.latencyMode))
            throw new TypeError("latencyMode, when provided, must be 'quality' or 'realtime'.");
        if (void 0 !== t.fullCodecString && "string" != typeof t.fullCodecString)
            throw new TypeError("fullCodecString, when provided, must be a string.");
        if (void 0 !== t.fullCodecString && b_(t.fullCodecString) !== e)
            throw new TypeError(
                `fullCodecString, when provided, must be a string that matches the specified codec (${e}).`
            );
        if (
            void 0 !== t.hardwareAcceleration &&
            !["no-preference", "prefer-hardware", "prefer-software"].includes(t.hardwareAcceleration)
        )
            throw new TypeError(
                "hardwareAcceleration, when provided, must be 'no-preference', 'prefer-hardware' or 'prefer-software'."
            );
        if (void 0 !== t.scalabilityMode && "string" != typeof t.scalabilityMode)
            throw new TypeError("scalabilityMode, when provided, must be a string.");
        if (void 0 !== t.contentHint && "string" != typeof t.contentHint)
            throw new TypeError("contentHint, when provided, must be a string.");
    },
    Cx = (e) => {
        const t = e.bitrate instanceof Px ? e.bitrate._toVideoBitrate(e.codec, e.width, e.height) : e.bitrate;
        return {
            codec: e.fullCodecString ?? s_(e.codec, e.width, e.height, t),
            width: e.width,
            height: e.height,
            bitrate: t,
            bitrateMode: e.bitrateMode,
            alpha: e.alpha ?? "discard",
            framerate: e.framerate,
            latencyMode: e.latencyMode,
            hardwareAcceleration: e.hardwareAcceleration,
            scalabilityMode: e.scalabilityMode,
            contentHint: e.contentHint,
            ...((n = e.codec),
            "avc" === n ? { avc: { format: "avc" } } : "hevc" === n ? { hevc: { format: "hevc" } } : {}),
        };
        var n;
    },
    Ix = (e) => {
        if (!e || "object" != typeof e) throw new TypeError("Encoding config must be an object.");
        if (!QT.includes(e.codec))
            throw new TypeError(`Invalid audio codec '${e.codec}'. Must be one of: ${QT.join(", ")}.`);
        if (void 0 === e.bitrate && (!KT.includes(e.codec) || "flac" === e.codec))
            throw new TypeError("config.bitrate must be provided for compressed audio codecs.");
        if (void 0 !== e.bitrate && !(e.bitrate instanceof Px) && (!Number.isInteger(e.bitrate) || e.bitrate <= 0))
            throw new TypeError("config.bitrate, when provided, must be a positive integer or a quality.");
        if (void 0 !== e.onEncodedPacket && "function" != typeof e.onEncodedPacket)
            throw new TypeError("config.onEncodedChunk, when provided, must be a function.");
        if (void 0 !== e.onEncoderConfig && "function" != typeof e.onEncoderConfig)
            throw new TypeError("config.onEncoderConfig, when provided, must be a function.");
        xx(e.codec, e);
    },
    xx = (e, t) => {
        if (!t || "object" != typeof t) throw new TypeError("Encoding options must be an object.");
        if (void 0 !== t.bitrateMode && !["constant", "variable"].includes(t.bitrateMode))
            throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");
        if (void 0 !== t.fullCodecString && "string" != typeof t.fullCodecString)
            throw new TypeError("fullCodecString, when provided, must be a string.");
        if (void 0 !== t.fullCodecString && b_(t.fullCodecString) !== e)
            throw new TypeError(
                `fullCodecString, when provided, must be a string that matches the specified codec (${e}).`
            );
    },
    Ax = (e) => {
        const t = e.bitrate instanceof Px ? e.bitrate._toAudioBitrate(e.codec) : e.bitrate;
        return {
            codec: e.fullCodecString ?? l_(e.codec, e.numberOfChannels, e.sampleRate),
            numberOfChannels: e.numberOfChannels,
            sampleRate: e.sampleRate,
            bitrate: t,
            bitrateMode: e.bitrateMode,
            ...((n = e.codec),
            "aac" === n ? { aac: { format: "aac" } } : "opus" === n ? { opus: { format: "opus" } } : {}),
        };
        var n;
    };
class Px {
    constructor(e) {
        this._factor = e;
    }
    _toVideoBitrate(e, t, n) {
        const r = t * n,
            i =
                3e6 *
                Math.pow(r / 2073600, 0.95) *
                { avc: 1, hevc: 0.6, vp9: 0.6, av1: 0.4, vp8: 1.2 }[e] *
                this._factor;
        return 1e3 * Math.ceil(i / 1e3);
    }
    _toAudioBitrate(e) {
        if (KT.includes(e) || "flac" === e) return;
        const t = { aac: 128e3, opus: 64e3, mp3: 16e4, vorbis: 64e3 }[e];
        if (!t) throw new Error(`Unhandled codec: ${e}`);
        let n = t * this._factor;
        if ("aac" === e) {
            n = [96e3, 128e3, 16e4, 192e3].reduce((e, t) => (Math.abs(t - n) < Math.abs(e - n) ? t : e));
        } else if ("opus" === e || "vorbis" === e) n = Math.max(6e3, n);
        else if ("mp3" === e) {
            n = [
                8e3, 16e3, 24e3, 32e3, 4e4, 48e3, 64e3, 8e4, 96e3, 112e3, 128e3, 16e4, 192e3, 224e3, 256e3, 32e4,
            ].reduce((e, t) => (Math.abs(t - n) < Math.abs(e - n) ? t : e));
        }
        return 1e3 * Math.round(n / 1e3);
    }
}
const Ox = new Px(0.6),
    Nx = new Px(1),
    Rx = new Px(2),
    Mx = new Px(4),
    Dx = async (e, t = {}) => {
        const { width: n = 1280, height: r = 720, bitrate: i = 1e6, ...s } = t;
        if (!GT.includes(e)) return !1;
        if (!Number.isInteger(n) || n <= 0) throw new TypeError("width must be a positive integer.");
        if (!Number.isInteger(r) || r <= 0) throw new TypeError("height must be a positive integer.");
        if (!(i instanceof Px) && (!Number.isInteger(i) || i <= 0))
            throw new TypeError("bitrate must be a positive integer or a quality.");
        Ex(e, s);
        let a = null;
        if (
            av.length > 0 &&
            ((a ??= Cx({ codec: e, width: n, height: r, bitrate: i, framerate: void 0, ...s })),
            av.some((t) => t.supports(e, a)))
        )
            return !0;
        if ("undefined" == typeof VideoEncoder) return !1;
        if ((n % 2 == 1 || r % 2 == 1) && ("avc" === e || "hevc" === e)) return !1;
        a ??= Cx({ codec: e, width: n, height: r, bitrate: i, framerate: void 0, ...s, alpha: "discard" });
        return !0 === (await VideoEncoder.isConfigSupported(a)).supported;
    },
    Fx = async (e = QT, t) => {
        const n = await Promise.all(
            e.map((e) =>
                (async (e, t = {}) => {
                    const { numberOfChannels: n = 2, sampleRate: r = 48e3, bitrate: i = 128e3, ...s } = t;
                    if (!QT.includes(e)) return !1;
                    if (!Number.isInteger(n) || n <= 0)
                        throw new TypeError("numberOfChannels must be a positive integer.");
                    if (!Number.isInteger(r) || r <= 0) throw new TypeError("sampleRate must be a positive integer.");
                    if (!(i instanceof Px) && (!Number.isInteger(i) || i <= 0))
                        throw new TypeError("bitrate must be a positive integer.");
                    xx(e, s);
                    let a = null;
                    return (
                        !!(
                            ov.length > 0 &&
                            ((a ??= Ax({ codec: e, numberOfChannels: n, sampleRate: r, bitrate: i, ...s })),
                            ov.some((t) => t.supports(e, a)))
                        ) ||
                        !!KT.includes(e) ||
                        ("undefined" != typeof AudioEncoder &&
                            ((a ??= Ax({ codec: e, numberOfChannels: n, sampleRate: r, bitrate: i, ...s })),
                            !0 === (await AudioEncoder.isConfigSupported(a)).supported))
                    );
                })(e, t)
            )
        );
        return e.filter((e, t) => n[t]);
    };
class Lx {
    constructor() {
        (this._connectedTrack = null), (this._closingPromise = null), (this._closed = !1), (this._timestampOffset = 0);
    }
    _ensureValidAdd() {
        if (!this._connectedTrack) throw new Error("Source is not connected to an output track.");
        if ("canceled" === this._connectedTrack.output.state) throw new Error("Output has been canceled.");
        if ("finalizing" === this._connectedTrack.output.state || "finalized" === this._connectedTrack.output.state)
            throw new Error("Output has been finalized.");
        if ("pending" === this._connectedTrack.output.state) throw new Error("Output has not started.");
        if (this._closed) throw new Error("Source is closed.");
    }
    async _start() {}
    async _flushAndClose(e) {}
    close() {
        if (this._closingPromise) return;
        const e = this._connectedTrack;
        if (!e) throw new Error("Cannot call close without connecting the source to an output track.");
        if ("pending" === e.output.state) throw new Error("Cannot call close before output has been started.");
        this._closingPromise = (async () => {
            await this._flushAndClose(!1),
                (this._closed = !0),
                "finalizing" !== e.output.state && "finalized" !== e.output.state && e.output._muxer.onTrackClose(e);
        })();
    }
    async _flushOrWaitForOngoingClose(e) {
        return this._closingPromise ? this._closingPromise : this._flushAndClose(e);
    }
}
class Bx extends Lx {
    constructor(e) {
        if ((super(), (this._connectedTrack = null), !GT.includes(e)))
            throw new TypeError(`Invalid video codec '${e}'. Must be one of: ${GT.join(", ")}.`);
        this._codec = e;
    }
}
class zx extends Bx {
    constructor(e) {
        super(e);
    }
    add(e, t) {
        if (!(e instanceof lv)) throw new TypeError("packet must be an EncodedPacket.");
        if (e.isMetadataOnly) throw new TypeError("Metadata-only packets cannot be added.");
        if (void 0 !== t && (!t || "object" != typeof t))
            throw new TypeError("meta, when provided, must be an object.");
        return (
            this._ensureValidAdd(), this._connectedTrack.output._muxer.addEncodedVideoPacket(this._connectedTrack, e, t)
        );
    }
}
class Ux {
    constructor(e, t) {
        (this.source = e),
            (this.encodingConfig = t),
            (this.ensureEncoderPromise = null),
            (this.encoderInitialized = !1),
            (this.encoder = null),
            (this.muxer = null),
            (this.lastMultipleOfKeyFrameInterval = -1),
            (this.codedWidth = null),
            (this.codedHeight = null),
            (this.resizeCanvas = null),
            (this.customEncoder = null),
            (this.customEncoderCallSerializer = new NT()),
            (this.customEncoderQueueSize = 0),
            (this.alphaEncoder = null),
            (this.splitter = null),
            (this.splitterCreationFailed = !1),
            (this.alphaFrameQueue = []),
            (this.error = null),
            (this.errorNeedsNewStack = !0);
    }
    async add(e, t, n) {
        try {
            if (
                (this.checkForEncoderError(),
                this.source._ensureValidAdd(),
                null !== this.codedWidth && null !== this.codedHeight)
            ) {
                if (e.codedWidth !== this.codedWidth || e.codedHeight !== this.codedHeight) {
                    const n = this.encodingConfig.sizeChangeBehavior ?? "deny";
                    if ("passThrough" === n);
                    else {
                        if ("deny" === n)
                            throw new Error(
                                `Video sample size must remain constant. Expected ${this.codedWidth}x${this.codedHeight}, got ${e.codedWidth}x${e.codedHeight}. To allow the sample size to change over time, set \`sizeChangeBehavior\` to a value other than 'strict' in the encoding options.`
                            );
                        {
                            let r = !1;
                            this.resizeCanvas ||
                                ("undefined" != typeof document
                                    ? ((this.resizeCanvas = document.createElement("canvas")),
                                      (this.resizeCanvas.width = this.codedWidth),
                                      (this.resizeCanvas.height = this.codedHeight))
                                    : (this.resizeCanvas = new OffscreenCanvas(this.codedWidth, this.codedHeight)),
                                (r = !0));
                            const i = this.resizeCanvas.getContext("2d", { alpha: FT() });
                            Vk(i),
                                r ||
                                    (FT()
                                        ? ((i.fillStyle = "black"), i.fillRect(0, 0, this.codedWidth, this.codedHeight))
                                        : i.clearRect(0, 0, this.codedWidth, this.codedHeight)),
                                e.drawWithFit(i, { fit: n }),
                                t && e.close(),
                                (e = new uv(this.resizeCanvas, {
                                    timestamp: e.timestamp,
                                    duration: e.duration,
                                    rotation: e.rotation,
                                })),
                                (t = !0);
                        }
                    }
                }
            } else (this.codedWidth = e.codedWidth), (this.codedHeight = e.codedHeight);
            this.encoderInitialized ||
                (this.ensureEncoderPromise || this.ensureEncoder(e),
                this.encoderInitialized || (await this.ensureEncoderPromise)),
                Vk(this.encoderInitialized);
            const i = this.encodingConfig.keyFrameInterval ?? 5,
                s = Math.floor(e.timestamp / i),
                a = { ...n, keyFrame: n?.keyFrame || 0 === i || s !== this.lastMultipleOfKeyFrameInterval };
            if (((this.lastMultipleOfKeyFrameInterval = s), this.customEncoder)) {
                this.customEncoderQueueSize++;
                const t = e.clone(),
                    n = this.customEncoderCallSerializer
                        .call(() => this.customEncoder.encode(t, a))
                        .then(() => this.customEncoderQueueSize--)
                        .catch((e) => (this.error ??= e))
                        .finally(() => {
                            t.close();
                        });
                this.customEncoderQueueSize >= 4 && (await n);
            } else {
                Vk(this.encoder);
                const n = e.toVideoFrame();
                if (this.alphaEncoder) {
                    if ((!!n.format && !n.format.includes("A")) || this.splitterCreationFailed)
                        this.alphaFrameQueue.push(null), this.encoder.encode(n, a), n.close();
                    else {
                        const e = n.displayWidth,
                            t = n.displayHeight;
                        if (!this.splitter)
                            try {
                                this.splitter = new $x(e, t);
                            } catch (r) {
                                (this.splitterCreationFailed = !0),
                                    this.alphaFrameQueue.push(null),
                                    this.encoder.encode(n, a),
                                    n.close();
                            }
                        if (this.splitter) {
                            const e = this.splitter.extractColor(n),
                                t = this.splitter.extractAlpha(n);
                            this.alphaFrameQueue.push(t), this.encoder.encode(e, a), e.close(), n.close();
                        }
                    }
                } else this.encoder.encode(n, a), n.close();
                t && e.close(),
                    this.encoder.encodeQueueSize >= 4 &&
                        (await new Promise((e) => this.encoder.addEventListener("dequeue", e, { once: !0 })));
            }
            await this.muxer.mutex.currentPromise;
        } finally {
            t && e.close();
        }
    }
    ensureEncoder(e) {
        const t = new Error();
        this.ensureEncoderPromise = (async () => {
            const n = Cx({
                width: e.codedWidth,
                height: e.codedHeight,
                ...this.encodingConfig,
                framerate: this.source._connectedTrack?.metadata.frameRate,
            });
            this.encodingConfig.onEncoderConfig?.(n);
            const r = av.find((e) => e.supports(this.encodingConfig.codec, n));
            if (r)
                (this.customEncoder = new r()),
                    (this.customEncoder.codec = this.encodingConfig.codec),
                    (this.customEncoder.config = n),
                    (this.customEncoder.onPacket = (e, t) => {
                        if (!(e instanceof lv))
                            throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");
                        if (void 0 !== t && (!t || "object" != typeof t))
                            throw new TypeError(
                                "The second argument passed to onPacket must be an object or undefined."
                            );
                        this.encodingConfig.onEncodedPacket?.(e, t),
                            this.muxer.addEncodedVideoPacket(this.source._connectedTrack, e, t).catch((e) => {
                                (this.error ??= e), (this.errorNeedsNewStack = !1);
                            });
                    }),
                    await this.customEncoder.init();
            else {
                if ("undefined" == typeof VideoEncoder)
                    throw new Error("VideoEncoder is not supported by this browser.");
                (n.alpha = "discard"), "keep" === this.encodingConfig.alpha && (n.latencyMode = "quality");
                if (
                    (n.width % 2 == 1 || n.height % 2 == 1) &&
                    ("avc" === this.encodingConfig.codec || "hevc" === this.encodingConfig.codec)
                )
                    throw new Error(
                        `The dimensions ${n.width}x${n.height} are not supported for codec '${this.encodingConfig.codec}'; both width and height must be even numbers. Make sure to round your dimensions to the nearest even number.`
                    );
                if (!(await VideoEncoder.isConfigSupported(n)).supported)
                    throw new Error(
                        `This specific encoder configuration (${n.codec}, ${n.bitrate} bps, ${n.width}x${n.height}, hardware acceleration: ${n.hardwareAcceleration ?? "no-preference"}) is not supported by this browser. Consider using another codec or changing your video parameters.`
                    );
                const e = [],
                    r = [];
                let i = 0,
                    s = 0;
                const a = (e, t, n) => {
                    const r = {};
                    if (t) {
                        const e = new Uint8Array(t.byteLength);
                        t.copyTo(e), (r.alpha = e);
                    }
                    const i = lv.fromEncodedChunk(e, r);
                    this.encodingConfig.onEncodedPacket?.(i, n),
                        this.muxer.addEncodedVideoPacket(this.source._connectedTrack, i, n).catch((e) => {
                            (this.error ??= e), (this.errorNeedsNewStack = !1);
                        });
                };
                (this.encoder = new VideoEncoder({
                    output: (t, n) => {
                        if (!this.alphaEncoder) return void a(t, null, n);
                        const o = this.alphaFrameQueue.shift();
                        Vk(void 0 !== o),
                            o
                                ? (this.alphaEncoder.encode(o, { keyFrame: "key" === t.type }),
                                  s++,
                                  o.close(),
                                  e.push({ chunk: t, meta: n }))
                                : 0 === s
                                  ? a(t, null, n)
                                  : (r.push(i + s), e.push({ chunk: t, meta: n }));
                    },
                    error: (e) => {
                        (e.stack = t.stack), (this.error ??= e);
                    },
                })),
                    this.encoder.configure(n),
                    "keep" === this.encodingConfig.alpha &&
                        ((this.alphaEncoder = new VideoEncoder({
                            output: (t, n) => {
                                s--;
                                const o = e.shift();
                                for (Vk(void 0 !== o), a(o.chunk, t, o.meta), i++; r.length > 0 && r[0] === i; ) {
                                    r.shift();
                                    const t = e.shift();
                                    Vk(void 0 !== t), a(t.chunk, null, t.meta);
                                }
                            },
                            error: (e) => {
                                (e.stack = t.stack), (this.error ??= e);
                            },
                        })),
                        this.alphaEncoder.configure(n));
            }
            Vk(this.source._connectedTrack),
                (this.muxer = this.source._connectedTrack.output._muxer),
                (this.encoderInitialized = !0);
        })();
    }
    async flushAndClose(e) {
        e || this.checkForEncoderError(),
            this.customEncoder
                ? (e || this.customEncoderCallSerializer.call(() => this.customEncoder.flush()),
                  await this.customEncoderCallSerializer.call(() => this.customEncoder.close()))
                : this.encoder &&
                  (e || (await this.encoder.flush(), await this.alphaEncoder?.flush()),
                  "closed" !== this.encoder.state && this.encoder.close(),
                  this.alphaEncoder && "closed" !== this.alphaEncoder.state && this.alphaEncoder.close(),
                  this.alphaFrameQueue.forEach((e) => e?.close()),
                  this.splitter?.close()),
            e || this.checkForEncoderError();
    }
    getQueueSize() {
        return this.customEncoder ? this.customEncoderQueueSize : (this.encoder?.encodeQueueSize ?? 0);
    }
    checkForEncoderError() {
        if (this.error) throw (this.errorNeedsNewStack && (this.error.stack = new Error().stack), this.error);
    }
}
class $x {
    constructor(e, t) {
        (this.lastFrame = null),
            "undefined" != typeof OffscreenCanvas
                ? (this.canvas = new OffscreenCanvas(e, t))
                : ((this.canvas = document.createElement("canvas")), (this.canvas.width = e), (this.canvas.height = t));
        const n = this.canvas.getContext("webgl2", { alpha: !0 });
        if (!n) throw new Error("Couldn't acquire WebGL 2 context.");
        (this.gl = n),
            (this.colorProgram = this.createColorProgram()),
            (this.alphaProgram = this.createAlphaProgram()),
            (this.vao = this.createVAO()),
            (this.sourceTexture = this.createTexture()),
            (this.alphaResolutionLocation = this.gl.getUniformLocation(this.alphaProgram, "u_resolution")),
            this.gl.useProgram(this.colorProgram),
            this.gl.uniform1i(this.gl.getUniformLocation(this.colorProgram, "u_sourceTexture"), 0),
            this.gl.useProgram(this.alphaProgram),
            this.gl.uniform1i(this.gl.getUniformLocation(this.alphaProgram, "u_sourceTexture"), 0);
    }
    createVertexShader() {
        return this.createShader(
            this.gl.VERTEX_SHADER,
            "#version 300 es\n\t\t\tin vec2 a_position;\n\t\t\tin vec2 a_texCoord;\n\t\t\tout vec2 v_texCoord;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tgl_Position = vec4(a_position, 0.0, 1.0);\n\t\t\t\tv_texCoord = a_texCoord;\n\t\t\t}\n\t\t"
        );
    }
    createColorProgram() {
        const e = this.createVertexShader(),
            t = this.createShader(
                this.gl.FRAGMENT_SHADER,
                "#version 300 es\n\t\t\tprecision highp float;\n\t\t\t\n\t\t\tuniform sampler2D u_sourceTexture;\n\t\t\tin vec2 v_texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tvec4 source = texture(u_sourceTexture, v_texCoord);\n\t\t\t\tfragColor = vec4(source.rgb, 1.0);\n\t\t\t}\n\t\t"
            ),
            n = this.gl.createProgram();
        return this.gl.attachShader(n, e), this.gl.attachShader(n, t), this.gl.linkProgram(n), n;
    }
    createAlphaProgram() {
        const e = this.createVertexShader(),
            t = this.createShader(
                this.gl.FRAGMENT_SHADER,
                "#version 300 es\n\t\t\tprecision highp float;\n\t\t\t\n\t\t\tuniform sampler2D u_sourceTexture;\n\t\t\tuniform vec2 u_resolution; // The width and height of the canvas\n\t\t\tin vec2 v_texCoord;\n\t\t\tout vec4 fragColor;\n\n\t\t\t// This function determines the value for a single byte in the YUV stream\n\t\t\tfloat getByteValue(float byteOffset) {\n\t\t\t\tfloat width = u_resolution.x;\n\t\t\t\tfloat height = u_resolution.y;\n\n\t\t\t\tfloat yPlaneSize = width * height;\n\n\t\t\t\tif (byteOffset < yPlaneSize) {\n\t\t\t\t\t// This byte is in the luma plane. Find the corresponding pixel coordinates to sample from\n\t\t\t\t\tfloat y = floor(byteOffset / width);\n\t\t\t\t\tfloat x = mod(byteOffset, width);\n\t\t\t\t\t\n\t\t\t\t\t// Add 0.5 to sample the center of the texel\n\t\t\t\t\tvec2 sampleCoord = (vec2(x, y) + 0.5) / u_resolution;\n\t\t\t\t\t\n\t\t\t\t\t// The luma value is the alpha from the source texture\n\t\t\t\t\treturn texture(u_sourceTexture, sampleCoord).a;\n\t\t\t\t} else {\n\t\t\t\t\t// Write a fixed value for chroma and beyond\n\t\t\t\t\treturn 128.0 / 255.0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\t// Each fragment writes 4 bytes (R, G, B, A)\n\t\t\t\tfloat pixelIndex = floor(gl_FragCoord.y) * u_resolution.x + floor(gl_FragCoord.x);\n\t\t\t\tfloat baseByteOffset = pixelIndex * 4.0;\n\n\t\t\t\tvec4 result;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tfloat currentByteOffset = baseByteOffset + float(i);\n\t\t\t\t\tresult[i] = getByteValue(currentByteOffset);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfragColor = result;\n\t\t\t}\n\t\t"
            ),
            n = this.gl.createProgram();
        return this.gl.attachShader(n, e), this.gl.attachShader(n, t), this.gl.linkProgram(n), n;
    }
    createShader(e, t) {
        const n = this.gl.createShader(e);
        return (
            this.gl.shaderSource(n, t),
            this.gl.compileShader(n),
            this.gl.getShaderParameter(n, this.gl.COMPILE_STATUS),
            n
        );
    }
    createVAO() {
        const e = this.gl.createVertexArray();
        this.gl.bindVertexArray(e);
        const t = new Float32Array([-1, -1, 0, 1, 1, -1, 1, 1, -1, 1, 0, 0, 1, 1, 1, 0]),
            n = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, n), this.gl.bufferData(this.gl.ARRAY_BUFFER, t, this.gl.STATIC_DRAW);
        const r = this.gl.getAttribLocation(this.colorProgram, "a_position"),
            i = this.gl.getAttribLocation(this.colorProgram, "a_texCoord");
        return (
            this.gl.enableVertexAttribArray(r),
            this.gl.vertexAttribPointer(r, 2, this.gl.FLOAT, !1, 16, 0),
            this.gl.enableVertexAttribArray(i),
            this.gl.vertexAttribPointer(i, 2, this.gl.FLOAT, !1, 16, 8),
            e
        );
    }
    createTexture() {
        const e = this.gl.createTexture();
        return (
            this.gl.bindTexture(this.gl.TEXTURE_2D, e),
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE),
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE),
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR),
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR),
            e
        );
    }
    updateTexture(e) {
        this.lastFrame !== e &&
            ((e.displayWidth === this.canvas.width && e.displayHeight === this.canvas.height) ||
                ((this.canvas.width = e.displayWidth), (this.canvas.height = e.displayHeight)),
            this.gl.activeTexture(this.gl.TEXTURE0),
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.sourceTexture),
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, e),
            (this.lastFrame = e));
    }
    extractColor(e) {
        return (
            this.updateTexture(e),
            this.gl.useProgram(this.colorProgram),
            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height),
            this.gl.clear(this.gl.COLOR_BUFFER_BIT),
            this.gl.bindVertexArray(this.vao),
            this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4),
            new VideoFrame(this.canvas, { timestamp: e.timestamp, duration: e.duration ?? void 0, alpha: "discard" })
        );
    }
    extractAlpha(e) {
        this.updateTexture(e),
            this.gl.useProgram(this.alphaProgram),
            this.gl.uniform2f(this.alphaResolutionLocation, this.canvas.width, this.canvas.height),
            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height),
            this.gl.clear(this.gl.COLOR_BUFFER_BIT),
            this.gl.bindVertexArray(this.vao),
            this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
        const { width: t, height: n } = this.canvas,
            r = t * n + 2 * (Math.ceil(t / 2) * Math.ceil(n / 2)),
            i = Math.ceil(r / (4 * t));
        let s = new Uint8Array(4 * t * i);
        this.gl.readPixels(0, 0, t, i, this.gl.RGBA, this.gl.UNSIGNED_BYTE, s),
            (s = s.subarray(0, r)),
            Vk(128 === s[t * n]),
            Vk(128 === s[s.length - 1]);
        const a = {
            format: "I420",
            codedWidth: t,
            codedHeight: n,
            timestamp: e.timestamp,
            duration: e.duration ?? void 0,
            transfer: [s.buffer],
        };
        return new VideoFrame(s, a);
    }
    close() {
        this.gl.getExtension("WEBGL_lose_context")?.loseContext(), (this.gl = null);
    }
}
class Vx extends Bx {
    constructor(e) {
        Sx(e), super(e.codec), (this._encoder = new Ux(this, e));
    }
    add(e, t) {
        if (!(e instanceof uv)) throw new TypeError("videoSample must be a VideoSample.");
        return this._encoder.add(e, !1, t);
    }
    _flushAndClose(e) {
        return this._encoder.flushAndClose(e);
    }
}
class Wx extends Bx {
    constructor(e, t) {
        if (
            !(
                ("undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement) ||
                ("undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas)
            )
        )
            throw new TypeError("canvas must be an HTMLCanvasElement or OffscreenCanvas.");
        Sx(t), super(t.codec), (this._encoder = new Ux(this, t)), (this._canvas = e);
    }
    add(e, t = 0, n) {
        if (!Number.isFinite(e) || e < 0) throw new TypeError("timestamp must be a non-negative number.");
        if (!Number.isFinite(t) || t < 0) throw new TypeError("duration must be a non-negative number.");
        const r = new uv(this._canvas, { timestamp: e, duration: t });
        return this._encoder.add(r, !0, n);
    }
    _flushAndClose(e) {
        return this._encoder.flushAndClose(e);
    }
}
class jx extends Lx {
    constructor(e) {
        if ((super(), (this._connectedTrack = null), !QT.includes(e)))
            throw new TypeError(`Invalid audio codec '${e}'. Must be one of: ${QT.join(", ")}.`);
        this._codec = e;
    }
}
class Hx extends jx {
    constructor(e) {
        super(e);
    }
    add(e, t) {
        if (!(e instanceof lv)) throw new TypeError("packet must be an EncodedPacket.");
        if (e.isMetadataOnly) throw new TypeError("Metadata-only packets cannot be added.");
        if (void 0 !== t && (!t || "object" != typeof t))
            throw new TypeError("meta, when provided, must be an object.");
        return (
            this._ensureValidAdd(), this._connectedTrack.output._muxer.addEncodedAudioPacket(this._connectedTrack, e, t)
        );
    }
}
class qx {
    constructor(e, t) {
        (this.source = e),
            (this.encodingConfig = t),
            (this.ensureEncoderPromise = null),
            (this.encoderInitialized = !1),
            (this.encoder = null),
            (this.muxer = null),
            (this.lastNumberOfChannels = null),
            (this.lastSampleRate = null),
            (this.isPcmEncoder = !1),
            (this.outputSampleSize = null),
            (this.writeOutputValue = null),
            (this.customEncoder = null),
            (this.customEncoderCallSerializer = new NT()),
            (this.customEncoderQueueSize = 0),
            (this.error = null),
            (this.errorNeedsNewStack = !0);
    }
    async add(e, t) {
        try {
            if (
                (this.checkForEncoderError(),
                this.source._ensureValidAdd(),
                null !== this.lastNumberOfChannels && null !== this.lastSampleRate)
            ) {
                if (e.numberOfChannels !== this.lastNumberOfChannels || e.sampleRate !== this.lastSampleRate)
                    throw new Error(
                        `Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at ${this.lastSampleRate} Hz, got ${e.numberOfChannels} channels at ${e.sampleRate} Hz.`
                    );
            } else (this.lastNumberOfChannels = e.numberOfChannels), (this.lastSampleRate = e.sampleRate);
            if (
                (this.encoderInitialized ||
                    (this.ensureEncoderPromise || this.ensureEncoder(e),
                    this.encoderInitialized || (await this.ensureEncoderPromise)),
                Vk(this.encoderInitialized),
                this.customEncoder)
            ) {
                this.customEncoderQueueSize++;
                const t = e.clone(),
                    n = this.customEncoderCallSerializer
                        .call(() => this.customEncoder.encode(t))
                        .then(() => this.customEncoderQueueSize--)
                        .catch((e) => (this.error ??= e))
                        .finally(() => {
                            t.close();
                        });
                this.customEncoderQueueSize >= 4 && (await n), await this.muxer.mutex.currentPromise;
            } else if (this.isPcmEncoder) await this.doPcmEncoding(e, t);
            else {
                Vk(this.encoder);
                const n = e.toAudioData();
                this.encoder.encode(n),
                    n.close(),
                    t && e.close(),
                    this.encoder.encodeQueueSize >= 4 &&
                        (await new Promise((e) => this.encoder.addEventListener("dequeue", e, { once: !0 }))),
                    await this.muxer.mutex.currentPromise;
            }
        } finally {
            t && e.close();
        }
    }
    async doPcmEncoding(e, t) {
        Vk(this.outputSampleSize), Vk(this.writeOutputValue);
        const { numberOfChannels: n, numberOfFrames: r, sampleRate: i, timestamp: s } = e,
            a = 2048,
            o = [];
        for (let d = 0; d < r; d += a) {
            const t = Math.min(a, e.numberOfFrames - d),
                r = t * n * this.outputSampleSize,
                i = new ArrayBuffer(r),
                s = new DataView(i);
            o.push({ frameCount: t, view: s });
        }
        const c = e.allocationSize({ planeIndex: 0, format: "f32-planar" }),
            l = new Float32Array(c / Float32Array.BYTES_PER_ELEMENT);
        for (let d = 0; d < n; d++) {
            e.copyTo(l, { planeIndex: d, format: "f32-planar" });
            for (let e = 0; e < o.length; e++) {
                const { frameCount: t, view: r } = o[e];
                for (let i = 0; i < t; i++) this.writeOutputValue(r, (i * n + d) * this.outputSampleSize, l[e * a + i]);
            }
        }
        t && e.close();
        const u = { decoderConfig: { codec: this.encodingConfig.codec, numberOfChannels: n, sampleRate: i } };
        for (let d = 0; d < o.length; d++) {
            const { frameCount: e, view: t } = o[d],
                n = t.buffer,
                r = d * a,
                c = new lv(new Uint8Array(n), "key", s + r / i, e / i);
            this.encodingConfig.onEncodedPacket?.(c, u),
                await this.muxer.addEncodedAudioPacket(this.source._connectedTrack, c, u);
        }
    }
    ensureEncoder(e) {
        const t = new Error();
        this.ensureEncoderPromise = (async () => {
            const { numberOfChannels: n, sampleRate: r } = e,
                i = Ax({ numberOfChannels: n, sampleRate: r, ...this.encodingConfig });
            this.encodingConfig.onEncoderConfig?.(i);
            const s = ov.find((e) => e.supports(this.encodingConfig.codec, i));
            if (s)
                (this.customEncoder = new s()),
                    (this.customEncoder.codec = this.encodingConfig.codec),
                    (this.customEncoder.config = i),
                    (this.customEncoder.onPacket = (e, t) => {
                        if (!(e instanceof lv))
                            throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");
                        if (void 0 !== t && (!t || "object" != typeof t))
                            throw new TypeError(
                                "The second argument passed to onPacket must be an object or undefined."
                            );
                        this.encodingConfig.onEncodedPacket?.(e, t),
                            this.muxer.addEncodedAudioPacket(this.source._connectedTrack, e, t).catch((e) => {
                                (this.error ??= e), (this.errorNeedsNewStack = !1);
                            });
                    }),
                    await this.customEncoder.init();
            else if (KT.includes(this.encodingConfig.codec)) this.initPcmEncoder();
            else {
                if ("undefined" == typeof AudioEncoder)
                    throw new Error("AudioEncoder is not supported by this browser.");
                if (!(await AudioEncoder.isConfigSupported(i)).supported)
                    throw new Error(
                        `This specific encoder configuration (${i.codec}, ${i.bitrate} bps, ${i.numberOfChannels} channels, ${i.sampleRate} Hz) is not supported by this browser. Consider using another codec or changing your audio parameters.`
                    );
                (this.encoder = new AudioEncoder({
                    output: (e, t) => {
                        const n = lv.fromEncodedChunk(e);
                        this.encodingConfig.onEncodedPacket?.(n, t),
                            this.muxer.addEncodedAudioPacket(this.source._connectedTrack, n, t).catch((e) => {
                                (this.error ??= e), (this.errorNeedsNewStack = !1);
                            });
                    },
                    error: (e) => {
                        (e.stack = t.stack), (this.error ??= e);
                    },
                })),
                    this.encoder.configure(i);
            }
            Vk(this.source._connectedTrack),
                (this.muxer = this.source._connectedTrack.output._muxer),
                (this.encoderInitialized = !0);
        })();
    }
    initPcmEncoder() {
        this.isPcmEncoder = !0;
        const e = this.encodingConfig.codec,
            { dataType: t, sampleSize: n, littleEndian: r } = g_(e);
        switch (((this.outputSampleSize = n), n)) {
            case 1:
                "unsigned" === t
                    ? (this.writeOutputValue = (e, t, n) => e.setUint8(t, _T(127.5 * (n + 1), 0, 255)))
                    : "signed" === t
                      ? (this.writeOutputValue = (e, t, n) => {
                            e.setInt8(t, _T(Math.round(128 * n), -128, 127));
                        })
                      : "ulaw" === t
                        ? (this.writeOutputValue = (e, t, n) => {
                              const r = _T(Math.floor(32767 * n), -32768, 32767);
                              e.setUint8(
                                  t,
                                  ((e) => {
                                      let t = e,
                                          n = 4096,
                                          r = 0,
                                          i = 12,
                                          s = 0;
                                      for (
                                          t < 0 && ((t = -t), (r = 128)), t += 33, t > 8191 && (t = 8191);
                                          (t & n) !== n && i >= 5;

                                      )
                                          (n >>= 1), i--;
                                      return (s = (t >> (i - 4)) & 15), 255 & ~(r | ((i - 5) << 4) | s);
                                  })(r)
                              );
                          })
                        : "alaw" === t
                          ? (this.writeOutputValue = (e, t, n) => {
                                const r = _T(Math.floor(32767 * n), -32768, 32767);
                                e.setUint8(
                                    t,
                                    ((e) => {
                                        let t = 2048,
                                            n = 0,
                                            r = 11,
                                            i = 0,
                                            s = e;
                                        for (
                                            s < 0 && ((s = -s), (n = 128)), s > 4095 && (s = 4095);
                                            (s & t) !== t && r >= 5;

                                        )
                                            (t >>= 1), r--;
                                        return (i = (s >> (4 === r ? 1 : r - 4)) & 15), 85 ^ (n | ((r - 4) << 4) | i);
                                    })(r)
                                );
                            })
                          : Vk(!1);
                break;
            case 2:
                "unsigned" === t
                    ? (this.writeOutputValue = (e, t, n) => e.setUint16(t, _T(32767.5 * (n + 1), 0, 65535), r))
                    : "signed" === t
                      ? (this.writeOutputValue = (e, t, n) =>
                            e.setInt16(t, _T(Math.round(32767 * n), -32768, 32767), r))
                      : Vk(!1);
                break;
            case 3:
                "unsigned" === t
                    ? (this.writeOutputValue = (e, t, n) => kT(e, t, _T(8388607.5 * (n + 1), 0, 16777215), r))
                    : "signed" === t
                      ? (this.writeOutputValue = (e, t, n) =>
                            ((e, t, n, r) => {
                                (n = _T(n, -8388608, 8388607)) < 0 && (n = (n + 16777216) & 16777215), kT(e, t, n, r);
                            })(e, t, _T(Math.round(8388607 * n), -8388608, 8388607), r))
                      : Vk(!1);
                break;
            case 4:
                "unsigned" === t
                    ? (this.writeOutputValue = (e, t, n) =>
                          e.setUint32(t, _T(2147483647.5 * (n + 1), 0, 4294967295), r))
                    : "signed" === t
                      ? (this.writeOutputValue = (e, t, n) =>
                            e.setInt32(t, _T(Math.round(2147483647 * n), -2147483648, 2147483647), r))
                      : "float" === t
                        ? (this.writeOutputValue = (e, t, n) => e.setFloat32(t, n, r))
                        : Vk(!1);
                break;
            case 8:
                "float" === t ? (this.writeOutputValue = (e, t, n) => e.setFloat64(t, n, r)) : Vk(!1);
                break;
            default:
                yT(n), Vk(!1);
        }
    }
    async flushAndClose(e) {
        e || this.checkForEncoderError(),
            this.customEncoder
                ? (e || this.customEncoderCallSerializer.call(() => this.customEncoder.flush()),
                  await this.customEncoderCallSerializer.call(() => this.customEncoder.close()))
                : this.encoder &&
                  (e || (await this.encoder.flush()), "closed" !== this.encoder.state && this.encoder.close()),
            e || this.checkForEncoderError();
    }
    getQueueSize() {
        return this.customEncoder
            ? this.customEncoderQueueSize
            : this.isPcmEncoder
              ? 0
              : (this.encoder?.encodeQueueSize ?? 0);
    }
    checkForEncoderError() {
        if (this.error) throw (this.errorNeedsNewStack && (this.error.stack = new Error().stack), this.error);
    }
}
class Xx extends jx {
    constructor(e) {
        Ix(e), super(e.codec), (this._encoder = new qx(this, e));
    }
    add(e) {
        if (!(e instanceof fv)) throw new TypeError("audioSample must be an AudioSample.");
        return this._encoder.add(e, !1);
    }
    _flushAndClose(e) {
        return this._encoder.flushAndClose(e);
    }
}
class Gx extends jx {
    constructor(e) {
        Ix(e), super(e.codec), (this._accumulatedTime = 0), (this._encoder = new qx(this, e));
    }
    async add(e) {
        if (!(e instanceof AudioBuffer)) throw new TypeError("audioBuffer must be an AudioBuffer.");
        const t = fv._fromAudioBuffer(e, this._accumulatedTime);
        this._accumulatedTime += e.duration;
        for (const n of t) await this._encoder.add(n, !0);
    }
    _flushAndClose(e) {
        return this._encoder.flushAndClose(e);
    }
}
class Kx extends Lx {
    constructor(e) {
        if ((super(), (this._connectedTrack = null), !JT.includes(e)))
            throw new TypeError(`Invalid subtitle codec '${e}'. Must be one of: ${JT.join(", ")}.`);
        this._codec = e;
    }
}
const Yx = ["video", "audio", "subtitle"],
    Qx = (e) => {
        if (!e || "object" != typeof e) throw new TypeError("metadata must be an object.");
        if (void 0 !== e.languageCode && !IT(e.languageCode))
            throw new TypeError(
                "metadata.languageCode, when provided, must be a three-letter, ISO 639-2/T language code."
            );
        if (void 0 !== e.name && "string" != typeof e.name)
            throw new TypeError("metadata.name, when provided, must be a string.");
        if (void 0 !== e.maximumPacketCount && (!Number.isInteger(e.maximumPacketCount) || e.maximumPacketCount < 0))
            throw new TypeError("metadata.maximumPacketCount, when provided, must be a non-negative integer.");
    };
class Jx {
    constructor(e) {
        if (
            ((this.state = "pending"),
            (this._tracks = []),
            (this._startPromise = null),
            (this._cancelPromise = null),
            (this._finalizePromise = null),
            (this._mutex = new lT()),
            (this._metadataTags = {}),
            !e || "object" != typeof e)
        )
            throw new TypeError("options must be an object.");
        if (!(e.format instanceof bx)) throw new TypeError("options.format must be an OutputFormat.");
        if (!(e.target instanceof sx)) throw new TypeError("options.target must be a Target.");
        if (e.target._output) throw new Error("Target is already used for another output.");
        (e.target._output = this),
            (this.format = e.format),
            (this.target = e.target),
            (this._writer = e.target._createWriter()),
            (this._muxer = e.format._createMuxer(this));
    }
    addVideoTrack(e, t = {}) {
        if (!(e instanceof Bx)) throw new TypeError("source must be a VideoSource.");
        if ((Qx(t), void 0 !== t.rotation && ![0, 90, 180, 270].includes(t.rotation)))
            throw new TypeError(`Invalid video rotation: ${t.rotation}. Has to be 0, 90, 180 or 270.`);
        if (!this.format.supportsVideoRotationMetadata && t.rotation)
            throw new Error(`${this.format._name} does not support video rotation metadata.`);
        if (void 0 !== t.frameRate && (!Number.isFinite(t.frameRate) || t.frameRate <= 0))
            throw new TypeError(`Invalid video frame rate: ${t.frameRate}. Must be a positive number.`);
        this._addTrack("video", e, t);
    }
    addAudioTrack(e, t = {}) {
        if (!(e instanceof jx)) throw new TypeError("source must be an AudioSource.");
        Qx(t), this._addTrack("audio", e, t);
    }
    addSubtitleTrack(e, t = {}) {
        if (!(e instanceof Kx)) throw new TypeError("source must be a SubtitleSource.");
        Qx(t), this._addTrack("subtitle", e, t);
    }
    setMetadataTags(e) {
        if ((XT(e), "pending" !== this.state))
            throw new Error("Cannot set metadata tags after output has been started or canceled.");
        this._metadataTags = e;
    }
    _addTrack(e, t, n) {
        if ("pending" !== this.state) throw new Error("Cannot add track after output has been started or canceled.");
        if (t._connectedTrack) throw new Error("Source is already used for a track.");
        const r = this.format.getSupportedTrackCounts(),
            i = this._tracks.reduce((t, n) => t + (n.type === e ? 1 : 0), 0),
            s = r[e].max;
        if (i === s)
            throw new Error(
                0 === s
                    ? `${this.format._name} does not support ${e} tracks.`
                    : `${this.format._name} does not support more than ${s} ${e} track${1 === s ? "" : "s"}.`
            );
        const a = r.total.max;
        if (this._tracks.length === a)
            throw new Error(
                `${this.format._name} does not support more than ${a} tracks${1 === a ? "" : "s"} in total.`
            );
        const o = { id: this._tracks.length + 1, output: this, type: e, source: t, metadata: n };
        if ("video" === o.type) {
            const e = this.format.getSupportedVideoCodecs();
            if (0 === e.length)
                throw new Error(
                    `${this.format._name} does not support video tracks.` +
                        this.format._codecUnsupportedHint(o.source._codec)
                );
            if (!e.includes(o.source._codec))
                throw new Error(
                    `Codec '${o.source._codec}' cannot be contained within ${this.format._name}. Supported video codecs are: ${e.map((e) => `'${e}'`).join(", ")}.` +
                        this.format._codecUnsupportedHint(o.source._codec)
                );
        } else if ("audio" === o.type) {
            const e = this.format.getSupportedAudioCodecs();
            if (0 === e.length)
                throw new Error(
                    `${this.format._name} does not support audio tracks.` +
                        this.format._codecUnsupportedHint(o.source._codec)
                );
            if (!e.includes(o.source._codec))
                throw new Error(
                    `Codec '${o.source._codec}' cannot be contained within ${this.format._name}. Supported audio codecs are: ${e.map((e) => `'${e}'`).join(", ")}.` +
                        this.format._codecUnsupportedHint(o.source._codec)
                );
        } else if ("subtitle" === o.type) {
            const e = this.format.getSupportedSubtitleCodecs();
            if (0 === e.length)
                throw new Error(
                    `${this.format._name} does not support subtitle tracks.` +
                        this.format._codecUnsupportedHint(o.source._codec)
                );
            if (!e.includes(o.source._codec))
                throw new Error(
                    `Codec '${o.source._codec}' cannot be contained within ${this.format._name}. Supported subtitle codecs are: ${e.map((e) => `'${e}'`).join(", ")}.` +
                        this.format._codecUnsupportedHint(o.source._codec)
                );
        }
        this._tracks.push(o), (t._connectedTrack = o);
    }
    async start() {
        const e = this.format.getSupportedTrackCounts();
        for (const n of Yx) {
            const t = this._tracks.reduce((e, t) => e + (t.type === n ? 1 : 0), 0),
                r = e[n].min;
            if (t < r)
                throw new Error(
                    r === e[n].max
                        ? `${this.format._name} requires exactly ${r} ${n} track${1 === r ? "" : "s"}.`
                        : `${this.format._name} requires at least ${r} ${n} track${1 === r ? "" : "s"}.`
                );
        }
        const t = e.total.min;
        if (this._tracks.length < t)
            throw new Error(
                t === e.total.max
                    ? `${this.format._name} requires exactly ${t} track${1 === t ? "" : "s"}.`
                    : `${this.format._name} requires at least ${t} track${1 === t ? "" : "s"}.`
            );
        if ("canceled" === this.state) throw new Error("Output has been canceled.");
        return this._startPromise
            ? this._startPromise
            : (this._startPromise = (async () => {
                  (this.state = "started"), this._writer.start();
                  const e = await this._mutex.acquire();
                  await this._muxer.start();
                  const t = this._tracks.map((e) => e.source._start());
                  await Promise.all(t), e();
              })());
    }
    getMimeType() {
        return this._muxer.getMimeType();
    }
    async cancel() {
        return this._cancelPromise
            ? this._cancelPromise
            : "finalizing" !== this.state && "finalized" !== this.state
              ? (this._cancelPromise = (async () => {
                    this.state = "canceled";
                    const e = await this._mutex.acquire(),
                        t = this._tracks.map((e) => e.source._flushOrWaitForOngoingClose(!0));
                    await Promise.all(t), await this._writer.close(), e();
                })())
              : void 0;
    }
    async finalize() {
        if ("pending" === this.state) throw new Error("Cannot finalize before starting.");
        if ("canceled" === this.state) throw new Error("Cannot finalize after canceling.");
        return this._finalizePromise
            ? this._finalizePromise
            : (this._finalizePromise = (async () => {
                  this.state = "finalizing";
                  const e = await this._mutex.acquire(),
                      t = this._tracks.map((e) => e.source._flushOrWaitForOngoingClose(!1));
                  await Promise.all(t),
                      await this._muxer.finalize(),
                      await this._writer.flush(),
                      await this._writer.finalize(),
                      (this.state = "finalized"),
                      e();
              })());
    }
}
const Zx = (e) => {
        if (void 0 !== e && (!e || "object" != typeof e))
            throw new TypeError("options.video, when provided, must be an object.");
        if (void 0 !== e?.discard && "boolean" != typeof e.discard)
            throw new TypeError("options.video.discard, when provided, must be a boolean.");
        if (void 0 !== e?.forceTranscode && "boolean" != typeof e.forceTranscode)
            throw new TypeError("options.video.forceTranscode, when provided, must be a boolean.");
        if (void 0 !== e?.codec && !GT.includes(e.codec))
            throw new TypeError(`options.video.codec, when provided, must be one of: ${GT.join(", ")}.`);
        if (void 0 !== e?.bitrate && !(e.bitrate instanceof Px) && (!Number.isInteger(e.bitrate) || e.bitrate <= 0))
            throw new TypeError("options.video.bitrate, when provided, must be a positive integer or a quality.");
        if (void 0 !== e?.width && (!Number.isInteger(e.width) || e.width <= 0))
            throw new TypeError("options.video.width, when provided, must be a positive integer.");
        if (void 0 !== e?.height && (!Number.isInteger(e.height) || e.height <= 0))
            throw new TypeError("options.video.height, when provided, must be a positive integer.");
        if (void 0 !== e?.fit && !["fill", "contain", "cover"].includes(e.fit))
            throw new TypeError("options.video.fit, when provided, must be one of 'fill', 'contain', or 'cover'.");
        if (void 0 !== e?.width && void 0 !== e.height && void 0 === e.fit)
            throw new TypeError(
                "When both options.video.width and options.video.height are provided, options.video.fit must also be provided."
            );
        if (void 0 !== e?.rotate && ![0, 90, 180, 270].includes(e.rotate))
            throw new TypeError("options.video.rotate, when provided, must be 0, 90, 180 or 270.");
        if (
            (void 0 !== e?.crop && mv(e.crop, "options.video."),
            void 0 !== e?.frameRate && (!Number.isFinite(e.frameRate) || e.frameRate <= 0))
        )
            throw new TypeError("options.video.frameRate, when provided, must be a finite positive number.");
        if (void 0 !== e?.alpha && !["discard", "keep"].includes(e.alpha))
            throw new TypeError("options.video.alpha, when provided, must be either 'discard' or 'keep'.");
        if (void 0 !== e?.keyFrameInterval && (!Number.isFinite(e.keyFrameInterval) || e.keyFrameInterval < 0))
            throw new TypeError("options.video.keyFrameInterval, when provided, must be a non-negative number.");
        if (void 0 !== e?.process && "function" != typeof e.process)
            throw new TypeError("options.video.process, when provided, must be a function.");
        if (void 0 !== e?.processedWidth && (!Number.isInteger(e.processedWidth) || e.processedWidth <= 0))
            throw new TypeError("options.video.processedWidth, when provided, must be a positive integer.");
        if (void 0 !== e?.processedHeight && (!Number.isInteger(e.processedHeight) || e.processedHeight <= 0))
            throw new TypeError("options.video.processedHeight, when provided, must be a positive integer.");
    },
    eA = (e) => {
        if (void 0 !== e && (!e || "object" != typeof e))
            throw new TypeError("options.audio, when provided, must be an object.");
        if (void 0 !== e?.discard && "boolean" != typeof e.discard)
            throw new TypeError("options.audio.discard, when provided, must be a boolean.");
        if (void 0 !== e?.forceTranscode && "boolean" != typeof e.forceTranscode)
            throw new TypeError("options.audio.forceTranscode, when provided, must be a boolean.");
        if (void 0 !== e?.codec && !QT.includes(e.codec))
            throw new TypeError(`options.audio.codec, when provided, must be one of: ${QT.join(", ")}.`);
        if (void 0 !== e?.bitrate && !(e.bitrate instanceof Px) && (!Number.isInteger(e.bitrate) || e.bitrate <= 0))
            throw new TypeError("options.audio.bitrate, when provided, must be a positive integer or a quality.");
        if (void 0 !== e?.numberOfChannels && (!Number.isInteger(e.numberOfChannels) || e.numberOfChannels <= 0))
            throw new TypeError("options.audio.numberOfChannels, when provided, must be a positive integer.");
        if (void 0 !== e?.sampleRate && (!Number.isInteger(e.sampleRate) || e.sampleRate <= 0))
            throw new TypeError("options.audio.sampleRate, when provided, must be a positive integer.");
        if (void 0 !== e?.process && "function" != typeof e.process)
            throw new TypeError("options.audio.process, when provided, must be a function.");
        if (
            void 0 !== e?.processedNumberOfChannels &&
            (!Number.isInteger(e.processedNumberOfChannels) || e.processedNumberOfChannels <= 0)
        )
            throw new TypeError("options.audio.processedNumberOfChannels, when provided, must be a positive integer.");
        if (
            void 0 !== e?.processedSampleRate &&
            (!Number.isInteger(e.processedSampleRate) || e.processedSampleRate <= 0)
        )
            throw new TypeError("options.audio.processedSampleRate, when provided, must be a positive integer.");
    },
    tA = 48e3;
class nA {
    static async init(e) {
        const t = new nA(e);
        return await t._init(), t;
    }
    constructor(e) {
        if (
            ((this._addedCounts = { video: 0, audio: 0, subtitle: 0 }),
            (this._totalTrackCount = 0),
            (this._trackPromises = []),
            (this._executed = !1),
            (this._synchronizer = new rA()),
            (this._totalDuration = null),
            (this._maxTimestamps = new Map()),
            (this._canceled = !1),
            (this.onProgress = void 0),
            (this._computeProgress = !1),
            (this._lastProgress = 0),
            (this.isValid = !1),
            (this.utilizedTracks = []),
            (this.discardedTracks = []),
            !e || "object" != typeof e)
        )
            throw new TypeError("options must be an object.");
        if (!(e.input instanceof QE)) throw new TypeError("options.input must be an Input.");
        if (!(e.output instanceof Jx)) throw new TypeError("options.output must be an Output.");
        if (
            e.output._tracks.length > 0 ||
            Object.keys(e.output._metadataTags).length > 0 ||
            "pending" !== e.output.state
        )
            throw new TypeError("options.output must be fresh: no tracks or metadata tags added and not started.");
        if (
            ("function" != typeof e.video && Zx(e.video),
            "function" != typeof e.audio && eA(e.audio),
            void 0 !== e.trim && (!e.trim || "object" != typeof e.trim))
        )
            throw new TypeError("options.trim, when provided, must be an object.");
        if (void 0 !== e.trim?.start && (!Number.isFinite(e.trim.start) || e.trim.start < 0))
            throw new TypeError("options.trim.start, when provided, must be a non-negative number.");
        if (void 0 !== e.trim?.end && (!Number.isFinite(e.trim.end) || e.trim.end < 0))
            throw new TypeError("options.trim.end, when provided, must be a non-negative number.");
        if (void 0 !== e.trim?.start && void 0 !== e.trim.end && e.trim.start >= e.trim.end)
            throw new TypeError("options.trim.start must be less than options.trim.end.");
        if (void 0 !== e.tags && ("object" != typeof e.tags || !e.tags) && "function" != typeof e.tags)
            throw new TypeError("options.tags, when provided, must be an object or a function.");
        if (("object" == typeof e.tags && XT(e.tags), void 0 !== e.showWarnings && "boolean" != typeof e.showWarnings))
            throw new TypeError("options.showWarnings, when provided, must be a boolean.");
        (this._options = e),
            (this.input = e.input),
            (this.output = e.output),
            (this._startTimestamp = e.trim?.start ?? 0),
            (this._endTimestamp = e.trim?.end ?? 1 / 0);
        const { promise: t, resolve: n } = fT();
        (this._started = t), (this._start = n);
    }
    async _init() {
        const e = await this.input.getTracks(),
            t = this.output.format.getSupportedTrackCounts();
        let n = 1,
            r = 1;
        for (const c of e) {
            let e;
            c.isVideoTrack()
                ? this._options.video &&
                  ("function" == typeof this._options.video
                      ? ((e = await this._options.video(c, n)), Zx(e), n++)
                      : (e = this._options.video))
                : c.isAudioTrack()
                  ? this._options.audio &&
                    ("function" == typeof this._options.audio
                        ? ((e = await this._options.audio(c, r)), eA(e), r++)
                        : (e = this._options.audio))
                  : Vk(!1),
                e?.discard
                    ? this.discardedTracks.push({ track: c, reason: "discarded_by_user" })
                    : this._totalTrackCount !== t.total.max
                      ? this._addedCounts[c.type] !== t[c.type].max
                          ? c.isVideoTrack()
                              ? await this._processVideoTrack(c, e ?? {})
                              : c.isAudioTrack() && (await this._processAudioTrack(c, e ?? {}))
                          : this.discardedTracks.push({ track: c, reason: "max_track_count_of_type_reached" })
                      : this.discardedTracks.push({ track: c, reason: "max_track_count_reached" });
        }
        const i = await this.input.getMetadataTags();
        let s;
        if (this._options.tags) {
            const e = "function" == typeof this._options.tags ? await this._options.tags(i) : this._options.tags;
            XT(e), (s = e);
        } else s = i;
        const a = (await this.input.getFormat()).mimeType === this.output.format.mimeType,
            o = i.raw === s.raw;
        if (
            (i.raw && o && !a && delete s.raw,
            this.output.setMetadataTags(s),
            (this.isValid =
                this._totalTrackCount >= t.total.min &&
                this._addedCounts.video >= t.video.min &&
                this._addedCounts.audio >= t.audio.min &&
                this._addedCounts.subtitle >= t.subtitle.min),
            this._options.showWarnings ?? 1)
        ) {
            const e = [],
                t = this.discardedTracks.filter((e) => "discarded_by_user" !== e.reason);
            t.length > 0 && e.push("Some tracks had to be discarded from the conversion:", t),
                this.isValid || e.push("\n\n" + this._getInvalidityExplanation().join("")),
                e.length;
        }
    }
    _getInvalidityExplanation() {
        const e = [];
        if (0 === this.discardedTracks.length) e.push("Due to missing tracks, this conversion cannot be executed.");
        else {
            const t = this.discardedTracks.every(
                (e) => "discarded_by_user" === e.reason || "no_encodable_target_codec" === e.reason
            );
            if ((e.push("Due to discarded tracks, this conversion cannot be executed."), t)) {
                const t = this.discardedTracks.flatMap((e) =>
                    "discarded_by_user" === e.reason
                        ? []
                        : "video" === e.track.type
                          ? this.output.format.getSupportedVideoCodecs()
                          : "audio" === e.track.type
                            ? this.output.format.getSupportedAudioCodecs()
                            : this.output.format.getSupportedSubtitleCodecs()
                );
                1 === t.length
                    ? e.push(`\nTracks were discarded because your environment is not able to encode '${t[0]}'.`)
                    : e.push(
                          `\nTracks were discarded because your environment is not able to encode any of the following codecs: ${t.map((e) => `'${e}'`).join(", ")}.`
                      ),
                    t.includes("mp3") &&
                        e.push("\nThe @mediabunny/mp3-encoder extension package provides support for encoding MP3.");
            } else e.push("\nCheck the discardedTracks field for more info.");
        }
        return e;
    }
    async execute() {
        if (!this.isValid)
            throw new Error(
                "Cannot execute this conversion because its output configuration is invalid. Make sure to always check the isValid field before executing a conversion.\n" +
                    this._getInvalidityExplanation().join("")
            );
        if (this._executed) throw new Error("Conversion cannot be executed twice.");
        if (((this._executed = !0), this.onProgress)) {
            (this._computeProgress = !0),
                (this._totalDuration = Math.min(
                    (await this.input.computeDuration()) - this._startTimestamp,
                    this._endTimestamp - this._startTimestamp
                ));
            for (const e of this.utilizedTracks) this._maxTimestamps.set(e.id, 0);
            this.onProgress?.(0);
        }
        await this.output.start(), this._start();
        try {
            await Promise.all(this._trackPromises);
        } catch (e) {
            throw (this._canceled || this.cancel(), e);
        }
        this._canceled && (await new Promise(() => {})),
            await this.output.finalize(),
            this._computeProgress && this.onProgress?.(1);
    }
    async cancel() {
        "finalizing" !== this.output.state &&
            "finalized" !== this.output.state &&
            (this._canceled || ((this._canceled = !0), await this.output.cancel()));
    }
    async _processVideoTrack(e, t) {
        const n = e.codec;
        if (!n) return void this.discardedTracks.push({ track: e, reason: "unknown_source_codec" });
        let r;
        const i = Wk(e.rotation + (t.rotate ?? 0)),
            s = this.output.format.supportsVideoRotationMetadata,
            [a, o] = i % 180 == 0 ? [e.codedWidth, e.codedHeight] : [e.codedHeight, e.codedWidth],
            c = t.crop;
        c && hv(c, a, o);
        const [l, u] = c ? [c.width, c.height] : [a, o];
        let d = l,
            h = u;
        const m = d / h,
            p = (e) => 2 * Math.ceil(e / 2);
        void 0 !== t.width && void 0 === t.height
            ? ((d = p(t.width)), (h = p(Math.round(d / m))))
            : void 0 === t.width && void 0 !== t.height
              ? ((h = p(t.height)), (d = p(Math.round(h * m))))
              : void 0 !== t.width && void 0 !== t.height && ((d = p(t.width)), (h = p(t.height)));
        const f = await e.getFirstTimestamp(),
            g =
                !!t.forceTranscode ||
                this._startTimestamp > 0 ||
                f < 0 ||
                !!t.frameRate ||
                void 0 !== t.keyFrameInterval ||
                void 0 !== t.process;
        let b = d !== l || h !== u || (0 !== i && !s) || !!c;
        const y = t.alpha ?? "discard";
        let w = this.output.format.getSupportedVideoCodecs();
        if (g || t.bitrate || b || !w.includes(n) || (t.codec && t.codec !== n)) {
            if (!(await e.canDecode()))
                return void this.discardedTracks.push({ track: e, reason: "undecodable_source_codec" });
            t.codec && (w = w.filter((e) => e === t.codec));
            const n = t.bitrate ?? Rx,
                s = await (async (e, t) => {
                    for (const n of e) if (await Dx(n, t)) return n;
                    return null;
                })(w, {
                    width: t.process && t.processedWidth ? t.processedWidth : d,
                    height: t.process && t.processedHeight ? t.processedHeight : h,
                    bitrate: n,
                });
            if (!s) return void this.discardedTracks.push({ track: e, reason: "no_encodable_target_codec" });
            const a = {
                    codec: s,
                    bitrate: n,
                    keyFrameInterval: t.keyFrameInterval,
                    sizeChangeBehavior: t.fit ?? "passThrough",
                    alpha: y,
                },
                o = new Vx(a);
            if (((r = o), !b)) {
                const t = new Jx({ format: new wx(), target: new ox() }),
                    n = new Vx(a);
                t.addVideoTrack(n), await t.start();
                const r = new Pv(e),
                    i = await r.getSample(f);
                if (i)
                    try {
                        await n.add(i), i.close(), await t.finalize();
                    } catch (k) {
                        (b = !0), t.cancel();
                    }
                else await t.cancel();
            }
            b
                ? this._trackPromises.push(
                      (async () => {
                          await this._started;
                          const n = new Ov(e, {
                                  width: d,
                                  height: h,
                                  fit: t.fit ?? "fill",
                                  rotation: i,
                                  crop: t.crop,
                                  poolSize: 1,
                                  alpha: "keep" === y,
                              }).canvases(this._startTimestamp, this._endTimestamp),
                              r = t.frameRate;
                          let s = null,
                              a = null,
                              c = null;
                          const l = async (n) => {
                              Vk(s), Vk(void 0 !== r);
                              const i = Math.round((n - a) * r);
                              for (let c = 1; c < i; c++) {
                                  const n = new uv(s, { timestamp: a + c / r, duration: 1 / r });
                                  await this._registerVideoSample(e, t, o, n);
                              }
                          };
                          for await (const { canvas: i, timestamp: u, duration: d } of n) {
                              if (this._canceled) return;
                              let n = Math.max(u - this._startTimestamp, 0);
                              if (((c = n + d), void 0 !== r)) {
                                  const e = Math.floor(n * r) / r;
                                  if (null !== s) {
                                      if (e <= a) {
                                          (s = i), (a = e);
                                          continue;
                                      }
                                      await l(e);
                                  }
                                  n = e;
                              }
                              const h = new uv(i, { timestamp: n, duration: void 0 !== r ? 1 / r : d });
                              await this._registerVideoSample(e, t, o, h),
                                  void 0 !== r ? ((s = i), (a = n)) : h.close();
                          }
                          s && (Vk(null !== c), Vk(void 0 !== r), await l(Math.floor(c * r) / r)),
                              o.close(),
                              this._synchronizer.closeTrack(e.id);
                      })()
                  )
                : this._trackPromises.push(
                      (async () => {
                          await this._started;
                          const n = new Pv(e),
                              r = t.frameRate;
                          let i = null,
                              s = null,
                              a = null;
                          const c = async (n) => {
                              Vk(i), Vk(void 0 !== r);
                              const a = Math.round((n - s) * r);
                              for (let c = 1; c < a; c++)
                                  i.setTimestamp(s + c / r),
                                      i.setDuration(1 / r),
                                      await this._registerVideoSample(e, t, o, i);
                              i.close();
                          };
                          for await (const l of n.samples(this._startTimestamp, this._endTimestamp)) {
                              if (this._canceled) return void i?.close();
                              let n = Math.max(l.timestamp - this._startTimestamp, 0);
                              if (((a = n + l.duration), void 0 !== r)) {
                                  const e = Math.floor(n * r) / r;
                                  if (null !== i) {
                                      if (e <= s) {
                                          i.close(), (i = l), (s = e);
                                          continue;
                                      }
                                      await c(e);
                                  }
                                  (n = e), l.setDuration(1 / r);
                              }
                              l.setTimestamp(n),
                                  await this._registerVideoSample(e, t, o, l),
                                  void 0 !== r ? ((i = l), (s = n)) : l.close();
                          }
                          i && (Vk(null !== a), Vk(void 0 !== r), await c(Math.floor(a * r) / r)),
                              o.close(),
                              this._synchronizer.closeTrack(e.id);
                      })()
                  );
        } else {
            const t = new zx(n);
            (r = t),
                this._trackPromises.push(
                    (async () => {
                        await this._started;
                        const n = new Sv(e),
                            r = { decoderConfig: (await e.getDecoderConfig()) ?? void 0 },
                            i = Number.isFinite(this._endTimestamp)
                                ? ((await n.getPacket(this._endTimestamp, { metadataOnly: !0 })) ?? void 0)
                                : void 0;
                        for await (const s of n.packets(void 0, i, { verifyKeyPackets: !0 })) {
                            if (this._canceled) return;
                            "discard" === y && (delete s.sideData.alpha, delete s.sideData.alphaByteLength),
                                this._reportProgress(e.id, s.timestamp),
                                await t.add(s, r),
                                this._synchronizer.shouldWait(e.id, s.timestamp) &&
                                    (await this._synchronizer.wait(s.timestamp));
                        }
                        t.close(), this._synchronizer.closeTrack(e.id);
                    })()
                );
        }
        this.output.addVideoTrack(r, {
            frameRate: t.frameRate,
            languageCode: IT(e.languageCode) ? e.languageCode : void 0,
            name: e.name ?? void 0,
            rotation: b ? 0 : i,
        }),
            this._addedCounts.video++,
            this._totalTrackCount++,
            this.utilizedTracks.push(e);
    }
    async _registerVideoSample(e, t, n, r) {
        if (this._canceled) return;
        let i;
        if ((this._reportProgress(e.id, r.timestamp), t.process)) {
            let e = t.process(r);
            e instanceof Promise && (e = await e),
                Array.isArray(e) || (e = null === e ? [] : [e]),
                (i = e.map((e) =>
                    e instanceof uv
                        ? e
                        : "undefined" != typeof VideoFrame && e instanceof VideoFrame
                          ? new uv(e)
                          : new uv(e, { timestamp: r.timestamp, duration: r.duration })
                ));
        } else i = [r];
        for (const s of i) {
            if (this._canceled) break;
            await n.add(s),
                this._synchronizer.shouldWait(e.id, s.timestamp) && (await this._synchronizer.wait(s.timestamp));
        }
        for (const s of i) s !== r && s.close();
    }
    async _processAudioTrack(e, t) {
        const n = e.codec;
        if (!n) return void this.discardedTracks.push({ track: e, reason: "unknown_source_codec" });
        let r;
        const i = e.numberOfChannels,
            s = e.sampleRate,
            a = await e.getFirstTimestamp();
        let o = t.numberOfChannels ?? i,
            c = t.sampleRate ?? s,
            l = o !== i || c !== s || this._startTimestamp > 0 || a < 0,
            u = this.output.format.getSupportedAudioCodecs();
        if (t.forceTranscode || t.bitrate || l || !u.includes(n) || (t.codec && t.codec !== n) || t.process) {
            if (!(await e.canDecode()))
                return void this.discardedTracks.push({ track: e, reason: "undecodable_source_codec" });
            let n = null;
            t.codec && (u = u.filter((e) => e === t.codec));
            const i = t.bitrate ?? Rx,
                s = await Fx(u, {
                    numberOfChannels: t.process && t.processedNumberOfChannels ? t.processedNumberOfChannels : o,
                    sampleRate: t.process && t.processedSampleRate ? t.processedSampleRate : c,
                    bitrate: i,
                });
            if (s.some((e) => YT.includes(e)) || !u.some((e) => YT.includes(e)) || (2 === o && c === tA))
                n = s[0] ?? null;
            else {
                const e = (await Fx(u, { numberOfChannels: 2, sampleRate: tA, bitrate: i })).find((e) =>
                    YT.includes(e)
                );
                e && ((l = !0), (n = e), (o = 2), (c = tA));
            }
            if (null === n) return void this.discardedTracks.push({ track: e, reason: "no_encodable_target_codec" });
            if (l) r = this._resampleAudio(e, t, n, o, c, i);
            else {
                const s = new Xx({ codec: n, bitrate: i });
                (r = s),
                    this._trackPromises.push(
                        (async () => {
                            await this._started;
                            const n = new Mv(e);
                            for await (const r of n.samples(void 0, this._endTimestamp)) {
                                if (this._canceled) return;
                                await this._registerAudioSample(e, t, s, r), r.close();
                            }
                            s.close(), this._synchronizer.closeTrack(e.id);
                        })()
                    );
            }
        } else {
            const t = new Hx(n);
            (r = t),
                this._trackPromises.push(
                    (async () => {
                        await this._started;
                        const n = new Sv(e),
                            r = { decoderConfig: (await e.getDecoderConfig()) ?? void 0 },
                            i = Number.isFinite(this._endTimestamp)
                                ? ((await n.getPacket(this._endTimestamp, { metadataOnly: !0 })) ?? void 0)
                                : void 0;
                        for await (const s of n.packets(void 0, i)) {
                            if (this._canceled) return;
                            this._reportProgress(e.id, s.timestamp),
                                await t.add(s, r),
                                this._synchronizer.shouldWait(e.id, s.timestamp) &&
                                    (await this._synchronizer.wait(s.timestamp));
                        }
                        t.close(), this._synchronizer.closeTrack(e.id);
                    })()
                );
        }
        this.output.addAudioTrack(r, {
            languageCode: IT(e.languageCode) ? e.languageCode : void 0,
            name: e.name ?? void 0,
        }),
            this._addedCounts.audio++,
            this._totalTrackCount++,
            this.utilizedTracks.push(e);
    }
    async _registerAudioSample(e, t, n, r) {
        if (this._canceled) return;
        let i;
        if ((this._reportProgress(e.id, r.timestamp), t.process)) {
            let e = t.process(r);
            if (
                (e instanceof Promise && (e = await e),
                Array.isArray(e) || (e = null === e ? [] : [e]),
                !e.every((e) => e instanceof fv))
            )
                throw new TypeError(
                    "The audio process function must return an AudioSample, null, or an array of AudioSamples."
                );
            i = e;
        } else i = [r];
        for (const s of i) {
            if (this._canceled) break;
            await n.add(s),
                this._synchronizer.shouldWait(e.id, s.timestamp) && (await this._synchronizer.wait(s.timestamp));
        }
        for (const s of i) s !== r && s.close();
    }
    _resampleAudio(e, t, n, r, i, s) {
        const a = new Xx({ codec: n, bitrate: s });
        return (
            this._trackPromises.push(
                (async () => {
                    await this._started;
                    const n = new iA({
                            targetNumberOfChannels: r,
                            targetSampleRate: i,
                            startTime: this._startTimestamp,
                            endTime: this._endTimestamp,
                            onSample: (n) => this._registerAudioSample(e, t, a, n),
                        }),
                        s = new Mv(e).samples(this._startTimestamp, this._endTimestamp);
                    for await (const e of s) {
                        if (this._canceled) return;
                        await n.add(e);
                    }
                    await n.finalize(), a.close(), this._synchronizer.closeTrack(e.id);
                })()
            ),
            a
        );
    }
    _reportProgress(e, t) {
        if (!this._computeProgress) return;
        Vk(null !== this._totalDuration), this._maxTimestamps.set(e, Math.max(t, this._maxTimestamps.get(e)));
        const n = Math.min(...this._maxTimestamps.values()),
            r = _T(n / this._totalDuration, 0, 1);
        r !== this._lastProgress && ((this._lastProgress = r), this.onProgress?.(r));
    }
}
class rA {
    constructor() {
        (this.maxTimestamps = new Map()), (this.resolvers = []);
    }
    computeMinAndMaybeResolve() {
        let e = 1 / 0;
        for (const [, t] of this.maxTimestamps) e = Math.min(e, t);
        for (let t = 0; t < this.resolvers.length; t++) {
            const n = this.resolvers[t];
            n.timestamp - e < 5 && (n.resolve(), this.resolvers.splice(t, 1), t--);
        }
        return e;
    }
    shouldWait(e, t) {
        this.maxTimestamps.set(e, Math.max(t, this.maxTimestamps.get(e) ?? -1 / 0));
        return t - this.computeMinAndMaybeResolve() >= 5;
    }
    wait(e) {
        const { promise: t, resolve: n } = fT();
        return this.resolvers.push({ timestamp: e, resolve: n }), t;
    }
    closeTrack(e) {
        this.maxTimestamps.delete(e), this.computeMinAndMaybeResolve();
    }
}
class iA {
    constructor(e) {
        (this.sourceSampleRate = null),
            (this.sourceNumberOfChannels = null),
            (this.targetSampleRate = e.targetSampleRate),
            (this.targetNumberOfChannels = e.targetNumberOfChannels),
            (this.startTime = e.startTime),
            (this.endTime = e.endTime),
            (this.onSample = e.onSample),
            (this.bufferSizeInFrames = Math.floor(5 * this.targetSampleRate)),
            (this.bufferSizeInSamples = this.bufferSizeInFrames * this.targetNumberOfChannels),
            (this.outputBuffer = new Float32Array(this.bufferSizeInSamples)),
            (this.bufferStartFrame = 0),
            (this.maxWrittenFrame = -1);
    }
    doChannelMixerSetup() {
        Vk(null !== this.sourceNumberOfChannels);
        const e = this.sourceNumberOfChannels,
            t = this.targetNumberOfChannels;
        this.channelMixer =
            1 === e && 2 === t
                ? (t, n) => t[n * e]
                : 1 === e && 4 === t
                  ? (t, n, r) => t[n * e] * +(r < 2)
                  : 1 === e && 6 === t
                    ? (t, n, r) => t[n * e] * +(2 === r)
                    : 2 === e && 1 === t
                      ? (t, n) => {
                            const r = n * e;
                            return 0.5 * (t[r] + t[r + 1]);
                        }
                      : (2 === e && 4 === t) || (2 === e && 6 === t)
                        ? (t, n, r) => t[n * e + r] * +(r < 2)
                        : 4 === e && 1 === t
                          ? (t, n) => {
                                const r = n * e;
                                return 0.25 * (t[r] + t[r + 1] + t[r + 2] + t[r + 3]);
                            }
                          : 4 === e && 2 === t
                            ? (t, n, r) => {
                                  const i = n * e;
                                  return 0.5 * (t[i + r] + t[i + r + 2]);
                              }
                            : 4 === e && 6 === t
                              ? (t, n, r) => {
                                    const i = n * e;
                                    return r < 2 ? t[i + r] : 2 === r || 3 === r ? 0 : t[i + r - 2];
                                }
                              : 6 === e && 1 === t
                                ? (t, n) => {
                                      const r = n * e;
                                      return Math.SQRT1_2 * (t[r] + t[r + 1]) + t[r + 2] + 0.5 * (t[r + 4] + t[r + 5]);
                                  }
                                : 6 === e && 2 === t
                                  ? (t, n, r) => {
                                        const i = n * e;
                                        return t[i + r] + Math.SQRT1_2 * (t[i + 2] + t[i + r + 4]);
                                    }
                                  : 6 === e && 4 === t
                                    ? (t, n, r) => {
                                          const i = n * e;
                                          return r < 2 ? t[i + r] + Math.SQRT1_2 * t[i + 2] : t[i + r + 2];
                                      }
                                    : (t, n, r) => (r < e ? t[n * e + r] : 0);
    }
    ensureTempBufferSize(e) {
        let t = this.tempSourceBuffer.length;
        for (; t < e; ) t *= 2;
        if (t !== this.tempSourceBuffer.length) {
            const e = new Float32Array(t);
            e.set(this.tempSourceBuffer), (this.tempSourceBuffer = e);
        }
    }
    async add(e) {
        null === this.sourceSampleRate &&
            ((this.sourceSampleRate = e.sampleRate),
            (this.sourceNumberOfChannels = e.numberOfChannels),
            (this.tempSourceBuffer = new Float32Array(this.sourceSampleRate * this.sourceNumberOfChannels)),
            this.doChannelMixerSetup());
        const t = e.numberOfFrames * e.numberOfChannels;
        this.ensureTempBufferSize(t);
        const n = e.allocationSize({ planeIndex: 0, format: "f32" }),
            r = new Float32Array(this.tempSourceBuffer.buffer, 0, n / 4);
        e.copyTo(r, { planeIndex: 0, format: "f32" });
        const i = e.timestamp - this.startTime,
            s = e.numberOfFrames / this.sourceSampleRate,
            a = Math.min(i + s, this.endTime - this.startTime),
            o = Math.floor(i * this.targetSampleRate),
            c = Math.ceil(a * this.targetSampleRate);
        for (let l = o; l < c; l++) {
            if (l < this.bufferStartFrame) continue;
            for (; l >= this.bufferStartFrame + this.bufferSizeInFrames; )
                await this.finalizeCurrentBuffer(), (this.bufferStartFrame += this.bufferSizeInFrames);
            const t = l - this.bufferStartFrame;
            Vk(t < this.bufferSizeInFrames);
            const n = (l / this.targetSampleRate - i) * this.sourceSampleRate,
                s = Math.floor(n),
                a = Math.ceil(n),
                o = n - s;
            for (let i = 0; i < this.targetNumberOfChannels; i++) {
                let n = 0,
                    c = 0;
                s >= 0 && s < e.numberOfFrames && (n = this.channelMixer(r, s, i)),
                    a >= 0 && a < e.numberOfFrames && (c = this.channelMixer(r, a, i));
                const l = n + o * (c - n),
                    u = t * this.targetNumberOfChannels + i;
                this.outputBuffer[u] += l;
            }
            this.maxWrittenFrame = Math.max(this.maxWrittenFrame, t);
        }
    }
    async finalizeCurrentBuffer() {
        if (this.maxWrittenFrame < 0) return;
        const e = (this.maxWrittenFrame + 1) * this.targetNumberOfChannels,
            t = new Float32Array(e);
        t.set(this.outputBuffer.subarray(0, e));
        const n = this.bufferStartFrame / this.targetSampleRate,
            r = new fv({
                format: "f32",
                sampleRate: this.targetSampleRate,
                numberOfChannels: this.targetNumberOfChannels,
                timestamp: n,
                data: t,
            });
        await this.onSample(r), this.outputBuffer.fill(0), (this.maxWrittenFrame = -1);
    }
    finalize() {
        return this.finalizeCurrentBuffer();
    }
}
var sA,
    aA = { exports: {} };
var oA =
    (sA ||
        ((sA = 1),
        (function (e) {
            var t = Object.prototype.hasOwnProperty,
                n = "~";
            function r() {}
            function i(e, t, n) {
                (this.fn = e), (this.context = t), (this.once = n || !1);
            }
            function s(e, t, r, s, a) {
                if ("function" != typeof r) throw new TypeError("The listener must be a function");
                var o = new i(r, s || e, a),
                    c = n ? n + t : t;
                return (
                    e._events[c]
                        ? e._events[c].fn
                            ? (e._events[c] = [e._events[c], o])
                            : e._events[c].push(o)
                        : ((e._events[c] = o), e._eventsCount++),
                    e
                );
            }
            function a(e, t) {
                0 === --e._eventsCount ? (e._events = new r()) : delete e._events[t];
            }
            function o() {
                (this._events = new r()), (this._eventsCount = 0);
            }
            Object.create && ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1)),
                (o.prototype.eventNames = function () {
                    var e,
                        r,
                        i = [];
                    if (0 === this._eventsCount) return i;
                    for (r in (e = this._events)) t.call(e, r) && i.push(n ? r.slice(1) : r);
                    return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(e)) : i;
                }),
                (o.prototype.listeners = function (e) {
                    var t = n ? n + e : e,
                        r = this._events[t];
                    if (!r) return [];
                    if (r.fn) return [r.fn];
                    for (var i = 0, s = r.length, a = new Array(s); i < s; i++) a[i] = r[i].fn;
                    return a;
                }),
                (o.prototype.listenerCount = function (e) {
                    var t = n ? n + e : e,
                        r = this._events[t];
                    return r ? (r.fn ? 1 : r.length) : 0;
                }),
                (o.prototype.emit = function (e, t, r, i, s, a) {
                    var o = n ? n + e : e;
                    if (!this._events[o]) return !1;
                    var c,
                        l,
                        u = this._events[o],
                        d = arguments.length;
                    if (u.fn) {
                        switch ((u.once && this.removeListener(e, u.fn, void 0, !0), d)) {
                            case 1:
                                return u.fn.call(u.context), !0;
                            case 2:
                                return u.fn.call(u.context, t), !0;
                            case 3:
                                return u.fn.call(u.context, t, r), !0;
                            case 4:
                                return u.fn.call(u.context, t, r, i), !0;
                            case 5:
                                return u.fn.call(u.context, t, r, i, s), !0;
                            case 6:
                                return u.fn.call(u.context, t, r, i, s, a), !0;
                        }
                        for (l = 1, c = new Array(d - 1); l < d; l++) c[l - 1] = arguments[l];
                        u.fn.apply(u.context, c);
                    } else {
                        var h,
                            m = u.length;
                        for (l = 0; l < m; l++)
                            switch ((u[l].once && this.removeListener(e, u[l].fn, void 0, !0), d)) {
                                case 1:
                                    u[l].fn.call(u[l].context);
                                    break;
                                case 2:
                                    u[l].fn.call(u[l].context, t);
                                    break;
                                case 3:
                                    u[l].fn.call(u[l].context, t, r);
                                    break;
                                case 4:
                                    u[l].fn.call(u[l].context, t, r, i);
                                    break;
                                default:
                                    if (!c) for (h = 1, c = new Array(d - 1); h < d; h++) c[h - 1] = arguments[h];
                                    u[l].fn.apply(u[l].context, c);
                            }
                    }
                    return !0;
                }),
                (o.prototype.on = function (e, t, n) {
                    return s(this, e, t, n, !1);
                }),
                (o.prototype.once = function (e, t, n) {
                    return s(this, e, t, n, !0);
                }),
                (o.prototype.removeListener = function (e, t, r, i) {
                    var s = n ? n + e : e;
                    if (!this._events[s]) return this;
                    if (!t) return a(this, s), this;
                    var o = this._events[s];
                    if (o.fn) o.fn !== t || (i && !o.once) || (r && o.context !== r) || a(this, s);
                    else {
                        for (var c = 0, l = [], u = o.length; c < u; c++)
                            (o[c].fn !== t || (i && !o[c].once) || (r && o[c].context !== r)) && l.push(o[c]);
                        l.length ? (this._events[s] = 1 === l.length ? l[0] : l) : a(this, s);
                    }
                    return this;
                }),
                (o.prototype.removeAllListeners = function (e) {
                    var t;
                    return (
                        e
                            ? ((t = n ? n + e : e), this._events[t] && a(this, t))
                            : ((this._events = new r()), (this._eventsCount = 0)),
                        this
                    );
                }),
                (o.prototype.off = o.prototype.removeListener),
                (o.prototype.addListener = o.prototype.on),
                (o.prefixed = n),
                (o.EventEmitter = o),
                (e.exports = o);
        })(aA)),
    aA.exports);
const cA = kc(oA);
class lA extends Error {
    constructor(e) {
        super(e), (this.name = "TimeoutError");
    }
}
class uA extends Error {
    constructor(e) {
        super(), (this.name = "AbortError"), (this.message = e);
    }
}
const dA = (e) => (void 0 === globalThis.DOMException ? new uA(e) : new DOMException(e)),
    hA = (e) => {
        const t = void 0 === e.reason ? dA("This operation was aborted.") : e.reason;
        return t instanceof Error ? t : dA(t);
    };
class mA {
    #e = [];
    enqueue(e, t) {
        const n = { priority: (t = { priority: 0, ...t }).priority, id: t.id, run: e };
        if (0 === this.size || this.#e[this.size - 1].priority >= t.priority) return void this.#e.push(n);
        const r = (function (e, t, n) {
            let r = 0,
                i = e.length;
            for (; i > 0; ) {
                const s = Math.trunc(i / 2);
                let a = r + s;
                n(e[a], t) <= 0 ? ((r = ++a), (i -= s + 1)) : (i = s);
            }
            return r;
        })(this.#e, n, (e, t) => t.priority - e.priority);
        this.#e.splice(r, 0, n);
    }
    setPriority(e, t) {
        const n = this.#e.findIndex((t) => t.id === e);
        if (-1 === n) throw new ReferenceError(`No promise function with the id "${e}" exists in the queue.`);
        const [r] = this.#e.splice(n, 1);
        this.enqueue(r.run, { priority: t, id: e });
    }
    dequeue() {
        const e = this.#e.shift();
        return e?.run;
    }
    filter(e) {
        return this.#e.filter((t) => t.priority === e.priority).map((e) => e.run);
    }
    get size() {
        return this.#e.length;
    }
}
class pA extends cA {
    #t;
    #n;
    #r = 0;
    #i;
    #s;
    #a = 0;
    #o;
    #c;
    #e;
    #l;
    #u = 0;
    #d;
    #h;
    #m;
    #p = 1n;
    timeout;
    constructor(e) {
        if (
            (super(),
            !(
                "number" ==
                    typeof (e = {
                        carryoverConcurrencyCount: !1,
                        intervalCap: Number.POSITIVE_INFINITY,
                        interval: 0,
                        concurrency: Number.POSITIVE_INFINITY,
                        autoStart: !0,
                        queueClass: mA,
                        ...e,
                    }).intervalCap && e.intervalCap >= 1
            ))
        )
            throw new TypeError(
                `Expected \`intervalCap\` to be a number from 1 and up, got \`${e.intervalCap?.toString() ?? ""}\` (${typeof e.intervalCap})`
            );
        if (void 0 === e.interval || !(Number.isFinite(e.interval) && e.interval >= 0))
            throw new TypeError(
                `Expected \`interval\` to be a finite number >= 0, got \`${e.interval?.toString() ?? ""}\` (${typeof e.interval})`
            );
        (this.#t = e.carryoverConcurrencyCount),
            (this.#n = e.intervalCap === Number.POSITIVE_INFINITY || 0 === e.interval),
            (this.#i = e.intervalCap),
            (this.#s = e.interval),
            (this.#e = new e.queueClass()),
            (this.#l = e.queueClass),
            (this.concurrency = e.concurrency),
            (this.timeout = e.timeout),
            (this.#m = !0 === e.throwOnTimeout),
            (this.#h = !1 === e.autoStart);
    }
    get #f() {
        return this.#n || this.#r < this.#i;
    }
    get #g() {
        return this.#u < this.#d;
    }
    #b() {
        this.#u--, this.#y(), this.emit("next");
    }
    #w() {
        this.#k(), this.#T(), (this.#c = void 0);
    }
    get #_() {
        const e = Date.now();
        if (void 0 === this.#o) {
            const t = this.#a - e;
            if (!(t < 0))
                return (
                    void 0 === this.#c &&
                        (this.#c = setTimeout(() => {
                            this.#w();
                        }, t)),
                    !0
                );
            this.#r = this.#t ? this.#u : 0;
        }
        return !1;
    }
    #y() {
        if (0 === this.#e.size)
            return (
                this.#o && clearInterval(this.#o),
                (this.#o = void 0),
                this.emit("empty"),
                0 === this.#u && this.emit("idle"),
                !1
            );
        if (!this.#h) {
            const e = !this.#_;
            if (this.#f && this.#g) {
                const t = this.#e.dequeue();
                return !!t && (this.emit("active"), t(), e && this.#T(), !0);
            }
        }
        return !1;
    }
    #T() {
        this.#n ||
            void 0 !== this.#o ||
            ((this.#o = setInterval(() => {
                this.#k();
            }, this.#s)),
            (this.#a = Date.now() + this.#s));
    }
    #k() {
        0 === this.#r && 0 === this.#u && this.#o && (clearInterval(this.#o), (this.#o = void 0)),
            (this.#r = this.#t ? this.#u : 0),
            this.#v();
    }
    #v() {
        for (; this.#y(); );
    }
    get concurrency() {
        return this.#d;
    }
    set concurrency(e) {
        if (!("number" == typeof e && e >= 1))
            throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);
        (this.#d = e), this.#v();
    }
    async #S(e) {
        return new Promise((t, n) => {
            e.addEventListener(
                "abort",
                () => {
                    n(e.reason);
                },
                { once: !0 }
            );
        });
    }
    setPriority(e, t) {
        this.#e.setPriority(e, t);
    }
    async add(e, t = {}) {
        return (
            (t.id ??= (this.#p++).toString()),
            (t = { timeout: this.timeout, throwOnTimeout: this.#m, ...t }),
            new Promise((n, r) => {
                this.#e.enqueue(async () => {
                    this.#u++;
                    try {
                        t.signal?.throwIfAborted(), this.#r++;
                        let r = e({ signal: t.signal });
                        t.timeout &&
                            (r = (function (e, t) {
                                const {
                                    milliseconds: n,
                                    fallback: r,
                                    message: i,
                                    customTimers: s = { setTimeout: setTimeout, clearTimeout: clearTimeout },
                                } = t;
                                let a, o;
                                const c = new Promise((c, l) => {
                                    if ("number" != typeof n || 1 !== Math.sign(n))
                                        throw new TypeError(
                                            `Expected \`milliseconds\` to be a positive number, got \`${n}\``
                                        );
                                    if (t.signal) {
                                        const { signal: e } = t;
                                        e.aborted && l(hA(e)),
                                            (o = () => {
                                                l(hA(e));
                                            }),
                                            e.addEventListener("abort", o, { once: !0 });
                                    }
                                    if (n === Number.POSITIVE_INFINITY) return void e.then(c, l);
                                    const u = new lA();
                                    (a = s.setTimeout.call(
                                        void 0,
                                        () => {
                                            if (r)
                                                try {
                                                    c(r());
                                                } catch (t) {
                                                    l(t);
                                                }
                                            else
                                                "function" == typeof e.cancel && e.cancel(),
                                                    !1 === i
                                                        ? c()
                                                        : i instanceof Error
                                                          ? l(i)
                                                          : ((u.message =
                                                                i ?? `Promise timed out after ${n} milliseconds`),
                                                            l(u));
                                        },
                                        n
                                    )),
                                        (async () => {
                                            try {
                                                c(await e);
                                            } catch (t) {
                                                l(t);
                                            }
                                        })();
                                }).finally(() => {
                                    c.clear(), o && t.signal && t.signal.removeEventListener("abort", o);
                                });
                                return (
                                    (c.clear = () => {
                                        s.clearTimeout.call(void 0, a), (a = void 0);
                                    }),
                                    c
                                );
                            })(Promise.resolve(r), { milliseconds: t.timeout })),
                            t.signal && (r = Promise.race([r, this.#S(t.signal)]));
                        const i = await r;
                        n(i), this.emit("completed", i);
                    } catch (i) {
                        if (i instanceof lA && !t.throwOnTimeout) return void n();
                        r(i), this.emit("error", i);
                    } finally {
                        this.#b();
                    }
                }, t),
                    this.emit("add"),
                    this.#y();
            })
        );
    }
    async addAll(e, t) {
        return Promise.all(e.map(async (e) => this.add(e, t)));
    }
    start() {
        return this.#h ? ((this.#h = !1), this.#v(), this) : this;
    }
    pause() {
        this.#h = !0;
    }
    clear() {
        this.#e = new this.#l();
    }
    async onEmpty() {
        0 !== this.#e.size && (await this.#E("empty"));
    }
    async onSizeLessThan(e) {
        this.#e.size < e || (await this.#E("next", () => this.#e.size < e));
    }
    async onIdle() {
        (0 === this.#u && 0 === this.#e.size) || (await this.#E("idle"));
    }
    async #E(e, t) {
        return new Promise((n) => {
            const r = () => {
                (t && !t()) || (this.off(e, r), n());
            };
            this.on(e, r);
        });
    }
    get size() {
        return this.#e.size;
    }
    sizeBy(e) {
        return this.#e.filter(e).length;
    }
    get pending() {
        return this.#u;
    }
    get isPaused() {
        return this.#h;
    }
}
var fA, gA, bA, yA, wA, kA;
((gA = fA || (fA = {})).STRING = "string"),
    (gA.NUMBER = "number"),
    (gA.INTEGER = "integer"),
    (gA.BOOLEAN = "boolean"),
    (gA.ARRAY = "array"),
    (gA.OBJECT = "object"),
    ((yA = bA || (bA = {})).LANGUAGE_UNSPECIFIED = "language_unspecified"),
    (yA.PYTHON = "python"),
    ((kA = wA || (wA = {})).OUTCOME_UNSPECIFIED = "outcome_unspecified"),
    (kA.OUTCOME_OK = "outcome_ok"),
    (kA.OUTCOME_FAILED = "outcome_failed"),
    (kA.OUTCOME_DEADLINE_EXCEEDED = "outcome_deadline_exceeded");
const TA = ["user", "model", "function", "system"];
var _A, vA, SA, EA, CA, IA, xA, AA, PA, OA, NA, RA, MA, DA, FA, LA;
((vA = _A || (_A = {})).HARM_CATEGORY_UNSPECIFIED = "HARM_CATEGORY_UNSPECIFIED"),
    (vA.HARM_CATEGORY_HATE_SPEECH = "HARM_CATEGORY_HATE_SPEECH"),
    (vA.HARM_CATEGORY_SEXUALLY_EXPLICIT = "HARM_CATEGORY_SEXUALLY_EXPLICIT"),
    (vA.HARM_CATEGORY_HARASSMENT = "HARM_CATEGORY_HARASSMENT"),
    (vA.HARM_CATEGORY_DANGEROUS_CONTENT = "HARM_CATEGORY_DANGEROUS_CONTENT"),
    (vA.HARM_CATEGORY_CIVIC_INTEGRITY = "HARM_CATEGORY_CIVIC_INTEGRITY"),
    ((EA = SA || (SA = {})).HARM_BLOCK_THRESHOLD_UNSPECIFIED = "HARM_BLOCK_THRESHOLD_UNSPECIFIED"),
    (EA.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE"),
    (EA.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE"),
    (EA.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH"),
    (EA.BLOCK_NONE = "BLOCK_NONE"),
    ((IA = CA || (CA = {})).HARM_PROBABILITY_UNSPECIFIED = "HARM_PROBABILITY_UNSPECIFIED"),
    (IA.NEGLIGIBLE = "NEGLIGIBLE"),
    (IA.LOW = "LOW"),
    (IA.MEDIUM = "MEDIUM"),
    (IA.HIGH = "HIGH"),
    ((AA = xA || (xA = {})).BLOCKED_REASON_UNSPECIFIED = "BLOCKED_REASON_UNSPECIFIED"),
    (AA.SAFETY = "SAFETY"),
    (AA.OTHER = "OTHER"),
    ((OA = PA || (PA = {})).FINISH_REASON_UNSPECIFIED = "FINISH_REASON_UNSPECIFIED"),
    (OA.STOP = "STOP"),
    (OA.MAX_TOKENS = "MAX_TOKENS"),
    (OA.SAFETY = "SAFETY"),
    (OA.RECITATION = "RECITATION"),
    (OA.LANGUAGE = "LANGUAGE"),
    (OA.BLOCKLIST = "BLOCKLIST"),
    (OA.PROHIBITED_CONTENT = "PROHIBITED_CONTENT"),
    (OA.SPII = "SPII"),
    (OA.MALFORMED_FUNCTION_CALL = "MALFORMED_FUNCTION_CALL"),
    (OA.OTHER = "OTHER"),
    ((RA = NA || (NA = {})).TASK_TYPE_UNSPECIFIED = "TASK_TYPE_UNSPECIFIED"),
    (RA.RETRIEVAL_QUERY = "RETRIEVAL_QUERY"),
    (RA.RETRIEVAL_DOCUMENT = "RETRIEVAL_DOCUMENT"),
    (RA.SEMANTIC_SIMILARITY = "SEMANTIC_SIMILARITY"),
    (RA.CLASSIFICATION = "CLASSIFICATION"),
    (RA.CLUSTERING = "CLUSTERING"),
    ((DA = MA || (MA = {})).MODE_UNSPECIFIED = "MODE_UNSPECIFIED"),
    (DA.AUTO = "AUTO"),
    (DA.ANY = "ANY"),
    (DA.NONE = "NONE"),
    ((LA = FA || (FA = {})).MODE_UNSPECIFIED = "MODE_UNSPECIFIED"),
    (LA.MODE_DYNAMIC = "MODE_DYNAMIC");
class BA extends Error {
    constructor(e) {
        super(`[GoogleGenerativeAI Error]: ${e}`);
    }
}
class zA extends BA {
    constructor(e, t) {
        super(e), (this.response = t);
    }
}
class UA extends BA {
    constructor(e, t, n, r) {
        super(e), (this.status = t), (this.statusText = n), (this.errorDetails = r);
    }
}
class $A extends BA {}
class VA extends BA {}
var WA, jA;
((jA = WA || (WA = {})).GENERATE_CONTENT = "generateContent"),
    (jA.STREAM_GENERATE_CONTENT = "streamGenerateContent"),
    (jA.COUNT_TOKENS = "countTokens"),
    (jA.EMBED_CONTENT = "embedContent"),
    (jA.BATCH_EMBED_CONTENTS = "batchEmbedContents");
class HA {
    constructor(e, t, n, r, i) {
        (this.model = e), (this.task = t), (this.apiKey = n), (this.stream = r), (this.requestOptions = i);
    }
    toString() {
        var e, t;
        const n = (null === (e = this.requestOptions) || void 0 === e ? void 0 : e.apiVersion) || "v1beta";
        let r = `${(null === (t = this.requestOptions) || void 0 === t ? void 0 : t.baseUrl) || "https://generativelanguage.googleapis.com"}/${n}/${this.model}:${this.task}`;
        return this.stream && (r += "?alt=sse"), r;
    }
}
async function qA(e) {
    var t;
    const n = new Headers();
    n.append("Content-Type", "application/json"),
        n.append(
            "x-goog-api-client",
            (function (e) {
                const t = [];
                return (
                    (null == e ? void 0 : e.apiClient) && t.push(e.apiClient), t.push("genai-js/0.24.1"), t.join(" ")
                );
            })(e.requestOptions)
        ),
        n.append("x-goog-api-key", e.apiKey);
    let r = null === (t = e.requestOptions) || void 0 === t ? void 0 : t.customHeaders;
    if (r) {
        if (!(r instanceof Headers))
            try {
                r = new Headers(r);
            } catch (ez) {
                throw new $A(`unable to convert customHeaders value ${JSON.stringify(r)} to Headers: ${ez.message}`);
            }
        for (const [e, t] of r.entries()) {
            if ("x-goog-api-key" === e) throw new $A(`Cannot set reserved header name ${e}`);
            if ("x-goog-api-client" === e) throw new $A(`Header name ${e} can only be set using the apiClient field`);
            n.append(e, t);
        }
    }
    return n;
}
async function XA(e, t, n, r, i, s = {}, a = fetch) {
    const { url: o, fetchOptions: c } = await (async function (e, t, n, r, i, s) {
        const a = new HA(e, t, n, r, s);
        return {
            url: a.toString(),
            fetchOptions: Object.assign(Object.assign({}, GA(s)), { method: "POST", headers: await qA(a), body: i }),
        };
    })(e, t, n, r, i, s);
    return (async function (e, t, n = fetch) {
        let r;
        try {
            r = await n(e, t);
        } catch (ez) {
            !(function (e, t) {
                let n = e;
                "AbortError" === n.name
                    ? ((n = new VA(`Request aborted when fetching ${t.toString()}: ${e.message}`)), (n.stack = e.stack))
                    : e instanceof UA ||
                      e instanceof $A ||
                      ((n = new BA(`Error fetching from ${t.toString()}: ${e.message}`)), (n.stack = e.stack));
                throw n;
            })(ez, e);
        }
        r.ok ||
            (await (async function (e, t) {
                let n,
                    r = "";
                try {
                    const t = await e.json();
                    (r = t.error.message),
                        t.error.details && ((r += ` ${JSON.stringify(t.error.details)}`), (n = t.error.details));
                } catch (ez) {}
                throw new UA(
                    `Error fetching from ${t.toString()}: [${e.status} ${e.statusText}] ${r}`,
                    e.status,
                    e.statusText,
                    n
                );
            })(r, e));
        return r;
    })(o, c, a);
}
function GA(e) {
    const t = {};
    if (void 0 !== (null == e ? void 0 : e.signal) || (null == e ? void 0 : e.timeout) >= 0) {
        const n = new AbortController();
        (null == e ? void 0 : e.timeout) >= 0 && setTimeout(() => n.abort(), e.timeout),
            (null == e ? void 0 : e.signal) &&
                e.signal.addEventListener("abort", () => {
                    n.abort();
                }),
            (t.signal = n.signal);
    }
    return t;
}
function KA(e) {
    return (
        (e.text = () => {
            if (e.candidates && e.candidates.length > 0) {
                if ((e.candidates.length, JA(e.candidates[0]))) throw new zA(`${ZA(e)}`, e);
                return (function (e) {
                    var t, n, r, i;
                    const s = [];
                    if (
                        null === (n = null === (t = e.candidates) || void 0 === t ? void 0 : t[0].content) ||
                        void 0 === n
                            ? void 0
                            : n.parts
                    )
                        for (const a of null ===
                            (i = null === (r = e.candidates) || void 0 === r ? void 0 : r[0].content) || void 0 === i
                            ? void 0
                            : i.parts)
                            a.text && s.push(a.text),
                                a.executableCode &&
                                    s.push(
                                        "\n```" + a.executableCode.language + "\n" + a.executableCode.code + "\n```\n"
                                    ),
                                a.codeExecutionResult && s.push("\n```\n" + a.codeExecutionResult.output + "\n```\n");
                    return s.length > 0 ? s.join("") : "";
                })(e);
            }
            if (e.promptFeedback) throw new zA(`Text not available. ${ZA(e)}`, e);
            return "";
        }),
        (e.functionCall = () => {
            if (e.candidates && e.candidates.length > 0) {
                if ((e.candidates.length, JA(e.candidates[0]))) throw new zA(`${ZA(e)}`, e);
                return YA(e)[0];
            }
            if (e.promptFeedback) throw new zA(`Function call not available. ${ZA(e)}`, e);
        }),
        (e.functionCalls = () => {
            if (e.candidates && e.candidates.length > 0) {
                if ((e.candidates.length, JA(e.candidates[0]))) throw new zA(`${ZA(e)}`, e);
                return YA(e);
            }
            if (e.promptFeedback) throw new zA(`Function call not available. ${ZA(e)}`, e);
        }),
        e
    );
}
function YA(e) {
    var t, n, r, i;
    const s = [];
    if (
        null === (n = null === (t = e.candidates) || void 0 === t ? void 0 : t[0].content) || void 0 === n
            ? void 0
            : n.parts
    )
        for (const a of null === (i = null === (r = e.candidates) || void 0 === r ? void 0 : r[0].content) ||
        void 0 === i
            ? void 0
            : i.parts)
            a.functionCall && s.push(a.functionCall);
    return s.length > 0 ? s : void 0;
}
const QA = [PA.RECITATION, PA.SAFETY, PA.LANGUAGE];
function JA(e) {
    return !!e.finishReason && QA.includes(e.finishReason);
}
function ZA(e) {
    var t, n, r;
    let i = "";
    if ((e.candidates && 0 !== e.candidates.length) || !e.promptFeedback) {
        if (null === (r = e.candidates) || void 0 === r ? void 0 : r[0]) {
            const t = e.candidates[0];
            JA(t) &&
                ((i += `Candidate was blocked due to ${t.finishReason}`),
                t.finishMessage && (i += `: ${t.finishMessage}`));
        }
    } else
        (i += "Response was blocked"),
            (null === (t = e.promptFeedback) || void 0 === t ? void 0 : t.blockReason) &&
                (i += ` due to ${e.promptFeedback.blockReason}`),
            (null === (n = e.promptFeedback) || void 0 === n ? void 0 : n.blockReasonMessage) &&
                (i += `: ${e.promptFeedback.blockReasonMessage}`);
    return i;
}
function eP(e) {
    return this instanceof eP ? ((this.v = e), this) : new eP(e);
}
function tP(e, t, n) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var r,
        i = n.apply(e, t || []),
        s = [];
    return (
        (r = {}),
        a("next"),
        a("throw"),
        a("return"),
        (r[Symbol.asyncIterator] = function () {
            return this;
        }),
        r
    );
    function a(e) {
        i[e] &&
            (r[e] = function (t) {
                return new Promise(function (n, r) {
                    s.push([e, t, n, r]) > 1 || o(e, t);
                });
            });
    }
    function o(e, t) {
        try {
            (n = i[e](t)).value instanceof eP ? Promise.resolve(n.value.v).then(c, l) : u(s[0][2], n);
        } catch (ez) {
            u(s[0][3], ez);
        }
        var n;
    }
    function c(e) {
        o("next", e);
    }
    function l(e) {
        o("throw", e);
    }
    function u(e, t) {
        e(t), s.shift(), s.length && o(s[0][0], s[0][1]);
    }
}
"function" == typeof SuppressedError && SuppressedError;
const nP = /^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
function rP(e) {
    const t = (function (e) {
            const t = e.getReader();
            return new ReadableStream({
                start(e) {
                    let n = "";
                    return r();
                    function r() {
                        return t
                            .read()
                            .then(({ value: t, done: i }) => {
                                if (i)
                                    return n.trim() ? void e.error(new BA("Failed to parse stream")) : void e.close();
                                n += t;
                                let s,
                                    a = n.match(nP);
                                for (; a; ) {
                                    try {
                                        s = JSON.parse(a[1]);
                                    } catch (ez) {
                                        return void e.error(new BA(`Error parsing JSON response: "${a[1]}"`));
                                    }
                                    e.enqueue(s), (n = n.substring(a[0].length)), (a = n.match(nP));
                                }
                                return r();
                            })
                            .catch((e) => {
                                let t = e;
                                throw (
                                    ((t.stack = e.stack),
                                    (t =
                                        "AbortError" === t.name
                                            ? new VA("Request aborted when reading from the stream")
                                            : new BA("Error reading from the stream")),
                                    t)
                                );
                            });
                    }
                },
            });
        })(e.body.pipeThrough(new TextDecoderStream("utf8", { fatal: !0 }))),
        [n, r] = t.tee();
    return { stream: sP(n), response: iP(r) };
}
async function iP(e) {
    const t = [],
        n = e.getReader();
    for (;;) {
        const { done: e, value: r } = await n.read();
        if (e) return KA(aP(t));
        t.push(r);
    }
}
function sP(e) {
    return tP(this, arguments, function* () {
        const t = e.getReader();
        for (;;) {
            const { value: e, done: n } = yield eP(t.read());
            if (n) break;
            yield yield eP(KA(e));
        }
    });
}
function aP(e) {
    const t = e[e.length - 1],
        n = { promptFeedback: null == t ? void 0 : t.promptFeedback };
    for (const r of e) {
        if (r.candidates) {
            let e = 0;
            for (const t of r.candidates)
                if (
                    (n.candidates || (n.candidates = []),
                    n.candidates[e] || (n.candidates[e] = { index: e }),
                    (n.candidates[e].citationMetadata = t.citationMetadata),
                    (n.candidates[e].groundingMetadata = t.groundingMetadata),
                    (n.candidates[e].finishReason = t.finishReason),
                    (n.candidates[e].finishMessage = t.finishMessage),
                    (n.candidates[e].safetyRatings = t.safetyRatings),
                    t.content && t.content.parts)
                ) {
                    n.candidates[e].content ||
                        (n.candidates[e].content = { role: t.content.role || "user", parts: [] });
                    const r = {};
                    for (const i of t.content.parts)
                        i.text && (r.text = i.text),
                            i.functionCall && (r.functionCall = i.functionCall),
                            i.executableCode && (r.executableCode = i.executableCode),
                            i.codeExecutionResult && (r.codeExecutionResult = i.codeExecutionResult),
                            0 === Object.keys(r).length && (r.text = ""),
                            n.candidates[e].content.parts.push(r);
                }
            e++;
        }
        r.usageMetadata && (n.usageMetadata = r.usageMetadata);
    }
    return n;
}
async function oP(e, t, n, r) {
    return rP(await XA(t, WA.STREAM_GENERATE_CONTENT, e, !0, JSON.stringify(n), r));
}
async function cP(e, t, n, r) {
    const i = await XA(t, WA.GENERATE_CONTENT, e, !1, JSON.stringify(n), r);
    return { response: KA(await i.json()) };
}
function lP(e) {
    if (null != e)
        return "string" == typeof e
            ? { role: "system", parts: [{ text: e }] }
            : e.text
              ? { role: "system", parts: [e] }
              : e.parts
                ? e.role
                    ? e
                    : { role: "system", parts: e.parts }
                : void 0;
}
function uP(e) {
    let t = [];
    if ("string" == typeof e) t = [{ text: e }];
    else for (const n of e) "string" == typeof n ? t.push({ text: n }) : t.push(n);
    return (function (e) {
        const t = { role: "user", parts: [] },
            n = { role: "function", parts: [] };
        let r = !1,
            i = !1;
        for (const s of e) "functionResponse" in s ? (n.parts.push(s), (i = !0)) : (t.parts.push(s), (r = !0));
        if (r && i)
            throw new BA(
                "Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message."
            );
        if (!r && !i) throw new BA("No content is provided for sending chat message.");
        if (r) return t;
        return n;
    })(t);
}
function dP(e) {
    let t;
    if (e.contents) t = e;
    else {
        t = { contents: [uP(e)] };
    }
    return e.systemInstruction && (t.systemInstruction = lP(e.systemInstruction)), t;
}
const hP = ["text", "inlineData", "functionCall", "functionResponse", "executableCode", "codeExecutionResult"],
    mP = {
        user: ["text", "inlineData"],
        function: ["functionResponse"],
        model: ["text", "functionCall", "executableCode", "codeExecutionResult"],
        system: ["text"],
    };
function pP(e) {
    var t;
    if (void 0 === e.candidates || 0 === e.candidates.length) return !1;
    const n = null === (t = e.candidates[0]) || void 0 === t ? void 0 : t.content;
    if (void 0 === n) return !1;
    if (void 0 === n.parts || 0 === n.parts.length) return !1;
    for (const r of n.parts) {
        if (void 0 === r || 0 === Object.keys(r).length) return !1;
        if (void 0 !== r.text && "" === r.text) return !1;
    }
    return !0;
}
const fP = "SILENT_ERROR";
class gP {
    constructor(e, t, n, r = {}) {
        (this.model = t),
            (this.params = n),
            (this._requestOptions = r),
            (this._history = []),
            (this._sendPromise = Promise.resolve()),
            (this._apiKey = e),
            (null == n ? void 0 : n.history) &&
                (!(function (e) {
                    let t = !1;
                    for (const n of e) {
                        const { role: e, parts: r } = n;
                        if (!t && "user" !== e) throw new BA(`First content should be with role 'user', got ${e}`);
                        if (!TA.includes(e))
                            throw new BA(
                                `Each item should include role field. Got ${e} but valid roles are: ${JSON.stringify(TA)}`
                            );
                        if (!Array.isArray(r))
                            throw new BA("Content should have 'parts' property with an array of Parts");
                        if (0 === r.length) throw new BA("Each Content should have at least one part");
                        const i = {
                            text: 0,
                            inlineData: 0,
                            functionCall: 0,
                            functionResponse: 0,
                            fileData: 0,
                            executableCode: 0,
                            codeExecutionResult: 0,
                        };
                        for (const t of r) for (const e of hP) e in t && (i[e] += 1);
                        const s = mP[e];
                        for (const t of hP)
                            if (!s.includes(t) && i[t] > 0)
                                throw new BA(`Content with role '${e}' can't contain '${t}' part`);
                        t = !0;
                    }
                })(n.history),
                (this._history = n.history));
    }
    async getHistory() {
        return await this._sendPromise, this._history;
    }
    async sendMessage(e, t = {}) {
        var n, r, i, s, a, o;
        await this._sendPromise;
        const c = uP(e),
            l = {
                safetySettings: null === (n = this.params) || void 0 === n ? void 0 : n.safetySettings,
                generationConfig: null === (r = this.params) || void 0 === r ? void 0 : r.generationConfig,
                tools: null === (i = this.params) || void 0 === i ? void 0 : i.tools,
                toolConfig: null === (s = this.params) || void 0 === s ? void 0 : s.toolConfig,
                systemInstruction: null === (a = this.params) || void 0 === a ? void 0 : a.systemInstruction,
                cachedContent: null === (o = this.params) || void 0 === o ? void 0 : o.cachedContent,
                contents: [...this._history, c],
            },
            u = Object.assign(Object.assign({}, this._requestOptions), t);
        let d;
        return (
            (this._sendPromise = this._sendPromise
                .then(() => cP(this._apiKey, this.model, l, u))
                .then((e) => {
                    var t;
                    if (pP(e.response)) {
                        this._history.push(c);
                        const n = Object.assign(
                            { parts: [], role: "model" },
                            null === (t = e.response.candidates) || void 0 === t ? void 0 : t[0].content
                        );
                        this._history.push(n);
                    } else {
                        ZA(e.response);
                    }
                    d = e;
                })
                .catch((e) => {
                    throw ((this._sendPromise = Promise.resolve()), e);
                })),
            await this._sendPromise,
            d
        );
    }
    async sendMessageStream(e, t = {}) {
        var n, r, i, s, a, o;
        await this._sendPromise;
        const c = uP(e),
            l = {
                safetySettings: null === (n = this.params) || void 0 === n ? void 0 : n.safetySettings,
                generationConfig: null === (r = this.params) || void 0 === r ? void 0 : r.generationConfig,
                tools: null === (i = this.params) || void 0 === i ? void 0 : i.tools,
                toolConfig: null === (s = this.params) || void 0 === s ? void 0 : s.toolConfig,
                systemInstruction: null === (a = this.params) || void 0 === a ? void 0 : a.systemInstruction,
                cachedContent: null === (o = this.params) || void 0 === o ? void 0 : o.cachedContent,
                contents: [...this._history, c],
            },
            u = Object.assign(Object.assign({}, this._requestOptions), t),
            d = oP(this._apiKey, this.model, l, u);
        return (
            (this._sendPromise = this._sendPromise
                .then(() => d)
                .catch((e) => {
                    throw new Error(fP);
                })
                .then((e) => e.response)
                .then((e) => {
                    if (pP(e)) {
                        this._history.push(c);
                        const t = Object.assign({}, e.candidates[0].content);
                        t.role || (t.role = "model"), this._history.push(t);
                    } else {
                        ZA(e);
                    }
                })
                .catch((e) => {
                    e.message;
                })),
            d
        );
    }
}
class bP {
    constructor(e, t, n = {}) {
        (this.apiKey = e),
            (this._requestOptions = n),
            t.model.includes("/") ? (this.model = t.model) : (this.model = `models/${t.model}`),
            (this.generationConfig = t.generationConfig || {}),
            (this.safetySettings = t.safetySettings || []),
            (this.tools = t.tools),
            (this.toolConfig = t.toolConfig),
            (this.systemInstruction = lP(t.systemInstruction)),
            (this.cachedContent = t.cachedContent);
    }
    async generateContent(e, t = {}) {
        var n;
        const r = dP(e),
            i = Object.assign(Object.assign({}, this._requestOptions), t);
        return cP(
            this.apiKey,
            this.model,
            Object.assign(
                {
                    generationConfig: this.generationConfig,
                    safetySettings: this.safetySettings,
                    tools: this.tools,
                    toolConfig: this.toolConfig,
                    systemInstruction: this.systemInstruction,
                    cachedContent: null === (n = this.cachedContent) || void 0 === n ? void 0 : n.name,
                },
                r
            ),
            i
        );
    }
    async generateContentStream(e, t = {}) {
        var n;
        const r = dP(e),
            i = Object.assign(Object.assign({}, this._requestOptions), t);
        return oP(
            this.apiKey,
            this.model,
            Object.assign(
                {
                    generationConfig: this.generationConfig,
                    safetySettings: this.safetySettings,
                    tools: this.tools,
                    toolConfig: this.toolConfig,
                    systemInstruction: this.systemInstruction,
                    cachedContent: null === (n = this.cachedContent) || void 0 === n ? void 0 : n.name,
                },
                r
            ),
            i
        );
    }
    startChat(e) {
        var t;
        return new gP(
            this.apiKey,
            this.model,
            Object.assign(
                {
                    generationConfig: this.generationConfig,
                    safetySettings: this.safetySettings,
                    tools: this.tools,
                    toolConfig: this.toolConfig,
                    systemInstruction: this.systemInstruction,
                    cachedContent: null === (t = this.cachedContent) || void 0 === t ? void 0 : t.name,
                },
                e
            ),
            this._requestOptions
        );
    }
    async countTokens(e, t = {}) {
        const n = (function (e, t) {
                var n;
                let r = {
                    model: null == t ? void 0 : t.model,
                    generationConfig: null == t ? void 0 : t.generationConfig,
                    safetySettings: null == t ? void 0 : t.safetySettings,
                    tools: null == t ? void 0 : t.tools,
                    toolConfig: null == t ? void 0 : t.toolConfig,
                    systemInstruction: null == t ? void 0 : t.systemInstruction,
                    cachedContent:
                        null === (n = null == t ? void 0 : t.cachedContent) || void 0 === n ? void 0 : n.name,
                    contents: [],
                };
                const i = null != e.generateContentRequest;
                if (e.contents) {
                    if (i)
                        throw new $A(
                            "CountTokensRequest must have one of contents or generateContentRequest, not both."
                        );
                    r.contents = e.contents;
                } else if (i) r = Object.assign(Object.assign({}, r), e.generateContentRequest);
                else {
                    const t = uP(e);
                    r.contents = [t];
                }
                return { generateContentRequest: r };
            })(e, {
                model: this.model,
                generationConfig: this.generationConfig,
                safetySettings: this.safetySettings,
                tools: this.tools,
                toolConfig: this.toolConfig,
                systemInstruction: this.systemInstruction,
                cachedContent: this.cachedContent,
            }),
            r = Object.assign(Object.assign({}, this._requestOptions), t);
        return (async function (e, t, n, r) {
            return (await XA(t, WA.COUNT_TOKENS, e, !1, JSON.stringify(n), r)).json();
        })(this.apiKey, this.model, n, r);
    }
    async embedContent(e, t = {}) {
        const n = (function (e) {
                if ("string" == typeof e || Array.isArray(e)) return { content: uP(e) };
                return e;
            })(e),
            r = Object.assign(Object.assign({}, this._requestOptions), t);
        return (async function (e, t, n, r) {
            return (await XA(t, WA.EMBED_CONTENT, e, !1, JSON.stringify(n), r)).json();
        })(this.apiKey, this.model, n, r);
    }
    async batchEmbedContents(e, t = {}) {
        const n = Object.assign(Object.assign({}, this._requestOptions), t);
        return (async function (e, t, n, r) {
            const i = n.requests.map((e) => Object.assign(Object.assign({}, e), { model: t }));
            return (await XA(t, WA.BATCH_EMBED_CONTENTS, e, !1, JSON.stringify({ requests: i }), r)).json();
        })(this.apiKey, this.model, e, n);
    }
}
class yP {
    constructor(e) {
        this.apiKey = e;
    }
    getGenerativeModel(e, t) {
        if (!e.model)
            throw new BA("Must provide a model name. Example: genai.getGenerativeModel({ model: 'my-model-name' })");
        return new bP(this.apiKey, e, t);
    }
    getGenerativeModelFromCachedContent(e, t, n) {
        if (!e.name) throw new $A("Cached content must contain a `name` field.");
        if (!e.model) throw new $A("Cached content must contain a `model` field.");
        const r = ["model", "systemInstruction"];
        for (const s of r)
            if ((null == t ? void 0 : t[s]) && e[s] && (null == t ? void 0 : t[s]) !== e[s]) {
                if ("model" === s) {
                    if (
                        (t.model.startsWith("models/") ? t.model.replace("models/", "") : t.model) ===
                        (e.model.startsWith("models/") ? e.model.replace("models/", "") : e.model)
                    )
                        continue;
                }
                throw new $A(
                    `Different value for "${s}" specified in modelParams (${t[s]}) and cachedContent (${e[s]})`
                );
            }
        const i = Object.assign(Object.assign({}, t), {
            model: e.model,
            tools: e.tools,
            toolConfig: e.toolConfig,
            systemInstruction: e.systemInstruction,
            cachedContent: e,
        });
        return new bP(this.apiKey, i, n);
    }
}
function wP(e, t, n, r, i) {
    if ("function" == typeof t || !t.has(e))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return t.set(e, n), n;
}
function kP(e, t, n, r) {
    if ("a" === n && !r) throw new TypeError("Private accessor was defined without a getter");
    if ("function" == typeof t ? e !== t || !r : !t.has(e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e);
}
let TP = function () {
    const { crypto: e } = globalThis;
    if (e?.randomUUID) return (TP = e.randomUUID.bind(e)), e.randomUUID();
    const t = new Uint8Array(1),
        n = e ? () => e.getRandomValues(t)[0] : () => (255 * Math.random()) & 255;
    return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (e) =>
        (+e ^ (n() & (15 >> (+e / 4)))).toString(16)
    );
};
function _P(e) {
    return (
        "object" == typeof e &&
        null !== e &&
        (("name" in e && "AbortError" === e.name) ||
            ("message" in e && String(e.message).includes("FetchRequestCanceledException")))
    );
}
const vP = (e) => {
    if (e instanceof Error) return e;
    if ("object" == typeof e && null !== e) {
        try {
            if ("[object Error]" === Object.prototype.toString.call(e)) {
                const t = new Error(e.message, e.cause ? { cause: e.cause } : {});
                return (
                    e.stack && (t.stack = e.stack),
                    e.cause && !t.cause && (t.cause = e.cause),
                    e.name && (t.name = e.name),
                    t
                );
            }
        } catch {}
        try {
            return new Error(JSON.stringify(e));
        } catch {}
    }
    return new Error(e);
};
class SP extends Error {}
class EP extends SP {
    constructor(e, t, n, r) {
        super(`${EP.makeMessage(e, t, n)}`),
            (this.status = e),
            (this.headers = r),
            (this.requestID = r?.get("x-request-id")),
            (this.error = t);
        const i = t;
        (this.code = i?.code), (this.param = i?.param), (this.type = i?.type);
    }
    static makeMessage(e, t, n) {
        const r = t?.message
            ? "string" == typeof t.message
                ? t.message
                : JSON.stringify(t.message)
            : t
              ? JSON.stringify(t)
              : n;
        return e && r ? `${e} ${r}` : e ? `${e} status code (no body)` : r || "(no status code or body)";
    }
    static generate(e, t, n, r) {
        if (!e || !r) return new IP({ message: n, cause: vP(t) });
        const i = t?.error;
        return 400 === e
            ? new AP(e, i, n, r)
            : 401 === e
              ? new PP(e, i, n, r)
              : 403 === e
                ? new OP(e, i, n, r)
                : 404 === e
                  ? new NP(e, i, n, r)
                  : 409 === e
                    ? new RP(e, i, n, r)
                    : 422 === e
                      ? new MP(e, i, n, r)
                      : 429 === e
                        ? new DP(e, i, n, r)
                        : e >= 500
                          ? new FP(e, i, n, r)
                          : new EP(e, i, n, r);
    }
}
class CP extends EP {
    constructor({ message: e } = {}) {
        super(void 0, void 0, e || "Request was aborted.", void 0);
    }
}
class IP extends EP {
    constructor({ message: e, cause: t }) {
        super(void 0, void 0, e || "Connection error.", void 0), t && (this.cause = t);
    }
}
class xP extends IP {
    constructor({ message: e } = {}) {
        super({ message: e ?? "Request timed out." });
    }
}
class AP extends EP {}
class PP extends EP {}
class OP extends EP {}
class NP extends EP {}
class RP extends EP {}
class MP extends EP {}
class DP extends EP {}
class FP extends EP {}
class LP extends SP {
    constructor() {
        super("Could not parse response content as the length limit was reached");
    }
}
class BP extends SP {
    constructor() {
        super("Could not parse response content as the request was rejected by the content filter");
    }
}
class zP extends Error {
    constructor(e) {
        super(e);
    }
}
const UP = /^[a-z][a-z0-9+.-]*:/i;
let $P = (e) => (($P = Array.isArray), $P(e)),
    VP = $P;
function WP(e) {
    return "object" != typeof e ? {} : (e ?? {});
}
function jP(e) {
    return null != e && "object" == typeof e && !Array.isArray(e);
}
const HP = (e) => new Promise((t) => setTimeout(t, e)),
    qP = "5.20.3";
const XP = () => {
    const e =
        "undefined" != typeof Deno && null != Deno.build
            ? "deno"
            : "undefined" != typeof EdgeRuntime
              ? "edge"
              : "[object process]" ===
                  Object.prototype.toString.call(void 0 !== globalThis.process ? globalThis.process : 0)
                ? "node"
                : "unknown";
    if ("deno" === e)
        return {
            "X-Stainless-Lang": "js",
            "X-Stainless-Package-Version": qP,
            "X-Stainless-OS": KP(Deno.build.os),
            "X-Stainless-Arch": GP(Deno.build.arch),
            "X-Stainless-Runtime": "deno",
            "X-Stainless-Runtime-Version":
                "string" == typeof Deno.version ? Deno.version : (Deno.version?.deno ?? "unknown"),
        };
    if ("undefined" != typeof EdgeRuntime)
        return {
            "X-Stainless-Lang": "js",
            "X-Stainless-Package-Version": qP,
            "X-Stainless-OS": "Unknown",
            "X-Stainless-Arch": `other:${EdgeRuntime}`,
            "X-Stainless-Runtime": "edge",
            "X-Stainless-Runtime-Version": globalThis.process.version,
        };
    if ("node" === e)
        return {
            "X-Stainless-Lang": "js",
            "X-Stainless-Package-Version": qP,
            "X-Stainless-OS": KP(globalThis.process.platform ?? "unknown"),
            "X-Stainless-Arch": GP(globalThis.process.arch ?? "unknown"),
            "X-Stainless-Runtime": "node",
            "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown",
        };
    const t = (function () {
        if ("undefined" == typeof navigator || !navigator) return null;
        const e = [
            { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
            { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
            { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
            { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
            { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
            { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ },
        ];
        for (const { key: t, pattern: n } of e) {
            const e = n.exec(navigator.userAgent);
            if (e) {
                return { browser: t, version: `${e[1] || 0}.${e[2] || 0}.${e[3] || 0}` };
            }
        }
        return null;
    })();
    return t
        ? {
              "X-Stainless-Lang": "js",
              "X-Stainless-Package-Version": qP,
              "X-Stainless-OS": "Unknown",
              "X-Stainless-Arch": "unknown",
              "X-Stainless-Runtime": `browser:${t.browser}`,
              "X-Stainless-Runtime-Version": t.version,
          }
        : {
              "X-Stainless-Lang": "js",
              "X-Stainless-Package-Version": qP,
              "X-Stainless-OS": "Unknown",
              "X-Stainless-Arch": "unknown",
              "X-Stainless-Runtime": "unknown",
              "X-Stainless-Runtime-Version": "unknown",
          };
};
const GP = (e) =>
        "x32" === e
            ? "x32"
            : "x86_64" === e || "x64" === e
              ? "x64"
              : "arm" === e
                ? "arm"
                : "aarch64" === e || "arm64" === e
                  ? "arm64"
                  : e
                    ? `other:${e}`
                    : "unknown",
    KP = (e) =>
        (e = e.toLowerCase()).includes("ios")
            ? "iOS"
            : "android" === e
              ? "Android"
              : "darwin" === e
                ? "MacOS"
                : "win32" === e
                  ? "Windows"
                  : "freebsd" === e
                    ? "FreeBSD"
                    : "openbsd" === e
                      ? "OpenBSD"
                      : "linux" === e
                        ? "Linux"
                        : e
                          ? `Other:${e}`
                          : "Unknown";
let YP;
function QP(...e) {
    const t = globalThis.ReadableStream;
    if (void 0 === t)
        throw new Error(
            "`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`"
        );
    return new t(...e);
}
function JP(e) {
    let t = Symbol.asyncIterator in e ? e[Symbol.asyncIterator]() : e[Symbol.iterator]();
    return QP({
        start() {},
        async pull(e) {
            const { done: n, value: r } = await t.next();
            n ? e.close() : e.enqueue(r);
        },
        async cancel() {
            await t.return?.();
        },
    });
}
function ZP(e) {
    if (e[Symbol.asyncIterator]) return e;
    const t = e.getReader();
    return {
        async next() {
            try {
                const e = await t.read();
                return e?.done && t.releaseLock(), e;
            } catch (ez) {
                throw (t.releaseLock(), ez);
            }
        },
        async return() {
            const e = t.cancel();
            return t.releaseLock(), await e, { done: !0, value: void 0 };
        },
        [Symbol.asyncIterator]() {
            return this;
        },
    };
}
const eO = ({ headers: e, body: t }) => ({
        bodyHeaders: { "content-type": "application/json" },
        body: JSON.stringify(t),
    }),
    tO = "RFC3986",
    nO = (e) => String(e),
    rO = { RFC1738: (e) => String(e).replace(/%20/g, "+"), RFC3986: nO };
let iO = (e, t) => ((iO = Object.hasOwn ?? Function.prototype.call.bind(Object.prototype.hasOwnProperty)), iO(e, t));
const sO = (() => {
        const e = [];
        for (let t = 0; t < 256; ++t) e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
        return e;
    })(),
    aO = 1024;
function oO(e, t) {
    if ($P(e)) {
        const n = [];
        for (let r = 0; r < e.length; r += 1) n.push(t(e[r]));
        return n;
    }
    return t(e);
}
const cO = {
        brackets: (e) => String(e) + "[]",
        comma: "comma",
        indices: (e, t) => String(e) + "[" + t + "]",
        repeat: (e) => String(e),
    },
    lO = function (e, t) {
        Array.prototype.push.apply(e, $P(t) ? t : [t]);
    };
let uO;
const dO = {
    addQueryPrefix: !1,
    allowDots: !1,
    allowEmptyArrays: !1,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: !1,
    delimiter: "&",
    encode: !0,
    encodeDotInKeys: !1,
    encoder: (e, t, n, r, i) => {
        if (0 === e.length) return e;
        let s = e;
        if (
            ("symbol" == typeof e ? (s = Symbol.prototype.toString.call(e)) : "string" != typeof e && (s = String(e)),
            "iso-8859-1" === n)
        )
            return escape(s).replace(/%u[0-9a-f]{4}/gi, function (e) {
                return "%26%23" + parseInt(e.slice(2), 16) + "%3B";
            });
        let a = "";
        for (let o = 0; o < s.length; o += aO) {
            const e = s.length >= aO ? s.slice(o, o + aO) : s,
                t = [];
            for (let n = 0; n < e.length; ++n) {
                let r = e.charCodeAt(n);
                45 === r ||
                46 === r ||
                95 === r ||
                126 === r ||
                (r >= 48 && r <= 57) ||
                (r >= 65 && r <= 90) ||
                (r >= 97 && r <= 122) ||
                ("RFC1738" === i && (40 === r || 41 === r))
                    ? (t[t.length] = e.charAt(n))
                    : r < 128
                      ? (t[t.length] = sO[r])
                      : r < 2048
                        ? (t[t.length] = sO[192 | (r >> 6)] + sO[128 | (63 & r)])
                        : r < 55296 || r >= 57344
                          ? (t[t.length] = sO[224 | (r >> 12)] + sO[128 | ((r >> 6) & 63)] + sO[128 | (63 & r)])
                          : ((n += 1),
                            (r = 65536 + (((1023 & r) << 10) | (1023 & e.charCodeAt(n)))),
                            (t[t.length] =
                                sO[240 | (r >> 18)] +
                                sO[128 | ((r >> 12) & 63)] +
                                sO[128 | ((r >> 6) & 63)] +
                                sO[128 | (63 & r)]));
            }
            a += t.join("");
        }
        return a;
    },
    encodeValuesOnly: !1,
    format: tO,
    formatter: nO,
    indices: !1,
    serializeDate: (e) => (uO ?? (uO = Function.prototype.call.bind(Date.prototype.toISOString)))(e),
    skipNulls: !1,
    strictNullHandling: !1,
};
const hO = {};
function mO(e, t, n, r, i, s, a, o, c, l, u, d, h, m, p, f, g, b) {
    let y = e,
        w = b,
        k = 0,
        T = !1;
    for (; void 0 !== (w = w.get(hO)) && !T; ) {
        const t = w.get(e);
        if (((k += 1), void 0 !== t)) {
            if (t === k) throw new RangeError("Cyclic object value");
            T = !0;
        }
        void 0 === w.get(hO) && (k = 0);
    }
    if (
        ("function" == typeof l
            ? (y = l(t, y))
            : y instanceof Date
              ? (y = h?.(y))
              : "comma" === n &&
                $P(y) &&
                (y = oO(y, function (e) {
                    return e instanceof Date ? h?.(e) : e;
                })),
        null === y)
    ) {
        if (s) return c && !f ? c(t, dO.encoder, g, "key", m) : t;
        y = "";
    }
    if (
        "string" == typeof (_ = y) ||
        "number" == typeof _ ||
        "boolean" == typeof _ ||
        "symbol" == typeof _ ||
        "bigint" == typeof _ ||
        (function (e) {
            return !(
                !e ||
                "object" != typeof e ||
                !(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e))
            );
        })(y)
    ) {
        if (c) {
            const e = f ? t : c(t, dO.encoder, g, "key", m);
            return [p?.(e) + "=" + p?.(c(y, dO.encoder, g, "value", m))];
        }
        return [p?.(t) + "=" + p?.(String(y))];
    }
    var _;
    const v = [];
    if (void 0 === y) return v;
    let S;
    if ("comma" === n && $P(y))
        f && c && (y = oO(y, c)), (S = [{ value: y.length > 0 ? y.join(",") || null : void 0 }]);
    else if ($P(l)) S = l;
    else {
        const e = Object.keys(y);
        S = u ? e.sort(u) : e;
    }
    const E = o ? String(t).replace(/\./g, "%2E") : String(t),
        C = r && $P(y) && 1 === y.length ? E + "[]" : E;
    if (i && $P(y) && 0 === y.length) return C + "[]";
    for (let I = 0; I < S.length; ++I) {
        const t = S[I],
            w = "object" == typeof t && void 0 !== t.value ? t.value : y[t];
        if (a && null === w) continue;
        const T = d && o ? t.replace(/\./g, "%2E") : t,
            _ = $P(y) ? ("function" == typeof n ? n(C, T) : C) : C + (d ? "." + T : "[" + T + "]");
        b.set(e, k);
        const E = new WeakMap();
        E.set(hO, b),
            lO(v, mO(w, _, n, r, i, s, a, o, "comma" === n && f && $P(y) ? null : c, l, u, d, h, m, p, f, g, E));
    }
    return v;
}
function pO(e, t = {}) {
    let n = e;
    const r = (function (e = dO) {
        if (void 0 !== e.allowEmptyArrays && "boolean" != typeof e.allowEmptyArrays)
            throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (void 0 !== e.encodeDotInKeys && "boolean" != typeof e.encodeDotInKeys)
            throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
        if (null !== e.encoder && void 0 !== e.encoder && "function" != typeof e.encoder)
            throw new TypeError("Encoder has to be a function.");
        const t = e.charset || dO.charset;
        if (void 0 !== e.charset && "utf-8" !== e.charset && "iso-8859-1" !== e.charset)
            throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        let n = tO;
        if (void 0 !== e.format) {
            if (!iO(rO, e.format)) throw new TypeError("Unknown format option provided.");
            n = e.format;
        }
        const r = rO[n];
        let i,
            s = dO.filter;
        if (
            (("function" == typeof e.filter || $P(e.filter)) && (s = e.filter),
            (i =
                e.arrayFormat && e.arrayFormat in cO
                    ? e.arrayFormat
                    : "indices" in e
                      ? e.indices
                          ? "indices"
                          : "repeat"
                      : dO.arrayFormat),
            "commaRoundTrip" in e && "boolean" != typeof e.commaRoundTrip)
        )
            throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        const a = void 0 === e.allowDots ? 1 == !!e.encodeDotInKeys || dO.allowDots : !!e.allowDots;
        return {
            addQueryPrefix: "boolean" == typeof e.addQueryPrefix ? e.addQueryPrefix : dO.addQueryPrefix,
            allowDots: a,
            allowEmptyArrays: "boolean" == typeof e.allowEmptyArrays ? !!e.allowEmptyArrays : dO.allowEmptyArrays,
            arrayFormat: i,
            charset: t,
            charsetSentinel: "boolean" == typeof e.charsetSentinel ? e.charsetSentinel : dO.charsetSentinel,
            commaRoundTrip: !!e.commaRoundTrip,
            delimiter: void 0 === e.delimiter ? dO.delimiter : e.delimiter,
            encode: "boolean" == typeof e.encode ? e.encode : dO.encode,
            encodeDotInKeys: "boolean" == typeof e.encodeDotInKeys ? e.encodeDotInKeys : dO.encodeDotInKeys,
            encoder: "function" == typeof e.encoder ? e.encoder : dO.encoder,
            encodeValuesOnly: "boolean" == typeof e.encodeValuesOnly ? e.encodeValuesOnly : dO.encodeValuesOnly,
            filter: s,
            format: n,
            formatter: r,
            serializeDate: "function" == typeof e.serializeDate ? e.serializeDate : dO.serializeDate,
            skipNulls: "boolean" == typeof e.skipNulls ? e.skipNulls : dO.skipNulls,
            sort: "function" == typeof e.sort ? e.sort : null,
            strictNullHandling: "boolean" == typeof e.strictNullHandling ? e.strictNullHandling : dO.strictNullHandling,
        };
    })(t);
    let i, s;
    "function" == typeof r.filter ? ((s = r.filter), (n = s("", n))) : $P(r.filter) && ((s = r.filter), (i = s));
    const a = [];
    if ("object" != typeof n || null === n) return "";
    const o = cO[r.arrayFormat],
        c = "comma" === o && r.commaRoundTrip;
    i || (i = Object.keys(n)), r.sort && i.sort(r.sort);
    const l = new WeakMap();
    for (let h = 0; h < i.length; ++h) {
        const e = i[h];
        (r.skipNulls && null === n[e]) ||
            lO(
                a,
                mO(
                    n[e],
                    e,
                    o,
                    c,
                    r.allowEmptyArrays,
                    r.strictNullHandling,
                    r.skipNulls,
                    r.encodeDotInKeys,
                    r.encode ? r.encoder : null,
                    r.filter,
                    r.sort,
                    r.allowDots,
                    r.serializeDate,
                    r.format,
                    r.formatter,
                    r.encodeValuesOnly,
                    r.charset,
                    l
                )
            );
    }
    const u = a.join(r.delimiter);
    let d = !0 === r.addQueryPrefix ? "?" : "";
    return (
        r.charsetSentinel && ("iso-8859-1" === r.charset ? (d += "utf8=%26%2310003%3B&") : (d += "utf8=%E2%9C%93&")),
        u.length > 0 ? d + u : ""
    );
}
let fO, gO;
function bO(e) {
    let t;
    return (fO ?? ((t = new globalThis.TextEncoder()), (fO = t.encode.bind(t))))(e);
}
function yO(e) {
    let t;
    return (gO ?? ((t = new globalThis.TextDecoder()), (gO = t.decode.bind(t))))(e);
}
var wO, kO;
class TO {
    constructor() {
        wO.set(this, void 0), kO.set(this, void 0), wP(this, wO, new Uint8Array()), wP(this, kO, null);
    }
    decode(e) {
        if (null == e) return [];
        const t = e instanceof ArrayBuffer ? new Uint8Array(e) : "string" == typeof e ? bO(e) : e;
        wP(
            this,
            wO,
            (function (e) {
                let t = 0;
                for (const i of e) t += i.length;
                const n = new Uint8Array(t);
                let r = 0;
                for (const i of e) n.set(i, r), (r += i.length);
                return n;
            })([kP(this, wO, "f"), t])
        );
        const n = [];
        let r;
        for (; null != (r = _O(kP(this, wO, "f"), kP(this, kO, "f"))); ) {
            if (r.carriage && null == kP(this, kO, "f")) {
                wP(this, kO, r.index);
                continue;
            }
            if (null != kP(this, kO, "f") && (r.index !== kP(this, kO, "f") + 1 || r.carriage)) {
                n.push(yO(kP(this, wO, "f").subarray(0, kP(this, kO, "f") - 1))),
                    wP(this, wO, kP(this, wO, "f").subarray(kP(this, kO, "f"))),
                    wP(this, kO, null);
                continue;
            }
            const e = null !== kP(this, kO, "f") ? r.preceding - 1 : r.preceding,
                t = yO(kP(this, wO, "f").subarray(0, e));
            n.push(t), wP(this, wO, kP(this, wO, "f").subarray(r.index)), wP(this, kO, null);
        }
        return n;
    }
    flush() {
        return kP(this, wO, "f").length ? this.decode("\n") : [];
    }
}
function _O(e, t) {
    for (let n = t ?? 0; n < e.length; n++) {
        if (10 === e[n]) return { preceding: n, index: n + 1, carriage: !1 };
        if (13 === e[n]) return { preceding: n, index: n + 1, carriage: !0 };
    }
    return null;
}
function vO(e) {
    for (let t = 0; t < e.length - 1; t++) {
        if (10 === e[t] && 10 === e[t + 1]) return t + 2;
        if (13 === e[t] && 13 === e[t + 1]) return t + 2;
        if (13 === e[t] && 10 === e[t + 1] && t + 3 < e.length && 13 === e[t + 2] && 10 === e[t + 3]) return t + 4;
    }
    return -1;
}
(wO = new WeakMap()),
    (kO = new WeakMap()),
    (TO.NEWLINE_CHARS = new Set(["\n", "\r"])),
    (TO.NEWLINE_REGEXP = /\r\n|[\n\r]/g);
const SO = { off: 0, error: 200, warn: 300, info: 400, debug: 500 },
    EO = (e, t, n) => {
        var r, i;
        if (e)
            return (
                (r = SO),
                (i = e),
                Object.prototype.hasOwnProperty.call(r, i)
                    ? e
                    : void PO(n).warn(
                          `${t} was set to ${JSON.stringify(e)}, expected one of ${JSON.stringify(Object.keys(SO))}`
                      )
            );
    };
function CO() {}
function IO(e, t, n) {
    return !t || SO[e] > SO[n] ? CO : t[e].bind(t);
}
const xO = { error: CO, warn: CO, info: CO, debug: CO };
let AO = new WeakMap();
function PO(e) {
    const t = e.logger,
        n = e.logLevel ?? "off";
    if (!t) return xO;
    const r = AO.get(t);
    if (r && r[0] === n) return r[1];
    const i = { error: IO("error", t, n), warn: IO("warn", t, n), info: IO("info", t, n), debug: IO("debug", t, n) };
    return AO.set(t, [n, i]), i;
}
const OO = (e) => (
    e.options && ((e.options = { ...e.options }), delete e.options.headers),
    e.headers &&
        (e.headers = Object.fromEntries(
            (e.headers instanceof Headers ? [...e.headers] : Object.entries(e.headers)).map(([e, t]) => [
                e,
                "authorization" === e.toLowerCase() || "cookie" === e.toLowerCase() || "set-cookie" === e.toLowerCase()
                    ? "***"
                    : t,
            ])
        )),
    "retryOfRequestLogID" in e &&
        (e.retryOfRequestLogID && (e.retryOf = e.retryOfRequestLogID), delete e.retryOfRequestLogID),
    e
);
var NO, RO, MO;
class DO {
    constructor(e, t, n) {
        (this.iterator = e), NO.set(this, void 0), (this.controller = t), wP(this, NO, n);
    }
    static fromSSEResponse(e, t, n) {
        let r = !1;
        const i = n ? PO(n) : console;
        return new DO(
            async function* () {
                if (r) throw new SP("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
                r = !0;
                let n = !1;
                try {
                    for await (const r of (async function* (e, t) {
                        if (!e.body) {
                            if (
                                (t.abort(),
                                void 0 !== globalThis.navigator && "ReactNative" === globalThis.navigator.product)
                            )
                                throw new SP(
                                    "The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api"
                                );
                            throw new SP("Attempted to iterate over a response with no body");
                        }
                        const n = new FO(),
                            r = new TO(),
                            i = ZP(e.body);
                        for await (const s of (async function* (e) {
                            let t = new Uint8Array();
                            for await (const n of e) {
                                if (null == n) continue;
                                const e =
                                    n instanceof ArrayBuffer ? new Uint8Array(n) : "string" == typeof n ? bO(n) : n;
                                let r,
                                    i = new Uint8Array(t.length + e.length);
                                for (i.set(t), i.set(e, t.length), t = i; -1 !== (r = vO(t)); )
                                    yield t.slice(0, r), (t = t.slice(r));
                            }
                            t.length > 0 && (yield t);
                        })(i))
                            for (const e of r.decode(s)) {
                                const t = n.decode(e);
                                t && (yield t);
                            }
                        for (const s of r.flush()) {
                            const e = n.decode(s);
                            e && (yield e);
                        }
                    })(e, t))
                        if (!n)
                            if (r.data.startsWith("[DONE]")) n = !0;
                            else if (null !== r.event && r.event.startsWith("thread.")) {
                                let e;
                                try {
                                    e = JSON.parse(r.data);
                                } catch (ez) {
                                    throw ez;
                                }
                                if ("error" == r.event) throw new EP(void 0, e.error, e.message, void 0);
                                yield { event: r.event, data: e };
                            } else {
                                let t;
                                try {
                                    t = JSON.parse(r.data);
                                } catch (ez) {
                                    throw (
                                        (i.error("Could not parse message into JSON:", r.data),
                                        i.error("From chunk:", r.raw),
                                        ez)
                                    );
                                }
                                if (t && t.error) throw new EP(void 0, t.error, void 0, e.headers);
                                yield t;
                            }
                    n = !0;
                } catch (ez) {
                    if (_P(ez)) return;
                    throw ez;
                } finally {
                    n || t.abort();
                }
            },
            t,
            n
        );
    }
    static fromReadableStream(e, t, n) {
        let r = !1;
        return new DO(
            async function* () {
                if (r) throw new SP("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
                r = !0;
                let n = !1;
                try {
                    for await (const t of (async function* () {
                        const t = new TO(),
                            n = ZP(e);
                        for await (const e of n) for (const n of t.decode(e)) yield n;
                        for (const e of t.flush()) yield e;
                    })())
                        n || (t && (yield JSON.parse(t)));
                    n = !0;
                } catch (ez) {
                    if (_P(ez)) return;
                    throw ez;
                } finally {
                    n || t.abort();
                }
            },
            t,
            n
        );
    }
    [((NO = new WeakMap()), Symbol.asyncIterator)]() {
        return this.iterator();
    }
    tee() {
        const e = [],
            t = [],
            n = this.iterator(),
            r = (r) => ({
                next: () => {
                    if (0 === r.length) {
                        const r = n.next();
                        e.push(r), t.push(r);
                    }
                    return r.shift();
                },
            });
        return [
            new DO(() => r(e), this.controller, kP(this, NO, "f")),
            new DO(() => r(t), this.controller, kP(this, NO, "f")),
        ];
    }
    toReadableStream() {
        const e = this;
        let t;
        return QP({
            async start() {
                t = e[Symbol.asyncIterator]();
            },
            async pull(e) {
                try {
                    const { value: n, done: r } = await t.next();
                    if (r) return e.close();
                    const i = bO(JSON.stringify(n) + "\n");
                    e.enqueue(i);
                } catch (n) {
                    e.error(n);
                }
            },
            async cancel() {
                await t.return?.();
            },
        });
    }
}
class FO {
    constructor() {
        (this.event = null), (this.data = []), (this.chunks = []);
    }
    decode(e) {
        if ((e.endsWith("\r") && (e = e.substring(0, e.length - 1)), !e)) {
            if (!this.event && !this.data.length) return null;
            const e = { event: this.event, data: this.data.join("\n"), raw: this.chunks };
            return (this.event = null), (this.data = []), (this.chunks = []), e;
        }
        if ((this.chunks.push(e), e.startsWith(":"))) return null;
        let [t, n, r] = (function (e, t) {
            const n = e.indexOf(t);
            if (-1 !== n) return [e.substring(0, n), t, e.substring(n + t.length)];
            return [e, "", ""];
        })(e, ":");
        return (
            r.startsWith(" ") && (r = r.substring(1)),
            "event" === t ? (this.event = r) : "data" === t && this.data.push(r),
            null
        );
    }
}
async function LO(e, t) {
    const { response: n, requestLogID: r, retryOfRequestLogID: i, startTime: s } = t,
        a = await (async () => {
            if (t.options.stream)
                return (
                    PO(e).debug("response", n.status, n.url, n.headers, n.body),
                    t.options.__streamClass
                        ? t.options.__streamClass.fromSSEResponse(n, t.controller, e)
                        : DO.fromSSEResponse(n, t.controller, e)
                );
            if (204 === n.status) return null;
            if (t.options.__binaryResponse) return n;
            const r = n.headers.get("content-type"),
                i = r?.split(";")[0]?.trim();
            if (i?.includes("application/json") || i?.endsWith("+json")) {
                return BO(await n.json(), n);
            }
            return await n.text();
        })();
    return (
        PO(e).debug(
            `[${r}] response parsed`,
            OO({ retryOfRequestLogID: i, url: n.url, status: n.status, body: a, durationMs: Date.now() - s })
        ),
        a
    );
}
function BO(e, t) {
    return !e || "object" != typeof e || Array.isArray(e)
        ? e
        : Object.defineProperty(e, "_request_id", { value: t.headers.get("x-request-id"), enumerable: !1 });
}
class zO extends Promise {
    constructor(e, t, n = LO) {
        super((e) => {
            e(null);
        }),
            (this.responsePromise = t),
            (this.parseResponse = n),
            RO.set(this, void 0),
            wP(this, RO, e);
    }
    _thenUnwrap(e) {
        return new zO(kP(this, RO, "f"), this.responsePromise, async (t, n) =>
            BO(e(await this.parseResponse(t, n), n), n.response)
        );
    }
    asResponse() {
        return this.responsePromise.then((e) => e.response);
    }
    async withResponse() {
        const [e, t] = await Promise.all([this.parse(), this.asResponse()]);
        return { data: e, response: t, request_id: t.headers.get("x-request-id") };
    }
    parse() {
        return (
            this.parsedPromise ||
                (this.parsedPromise = this.responsePromise.then((e) => this.parseResponse(kP(this, RO, "f"), e))),
            this.parsedPromise
        );
    }
    then(e, t) {
        return this.parse().then(e, t);
    }
    catch(e) {
        return this.parse().catch(e);
    }
    finally(e) {
        return this.parse().finally(e);
    }
}
RO = new WeakMap();
class UO {
    constructor(e, t, n, r) {
        MO.set(this, void 0), wP(this, MO, e), (this.options = r), (this.response = t), (this.body = n);
    }
    hasNextPage() {
        return !!this.getPaginatedItems().length && null != this.nextPageRequestOptions();
    }
    async getNextPage() {
        const e = this.nextPageRequestOptions();
        if (!e) throw new SP("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
        return await kP(this, MO, "f").requestAPIList(this.constructor, e);
    }
    async *iterPages() {
        let e = this;
        for (yield e; e.hasNextPage(); ) (e = await e.getNextPage()), yield e;
    }
    async *[((MO = new WeakMap()), Symbol.asyncIterator)]() {
        for await (const e of this.iterPages()) for (const t of e.getPaginatedItems()) yield t;
    }
}
class $O extends zO {
    constructor(e, t, n) {
        super(e, t, async (e, t) => new n(e, t.response, await LO(e, t), t.options));
    }
    async *[Symbol.asyncIterator]() {
        const e = await this;
        for await (const t of e) yield t;
    }
}
class VO extends UO {
    constructor(e, t, n, r) {
        super(e, t, n, r), (this.data = n.data || []), (this.object = n.object);
    }
    getPaginatedItems() {
        return this.data ?? [];
    }
    nextPageRequestOptions() {
        return null;
    }
}
class WO extends UO {
    constructor(e, t, n, r) {
        super(e, t, n, r), (this.data = n.data || []), (this.has_more = n.has_more || !1);
    }
    getPaginatedItems() {
        return this.data ?? [];
    }
    hasNextPage() {
        return !1 !== this.has_more && super.hasNextPage();
    }
    nextPageRequestOptions() {
        const e = this.getPaginatedItems(),
            t = e[e.length - 1]?.id;
        return t ? { ...this.options, query: { ...WP(this.options.query), after: t } } : null;
    }
}
class jO extends UO {
    constructor(e, t, n, r) {
        super(e, t, n, r),
            (this.data = n.data || []),
            (this.has_more = n.has_more || !1),
            (this.last_id = n.last_id || "");
    }
    getPaginatedItems() {
        return this.data ?? [];
    }
    hasNextPage() {
        return !1 !== this.has_more && super.hasNextPage();
    }
    nextPageRequestOptions() {
        const e = this.last_id;
        return e ? { ...this.options, query: { ...WP(this.options.query), after: e } } : null;
    }
}
const HO = () => {
    if ("undefined" == typeof File) {
        const { process: e } = globalThis,
            t = "string" == typeof e?.versions?.node && parseInt(e.versions.node.split(".")) < 20;
        throw new Error(
            "`File` is not defined as a global, which is required for file uploads." +
                (t ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : "")
        );
    }
};
function qO(e, t, n) {
    return HO(), new File(e, t ?? "unknown_file", n);
}
function XO(e) {
    return (
        (
            ("object" == typeof e &&
                null !== e &&
                (("name" in e && e.name && String(e.name)) ||
                    ("url" in e && e.url && String(e.url)) ||
                    ("filename" in e && e.filename && String(e.filename)) ||
                    ("path" in e && e.path && String(e.path)))) ||
            ""
        )
            .split(/[\\/]/)
            .pop() || void 0
    );
}
const GO = (e) => null != e && "object" == typeof e && "function" == typeof e[Symbol.asyncIterator],
    KO = async (e, t) => ({ ...e, body: await QO(e.body, t) }),
    YO = new WeakMap();
const QO = async (e, t) => {
        if (
            !(await (function (e) {
                const t = "function" == typeof e ? e : e.fetch,
                    n = YO.get(t);
                if (n) return n;
                const r = (async () => {
                    try {
                        const e = "Response" in t ? t.Response : (await t("data:,")).constructor,
                            n = new FormData();
                        return n.toString() !== (await new e(n).text());
                    } catch {
                        return !0;
                    }
                })();
                return YO.set(t, r), r;
            })(t))
        )
            throw new TypeError(
                "The provided fetch function does not support file uploads with the current global FormData class."
            );
        const n = new FormData();
        return await Promise.all(Object.entries(e || {}).map(([e, t]) => JO(n, e, t))), n;
    },
    JO = async (e, t, n) => {
        if (void 0 !== n) {
            if (null == n)
                throw new TypeError(
                    `Received null for "${t}"; to pass null in FormData, you must use the string 'null'`
                );
            if ("string" == typeof n || "number" == typeof n || "boolean" == typeof n) e.append(t, String(n));
            else if (n instanceof Response) e.append(t, qO([await n.blob()], XO(n)));
            else if (GO(n)) e.append(t, qO([await new Response(JP(n)).blob()], XO(n)));
            else if (((e) => e instanceof Blob && "name" in e)(n)) e.append(t, n, XO(n));
            else if (Array.isArray(n)) await Promise.all(n.map((n) => JO(e, t + "[]", n)));
            else {
                if ("object" != typeof n)
                    throw new TypeError(
                        `Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${n} instead`
                    );
                await Promise.all(Object.entries(n).map(([n, r]) => JO(e, `${t}[${n}]`, r)));
            }
        }
    },
    ZO = (e) =>
        null != e &&
        "object" == typeof e &&
        "number" == typeof e.size &&
        "string" == typeof e.type &&
        "function" == typeof e.text &&
        "function" == typeof e.slice &&
        "function" == typeof e.arrayBuffer;
async function eN(e) {
    let t = [];
    if ("string" == typeof e || ArrayBuffer.isView(e) || e instanceof ArrayBuffer) t.push(e);
    else if (ZO(e)) t.push(e instanceof Blob ? e : await e.arrayBuffer());
    else {
        if (!GO(e)) {
            const t = e?.constructor?.name;
            throw new Error(
                `Unexpected data type: ${typeof e}${t ? `; constructor: ${t}` : ""}${(function (e) {
                    if ("object" != typeof e || null === e) return "";
                    const t = Object.getOwnPropertyNames(e);
                    return `; props: [${t.map((e) => `"${e}"`).join(", ")}]`;
                })(e)}`
            );
        }
        for await (const n of e) t.push(...(await eN(n)));
    }
    return t;
}
class tN {
    constructor(e) {
        this._client = e;
    }
}
function nN(e) {
    return e.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
const rN = Object.freeze(Object.create(null)),
    iN = ((e = nN) =>
        function (t, ...n) {
            if (1 === t.length) return t[0];
            let r = !1;
            const i = [],
                s = t.reduce((t, s, a) => {
                    /[?#]/.test(s) && (r = !0);
                    const o = n[a];
                    let c = (r ? encodeURIComponent : e)("" + o);
                    return (
                        a !== n.length &&
                            (null == o ||
                                ("object" == typeof o &&
                                    o.toString ===
                                        Object.getPrototypeOf(Object.getPrototypeOf(o.hasOwnProperty ?? rN) ?? rN)
                                            ?.toString)) &&
                            ((c = o + ""),
                            i.push({
                                start: t.length + s.length,
                                length: c.length,
                                error: `Value of type ${Object.prototype.toString.call(o).slice(8, -1)} is not a valid path parameter`,
                            })),
                        t + s + (a === n.length ? "" : c)
                    );
                }, ""),
                a = s.split(/[?#]/, 1)[0],
                o = new RegExp("(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)", "gi");
            let c;
            for (; null !== (c = o.exec(a)); )
                i.push({
                    start: c.index,
                    length: c[0].length,
                    error: `Value "${c[0]}" can't be safely passed as a path parameter`,
                });
            if ((i.sort((e, t) => e.start - t.start), i.length > 0)) {
                let e = 0;
                const t = i.reduce((t, n) => {
                    const r = " ".repeat(n.start - e),
                        i = "^".repeat(n.length);
                    return (e = n.start + n.length), t + r + i;
                }, "");
                throw new SP(
                    `Path parameters result in path with invalid segments:\n${i.map((e) => e.error).join("\n")}\n${s}\n${t}`
                );
            }
            return s;
        })(nN);
let sN = class extends tN {
    list(e, t = {}, n) {
        return this._client.getAPIList(iN`/chat/completions/${e}/messages`, WO, { query: t, ...n });
    }
};
function aN(e) {
    return void 0 !== e && "function" in e && void 0 !== e.function;
}
function oN(e) {
    return "auto-parseable-response-format" === e?.$brand;
}
function cN(e) {
    return "auto-parseable-tool" === e?.$brand;
}
function lN(e, t) {
    const n = e.choices.map((e) => {
        if ("length" === e.finish_reason) throw new LP();
        if ("content_filter" === e.finish_reason) throw new BP();
        return (
            mN(e.message.tool_calls),
            {
                ...e,
                message: {
                    ...e.message,
                    ...(e.message.tool_calls
                        ? {
                              tool_calls:
                                  e.message.tool_calls?.map((e) =>
                                      (function (e, t) {
                                          const n = e.tools?.find((e) => aN(e) && e.function?.name === t.function.name);
                                          return {
                                              ...t,
                                              function: {
                                                  ...t.function,
                                                  parsed_arguments: cN(n)
                                                      ? n.$parseRaw(t.function.arguments)
                                                      : n?.function.strict
                                                        ? JSON.parse(t.function.arguments)
                                                        : null,
                                              },
                                          };
                                      })(t, e)
                                  ) ?? void 0,
                          }
                        : void 0),
                    parsed: e.message.content && !e.message.refusal ? uN(t, e.message.content) : null,
                },
            }
        );
    });
    return { ...e, choices: n };
}
function uN(e, t) {
    if ("json_schema" !== e.response_format?.type) return null;
    if ("json_schema" === e.response_format?.type) {
        if ("$parseRaw" in e.response_format) {
            return e.response_format.$parseRaw(t);
        }
        return JSON.parse(t);
    }
    return null;
}
function dN(e, t) {
    if (!e || !("tools" in e) || !e.tools) return !1;
    const n = e.tools?.find((e) => aN(e) && e.function?.name === t.function.name);
    return aN(n) && (cN(n) || n?.function.strict || !1);
}
function hN(e) {
    return (
        !!oN(e.response_format) ||
        (e.tools?.some((e) => cN(e) || ("function" === e.type && !0 === e.function.strict)) ?? !1)
    );
}
function mN(e) {
    for (const t of e || [])
        if ("function" !== t.type)
            throw new SP(`Currently only \`function\` tool calls are supported; Received \`${t.type}\``);
}
const pN = (e) => "assistant" === e?.role,
    fN = (e) => "tool" === e?.role;
var gN, bN, yN, wN, kN, TN, _N, vN, SN, EN, CN, IN, xN, AN, PN, ON, NN, RN, MN, DN, FN;
class LN {
    constructor() {
        gN.add(this),
            (this.controller = new AbortController()),
            bN.set(this, void 0),
            yN.set(this, () => {}),
            wN.set(this, () => {}),
            kN.set(this, void 0),
            TN.set(this, () => {}),
            _N.set(this, () => {}),
            vN.set(this, {}),
            SN.set(this, !1),
            EN.set(this, !1),
            CN.set(this, !1),
            IN.set(this, !1),
            wP(
                this,
                bN,
                new Promise((e, t) => {
                    wP(this, yN, e), wP(this, wN, t);
                })
            ),
            wP(
                this,
                kN,
                new Promise((e, t) => {
                    wP(this, TN, e), wP(this, _N, t);
                })
            ),
            kP(this, bN, "f").catch(() => {}),
            kP(this, kN, "f").catch(() => {});
    }
    _run(e) {
        setTimeout(() => {
            e().then(
                () => {
                    this._emitFinal(), this._emit("end");
                },
                kP(this, gN, "m", xN).bind(this)
            );
        }, 0);
    }
    _connected() {
        this.ended || (kP(this, yN, "f").call(this), this._emit("connect"));
    }
    get ended() {
        return kP(this, SN, "f");
    }
    get errored() {
        return kP(this, EN, "f");
    }
    get aborted() {
        return kP(this, CN, "f");
    }
    abort() {
        this.controller.abort();
    }
    on(e, t) {
        return (kP(this, vN, "f")[e] || (kP(this, vN, "f")[e] = [])).push({ listener: t }), this;
    }
    off(e, t) {
        const n = kP(this, vN, "f")[e];
        if (!n) return this;
        const r = n.findIndex((e) => e.listener === t);
        return r >= 0 && n.splice(r, 1), this;
    }
    once(e, t) {
        return (kP(this, vN, "f")[e] || (kP(this, vN, "f")[e] = [])).push({ listener: t, once: !0 }), this;
    }
    emitted(e) {
        return new Promise((t, n) => {
            wP(this, IN, !0), "error" !== e && this.once("error", n), this.once(e, t);
        });
    }
    async done() {
        wP(this, IN, !0), await kP(this, kN, "f");
    }
    _emit(e, ...t) {
        if (kP(this, SN, "f")) return;
        "end" === e && (wP(this, SN, !0), kP(this, TN, "f").call(this));
        const n = kP(this, vN, "f")[e];
        if (
            (n && ((kP(this, vN, "f")[e] = n.filter((e) => !e.once)), n.forEach(({ listener: e }) => e(...t))),
            "abort" === e)
        ) {
            const e = t[0];
            return (
                kP(this, IN, "f") || n?.length || Promise.reject(e),
                kP(this, wN, "f").call(this, e),
                kP(this, _N, "f").call(this, e),
                void this._emit("end")
            );
        }
        if ("error" === e) {
            const e = t[0];
            kP(this, IN, "f") || n?.length || Promise.reject(e),
                kP(this, wN, "f").call(this, e),
                kP(this, _N, "f").call(this, e),
                this._emit("end");
        }
    }
    _emitFinal() {}
}
function BN(e) {
    return "function" == typeof e.parse;
}
(bN = new WeakMap()),
    (yN = new WeakMap()),
    (wN = new WeakMap()),
    (kN = new WeakMap()),
    (TN = new WeakMap()),
    (_N = new WeakMap()),
    (vN = new WeakMap()),
    (SN = new WeakMap()),
    (EN = new WeakMap()),
    (CN = new WeakMap()),
    (IN = new WeakMap()),
    (gN = new WeakSet()),
    (xN = function (e) {
        if ((wP(this, EN, !0), e instanceof Error && "AbortError" === e.name && (e = new CP()), e instanceof CP))
            return wP(this, CN, !0), this._emit("abort", e);
        if (e instanceof SP) return this._emit("error", e);
        if (e instanceof Error) {
            const t = new SP(e.message);
            return (t.cause = e), this._emit("error", t);
        }
        return this._emit("error", new SP(String(e)));
    });
const zN = 10;
class UN extends LN {
    constructor() {
        super(...arguments), AN.add(this), (this._chatCompletions = []), (this.messages = []);
    }
    _addChatCompletion(e) {
        this._chatCompletions.push(e), this._emit("chatCompletion", e);
        const t = e.choices[0]?.message;
        return t && this._addMessage(t), e;
    }
    _addMessage(e, t = !0) {
        if (("content" in e || (e.content = null), this.messages.push(e), t))
            if ((this._emit("message", e), fN(e) && e.content)) this._emit("functionToolCallResult", e.content);
            else if (pN(e) && e.tool_calls)
                for (const n of e.tool_calls) "function" === n.type && this._emit("functionToolCall", n.function);
    }
    async finalChatCompletion() {
        await this.done();
        const e = this._chatCompletions[this._chatCompletions.length - 1];
        if (!e) throw new SP("stream ended without producing a ChatCompletion");
        return e;
    }
    async finalContent() {
        return await this.done(), kP(this, AN, "m", PN).call(this);
    }
    async finalMessage() {
        return await this.done(), kP(this, AN, "m", ON).call(this);
    }
    async finalFunctionToolCall() {
        return await this.done(), kP(this, AN, "m", NN).call(this);
    }
    async finalFunctionToolCallResult() {
        return await this.done(), kP(this, AN, "m", RN).call(this);
    }
    async totalUsage() {
        return await this.done(), kP(this, AN, "m", MN).call(this);
    }
    allChatCompletions() {
        return [...this._chatCompletions];
    }
    _emitFinal() {
        const e = this._chatCompletions[this._chatCompletions.length - 1];
        e && this._emit("finalChatCompletion", e);
        const t = kP(this, AN, "m", ON).call(this);
        t && this._emit("finalMessage", t);
        const n = kP(this, AN, "m", PN).call(this);
        n && this._emit("finalContent", n);
        const r = kP(this, AN, "m", NN).call(this);
        r && this._emit("finalFunctionToolCall", r);
        const i = kP(this, AN, "m", RN).call(this);
        null != i && this._emit("finalFunctionToolCallResult", i),
            this._chatCompletions.some((e) => e.usage) && this._emit("totalUsage", kP(this, AN, "m", MN).call(this));
    }
    async _createChatCompletion(e, t, n) {
        const r = n?.signal;
        r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())),
            kP(this, AN, "m", DN).call(this, t);
        const i = await e.chat.completions.create({ ...t, stream: !1 }, { ...n, signal: this.controller.signal });
        return this._connected(), this._addChatCompletion(lN(i, t));
    }
    async _runChatCompletion(e, t, n) {
        for (const r of t.messages) this._addMessage(r, !1);
        return await this._createChatCompletion(e, t, n);
    }
    async _runTools(e, t, n) {
        const r = "tool",
            { tool_choice: i = "auto", stream: s, ...a } = t,
            o = "string" != typeof i && "function" === i.type && i?.function?.name,
            { maxChatCompletions: c = zN } = n || {},
            l = t.tools.map((e) => {
                if (cN(e)) {
                    if (!e.$callback)
                        throw new SP("Tool given to `.runTools()` that does not have an associated function");
                    return {
                        type: "function",
                        function: {
                            function: e.$callback,
                            name: e.function.name,
                            description: e.function.description || "",
                            parameters: e.function.parameters,
                            parse: e.$parseRaw,
                            strict: !0,
                        },
                    };
                }
                return e;
            }),
            u = {};
        for (const m of l) "function" === m.type && (u[m.function.name || m.function.function.name] = m.function);
        const d =
            "tools" in t
                ? l.map((e) =>
                      "function" === e.type
                          ? {
                                type: "function",
                                function: {
                                    name: e.function.name || e.function.function.name,
                                    parameters: e.function.parameters,
                                    description: e.function.description,
                                    strict: e.function.strict,
                                },
                            }
                          : e
                  )
                : void 0;
        for (const m of t.messages) this._addMessage(m, !1);
        for (let m = 0; m < c; ++m) {
            const t = await this._createChatCompletion(
                    e,
                    { ...a, tool_choice: i, tools: d, messages: [...this.messages] },
                    n
                ),
                s = t.choices[0]?.message;
            if (!s) throw new SP("missing message in ChatCompletion response");
            if (!s.tool_calls?.length) return;
            for (const e of s.tool_calls) {
                if ("function" !== e.type) continue;
                const t = e.id,
                    { name: n, arguments: i } = e.function,
                    s = u[n];
                if (!s) {
                    const e = `Invalid tool_call: ${JSON.stringify(n)}. Available options are: ${Object.keys(u)
                        .map((e) => JSON.stringify(e))
                        .join(", ")}. Please try again`;
                    this._addMessage({ role: r, tool_call_id: t, content: e });
                    continue;
                }
                if (o && o !== n) {
                    const e = `Invalid tool_call: ${JSON.stringify(n)}. ${JSON.stringify(o)} requested. Please try again`;
                    this._addMessage({ role: r, tool_call_id: t, content: e });
                    continue;
                }
                let a;
                try {
                    a = BN(s) ? await s.parse(i) : i;
                } catch (h) {
                    const e = h instanceof Error ? h.message : String(h);
                    this._addMessage({ role: r, tool_call_id: t, content: e });
                    continue;
                }
                const c = await s.function(a, this),
                    l = kP(this, AN, "m", FN).call(this, c);
                if ((this._addMessage({ role: r, tool_call_id: t, content: l }), o)) return;
            }
        }
    }
}
(AN = new WeakSet()),
    (PN = function () {
        return kP(this, AN, "m", ON).call(this).content ?? null;
    }),
    (ON = function () {
        let e = this.messages.length;
        for (; e-- > 0; ) {
            const t = this.messages[e];
            if (pN(t)) {
                return { ...t, content: t.content ?? null, refusal: t.refusal ?? null };
            }
        }
        throw new SP("stream ended without producing a ChatCompletionMessage with role=assistant");
    }),
    (NN = function () {
        for (let e = this.messages.length - 1; e >= 0; e--) {
            const t = this.messages[e];
            if (pN(t) && t?.tool_calls?.length)
                return t.tool_calls.filter((e) => "function" === e.type).at(-1)?.function;
        }
    }),
    (RN = function () {
        for (let e = this.messages.length - 1; e >= 0; e--) {
            const t = this.messages[e];
            if (
                fN(t) &&
                null != t.content &&
                "string" == typeof t.content &&
                this.messages.some(
                    (e) =>
                        "assistant" === e.role &&
                        e.tool_calls?.some((e) => "function" === e.type && e.id === t.tool_call_id)
                )
            )
                return t.content;
        }
    }),
    (MN = function () {
        const e = { completion_tokens: 0, prompt_tokens: 0, total_tokens: 0 };
        for (const { usage: t } of this._chatCompletions)
            t &&
                ((e.completion_tokens += t.completion_tokens),
                (e.prompt_tokens += t.prompt_tokens),
                (e.total_tokens += t.total_tokens));
        return e;
    }),
    (DN = function (e) {
        if (null != e.n && e.n > 1)
            throw new SP(
                "ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly."
            );
    }),
    (FN = function (e) {
        return "string" == typeof e ? e : void 0 === e ? "undefined" : JSON.stringify(e);
    });
class $N extends UN {
    static runTools(e, t, n) {
        const r = new $N(),
            i = { ...n, headers: { ...n?.headers, "X-Stainless-Helper-Method": "runTools" } };
        return r._run(() => r._runTools(e, t, i)), r;
    }
    _addMessage(e, t = !0) {
        super._addMessage(e, t), pN(e) && e.content && this._emit("content", e.content);
    }
}
const VN = 1,
    WN = 2,
    jN = 4,
    HN = 8,
    qN = 16,
    XN = 32,
    GN = 64,
    KN = 128,
    YN = 256,
    QN = 511;
class JN extends Error {}
class ZN extends Error {}
const eR = (e, t) => {
        const n = e.length;
        let r = 0;
        const i = (e) => {
                throw new JN(`${e} at position ${r}`);
            },
            s = (e) => {
                throw new ZN(`${e} at position ${r}`);
            },
            a = () => (
                d(),
                r >= n && i("Unexpected end of input"),
                '"' === e[r]
                    ? o()
                    : "{" === e[r]
                      ? c()
                      : "[" === e[r]
                        ? l()
                        : "null" === e.substring(r, r + 4) || (qN & t && n - r < 4 && "null".startsWith(e.substring(r)))
                          ? ((r += 4), null)
                          : "true" === e.substring(r, r + 4) ||
                              (XN & t && n - r < 4 && "true".startsWith(e.substring(r)))
                            ? ((r += 4), !0)
                            : "false" === e.substring(r, r + 5) ||
                                (XN & t && n - r < 5 && "false".startsWith(e.substring(r)))
                              ? ((r += 5), !1)
                              : "Infinity" === e.substring(r, r + 8) ||
                                  (KN & t && n - r < 8 && "Infinity".startsWith(e.substring(r)))
                                ? ((r += 8), 1 / 0)
                                : "-Infinity" === e.substring(r, r + 9) ||
                                    (YN & t && 1 < n - r && n - r < 9 && "-Infinity".startsWith(e.substring(r)))
                                  ? ((r += 9), -1 / 0)
                                  : "NaN" === e.substring(r, r + 3) ||
                                      (GN & t && n - r < 3 && "NaN".startsWith(e.substring(r)))
                                    ? ((r += 3), NaN)
                                    : u()
            ),
            o = () => {
                const a = r;
                let o = !1;
                for (r++; r < n && ('"' !== e[r] || (o && "\\" === e[r - 1])); ) (o = "\\" === e[r] && !o), r++;
                if ('"' == e.charAt(r))
                    try {
                        return JSON.parse(e.substring(a, ++r - Number(o)));
                    } catch (ez) {
                        s(String(ez));
                    }
                else if (VN & t)
                    try {
                        return JSON.parse(e.substring(a, r - Number(o)) + '"');
                    } catch (ez) {
                        return JSON.parse(e.substring(a, e.lastIndexOf("\\")) + '"');
                    }
                i("Unterminated string literal");
            },
            c = () => {
                r++, d();
                const s = {};
                try {
                    for (; "}" !== e[r]; ) {
                        if ((d(), r >= n && HN & t)) return s;
                        const i = o();
                        d(), r++;
                        try {
                            const e = a();
                            Object.defineProperty(s, i, { value: e, writable: !0, enumerable: !0, configurable: !0 });
                        } catch (ez) {
                            if (HN & t) return s;
                            throw ez;
                        }
                        d(), "," === e[r] && r++;
                    }
                } catch (ez) {
                    if (HN & t) return s;
                    i("Expected '}' at end of object");
                }
                return r++, s;
            },
            l = () => {
                r++;
                const n = [];
                try {
                    for (; "]" !== e[r]; ) n.push(a()), d(), "," === e[r] && r++;
                } catch (ez) {
                    if (jN & t) return n;
                    i("Expected ']' at end of array");
                }
                return r++, n;
            },
            u = () => {
                if (0 === r) {
                    "-" === e && WN & t && i("Not sure what '-' is");
                    try {
                        return JSON.parse(e);
                    } catch (ez) {
                        if (WN & t)
                            try {
                                return "." === e[e.length - 1]
                                    ? JSON.parse(e.substring(0, e.lastIndexOf(".")))
                                    : JSON.parse(e.substring(0, e.lastIndexOf("e")));
                            } catch (o) {}
                        s(String(ez));
                    }
                }
                const a = r;
                for ("-" === e[r] && r++; e[r] && !",]}".includes(e[r]); ) r++;
                r != n || WN & t || i("Unterminated number literal");
                try {
                    return JSON.parse(e.substring(a, r));
                } catch (ez) {
                    "-" === e.substring(a, r) && WN & t && i("Not sure what '-' is");
                    try {
                        return JSON.parse(e.substring(a, e.lastIndexOf("e")));
                    } catch (o) {
                        s(String(o));
                    }
                }
            },
            d = () => {
                for (; r < n && " \n\r\t".includes(e[r]); ) r++;
            };
        return a();
    },
    tR = (e) =>
        (function (e, t = QN) {
            if ("string" != typeof e) throw new TypeError("expecting str, got " + typeof e);
            if (!e.trim()) throw new Error(`${e} is empty`);
            return eR(e.trim(), t);
        })(e, QN ^ WN);
var nR, rR, iR, sR, aR, oR, cR, lR, uR, dR, hR, mR;
class pR extends UN {
    constructor(e) {
        super(),
            nR.add(this),
            rR.set(this, void 0),
            iR.set(this, void 0),
            sR.set(this, void 0),
            wP(this, rR, e),
            wP(this, iR, []);
    }
    get currentChatCompletionSnapshot() {
        return kP(this, sR, "f");
    }
    static fromReadableStream(e) {
        const t = new pR(null);
        return t._run(() => t._fromReadableStream(e)), t;
    }
    static createChatCompletion(e, t, n) {
        const r = new pR(t);
        return (
            r._run(() =>
                r._runChatCompletion(
                    e,
                    { ...t, stream: !0 },
                    { ...n, headers: { ...n?.headers, "X-Stainless-Helper-Method": "stream" } }
                )
            ),
            r
        );
    }
    async _createChatCompletion(e, t, n) {
        super._createChatCompletion;
        const r = n?.signal;
        r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())),
            kP(this, nR, "m", aR).call(this);
        const i = await e.chat.completions.create({ ...t, stream: !0 }, { ...n, signal: this.controller.signal });
        this._connected();
        for await (const s of i) kP(this, nR, "m", cR).call(this, s);
        if (i.controller.signal?.aborted) throw new CP();
        return this._addChatCompletion(kP(this, nR, "m", dR).call(this));
    }
    async _fromReadableStream(e, t) {
        const n = t?.signal;
        n && (n.aborted && this.controller.abort(), n.addEventListener("abort", () => this.controller.abort())),
            kP(this, nR, "m", aR).call(this),
            this._connected();
        const r = DO.fromReadableStream(e, this.controller);
        let i;
        for await (const s of r)
            i && i !== s.id && this._addChatCompletion(kP(this, nR, "m", dR).call(this)),
                kP(this, nR, "m", cR).call(this, s),
                (i = s.id);
        if (r.controller.signal?.aborted) throw new CP();
        return this._addChatCompletion(kP(this, nR, "m", dR).call(this));
    }
    [((rR = new WeakMap()),
    (iR = new WeakMap()),
    (sR = new WeakMap()),
    (nR = new WeakSet()),
    (aR = function () {
        this.ended || wP(this, sR, void 0);
    }),
    (oR = function (e) {
        let t = kP(this, iR, "f")[e.index];
        return (
            t ||
            ((t = {
                content_done: !1,
                refusal_done: !1,
                logprobs_content_done: !1,
                logprobs_refusal_done: !1,
                done_tool_calls: new Set(),
                current_tool_call_index: null,
            }),
            (kP(this, iR, "f")[e.index] = t),
            t)
        );
    }),
    (cR = function (e) {
        if (this.ended) return;
        const t = kP(this, nR, "m", mR).call(this, e);
        this._emit("chunk", e, t);
        for (const n of e.choices) {
            const e = t.choices[n.index];
            null != n.delta.content &&
                "assistant" === e.message?.role &&
                e.message?.content &&
                (this._emit("content", n.delta.content, e.message.content),
                this._emit("content.delta", {
                    delta: n.delta.content,
                    snapshot: e.message.content,
                    parsed: e.message.parsed,
                })),
                null != n.delta.refusal &&
                    "assistant" === e.message?.role &&
                    e.message?.refusal &&
                    this._emit("refusal.delta", { delta: n.delta.refusal, snapshot: e.message.refusal }),
                null != n.logprobs?.content &&
                    "assistant" === e.message?.role &&
                    this._emit("logprobs.content.delta", {
                        content: n.logprobs?.content,
                        snapshot: e.logprobs?.content ?? [],
                    }),
                null != n.logprobs?.refusal &&
                    "assistant" === e.message?.role &&
                    this._emit("logprobs.refusal.delta", {
                        refusal: n.logprobs?.refusal,
                        snapshot: e.logprobs?.refusal ?? [],
                    });
            const r = kP(this, nR, "m", oR).call(this, e);
            e.finish_reason &&
                (kP(this, nR, "m", uR).call(this, e),
                null != r.current_tool_call_index && kP(this, nR, "m", lR).call(this, e, r.current_tool_call_index));
            for (const t of n.delta.tool_calls ?? [])
                r.current_tool_call_index !== t.index &&
                    (kP(this, nR, "m", uR).call(this, e),
                    null != r.current_tool_call_index &&
                        kP(this, nR, "m", lR).call(this, e, r.current_tool_call_index)),
                    (r.current_tool_call_index = t.index);
            for (const t of n.delta.tool_calls ?? []) {
                const n = e.message.tool_calls?.[t.index];
                n?.type &&
                    ("function" === n?.type
                        ? this._emit("tool_calls.function.arguments.delta", {
                              name: n.function?.name,
                              index: t.index,
                              arguments: n.function.arguments,
                              parsed_arguments: n.function.parsed_arguments,
                              arguments_delta: t.function?.arguments ?? "",
                          })
                        : gR(n?.type));
            }
        }
    }),
    (lR = function (e, t) {
        if (kP(this, nR, "m", oR).call(this, e).done_tool_calls.has(t)) return;
        const n = e.message.tool_calls?.[t];
        if (!n) throw new Error("no tool call snapshot");
        if (!n.type) throw new Error("tool call snapshot missing `type`");
        if ("function" === n.type) {
            const e = kP(this, rR, "f")?.tools?.find((e) => aN(e) && e.function.name === n.function.name);
            this._emit("tool_calls.function.arguments.done", {
                name: n.function.name,
                index: t,
                arguments: n.function.arguments,
                parsed_arguments: cN(e)
                    ? e.$parseRaw(n.function.arguments)
                    : e?.function.strict
                      ? JSON.parse(n.function.arguments)
                      : null,
            });
        } else n.type;
    }),
    (uR = function (e) {
        const t = kP(this, nR, "m", oR).call(this, e);
        if (e.message.content && !t.content_done) {
            t.content_done = !0;
            const n = kP(this, nR, "m", hR).call(this);
            this._emit("content.done", {
                content: e.message.content,
                parsed: n ? n.$parseRaw(e.message.content) : null,
            });
        }
        e.message.refusal &&
            !t.refusal_done &&
            ((t.refusal_done = !0), this._emit("refusal.done", { refusal: e.message.refusal })),
            e.logprobs?.content &&
                !t.logprobs_content_done &&
                ((t.logprobs_content_done = !0), this._emit("logprobs.content.done", { content: e.logprobs.content })),
            e.logprobs?.refusal &&
                !t.logprobs_refusal_done &&
                ((t.logprobs_refusal_done = !0), this._emit("logprobs.refusal.done", { refusal: e.logprobs.refusal }));
    }),
    (dR = function () {
        if (this.ended) throw new SP("stream has ended, this shouldn't happen");
        const e = kP(this, sR, "f");
        if (!e) throw new SP("request ended without sending any chunks");
        return (
            wP(this, sR, void 0),
            wP(this, iR, []),
            (function (e, t) {
                const { id: n, choices: r, created: i, model: s, system_fingerprint: a, ...o } = e,
                    c = {
                        ...o,
                        id: n,
                        choices: r.map(({ message: t, finish_reason: n, index: r, logprobs: i, ...s }) => {
                            if (!n) throw new SP(`missing finish_reason for choice ${r}`);
                            const { content: a = null, function_call: o, tool_calls: c, ...l } = t,
                                u = t.role;
                            if (!u) throw new SP(`missing role for choice ${r}`);
                            if (o) {
                                const { arguments: e, name: c } = o;
                                if (null == e) throw new SP(`missing function_call.arguments for choice ${r}`);
                                if (!c) throw new SP(`missing function_call.name for choice ${r}`);
                                return {
                                    ...s,
                                    message: {
                                        content: a,
                                        function_call: { arguments: e, name: c },
                                        role: u,
                                        refusal: t.refusal ?? null,
                                    },
                                    finish_reason: n,
                                    index: r,
                                    logprobs: i,
                                };
                            }
                            return c
                                ? {
                                      ...s,
                                      index: r,
                                      finish_reason: n,
                                      logprobs: i,
                                      message: {
                                          ...l,
                                          role: u,
                                          content: a,
                                          refusal: t.refusal ?? null,
                                          tool_calls: c.map((t, n) => {
                                              const { function: i, type: s, id: a, ...o } = t,
                                                  { arguments: c, name: l, ...u } = i || {};
                                              if (null == a)
                                                  throw new SP(`missing choices[${r}].tool_calls[${n}].id\n${fR(e)}`);
                                              if (null == s)
                                                  throw new SP(`missing choices[${r}].tool_calls[${n}].type\n${fR(e)}`);
                                              if (null == l)
                                                  throw new SP(
                                                      `missing choices[${r}].tool_calls[${n}].function.name\n${fR(e)}`
                                                  );
                                              if (null == c)
                                                  throw new SP(
                                                      `missing choices[${r}].tool_calls[${n}].function.arguments\n${fR(e)}`
                                                  );
                                              return {
                                                  ...o,
                                                  id: a,
                                                  type: s,
                                                  function: { ...u, name: l, arguments: c },
                                              };
                                          }),
                                      },
                                  }
                                : {
                                      ...s,
                                      message: { ...l, content: a, role: u, refusal: t.refusal ?? null },
                                      finish_reason: n,
                                      index: r,
                                      logprobs: i,
                                  };
                        }),
                        created: i,
                        model: s,
                        object: "chat.completion",
                        ...(a ? { system_fingerprint: a } : {}),
                    };
                return (function (e, t) {
                    return t && hN(t)
                        ? lN(e, t)
                        : {
                              ...e,
                              choices: e.choices.map(
                                  (e) => (
                                      mN(e.message.tool_calls),
                                      {
                                          ...e,
                                          message: {
                                              ...e.message,
                                              parsed: null,
                                              ...(e.message.tool_calls ? { tool_calls: e.message.tool_calls } : void 0),
                                          },
                                      }
                                  )
                              ),
                          };
                })(c, t);
            })(e, kP(this, rR, "f"))
        );
    }),
    (hR = function () {
        const e = kP(this, rR, "f")?.response_format;
        return oN(e) ? e : null;
    }),
    (mR = function (e) {
        var t, n, r, i;
        let s = kP(this, sR, "f");
        const { choices: a, ...o } = e;
        s ? Object.assign(s, o) : (s = wP(this, sR, { ...o, choices: [] }));
        for (const { delta: c, finish_reason: l, index: u, logprobs: d = null, ...h } of e.choices) {
            let e = s.choices[u];
            if ((e || (e = s.choices[u] = { finish_reason: l, index: u, message: {}, logprobs: d, ...h }), d))
                if (e.logprobs) {
                    const { content: r, refusal: i, ...s } = d;
                    Object.assign(e.logprobs, s),
                        r && ((t = e.logprobs).content ?? (t.content = []), e.logprobs.content.push(...r)),
                        i && ((n = e.logprobs).refusal ?? (n.refusal = []), e.logprobs.refusal.push(...i));
                } else e.logprobs = Object.assign({}, d);
            if (l && ((e.finish_reason = l), kP(this, rR, "f") && hN(kP(this, rR, "f")))) {
                if ("length" === l) throw new LP();
                if ("content_filter" === l) throw new BP();
            }
            if ((Object.assign(e, h), !c)) continue;
            const { content: a, refusal: o, function_call: m, role: p, tool_calls: f, ...g } = c;
            if (
                (Object.assign(e.message, g),
                o && (e.message.refusal = (e.message.refusal || "") + o),
                p && (e.message.role = p),
                m &&
                    (e.message.function_call
                        ? (m.name && (e.message.function_call.name = m.name),
                          m.arguments &&
                              ((r = e.message.function_call).arguments ?? (r.arguments = ""),
                              (e.message.function_call.arguments += m.arguments)))
                        : (e.message.function_call = m)),
                a &&
                    ((e.message.content = (e.message.content || "") + a),
                    !e.message.refusal &&
                        kP(this, nR, "m", hR).call(this) &&
                        (e.message.parsed = tR(e.message.content))),
                f)
            ) {
                e.message.tool_calls || (e.message.tool_calls = []);
                for (const { index: t, id: n, type: r, function: s, ...a } of f) {
                    const o = (i = e.message.tool_calls)[t] ?? (i[t] = {});
                    Object.assign(o, a),
                        n && (o.id = n),
                        r && (o.type = r),
                        s && (o.function ?? (o.function = { name: s.name ?? "", arguments: "" })),
                        s?.name && (o.function.name = s.name),
                        s?.arguments &&
                            ((o.function.arguments += s.arguments),
                            dN(kP(this, rR, "f"), o) && (o.function.parsed_arguments = tR(o.function.arguments)));
                }
            }
        }
        return s;
    }),
    Symbol.asyncIterator)]() {
        const e = [],
            t = [];
        let n = !1;
        return (
            this.on("chunk", (n) => {
                const r = t.shift();
                r ? r.resolve(n) : e.push(n);
            }),
            this.on("end", () => {
                n = !0;
                for (const e of t) e.resolve(void 0);
                t.length = 0;
            }),
            this.on("abort", (e) => {
                n = !0;
                for (const n of t) n.reject(e);
                t.length = 0;
            }),
            this.on("error", (e) => {
                n = !0;
                for (const n of t) n.reject(e);
                t.length = 0;
            }),
            {
                next: async () => {
                    if (!e.length)
                        return n
                            ? { value: void 0, done: !0 }
                            : new Promise((e, n) => t.push({ resolve: e, reject: n })).then((e) =>
                                  e ? { value: e, done: !1 } : { value: void 0, done: !0 }
                              );
                    return { value: e.shift(), done: !1 };
                },
                return: async () => (this.abort(), { value: void 0, done: !0 }),
            }
        );
    }
    toReadableStream() {
        return new DO(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
    }
}
function fR(e) {
    return JSON.stringify(e);
}
function gR(e) {}
class bR extends pR {
    static fromReadableStream(e) {
        const t = new bR(null);
        return t._run(() => t._fromReadableStream(e)), t;
    }
    static runTools(e, t, n) {
        const r = new bR(t),
            i = { ...n, headers: { ...n?.headers, "X-Stainless-Helper-Method": "runTools" } };
        return r._run(() => r._runTools(e, t, i)), r;
    }
}
let yR = class extends tN {
    constructor() {
        super(...arguments), (this.messages = new sN(this._client));
    }
    create(e, t) {
        return this._client.post("/chat/completions", { body: e, ...t, stream: e.stream ?? !1 });
    }
    retrieve(e, t) {
        return this._client.get(iN`/chat/completions/${e}`, t);
    }
    update(e, t, n) {
        return this._client.post(iN`/chat/completions/${e}`, { body: t, ...n });
    }
    list(e = {}, t) {
        return this._client.getAPIList("/chat/completions", WO, { query: e, ...t });
    }
    delete(e, t) {
        return this._client.delete(iN`/chat/completions/${e}`, t);
    }
    parse(e, t) {
        return (
            (function (e) {
                for (const t of e ?? []) {
                    if ("function" !== t.type)
                        throw new SP(
                            `Currently only \`function\` tool types support auto-parsing; Received \`${t.type}\``
                        );
                    if (!0 !== t.function.strict)
                        throw new SP(
                            `The \`${t.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`
                        );
                }
            })(e.tools),
            this._client.chat.completions
                .create(e, { ...t, headers: { ...t?.headers, "X-Stainless-Helper-Method": "chat.completions.parse" } })
                ._thenUnwrap((t) => lN(t, e))
        );
    }
    runTools(e, t) {
        return e.stream ? bR.runTools(this._client, e, t) : $N.runTools(this._client, e, t);
    }
    stream(e, t) {
        return pR.createChatCompletion(this._client, e, t);
    }
};
yR.Messages = sN;
class wR extends tN {
    constructor() {
        super(...arguments), (this.completions = new yR(this._client));
    }
}
wR.Completions = yR;
const kR = Symbol("brand.privateNullableHeaders");
function* TR(e) {
    if (!e) return;
    if (kR in e) {
        const { values: t, nulls: n } = e;
        yield* t.entries();
        for (const e of n) yield [e, null];
        return;
    }
    let t,
        n = !1;
    e instanceof Headers ? (t = e.entries()) : VP(e) ? (t = e) : ((n = !0), (t = Object.entries(e ?? {})));
    for (let r of t) {
        const e = r[0];
        if ("string" != typeof e) throw new TypeError("expected header name to be a string");
        const t = VP(r[1]) ? r[1] : [r[1]];
        let i = !1;
        for (const r of t) void 0 !== r && (n && !i && ((i = !0), yield [e, null]), yield [e, r]);
    }
}
const _R = (e) => {
    const t = new Headers(),
        n = new Set();
    for (const r of e) {
        const e = new Set();
        for (const [i, s] of TR(r)) {
            const r = i.toLowerCase();
            e.has(r) || (t.delete(i), e.add(r)), null === s ? (t.delete(i), n.add(r)) : (t.append(i, s), n.delete(r));
        }
    }
    return { [kR]: !0, values: t, nulls: n };
};
class vR extends tN {
    create(e, t) {
        return this._client.post("/audio/speech", {
            body: e,
            ...t,
            headers: _R([{ Accept: "application/octet-stream" }, t?.headers]),
            __binaryResponse: !0,
        });
    }
}
class SR extends tN {
    create(e, t) {
        return this._client.post(
            "/audio/transcriptions",
            KO({ body: e, ...t, stream: e.stream ?? !1, __metadata: { model: e.model } }, this._client)
        );
    }
}
class ER extends tN {
    create(e, t) {
        return this._client.post(
            "/audio/translations",
            KO({ body: e, ...t, __metadata: { model: e.model } }, this._client)
        );
    }
}
class CR extends tN {
    constructor() {
        super(...arguments),
            (this.transcriptions = new SR(this._client)),
            (this.translations = new ER(this._client)),
            (this.speech = new vR(this._client));
    }
}
(CR.Transcriptions = SR), (CR.Translations = ER), (CR.Speech = vR);
class IR extends tN {
    create(e, t) {
        return this._client.post("/batches", { body: e, ...t });
    }
    retrieve(e, t) {
        return this._client.get(iN`/batches/${e}`, t);
    }
    list(e = {}, t) {
        return this._client.getAPIList("/batches", WO, { query: e, ...t });
    }
    cancel(e, t) {
        return this._client.post(iN`/batches/${e}/cancel`, t);
    }
}
class xR extends tN {
    create(e, t) {
        return this._client.post("/assistants", {
            body: e,
            ...t,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, t?.headers]),
        });
    }
    retrieve(e, t) {
        return this._client.get(iN`/assistants/${e}`, {
            ...t,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, t?.headers]),
        });
    }
    update(e, t, n) {
        return this._client.post(iN`/assistants/${e}`, {
            body: t,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    list(e = {}, t) {
        return this._client.getAPIList("/assistants", WO, {
            query: e,
            ...t,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, t?.headers]),
        });
    }
    delete(e, t) {
        return this._client.delete(iN`/assistants/${e}`, {
            ...t,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, t?.headers]),
        });
    }
}
class AR extends tN {
    create(e, t) {
        return this._client.post("/realtime/sessions", {
            body: e,
            ...t,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, t?.headers]),
        });
    }
}
class PR extends tN {
    create(e, t) {
        return this._client.post("/realtime/transcription_sessions", {
            body: e,
            ...t,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, t?.headers]),
        });
    }
}
let OR = class extends tN {
    constructor() {
        super(...arguments),
            (this.sessions = new AR(this._client)),
            (this.transcriptionSessions = new PR(this._client));
    }
};
(OR.Sessions = AR), (OR.TranscriptionSessions = PR);
class NR extends tN {
    create(e, t, n) {
        return this._client.post(iN`/threads/${e}/messages`, {
            body: t,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    retrieve(e, t, n) {
        const { thread_id: r } = t;
        return this._client.get(iN`/threads/${r}/messages/${e}`, {
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    update(e, t, n) {
        const { thread_id: r, ...i } = t;
        return this._client.post(iN`/threads/${r}/messages/${e}`, {
            body: i,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    list(e, t = {}, n) {
        return this._client.getAPIList(iN`/threads/${e}/messages`, WO, {
            query: t,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    delete(e, t, n) {
        const { thread_id: r } = t;
        return this._client.delete(iN`/threads/${r}/messages/${e}`, {
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
}
class RR extends tN {
    retrieve(e, t, n) {
        const { thread_id: r, run_id: i, ...s } = t;
        return this._client.get(iN`/threads/${r}/runs/${i}/steps/${e}`, {
            query: s,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    list(e, t, n) {
        const { thread_id: r, ...i } = t;
        return this._client.getAPIList(iN`/threads/${r}/runs/${e}/steps`, WO, {
            query: i,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
}
var MR = {};
const DR = (e) =>
    void 0 !== globalThis.process
        ? (MR?.[e]?.trim() ?? void 0)
        : void 0 !== globalThis.Deno
          ? globalThis.Deno.env?.get?.(e)?.trim()
          : void 0;
var FR, LR, BR, zR, UR, $R, VR, WR, jR, HR, qR, XR, GR, KR, YR, QR, JR, ZR, eM, tM, nM, rM, iM;
class sM extends LN {
    constructor() {
        super(...arguments),
            FR.add(this),
            BR.set(this, []),
            zR.set(this, {}),
            UR.set(this, {}),
            $R.set(this, void 0),
            VR.set(this, void 0),
            WR.set(this, void 0),
            jR.set(this, void 0),
            HR.set(this, void 0),
            qR.set(this, void 0),
            XR.set(this, void 0),
            GR.set(this, void 0),
            KR.set(this, void 0);
    }
    [((BR = new WeakMap()),
    (zR = new WeakMap()),
    (UR = new WeakMap()),
    ($R = new WeakMap()),
    (VR = new WeakMap()),
    (WR = new WeakMap()),
    (jR = new WeakMap()),
    (HR = new WeakMap()),
    (qR = new WeakMap()),
    (XR = new WeakMap()),
    (GR = new WeakMap()),
    (KR = new WeakMap()),
    (FR = new WeakSet()),
    Symbol.asyncIterator)]() {
        const e = [],
            t = [];
        let n = !1;
        return (
            this.on("event", (n) => {
                const r = t.shift();
                r ? r.resolve(n) : e.push(n);
            }),
            this.on("end", () => {
                n = !0;
                for (const e of t) e.resolve(void 0);
                t.length = 0;
            }),
            this.on("abort", (e) => {
                n = !0;
                for (const n of t) n.reject(e);
                t.length = 0;
            }),
            this.on("error", (e) => {
                n = !0;
                for (const n of t) n.reject(e);
                t.length = 0;
            }),
            {
                next: async () => {
                    if (!e.length)
                        return n
                            ? { value: void 0, done: !0 }
                            : new Promise((e, n) => t.push({ resolve: e, reject: n })).then((e) =>
                                  e ? { value: e, done: !1 } : { value: void 0, done: !0 }
                              );
                    return { value: e.shift(), done: !1 };
                },
                return: async () => (this.abort(), { value: void 0, done: !0 }),
            }
        );
    }
    static fromReadableStream(e) {
        const t = new LR();
        return t._run(() => t._fromReadableStream(e)), t;
    }
    async _fromReadableStream(e, t) {
        const n = t?.signal;
        n && (n.aborted && this.controller.abort(), n.addEventListener("abort", () => this.controller.abort())),
            this._connected();
        const r = DO.fromReadableStream(e, this.controller);
        for await (const i of r) kP(this, FR, "m", YR).call(this, i);
        if (r.controller.signal?.aborted) throw new CP();
        return this._addRun(kP(this, FR, "m", QR).call(this));
    }
    toReadableStream() {
        return new DO(this[Symbol.asyncIterator].bind(this), this.controller).toReadableStream();
    }
    static createToolAssistantStream(e, t, n, r) {
        const i = new LR();
        return (
            i._run(() =>
                i._runToolAssistantStream(e, t, n, {
                    ...r,
                    headers: { ...r?.headers, "X-Stainless-Helper-Method": "stream" },
                })
            ),
            i
        );
    }
    async _createToolAssistantStream(e, t, n, r) {
        const i = r?.signal;
        i && (i.aborted && this.controller.abort(), i.addEventListener("abort", () => this.controller.abort()));
        const s = { ...n, stream: !0 },
            a = await e.submitToolOutputs(t, s, { ...r, signal: this.controller.signal });
        this._connected();
        for await (const o of a) kP(this, FR, "m", YR).call(this, o);
        if (a.controller.signal?.aborted) throw new CP();
        return this._addRun(kP(this, FR, "m", QR).call(this));
    }
    static createThreadAssistantStream(e, t, n) {
        const r = new LR();
        return (
            r._run(() =>
                r._threadAssistantStream(e, t, {
                    ...n,
                    headers: { ...n?.headers, "X-Stainless-Helper-Method": "stream" },
                })
            ),
            r
        );
    }
    static createAssistantStream(e, t, n, r) {
        const i = new LR();
        return (
            i._run(() =>
                i._runAssistantStream(e, t, n, {
                    ...r,
                    headers: { ...r?.headers, "X-Stainless-Helper-Method": "stream" },
                })
            ),
            i
        );
    }
    currentEvent() {
        return kP(this, XR, "f");
    }
    currentRun() {
        return kP(this, GR, "f");
    }
    currentMessageSnapshot() {
        return kP(this, $R, "f");
    }
    currentRunStepSnapshot() {
        return kP(this, KR, "f");
    }
    async finalRunSteps() {
        return await this.done(), Object.values(kP(this, zR, "f"));
    }
    async finalMessages() {
        return await this.done(), Object.values(kP(this, UR, "f"));
    }
    async finalRun() {
        if ((await this.done(), !kP(this, VR, "f"))) throw Error("Final run was not received.");
        return kP(this, VR, "f");
    }
    async _createThreadAssistantStream(e, t, n) {
        const r = n?.signal;
        r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort()));
        const i = { ...t, stream: !0 },
            s = await e.createAndRun(i, { ...n, signal: this.controller.signal });
        this._connected();
        for await (const a of s) kP(this, FR, "m", YR).call(this, a);
        if (s.controller.signal?.aborted) throw new CP();
        return this._addRun(kP(this, FR, "m", QR).call(this));
    }
    async _createAssistantStream(e, t, n, r) {
        const i = r?.signal;
        i && (i.aborted && this.controller.abort(), i.addEventListener("abort", () => this.controller.abort()));
        const s = { ...n, stream: !0 },
            a = await e.create(t, s, { ...r, signal: this.controller.signal });
        this._connected();
        for await (const o of a) kP(this, FR, "m", YR).call(this, o);
        if (a.controller.signal?.aborted) throw new CP();
        return this._addRun(kP(this, FR, "m", QR).call(this));
    }
    static accumulateDelta(e, t) {
        for (const [n, r] of Object.entries(t)) {
            if (!e.hasOwnProperty(n)) {
                e[n] = r;
                continue;
            }
            let t = e[n];
            if (null != t)
                if ("index" !== n && "type" !== n) {
                    if ("string" == typeof t && "string" == typeof r) t += r;
                    else if ("number" == typeof t && "number" == typeof r) t += r;
                    else {
                        if (!jP(t) || !jP(r)) {
                            if (Array.isArray(t) && Array.isArray(r)) {
                                if (t.every((e) => "string" == typeof e || "number" == typeof e)) {
                                    t.push(...r);
                                    continue;
                                }
                                for (const e of r) {
                                    if (!jP(e))
                                        throw new Error(`Expected array delta entry to be an object but got: ${e}`);
                                    const n = e.index;
                                    if (null == n)
                                        throw new Error("Expected array delta entry to have an `index` property");
                                    if ("number" != typeof n)
                                        throw new Error(
                                            `Expected array delta entry \`index\` property to be a number but got ${n}`
                                        );
                                    const r = t[n];
                                    null == r ? t.push(e) : (t[n] = this.accumulateDelta(r, e));
                                }
                                continue;
                            }
                            throw Error(`Unhandled record type: ${n}, deltaValue: ${r}, accValue: ${t}`);
                        }
                        t = this.accumulateDelta(t, r);
                    }
                    e[n] = t;
                } else e[n] = r;
            else e[n] = r;
        }
        return e;
    }
    _addRun(e) {
        return e;
    }
    async _threadAssistantStream(e, t, n) {
        return await this._createThreadAssistantStream(t, e, n);
    }
    async _runAssistantStream(e, t, n, r) {
        return await this._createAssistantStream(t, e, n, r);
    }
    async _runToolAssistantStream(e, t, n, r) {
        return await this._createToolAssistantStream(t, e, n, r);
    }
}
(LR = sM),
    (YR = function (e) {
        if (!this.ended)
            switch ((wP(this, XR, e), kP(this, FR, "m", eM).call(this, e), e.event)) {
                case "thread.created":
                    break;
                case "thread.run.created":
                case "thread.run.queued":
                case "thread.run.in_progress":
                case "thread.run.requires_action":
                case "thread.run.completed":
                case "thread.run.incomplete":
                case "thread.run.failed":
                case "thread.run.cancelling":
                case "thread.run.cancelled":
                case "thread.run.expired":
                    kP(this, FR, "m", iM).call(this, e);
                    break;
                case "thread.run.step.created":
                case "thread.run.step.in_progress":
                case "thread.run.step.delta":
                case "thread.run.step.completed":
                case "thread.run.step.failed":
                case "thread.run.step.cancelled":
                case "thread.run.step.expired":
                    kP(this, FR, "m", ZR).call(this, e);
                    break;
                case "thread.message.created":
                case "thread.message.in_progress":
                case "thread.message.delta":
                case "thread.message.completed":
                case "thread.message.incomplete":
                    kP(this, FR, "m", JR).call(this, e);
                    break;
                case "error":
                    throw new Error(
                        "Encountered an error event in event processing - errors should be processed earlier"
                    );
            }
    }),
    (QR = function () {
        if (this.ended) throw new SP("stream has ended, this shouldn't happen");
        if (!kP(this, VR, "f")) throw Error("Final run has not been received");
        return kP(this, VR, "f");
    }),
    (JR = function (e) {
        const [t, n] = kP(this, FR, "m", nM).call(this, e, kP(this, $R, "f"));
        wP(this, $R, t), (kP(this, UR, "f")[t.id] = t);
        for (const r of n) {
            const e = t.content[r.index];
            "text" == e?.type && this._emit("textCreated", e.text);
        }
        switch (e.event) {
            case "thread.message.created":
                this._emit("messageCreated", e.data);
                break;
            case "thread.message.in_progress":
                break;
            case "thread.message.delta":
                if ((this._emit("messageDelta", e.data.delta, t), e.data.delta.content))
                    for (const n of e.data.delta.content) {
                        if ("text" == n.type && n.text) {
                            let e = n.text,
                                r = t.content[n.index];
                            if (!r || "text" != r.type)
                                throw Error("The snapshot associated with this text delta is not text or missing");
                            this._emit("textDelta", e, r.text);
                        }
                        if (n.index != kP(this, WR, "f")) {
                            if (kP(this, jR, "f"))
                                switch (kP(this, jR, "f").type) {
                                    case "text":
                                        this._emit("textDone", kP(this, jR, "f").text, kP(this, $R, "f"));
                                        break;
                                    case "image_file":
                                        this._emit("imageFileDone", kP(this, jR, "f").image_file, kP(this, $R, "f"));
                                }
                            wP(this, WR, n.index);
                        }
                        wP(this, jR, t.content[n.index]);
                    }
                break;
            case "thread.message.completed":
            case "thread.message.incomplete":
                if (void 0 !== kP(this, WR, "f")) {
                    const t = e.data.content[kP(this, WR, "f")];
                    if (t)
                        switch (t.type) {
                            case "image_file":
                                this._emit("imageFileDone", t.image_file, kP(this, $R, "f"));
                                break;
                            case "text":
                                this._emit("textDone", t.text, kP(this, $R, "f"));
                        }
                }
                kP(this, $R, "f") && this._emit("messageDone", e.data), wP(this, $R, void 0);
        }
    }),
    (ZR = function (e) {
        const t = kP(this, FR, "m", tM).call(this, e);
        switch ((wP(this, KR, t), e.event)) {
            case "thread.run.step.created":
                this._emit("runStepCreated", e.data);
                break;
            case "thread.run.step.delta":
                const n = e.data.delta;
                if (
                    n.step_details &&
                    "tool_calls" == n.step_details.type &&
                    n.step_details.tool_calls &&
                    "tool_calls" == t.step_details.type
                )
                    for (const e of n.step_details.tool_calls)
                        e.index == kP(this, HR, "f")
                            ? this._emit("toolCallDelta", e, t.step_details.tool_calls[e.index])
                            : (kP(this, qR, "f") && this._emit("toolCallDone", kP(this, qR, "f")),
                              wP(this, HR, e.index),
                              wP(this, qR, t.step_details.tool_calls[e.index]),
                              kP(this, qR, "f") && this._emit("toolCallCreated", kP(this, qR, "f")));
                this._emit("runStepDelta", e.data.delta, t);
                break;
            case "thread.run.step.completed":
            case "thread.run.step.failed":
            case "thread.run.step.cancelled":
            case "thread.run.step.expired":
                wP(this, KR, void 0);
                "tool_calls" == e.data.step_details.type &&
                    kP(this, qR, "f") &&
                    (this._emit("toolCallDone", kP(this, qR, "f")), wP(this, qR, void 0)),
                    this._emit("runStepDone", e.data, t);
        }
    }),
    (eM = function (e) {
        kP(this, BR, "f").push(e), this._emit("event", e);
    }),
    (tM = function (e) {
        switch (e.event) {
            case "thread.run.step.created":
                return (kP(this, zR, "f")[e.data.id] = e.data), e.data;
            case "thread.run.step.delta":
                let t = kP(this, zR, "f")[e.data.id];
                if (!t) throw Error("Received a RunStepDelta before creation of a snapshot");
                let n = e.data;
                if (n.delta) {
                    const r = LR.accumulateDelta(t, n.delta);
                    kP(this, zR, "f")[e.data.id] = r;
                }
                return kP(this, zR, "f")[e.data.id];
            case "thread.run.step.completed":
            case "thread.run.step.failed":
            case "thread.run.step.cancelled":
            case "thread.run.step.expired":
            case "thread.run.step.in_progress":
                kP(this, zR, "f")[e.data.id] = e.data;
        }
        if (kP(this, zR, "f")[e.data.id]) return kP(this, zR, "f")[e.data.id];
        throw new Error("No snapshot available");
    }),
    (nM = function (e, t) {
        let n = [];
        switch (e.event) {
            case "thread.message.created":
                return [e.data, n];
            case "thread.message.delta":
                if (!t)
                    throw Error(
                        "Received a delta with no existing snapshot (there should be one from message creation)"
                    );
                let r = e.data;
                if (r.delta.content)
                    for (const e of r.delta.content)
                        if (e.index in t.content) {
                            let n = t.content[e.index];
                            t.content[e.index] = kP(this, FR, "m", rM).call(this, e, n);
                        } else (t.content[e.index] = e), n.push(e);
                return [t, n];
            case "thread.message.in_progress":
            case "thread.message.completed":
            case "thread.message.incomplete":
                if (t) return [t, n];
                throw Error("Received thread message event with no existing snapshot");
        }
        throw Error("Tried to accumulate a non-message event");
    }),
    (rM = function (e, t) {
        return LR.accumulateDelta(t, e);
    }),
    (iM = function (e) {
        switch ((wP(this, GR, e.data), e.event)) {
            case "thread.run.created":
            case "thread.run.queued":
            case "thread.run.in_progress":
                break;
            case "thread.run.requires_action":
            case "thread.run.cancelled":
            case "thread.run.failed":
            case "thread.run.completed":
            case "thread.run.expired":
            case "thread.run.incomplete":
                wP(this, VR, e.data),
                    kP(this, qR, "f") && (this._emit("toolCallDone", kP(this, qR, "f")), wP(this, qR, void 0));
        }
    });
let aM = class extends tN {
    constructor() {
        super(...arguments), (this.steps = new RR(this._client));
    }
    create(e, t, n) {
        const { include: r, ...i } = t;
        return this._client.post(iN`/threads/${e}/runs`, {
            query: { include: r },
            body: i,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
            stream: t.stream ?? !1,
        });
    }
    retrieve(e, t, n) {
        const { thread_id: r } = t;
        return this._client.get(iN`/threads/${r}/runs/${e}`, {
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    update(e, t, n) {
        const { thread_id: r, ...i } = t;
        return this._client.post(iN`/threads/${r}/runs/${e}`, {
            body: i,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    list(e, t = {}, n) {
        return this._client.getAPIList(iN`/threads/${e}/runs`, WO, {
            query: t,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    cancel(e, t, n) {
        const { thread_id: r } = t;
        return this._client.post(iN`/threads/${r}/runs/${e}/cancel`, {
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    async createAndPoll(e, t, n) {
        const r = await this.create(e, t, n);
        return await this.poll(r.id, { thread_id: e }, n);
    }
    createAndStream(e, t, n) {
        return sM.createAssistantStream(e, this._client.beta.threads.runs, t, n);
    }
    async poll(e, t, n) {
        const r = _R([
            n?.headers,
            {
                "X-Stainless-Poll-Helper": "true",
                "X-Stainless-Custom-Poll-Interval": n?.pollIntervalMs?.toString() ?? void 0,
            },
        ]);
        for (;;) {
            const { data: i, response: s } = await this.retrieve(e, t, {
                ...n,
                headers: { ...n?.headers, ...r },
            }).withResponse();
            switch (i.status) {
                case "queued":
                case "in_progress":
                case "cancelling":
                    let e = 5e3;
                    if (n?.pollIntervalMs) e = n.pollIntervalMs;
                    else {
                        const t = s.headers.get("openai-poll-after-ms");
                        if (t) {
                            const n = parseInt(t);
                            isNaN(n) || (e = n);
                        }
                    }
                    await HP(e);
                    break;
                case "requires_action":
                case "incomplete":
                case "cancelled":
                case "completed":
                case "failed":
                case "expired":
                    return i;
            }
        }
    }
    stream(e, t, n) {
        return sM.createAssistantStream(e, this._client.beta.threads.runs, t, n);
    }
    submitToolOutputs(e, t, n) {
        const { thread_id: r, ...i } = t;
        return this._client.post(iN`/threads/${r}/runs/${e}/submit_tool_outputs`, {
            body: i,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
            stream: t.stream ?? !1,
        });
    }
    async submitToolOutputsAndPoll(e, t, n) {
        const r = await this.submitToolOutputs(e, t, n);
        return await this.poll(r.id, t, n);
    }
    submitToolOutputsStream(e, t, n) {
        return sM.createToolAssistantStream(e, this._client.beta.threads.runs, t, n);
    }
};
aM.Steps = RR;
class oM extends tN {
    constructor() {
        super(...arguments), (this.runs = new aM(this._client)), (this.messages = new NR(this._client));
    }
    create(e = {}, t) {
        return this._client.post("/threads", {
            body: e,
            ...t,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, t?.headers]),
        });
    }
    retrieve(e, t) {
        return this._client.get(iN`/threads/${e}`, {
            ...t,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, t?.headers]),
        });
    }
    update(e, t, n) {
        return this._client.post(iN`/threads/${e}`, {
            body: t,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    delete(e, t) {
        return this._client.delete(iN`/threads/${e}`, {
            ...t,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, t?.headers]),
        });
    }
    createAndRun(e, t) {
        return this._client.post("/threads/runs", {
            body: e,
            ...t,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, t?.headers]),
            stream: e.stream ?? !1,
        });
    }
    async createAndRunPoll(e, t) {
        const n = await this.createAndRun(e, t);
        return await this.runs.poll(n.id, { thread_id: n.thread_id }, t);
    }
    createAndRunStream(e, t) {
        return sM.createThreadAssistantStream(e, this._client.beta.threads, t);
    }
}
(oM.Runs = aM), (oM.Messages = NR);
class cM extends tN {
    constructor() {
        super(...arguments),
            (this.realtime = new OR(this._client)),
            (this.assistants = new xR(this._client)),
            (this.threads = new oM(this._client));
    }
}
(cM.Realtime = OR), (cM.Assistants = xR), (cM.Threads = oM);
class lM extends tN {
    create(e, t) {
        return this._client.post("/completions", { body: e, ...t, stream: e.stream ?? !1 });
    }
}
class uM extends tN {
    retrieve(e, t, n) {
        const { container_id: r } = t;
        return this._client.get(iN`/containers/${r}/files/${e}/content`, {
            ...n,
            headers: _R([{ Accept: "application/binary" }, n?.headers]),
            __binaryResponse: !0,
        });
    }
}
let dM = class extends tN {
    constructor() {
        super(...arguments), (this.content = new uM(this._client));
    }
    create(e, t, n) {
        return this._client.post(iN`/containers/${e}/files`, KO({ body: t, ...n }, this._client));
    }
    retrieve(e, t, n) {
        const { container_id: r } = t;
        return this._client.get(iN`/containers/${r}/files/${e}`, n);
    }
    list(e, t = {}, n) {
        return this._client.getAPIList(iN`/containers/${e}/files`, WO, { query: t, ...n });
    }
    delete(e, t, n) {
        const { container_id: r } = t;
        return this._client.delete(iN`/containers/${r}/files/${e}`, {
            ...n,
            headers: _R([{ Accept: "*/*" }, n?.headers]),
        });
    }
};
dM.Content = uM;
class hM extends tN {
    constructor() {
        super(...arguments), (this.files = new dM(this._client));
    }
    create(e, t) {
        return this._client.post("/containers", { body: e, ...t });
    }
    retrieve(e, t) {
        return this._client.get(iN`/containers/${e}`, t);
    }
    list(e = {}, t) {
        return this._client.getAPIList("/containers", WO, { query: e, ...t });
    }
    delete(e, t) {
        return this._client.delete(iN`/containers/${e}`, { ...t, headers: _R([{ Accept: "*/*" }, t?.headers]) });
    }
}
hM.Files = dM;
class mM extends tN {
    create(e, t, n) {
        const { include: r, ...i } = t;
        return this._client.post(iN`/conversations/${e}/items`, { query: { include: r }, body: i, ...n });
    }
    retrieve(e, t, n) {
        const { conversation_id: r, ...i } = t;
        return this._client.get(iN`/conversations/${r}/items/${e}`, { query: i, ...n });
    }
    list(e, t = {}, n) {
        return this._client.getAPIList(iN`/conversations/${e}/items`, jO, { query: t, ...n });
    }
    delete(e, t, n) {
        const { conversation_id: r } = t;
        return this._client.delete(iN`/conversations/${r}/items/${e}`, n);
    }
}
class pM extends tN {
    constructor() {
        super(...arguments), (this.items = new mM(this._client));
    }
    create(e, t) {
        return this._client.post("/conversations", { body: e, ...t });
    }
    retrieve(e, t) {
        return this._client.get(iN`/conversations/${e}`, t);
    }
    update(e, t, n) {
        return this._client.post(iN`/conversations/${e}`, { body: t, ...n });
    }
    delete(e, t) {
        return this._client.delete(iN`/conversations/${e}`, t);
    }
}
pM.Items = mM;
class fM extends tN {
    create(e, t) {
        const n = !!e.encoding_format;
        let r = n ? e.encoding_format : "base64";
        n && PO(this._client).debug("embeddings/user defined encoding_format:", e.encoding_format);
        const i = this._client.post("/embeddings", { body: { ...e, encoding_format: r }, ...t });
        return n
            ? i
            : (PO(this._client).debug("embeddings/decoding base64 embeddings from base64"),
              i._thenUnwrap(
                  (e) => (
                      e &&
                          e.data &&
                          e.data.forEach((e) => {
                              const t = e.embedding;
                              e.embedding = ((e) => {
                                  if ("undefined" != typeof Buffer) {
                                      const t = Buffer.from(e, "base64");
                                      return Array.from(
                                          new Float32Array(
                                              t.buffer,
                                              t.byteOffset,
                                              t.length / Float32Array.BYTES_PER_ELEMENT
                                          )
                                      );
                                  }
                                  {
                                      const t = atob(e),
                                          n = t.length,
                                          r = new Uint8Array(n);
                                      for (let e = 0; e < n; e++) r[e] = t.charCodeAt(e);
                                      return Array.from(new Float32Array(r.buffer));
                                  }
                              })(t);
                          }),
                      e
                  )
              ));
    }
}
class gM extends tN {
    retrieve(e, t, n) {
        const { eval_id: r, run_id: i } = t;
        return this._client.get(iN`/evals/${r}/runs/${i}/output_items/${e}`, n);
    }
    list(e, t, n) {
        const { eval_id: r, ...i } = t;
        return this._client.getAPIList(iN`/evals/${r}/runs/${e}/output_items`, WO, { query: i, ...n });
    }
}
class bM extends tN {
    constructor() {
        super(...arguments), (this.outputItems = new gM(this._client));
    }
    create(e, t, n) {
        return this._client.post(iN`/evals/${e}/runs`, { body: t, ...n });
    }
    retrieve(e, t, n) {
        const { eval_id: r } = t;
        return this._client.get(iN`/evals/${r}/runs/${e}`, n);
    }
    list(e, t = {}, n) {
        return this._client.getAPIList(iN`/evals/${e}/runs`, WO, { query: t, ...n });
    }
    delete(e, t, n) {
        const { eval_id: r } = t;
        return this._client.delete(iN`/evals/${r}/runs/${e}`, n);
    }
    cancel(e, t, n) {
        const { eval_id: r } = t;
        return this._client.post(iN`/evals/${r}/runs/${e}`, n);
    }
}
bM.OutputItems = gM;
class yM extends tN {
    constructor() {
        super(...arguments), (this.runs = new bM(this._client));
    }
    create(e, t) {
        return this._client.post("/evals", { body: e, ...t });
    }
    retrieve(e, t) {
        return this._client.get(iN`/evals/${e}`, t);
    }
    update(e, t, n) {
        return this._client.post(iN`/evals/${e}`, { body: t, ...n });
    }
    list(e = {}, t) {
        return this._client.getAPIList("/evals", WO, { query: e, ...t });
    }
    delete(e, t) {
        return this._client.delete(iN`/evals/${e}`, t);
    }
}
yM.Runs = bM;
let wM = class extends tN {
    create(e, t) {
        return this._client.post("/files", KO({ body: e, ...t }, this._client));
    }
    retrieve(e, t) {
        return this._client.get(iN`/files/${e}`, t);
    }
    list(e = {}, t) {
        return this._client.getAPIList("/files", WO, { query: e, ...t });
    }
    delete(e, t) {
        return this._client.delete(iN`/files/${e}`, t);
    }
    content(e, t) {
        return this._client.get(iN`/files/${e}/content`, {
            ...t,
            headers: _R([{ Accept: "application/binary" }, t?.headers]),
            __binaryResponse: !0,
        });
    }
    async waitForProcessing(e, { pollInterval: t = 5e3, maxWait: n = 18e5 } = {}) {
        const r = new Set(["processed", "error", "deleted"]),
            i = Date.now();
        let s = await this.retrieve(e);
        for (; !s.status || !r.has(s.status); )
            if ((await HP(t), (s = await this.retrieve(e)), Date.now() - i > n))
                throw new xP({
                    message: `Giving up on waiting for file ${e} to finish processing after ${n} milliseconds.`,
                });
        return s;
    }
};
class kM extends tN {}
let TM = class extends tN {
    run(e, t) {
        return this._client.post("/fine_tuning/alpha/graders/run", { body: e, ...t });
    }
    validate(e, t) {
        return this._client.post("/fine_tuning/alpha/graders/validate", { body: e, ...t });
    }
};
class _M extends tN {
    constructor() {
        super(...arguments), (this.graders = new TM(this._client));
    }
}
_M.Graders = TM;
class vM extends tN {
    create(e, t, n) {
        return this._client.getAPIList(iN`/fine_tuning/checkpoints/${e}/permissions`, VO, {
            body: t,
            method: "post",
            ...n,
        });
    }
    retrieve(e, t = {}, n) {
        return this._client.get(iN`/fine_tuning/checkpoints/${e}/permissions`, { query: t, ...n });
    }
    delete(e, t, n) {
        const { fine_tuned_model_checkpoint: r } = t;
        return this._client.delete(iN`/fine_tuning/checkpoints/${r}/permissions/${e}`, n);
    }
}
let SM = class extends tN {
    constructor() {
        super(...arguments), (this.permissions = new vM(this._client));
    }
};
SM.Permissions = vM;
class EM extends tN {
    list(e, t = {}, n) {
        return this._client.getAPIList(iN`/fine_tuning/jobs/${e}/checkpoints`, WO, { query: t, ...n });
    }
}
class CM extends tN {
    constructor() {
        super(...arguments), (this.checkpoints = new EM(this._client));
    }
    create(e, t) {
        return this._client.post("/fine_tuning/jobs", { body: e, ...t });
    }
    retrieve(e, t) {
        return this._client.get(iN`/fine_tuning/jobs/${e}`, t);
    }
    list(e = {}, t) {
        return this._client.getAPIList("/fine_tuning/jobs", WO, { query: e, ...t });
    }
    cancel(e, t) {
        return this._client.post(iN`/fine_tuning/jobs/${e}/cancel`, t);
    }
    listEvents(e, t = {}, n) {
        return this._client.getAPIList(iN`/fine_tuning/jobs/${e}/events`, WO, { query: t, ...n });
    }
    pause(e, t) {
        return this._client.post(iN`/fine_tuning/jobs/${e}/pause`, t);
    }
    resume(e, t) {
        return this._client.post(iN`/fine_tuning/jobs/${e}/resume`, t);
    }
}
CM.Checkpoints = EM;
class IM extends tN {
    constructor() {
        super(...arguments),
            (this.methods = new kM(this._client)),
            (this.jobs = new CM(this._client)),
            (this.checkpoints = new SM(this._client)),
            (this.alpha = new _M(this._client));
    }
}
(IM.Methods = kM), (IM.Jobs = CM), (IM.Checkpoints = SM), (IM.Alpha = _M);
class xM extends tN {}
class AM extends tN {
    constructor() {
        super(...arguments), (this.graderModels = new xM(this._client));
    }
}
AM.GraderModels = xM;
class PM extends tN {
    createVariation(e, t) {
        return this._client.post("/images/variations", KO({ body: e, ...t }, this._client));
    }
    edit(e, t) {
        return this._client.post("/images/edits", KO({ body: e, ...t, stream: e.stream ?? !1 }, this._client));
    }
    generate(e, t) {
        return this._client.post("/images/generations", { body: e, ...t, stream: e.stream ?? !1 });
    }
}
class OM extends tN {
    retrieve(e, t) {
        return this._client.get(iN`/models/${e}`, t);
    }
    list(e) {
        return this._client.getAPIList("/models", VO, e);
    }
    delete(e, t) {
        return this._client.delete(iN`/models/${e}`, t);
    }
}
class NM extends tN {
    create(e, t) {
        return this._client.post("/moderations", { body: e, ...t });
    }
}
class RM extends tN {
    create(e, t) {
        return this._client.post("/realtime/client_secrets", { body: e, ...t });
    }
}
class MM extends tN {
    constructor() {
        super(...arguments), (this.clientSecrets = new RM(this._client));
    }
}
function DM(e, t) {
    return t &&
        (function (e) {
            if (oN(e.text?.format)) return !0;
            return !1;
        })(t)
        ? FM(e, t)
        : {
              ...e,
              output_parsed: null,
              output: e.output.map((e) =>
                  "function_call" === e.type
                      ? { ...e, parsed_arguments: null }
                      : "message" === e.type
                        ? { ...e, content: e.content.map((e) => ({ ...e, parsed: null })) }
                        : e
              ),
          };
}
function FM(e, t) {
    const n = e.output.map((e) => {
            if ("function_call" === e.type) return { ...e, parsed_arguments: BM(t, e) };
            if ("message" === e.type) {
                const n = e.content.map((e) => ("output_text" === e.type ? { ...e, parsed: LM(t, e.text) } : e));
                return { ...e, content: n };
            }
            return e;
        }),
        r = Object.assign({}, e, { output: n });
    return (
        Object.getOwnPropertyDescriptor(e, "output_text") || zM(r),
        Object.defineProperty(r, "output_parsed", {
            enumerable: !0,
            get() {
                for (const e of r.output)
                    if ("message" === e.type)
                        for (const t of e.content) if ("output_text" === t.type && null !== t.parsed) return t.parsed;
                return null;
            },
        }),
        r
    );
}
function LM(e, t) {
    if ("json_schema" !== e.text?.format?.type) return null;
    if ("$parseRaw" in e.text?.format) {
        const n = e.text?.format;
        return n.$parseRaw(t);
    }
    return JSON.parse(t);
}
function BM(e, t) {
    const n = ((r = e.tools ?? []), (i = t.name), r.find((e) => "function" === e.type && e.name === i));
    var r, i, s;
    return {
        ...t,
        ...t,
        parsed_arguments:
            ((s = n),
            "auto-parseable-tool" === s?.$brand
                ? n.$parseRaw(t.arguments)
                : n?.strict
                  ? JSON.parse(t.arguments)
                  : null),
    };
}
function zM(e) {
    const t = [];
    for (const n of e.output)
        if ("message" === n.type) for (const e of n.content) "output_text" === e.type && t.push(e.text);
    e.output_text = t.join("");
}
var UM, $M, VM, WM, jM, HM, qM, XM;
MM.ClientSecrets = RM;
class GM extends LN {
    constructor(e) {
        super(), UM.add(this), $M.set(this, void 0), VM.set(this, void 0), WM.set(this, void 0), wP(this, $M, e);
    }
    static createResponse(e, t, n) {
        const r = new GM(t);
        return (
            r._run(() =>
                r._createOrRetrieveResponse(e, t, {
                    ...n,
                    headers: { ...n?.headers, "X-Stainless-Helper-Method": "stream" },
                })
            ),
            r
        );
    }
    async _createOrRetrieveResponse(e, t, n) {
        const r = n?.signal;
        let i;
        r && (r.aborted && this.controller.abort(), r.addEventListener("abort", () => this.controller.abort())),
            kP(this, UM, "m", jM).call(this);
        let s = null;
        "response_id" in t
            ? ((i = await e.responses.retrieve(
                  t.response_id,
                  { stream: !0 },
                  { ...n, signal: this.controller.signal, stream: !0 }
              )),
              (s = t.starting_after ?? null))
            : (i = await e.responses.create({ ...t, stream: !0 }, { ...n, signal: this.controller.signal })),
            this._connected();
        for await (const a of i) kP(this, UM, "m", HM).call(this, a, s);
        if (i.controller.signal?.aborted) throw new CP();
        return kP(this, UM, "m", qM).call(this);
    }
    [(($M = new WeakMap()),
    (VM = new WeakMap()),
    (WM = new WeakMap()),
    (UM = new WeakSet()),
    (jM = function () {
        this.ended || wP(this, VM, void 0);
    }),
    (HM = function (e, t) {
        if (this.ended) return;
        const n = (e, n) => {
                (null == t || n.sequence_number > t) && this._emit(e, n);
            },
            r = kP(this, UM, "m", XM).call(this, e);
        switch ((n("event", e), e.type)) {
            case "response.output_text.delta": {
                const t = r.output[e.output_index];
                if (!t) throw new SP(`missing output at index ${e.output_index}`);
                if ("message" === t.type) {
                    const r = t.content[e.content_index];
                    if (!r) throw new SP(`missing content at index ${e.content_index}`);
                    if ("output_text" !== r.type) throw new SP(`expected content to be 'output_text', got ${r.type}`);
                    n("response.output_text.delta", { ...e, snapshot: r.text });
                }
                break;
            }
            case "response.function_call_arguments.delta": {
                const t = r.output[e.output_index];
                if (!t) throw new SP(`missing output at index ${e.output_index}`);
                "function_call" === t.type &&
                    n("response.function_call_arguments.delta", { ...e, snapshot: t.arguments });
                break;
            }
            default:
                n(e.type, e);
        }
    }),
    (qM = function () {
        if (this.ended) throw new SP("stream has ended, this shouldn't happen");
        const e = kP(this, VM, "f");
        if (!e) throw new SP("request ended without sending any events");
        wP(this, VM, void 0);
        const t = (function (e, t) {
            return DM(e, t);
        })(e, kP(this, $M, "f"));
        return wP(this, WM, t), t;
    }),
    (XM = function (e) {
        let t = kP(this, VM, "f");
        if (!t) {
            if ("response.created" !== e.type)
                throw new SP(`When snapshot hasn't been set yet, expected 'response.created' event, got ${e.type}`);
            return (t = wP(this, VM, e.response)), t;
        }
        switch (e.type) {
            case "response.output_item.added":
                t.output.push(e.item);
                break;
            case "response.content_part.added": {
                const n = t.output[e.output_index];
                if (!n) throw new SP(`missing output at index ${e.output_index}`);
                "message" === n.type && n.content.push(e.part);
                break;
            }
            case "response.output_text.delta": {
                const n = t.output[e.output_index];
                if (!n) throw new SP(`missing output at index ${e.output_index}`);
                if ("message" === n.type) {
                    const t = n.content[e.content_index];
                    if (!t) throw new SP(`missing content at index ${e.content_index}`);
                    if ("output_text" !== t.type) throw new SP(`expected content to be 'output_text', got ${t.type}`);
                    t.text += e.delta;
                }
                break;
            }
            case "response.function_call_arguments.delta": {
                const n = t.output[e.output_index];
                if (!n) throw new SP(`missing output at index ${e.output_index}`);
                "function_call" === n.type && (n.arguments += e.delta);
                break;
            }
            case "response.completed":
                wP(this, VM, e.response);
        }
        return t;
    }),
    Symbol.asyncIterator)]() {
        const e = [],
            t = [];
        let n = !1;
        return (
            this.on("event", (n) => {
                const r = t.shift();
                r ? r.resolve(n) : e.push(n);
            }),
            this.on("end", () => {
                n = !0;
                for (const e of t) e.resolve(void 0);
                t.length = 0;
            }),
            this.on("abort", (e) => {
                n = !0;
                for (const n of t) n.reject(e);
                t.length = 0;
            }),
            this.on("error", (e) => {
                n = !0;
                for (const n of t) n.reject(e);
                t.length = 0;
            }),
            {
                next: async () => {
                    if (!e.length)
                        return n
                            ? { value: void 0, done: !0 }
                            : new Promise((e, n) => t.push({ resolve: e, reject: n })).then((e) =>
                                  e ? { value: e, done: !1 } : { value: void 0, done: !0 }
                              );
                    return { value: e.shift(), done: !1 };
                },
                return: async () => (this.abort(), { value: void 0, done: !0 }),
            }
        );
    }
    async finalResponse() {
        await this.done();
        const e = kP(this, WM, "f");
        if (!e) throw new SP("stream ended without producing a ChatCompletion");
        return e;
    }
}
class KM extends tN {
    list(e, t = {}, n) {
        return this._client.getAPIList(iN`/responses/${e}/input_items`, WO, { query: t, ...n });
    }
}
class YM extends tN {
    constructor() {
        super(...arguments), (this.inputItems = new KM(this._client));
    }
    create(e, t) {
        return this._client
            .post("/responses", { body: e, ...t, stream: e.stream ?? !1 })
            ._thenUnwrap((e) => ("object" in e && "response" === e.object && zM(e), e));
    }
    retrieve(e, t = {}, n) {
        return this._client
            .get(iN`/responses/${e}`, { query: t, ...n, stream: t?.stream ?? !1 })
            ._thenUnwrap((e) => ("object" in e && "response" === e.object && zM(e), e));
    }
    delete(e, t) {
        return this._client.delete(iN`/responses/${e}`, { ...t, headers: _R([{ Accept: "*/*" }, t?.headers]) });
    }
    parse(e, t) {
        return this._client.responses.create(e, t)._thenUnwrap((t) => FM(t, e));
    }
    stream(e, t) {
        return GM.createResponse(this._client, e, t);
    }
    cancel(e, t) {
        return this._client.post(iN`/responses/${e}/cancel`, t);
    }
}
YM.InputItems = KM;
class QM extends tN {
    create(e, t, n) {
        return this._client.post(iN`/uploads/${e}/parts`, KO({ body: t, ...n }, this._client));
    }
}
class JM extends tN {
    constructor() {
        super(...arguments), (this.parts = new QM(this._client));
    }
    create(e, t) {
        return this._client.post("/uploads", { body: e, ...t });
    }
    cancel(e, t) {
        return this._client.post(iN`/uploads/${e}/cancel`, t);
    }
    complete(e, t, n) {
        return this._client.post(iN`/uploads/${e}/complete`, { body: t, ...n });
    }
}
JM.Parts = QM;
class ZM extends tN {
    create(e, t, n) {
        return this._client.post(iN`/vector_stores/${e}/file_batches`, {
            body: t,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    retrieve(e, t, n) {
        const { vector_store_id: r } = t;
        return this._client.get(iN`/vector_stores/${r}/file_batches/${e}`, {
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    cancel(e, t, n) {
        const { vector_store_id: r } = t;
        return this._client.post(iN`/vector_stores/${r}/file_batches/${e}/cancel`, {
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    async createAndPoll(e, t, n) {
        const r = await this.create(e, t);
        return await this.poll(e, r.id, n);
    }
    listFiles(e, t, n) {
        const { vector_store_id: r, ...i } = t;
        return this._client.getAPIList(iN`/vector_stores/${r}/file_batches/${e}/files`, WO, {
            query: i,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    async poll(e, t, n) {
        const r = _R([
            n?.headers,
            {
                "X-Stainless-Poll-Helper": "true",
                "X-Stainless-Custom-Poll-Interval": n?.pollIntervalMs?.toString() ?? void 0,
            },
        ]);
        for (;;) {
            const { data: i, response: s } = await this.retrieve(
                t,
                { vector_store_id: e },
                { ...n, headers: r }
            ).withResponse();
            switch (i.status) {
                case "in_progress":
                    let e = 5e3;
                    if (n?.pollIntervalMs) e = n.pollIntervalMs;
                    else {
                        const t = s.headers.get("openai-poll-after-ms");
                        if (t) {
                            const n = parseInt(t);
                            isNaN(n) || (e = n);
                        }
                    }
                    await HP(e);
                    break;
                case "failed":
                case "cancelled":
                case "completed":
                    return i;
            }
        }
    }
    async uploadAndPoll(e, { files: t, fileIds: n = [] }, r) {
        if (null == t || 0 == t.length)
            throw new Error(
                "No `files` provided to process. If you've already uploaded files you should use `.createAndPoll()` instead"
            );
        const i = r?.maxConcurrency ?? 5,
            s = Math.min(i, t.length),
            a = this._client,
            o = t.values(),
            c = [...n];
        const l = Array(s)
            .fill(o)
            .map(async function (e) {
                for (let t of e) {
                    const e = await a.files.create({ file: t, purpose: "assistants" }, r);
                    c.push(e.id);
                }
            });
        return (
            await (async (e) => {
                const t = await Promise.allSettled(e),
                    n = t.filter((e) => "rejected" === e.status);
                if (n.length) {
                    for (const e of n);
                    throw new Error(`${n.length} promise(s) failed - see the above errors`);
                }
                const r = [];
                for (const i of t) "fulfilled" === i.status && r.push(i.value);
                return r;
            })(l),
            await this.createAndPoll(e, { file_ids: c })
        );
    }
}
class eD extends tN {
    create(e, t, n) {
        return this._client.post(iN`/vector_stores/${e}/files`, {
            body: t,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    retrieve(e, t, n) {
        const { vector_store_id: r } = t;
        return this._client.get(iN`/vector_stores/${r}/files/${e}`, {
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    update(e, t, n) {
        const { vector_store_id: r, ...i } = t;
        return this._client.post(iN`/vector_stores/${r}/files/${e}`, {
            body: i,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    list(e, t = {}, n) {
        return this._client.getAPIList(iN`/vector_stores/${e}/files`, WO, {
            query: t,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    delete(e, t, n) {
        const { vector_store_id: r } = t;
        return this._client.delete(iN`/vector_stores/${r}/files/${e}`, {
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    async createAndPoll(e, t, n) {
        const r = await this.create(e, t, n);
        return await this.poll(e, r.id, n);
    }
    async poll(e, t, n) {
        const r = _R([
            n?.headers,
            {
                "X-Stainless-Poll-Helper": "true",
                "X-Stainless-Custom-Poll-Interval": n?.pollIntervalMs?.toString() ?? void 0,
            },
        ]);
        for (;;) {
            const i = await this.retrieve(t, { vector_store_id: e }, { ...n, headers: r }).withResponse(),
                s = i.data;
            switch (s.status) {
                case "in_progress":
                    let e = 5e3;
                    if (n?.pollIntervalMs) e = n.pollIntervalMs;
                    else {
                        const t = i.response.headers.get("openai-poll-after-ms");
                        if (t) {
                            const n = parseInt(t);
                            isNaN(n) || (e = n);
                        }
                    }
                    await HP(e);
                    break;
                case "failed":
                case "completed":
                    return s;
            }
        }
    }
    async upload(e, t, n) {
        const r = await this._client.files.create({ file: t, purpose: "assistants" }, n);
        return this.create(e, { file_id: r.id }, n);
    }
    async uploadAndPoll(e, t, n) {
        const r = await this.upload(e, t, n);
        return await this.poll(e, r.id, n);
    }
    content(e, t, n) {
        const { vector_store_id: r } = t;
        return this._client.getAPIList(iN`/vector_stores/${r}/files/${e}/content`, VO, {
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
}
class tD extends tN {
    constructor() {
        super(...arguments), (this.files = new eD(this._client)), (this.fileBatches = new ZM(this._client));
    }
    create(e, t) {
        return this._client.post("/vector_stores", {
            body: e,
            ...t,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, t?.headers]),
        });
    }
    retrieve(e, t) {
        return this._client.get(iN`/vector_stores/${e}`, {
            ...t,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, t?.headers]),
        });
    }
    update(e, t, n) {
        return this._client.post(iN`/vector_stores/${e}`, {
            body: t,
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
    list(e = {}, t) {
        return this._client.getAPIList("/vector_stores", WO, {
            query: e,
            ...t,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, t?.headers]),
        });
    }
    delete(e, t) {
        return this._client.delete(iN`/vector_stores/${e}`, {
            ...t,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, t?.headers]),
        });
    }
    search(e, t, n) {
        return this._client.getAPIList(iN`/vector_stores/${e}/search`, VO, {
            body: t,
            method: "post",
            ...n,
            headers: _R([{ "OpenAI-Beta": "assistants=v2" }, n?.headers]),
        });
    }
}
var nD, rD, iD, sD, aD, oD, cD;
(tD.Files = eD), (tD.FileBatches = ZM);
class lD extends tN {
    constructor() {
        super(...arguments), nD.add(this);
    }
    async unwrap(e, t, n = this._client.webhookSecret, r = 300) {
        return await this.verifySignature(e, t, n, r), JSON.parse(e);
    }
    async verifySignature(e, t, n = this._client.webhookSecret, r = 300) {
        if (
            "undefined" == typeof crypto ||
            "function" != typeof crypto.subtle.importKey ||
            "function" != typeof crypto.subtle.verify
        )
            throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");
        kP(this, nD, "m", rD).call(this, n);
        const i = _R([t]).values,
            s = kP(this, nD, "m", iD).call(this, i, "webhook-signature"),
            a = kP(this, nD, "m", iD).call(this, i, "webhook-timestamp"),
            o = kP(this, nD, "m", iD).call(this, i, "webhook-id"),
            c = parseInt(a, 10);
        if (isNaN(c)) throw new zP("Invalid webhook timestamp format");
        const l = Math.floor(Date.now() / 1e3);
        if (l - c > r) throw new zP("Webhook timestamp is too old");
        if (c > l + r) throw new zP("Webhook timestamp is too new");
        const u = s.split(" ").map((e) => (e.startsWith("v1,") ? e.substring(3) : e)),
            d = n.startsWith("whsec_") ? Buffer.from(n.replace("whsec_", ""), "base64") : Buffer.from(n, "utf-8"),
            h = o ? `${o}.${a}.${e}` : `${a}.${e}`,
            m = await crypto.subtle.importKey("raw", d, { name: "HMAC", hash: "SHA-256" }, !1, ["verify"]);
        for (const p of u)
            try {
                const e = Buffer.from(p, "base64");
                if (await crypto.subtle.verify("HMAC", m, e, new TextEncoder().encode(h))) return;
            } catch {
                continue;
            }
        throw new zP("The given webhook signature does not match the expected signature");
    }
}
(nD = new WeakSet()),
    (rD = function (e) {
        if ("string" != typeof e || 0 === e.length)
            throw new Error(
                "The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function"
            );
    }),
    (iD = function (e, t) {
        if (!e) throw new Error("Headers are required");
        const n = e.get(t);
        if (null == n) throw new Error(`Missing required header: ${t}`);
        return n;
    });
class uD {
    constructor({
        baseURL: e = DR("OPENAI_BASE_URL"),
        apiKey: t = DR("OPENAI_API_KEY"),
        organization: n = DR("OPENAI_ORG_ID") ?? null,
        project: r = DR("OPENAI_PROJECT_ID") ?? null,
        webhookSecret: i = DR("OPENAI_WEBHOOK_SECRET") ?? null,
        ...s
    } = {}) {
        if (
            (sD.add(this),
            oD.set(this, void 0),
            (this.completions = new lM(this)),
            (this.chat = new wR(this)),
            (this.embeddings = new fM(this)),
            (this.files = new wM(this)),
            (this.images = new PM(this)),
            (this.audio = new CR(this)),
            (this.moderations = new NM(this)),
            (this.models = new OM(this)),
            (this.fineTuning = new IM(this)),
            (this.graders = new AM(this)),
            (this.vectorStores = new tD(this)),
            (this.webhooks = new lD(this)),
            (this.beta = new cM(this)),
            (this.batches = new IR(this)),
            (this.uploads = new JM(this)),
            (this.responses = new YM(this)),
            (this.realtime = new MM(this)),
            (this.conversations = new pM(this)),
            (this.evals = new yM(this)),
            (this.containers = new hM(this)),
            void 0 === t)
        )
            throw new SP(
                "Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable."
            );
        const a = {
            apiKey: t,
            organization: n,
            project: r,
            webhookSecret: i,
            ...s,
            baseURL: e || "https://api.openai.com/v1",
        };
        if (
            !a.dangerouslyAllowBrowser &&
            "undefined" != typeof window &&
            void 0 !== window.document &&
            "undefined" != typeof navigator
        )
            throw new SP(
                "It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n"
            );
        (this.baseURL = a.baseURL),
            (this.timeout = a.timeout ?? aD.DEFAULT_TIMEOUT),
            (this.logger = a.logger ?? console);
        const o = "warn";
        (this.logLevel = o),
            (this.logLevel =
                EO(a.logLevel, "ClientOptions.logLevel", this) ??
                EO(DR("OPENAI_LOG"), "process.env['OPENAI_LOG']", this) ??
                o),
            (this.fetchOptions = a.fetchOptions),
            (this.maxRetries = a.maxRetries ?? 2),
            (this.fetch =
                a.fetch ??
                (function () {
                    if ("undefined" != typeof fetch) return fetch;
                    throw new Error(
                        "`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`"
                    );
                })()),
            wP(this, oD, eO),
            (this._options = a),
            (this.apiKey = "string" == typeof t ? t : "Missing Key"),
            (this.organization = n),
            (this.project = r),
            (this.webhookSecret = i);
    }
    withOptions(e) {
        return new this.constructor({
            ...this._options,
            baseURL: this.baseURL,
            maxRetries: this.maxRetries,
            timeout: this.timeout,
            logger: this.logger,
            logLevel: this.logLevel,
            fetch: this.fetch,
            fetchOptions: this.fetchOptions,
            apiKey: this.apiKey,
            organization: this.organization,
            project: this.project,
            webhookSecret: this.webhookSecret,
            ...e,
        });
    }
    defaultQuery() {
        return this._options.defaultQuery;
    }
    validateHeaders({ values: e, nulls: t }) {}
    async authHeaders(e) {
        return _R([{ Authorization: `Bearer ${this.apiKey}` }]);
    }
    stringifyQuery(e) {
        return pO(e, { arrayFormat: "brackets" });
    }
    getUserAgent() {
        return `${this.constructor.name}/JS ${qP}`;
    }
    defaultIdempotencyKey() {
        return `stainless-node-retry-${TP()}`;
    }
    makeStatusError(e, t, n, r) {
        return EP.generate(e, t, n, r);
    }
    async _callApiKey() {
        const e = this._options.apiKey;
        if ("function" != typeof e) return !1;
        let t;
        try {
            t = await e();
        } catch (n) {
            if (n instanceof SP) throw n;
            throw new SP(`Failed to get token from 'apiKey' function: ${n.message}`, { cause: n });
        }
        if ("string" != typeof t || !t)
            throw new SP(`Expected 'apiKey' function argument to return a string but it returned ${t}`);
        return (this.apiKey = t), !0;
    }
    buildURL(e, t, n) {
        const r = (!kP(this, sD, "m", cD).call(this) && n) || this.baseURL,
            i = ((e) => UP.test(e))(e)
                ? new URL(e)
                : new URL(r + (r.endsWith("/") && e.startsWith("/") ? e.slice(1) : e)),
            s = this.defaultQuery();
        return (
            (function (e) {
                if (!e) return !0;
                for (const t in e) return !1;
                return !0;
            })(s) || (t = { ...s, ...t }),
            "object" == typeof t && t && !Array.isArray(t) && (i.search = this.stringifyQuery(t)),
            i.toString()
        );
    }
    async prepareOptions(e) {
        await this._callApiKey();
    }
    async prepareRequest(e, { url: t, options: n }) {}
    get(e, t) {
        return this.methodRequest("get", e, t);
    }
    post(e, t) {
        return this.methodRequest("post", e, t);
    }
    patch(e, t) {
        return this.methodRequest("patch", e, t);
    }
    put(e, t) {
        return this.methodRequest("put", e, t);
    }
    delete(e, t) {
        return this.methodRequest("delete", e, t);
    }
    methodRequest(e, t, n) {
        return this.request(Promise.resolve(n).then((n) => ({ method: e, path: t, ...n })));
    }
    request(e, t = null) {
        return new zO(this, this.makeRequest(e, t, void 0));
    }
    async makeRequest(e, t, n) {
        const r = await e,
            i = r.maxRetries ?? this.maxRetries;
        null == t && (t = i), await this.prepareOptions(r);
        const { req: s, url: a, timeout: o } = await this.buildRequest(r, { retryCount: i - t });
        await this.prepareRequest(s, { url: a, options: r });
        const c = "log_" + ((Math.random() * (1 << 24)) | 0).toString(16).padStart(6, "0"),
            l = void 0 === n ? "" : `, retryOf: ${n}`,
            u = Date.now();
        if (
            (PO(this).debug(
                `[${c}] sending request`,
                OO({ retryOfRequestLogID: n, method: r.method, url: a, options: r, headers: s.headers })
            ),
            r.signal?.aborted)
        )
            throw new CP();
        const d = new AbortController(),
            h = await this.fetchWithTimeout(a, s, o, d).catch(vP),
            m = Date.now();
        if (h instanceof globalThis.Error) {
            const e = `retrying, ${t} attempts remaining`;
            if (r.signal?.aborted) throw new CP();
            const i = _P(h) || /timed? ?out/i.test(String(h) + ("cause" in h ? String(h.cause) : ""));
            if (t)
                return (
                    PO(this).info(`[${c}] connection ${i ? "timed out" : "failed"} - ${e}`),
                    PO(this).debug(
                        `[${c}] connection ${i ? "timed out" : "failed"} (${e})`,
                        OO({ retryOfRequestLogID: n, url: a, durationMs: m - u, message: h.message })
                    ),
                    this.retryRequest(r, t, n ?? c)
                );
            if (
                (PO(this).info(`[${c}] connection ${i ? "timed out" : "failed"} - error; no more retries left`),
                PO(this).debug(
                    `[${c}] connection ${i ? "timed out" : "failed"} (error; no more retries left)`,
                    OO({ retryOfRequestLogID: n, url: a, durationMs: m - u, message: h.message })
                ),
                i)
            )
                throw new xP();
            throw new IP({ cause: h });
        }
        const p = `[${c}${l}${[...h.headers.entries()]
            .filter(([e]) => "x-request-id" === e)
            .map(([e, t]) => ", " + e + ": " + JSON.stringify(t))
            .join("")}] ${s.method} ${a} ${h.ok ? "succeeded" : "failed"} with status ${h.status} in ${m - u}ms`;
        if (!h.ok) {
            const e = await this.shouldRetry(h);
            if (t && e) {
                const e = `retrying, ${t} attempts remaining`;
                return (
                    await (async function (e) {
                        if (null === e || "object" != typeof e) return;
                        if (e[Symbol.asyncIterator]) return void (await e[Symbol.asyncIterator]().return?.());
                        const t = e.getReader(),
                            n = t.cancel();
                        t.releaseLock(), await n;
                    })(h.body),
                    PO(this).info(`${p} - ${e}`),
                    PO(this).debug(
                        `[${c}] response error (${e})`,
                        OO({
                            retryOfRequestLogID: n,
                            url: h.url,
                            status: h.status,
                            headers: h.headers,
                            durationMs: m - u,
                        })
                    ),
                    this.retryRequest(r, t, n ?? c, h.headers)
                );
            }
            const i = e ? "error; no more retries left" : "error; not retryable";
            PO(this).info(`${p} - ${i}`);
            const s = await h.text().catch((e) => vP(e).message),
                a = ((e) => {
                    try {
                        return JSON.parse(e);
                    } catch (t) {
                        return;
                    }
                })(s),
                o = a ? void 0 : s;
            PO(this).debug(
                `[${c}] response error (${i})`,
                OO({
                    retryOfRequestLogID: n,
                    url: h.url,
                    status: h.status,
                    headers: h.headers,
                    message: o,
                    durationMs: Date.now() - u,
                })
            );
            throw this.makeStatusError(h.status, a, o, h.headers);
        }
        return (
            PO(this).info(p),
            PO(this).debug(
                `[${c}] response start`,
                OO({ retryOfRequestLogID: n, url: h.url, status: h.status, headers: h.headers, durationMs: m - u })
            ),
            { response: h, options: r, controller: d, requestLogID: c, retryOfRequestLogID: n, startTime: u }
        );
    }
    getAPIList(e, t, n) {
        return this.requestAPIList(t, { method: "get", path: e, ...n });
    }
    requestAPIList(e, t) {
        const n = this.makeRequest(t, null, void 0);
        return new $O(this, n, e);
    }
    async fetchWithTimeout(e, t, n, r) {
        const { signal: i, method: s, ...a } = t || {};
        i && i.addEventListener("abort", () => r.abort());
        const o = setTimeout(() => r.abort(), n),
            c =
                (globalThis.ReadableStream && a.body instanceof globalThis.ReadableStream) ||
                ("object" == typeof a.body && null !== a.body && Symbol.asyncIterator in a.body),
            l = { signal: r.signal, ...(c ? { duplex: "half" } : {}), method: "GET", ...a };
        s && (l.method = s.toUpperCase());
        try {
            return await this.fetch.call(void 0, e, l);
        } finally {
            clearTimeout(o);
        }
    }
    async shouldRetry(e) {
        const t = e.headers.get("x-should-retry");
        return (
            "true" === t ||
            ("false" !== t && (408 === e.status || 409 === e.status || 429 === e.status || e.status >= 500))
        );
    }
    async retryRequest(e, t, n, r) {
        let i;
        const s = r?.get("retry-after-ms");
        if (s) {
            const e = parseFloat(s);
            Number.isNaN(e) || (i = e);
        }
        const a = r?.get("retry-after");
        if (a && !i) {
            const e = parseFloat(a);
            i = Number.isNaN(e) ? Date.parse(a) - Date.now() : 1e3 * e;
        }
        if (!(i && 0 <= i && i < 6e4)) {
            const n = e.maxRetries ?? this.maxRetries;
            i = this.calculateDefaultRetryTimeoutMillis(t, n);
        }
        return await HP(i), this.makeRequest(e, t - 1, n);
    }
    calculateDefaultRetryTimeoutMillis(e, t) {
        const n = t - e;
        return Math.min(0.5 * Math.pow(2, n), 8) * (1 - 0.25 * Math.random()) * 1e3;
    }
    async buildRequest(e, { retryCount: t = 0 } = {}) {
        const n = { ...e },
            { method: r, path: i, query: s, defaultBaseURL: a } = n,
            o = this.buildURL(i, s, a);
        "timeout" in n &&
            ((e, t) => {
                if ("number" != typeof t || !Number.isInteger(t)) throw new SP(`${e} must be an integer`);
                if (t < 0) throw new SP(`${e} must be a positive integer`);
            })("timeout", n.timeout),
            (n.timeout = n.timeout ?? this.timeout);
        const { bodyHeaders: c, body: l } = this.buildBody({ options: n });
        return {
            req: {
                method: r,
                headers: await this.buildHeaders({ options: e, method: r, bodyHeaders: c, retryCount: t }),
                ...(n.signal && { signal: n.signal }),
                ...(globalThis.ReadableStream && l instanceof globalThis.ReadableStream && { duplex: "half" }),
                ...(l && { body: l }),
                ...(this.fetchOptions ?? {}),
                ...(n.fetchOptions ?? {}),
            },
            url: o,
            timeout: n.timeout,
        };
    }
    async buildHeaders({ options: e, method: t, bodyHeaders: n, retryCount: r }) {
        let i = {};
        this.idempotencyHeader &&
            "get" !== t &&
            (e.idempotencyKey || (e.idempotencyKey = this.defaultIdempotencyKey()),
            (i[this.idempotencyHeader] = e.idempotencyKey));
        const s = _R([
            i,
            {
                Accept: "application/json",
                "User-Agent": this.getUserAgent(),
                "X-Stainless-Retry-Count": String(r),
                ...(e.timeout ? { "X-Stainless-Timeout": String(Math.trunc(e.timeout / 1e3)) } : {}),
                ...(YP ?? (YP = XP())),
                "OpenAI-Organization": this.organization,
                "OpenAI-Project": this.project,
            },
            await this.authHeaders(e),
            this._options.defaultHeaders,
            n,
            e.headers,
        ]);
        return this.validateHeaders(s), s.values;
    }
    buildBody({ options: { body: e, headers: t } }) {
        if (!e) return { bodyHeaders: void 0, body: void 0 };
        const n = _R([t]);
        return ArrayBuffer.isView(e) ||
            e instanceof ArrayBuffer ||
            e instanceof DataView ||
            ("string" == typeof e && n.values.has("content-type")) ||
            (globalThis.Blob && e instanceof globalThis.Blob) ||
            e instanceof FormData ||
            e instanceof URLSearchParams ||
            (globalThis.ReadableStream && e instanceof globalThis.ReadableStream)
            ? { bodyHeaders: void 0, body: e }
            : "object" == typeof e &&
                (Symbol.asyncIterator in e || (Symbol.iterator in e && "next" in e && "function" == typeof e.next))
              ? { bodyHeaders: void 0, body: JP(e) }
              : kP(this, oD, "f").call(this, { body: e, headers: n });
    }
}
(aD = uD),
    (oD = new WeakMap()),
    (sD = new WeakSet()),
    (cD = function () {
        return "https://api.openai.com/v1" !== this.baseURL;
    }),
    (uD.OpenAI = aD),
    (uD.DEFAULT_TIMEOUT = 6e5),
    (uD.OpenAIError = SP),
    (uD.APIError = EP),
    (uD.APIConnectionError = IP),
    (uD.APIConnectionTimeoutError = xP),
    (uD.APIUserAbortError = CP),
    (uD.NotFoundError = NP),
    (uD.ConflictError = RP),
    (uD.RateLimitError = DP),
    (uD.BadRequestError = AP),
    (uD.AuthenticationError = PP),
    (uD.InternalServerError = FP),
    (uD.PermissionDeniedError = OP),
    (uD.UnprocessableEntityError = MP),
    (uD.InvalidWebhookSignatureError = zP),
    (uD.toFile = async function (e, t, n) {
        if (
            (HO(),
            ((e) =>
                null != e &&
                "object" == typeof e &&
                "string" == typeof e.name &&
                "number" == typeof e.lastModified &&
                ZO(e))((e = await e)))
        )
            return e instanceof File ? e : qO([await e.arrayBuffer()], e.name);
        if (((e) => null != e && "object" == typeof e && "string" == typeof e.url && "function" == typeof e.blob)(e)) {
            const r = await e.blob();
            return t || (t = new URL(e.url).pathname.split(/[\\/]/).pop()), qO(await eN(r), t, n);
        }
        const r = await eN(e);
        if ((t || (t = XO(e)), !n?.type)) {
            const e = r.find((e) => "object" == typeof e && "type" in e && e.type);
            "string" == typeof e && (n = { ...n, type: e });
        }
        return qO(r, t, n);
    }),
    (uD.Completions = lM),
    (uD.Chat = wR),
    (uD.Embeddings = fM),
    (uD.Files = wM),
    (uD.Images = PM),
    (uD.Audio = CR),
    (uD.Moderations = NM),
    (uD.Models = OM),
    (uD.FineTuning = IM),
    (uD.Graders = AM),
    (uD.VectorStores = tD),
    (uD.Webhooks = lD),
    (uD.Beta = cM),
    (uD.Batches = IR),
    (uD.Uploads = JM),
    (uD.Responses = YM),
    (uD.Realtime = MM),
    (uD.Conversations = pM),
    (uD.Evals = yM),
    (uD.Containers = hM);
const dD = Tu("music-metadata:id3v2:frame-parser"),
    hD = "latin1";
function mD(e) {
    return "RX" === e ? "Remix" : "CR" === e ? "Cover" : e.match(/^\d*$/) ? om[Number.parseInt(e)] : void 0;
}
class pD {
    constructor(e, t) {
        (this.major = e), (this.warningCollector = t);
    }
    readData(e, t, n) {
        if (0 === e.length)
            return void this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${t}`);
        const { encoding: r, bom: i } = zd(e, 0),
            s = e.length;
        let a = 0,
            o = [];
        const c = pD.getNullTerminatorLength(r);
        let l;
        switch ((dD(`Parsing tag type=${t}, encoding=${r}, bom=${i}`), "TXXX" !== t && "T" === t[0] ? "T*" : t)) {
            case "T*":
            case "GRP1":
            case "IPLS":
            case "MVIN":
            case "MVNM":
            case "PCS":
            case "PCST": {
                let n;
                try {
                    n = Ad(e.slice(1), r).replace(/\x00+$/, "");
                } catch (u) {
                    if (u instanceof Error) {
                        this.warningCollector.addWarning(
                            `id3v2.${this.major} type=${t} header has invalid string value: ${u.message}`
                        );
                        break;
                    }
                    throw u;
                }
                switch (t) {
                    case "TMCL":
                    case "TIPL":
                    case "IPLS":
                        o = pD.functionList(this.splitValue(t, n));
                        break;
                    case "TRK":
                    case "TRCK":
                    case "TPOS":
                        o = n;
                        break;
                    case "TCOM":
                    case "TEXT":
                    case "TOLY":
                    case "TOPE":
                    case "TPE1":
                    case "TSRC":
                        o = this.splitValue(t, n);
                        break;
                    case "TCO":
                    case "TCON":
                        o = this.splitValue(t, n)
                            .map((e) =>
                                (function (e) {
                                    const t = [];
                                    let n,
                                        r = "";
                                    for (const i of e)
                                        if ("string" == typeof n)
                                            if ("(" === i && "" === n) (r += "("), (n = void 0);
                                            else if (")" === i) {
                                                "" !== r && (t.push(r), (r = ""));
                                                const e = mD(n);
                                                e && t.push(e), (n = void 0);
                                            } else n += i;
                                        else "(" === i ? (n = "") : (r += i);
                                    return r && (0 === t.length && r.match(/^\d*$/) && (r = mD(r)), r && t.push(r)), t;
                                })(e)
                            )
                            .reduce((e, t) => e.concat(t), []);
                        break;
                    case "PCS":
                    case "PCST":
                        (o = this.major >= 4 ? this.splitValue(t, n) : [n]),
                            (o = Array.isArray(o) && "" === o[0] ? 1 : 0);
                        break;
                    default:
                        o = this.major >= 4 ? this.splitValue(t, n) : [n];
                }
                break;
            }
            case "TXXX": {
                const n = pD.readIdentifierAndData(e, a + 1, s, r);
                o = { description: n.id, text: this.splitValue(t, Ad(n.data, r).replace(/\x00+$/, "")) };
                break;
            }
            case "PIC":
            case "APIC":
                if (n) {
                    const t = {};
                    switch (((a += 1), this.major)) {
                        case 2:
                            (t.format = Ad(e.slice(a, a + 3), "latin1")), (a += 3);
                            break;
                        case 3:
                        case 4:
                            (l = Id(e, a, s, hD)), (t.format = Ad(e.slice(a, l), hD)), (a = l + 1);
                            break;
                        default:
                            throw (function (e) {
                                throw new fD(`Unexpected majorVer: ${e}`);
                            })(this.major);
                    }
                    (t.format = pD.fixPictureMimeType(t.format)),
                        (t.type = Rd[e[a]]),
                        (a += 1),
                        (l = Id(e, a, s, r)),
                        (t.description = Ad(e.slice(a, l), r)),
                        (a = l + c),
                        (t.data = e.slice(a, s)),
                        (o = t);
                }
                break;
            case "CNT":
            case "PCNT":
                o = ml.get(e, 0);
                break;
            case "SYLT": {
                const t = Wd(e, 0);
                a += Vd;
                const n = {
                    descriptor: "",
                    language: t.language,
                    contentType: t.contentType,
                    timeStampFormat: t.timeStampFormat,
                    syncText: [],
                };
                let r = !1;
                for (; a < s; ) {
                    const i = pD.readNullTerminatedString(e.subarray(a), t.encoding);
                    if (((a += i.len), r)) {
                        const t = ml.get(e, a);
                        (a += ml.len), n.syncText.push({ text: i.text, timestamp: t });
                    } else (n.descriptor = i.text), (r = !0);
                }
                o = n;
                break;
            }
            case "ULT":
            case "USLT":
            case "COM":
            case "COMM": {
                const t = $d(e, a);
                a += Ud;
                const n = pD.readNullTerminatedString(e.subarray(a), t.encoding);
                a += n.len;
                const r = pD.readNullTerminatedString(e.subarray(a), t.encoding);
                o = { language: t.language, descriptor: n.text, text: r.text };
                break;
            }
            case "UFID": {
                const t = pD.readIdentifierAndData(e, a, s, hD);
                o = { owner_identifier: t.id, identifier: t.data };
                break;
            }
            case "PRIV": {
                const t = pD.readIdentifierAndData(e, a, s, hD);
                o = { owner_identifier: t.id, data: t.data };
                break;
            }
            case "POPM": {
                l = Id(e, a, s, hD);
                const t = Ad(e.slice(a, l), hD);
                a = l + 1;
                const n = s - a;
                o = { email: t, rating: ol.get(e, a), counter: n >= 5 ? ml.get(e, a + 1) : void 0 };
                break;
            }
            case "GEOB": {
                l = Id(e, a + 1, s, r);
                const t = Ad(e.slice(a + 1, l), hD);
                (a = l + 1), (l = Id(e, a, s, r));
                const n = Ad(e.slice(a, l), hD);
                (a = l + 1), (l = Id(e, a, s, r));
                const i = Ad(e.slice(a, l), hD);
                a = l + 1;
                o = { type: t, filename: n, description: i, data: e.slice(a, s) };
                break;
            }
            case "WCOM":
            case "WCOP":
            case "WOAF":
            case "WOAR":
            case "WOAS":
            case "WORS":
            case "WPAY":
            case "WPUB":
                (l = Id(e, a + 1, s, r)), (o = Ad(e.slice(a, l), hD));
                break;
            case "WXXX": {
                l = Id(e, a + 1, s, r);
                const t = Ad(e.slice(a + 1, l), r);
                (a = l + ("utf-16le" === r ? 2 : 1)), (o = { description: t, url: Ad(e.slice(a, s), hD) });
                break;
            }
            case "WFD":
            case "WFED":
                o = Ad(e.slice(a + 1, Id(e, a + 1, s, r)), r);
                break;
            case "MCDI":
                o = e.slice(0, s);
                break;
            default:
                dD(`Warning: unsupported id3v2-tag-type: ${t}`);
        }
        return o;
    }
    static readNullTerminatedString(e, t) {
        let n = t.bom ? 2 : 0;
        const r = Id(e, n, e.length, t.encoding),
            i = e.slice(n, r);
        return (n = "utf-16le" === t.encoding ? r + 2 : r + 1), { text: Ad(i, t.encoding), len: n };
    }
    static fixPictureMimeType(e) {
        switch ((e = e.toLocaleLowerCase())) {
            case "jpg":
                return "image/jpeg";
            case "png":
                return "image/png";
        }
        return e;
    }
    static functionList(e) {
        const t = {};
        for (let n = 0; n + 1 < e.length; n += 2) {
            const r = e[n + 1].split(",");
            t[e[n]] = t[e[n]] ? t[e[n]].concat(r) : r;
        }
        return t;
    }
    splitValue(e, t) {
        let n;
        return (
            this.major < 4
                ? ((n = t.split(/\x00/g)),
                  n.length > 1
                      ? this.warningCollector.addWarning(`ID3v2.${this.major} ${e} uses non standard null-separator.`)
                      : (n = t.split(/\//g)))
                : (n = t.split(/\x00/g)),
            pD.trimArray(n)
        );
    }
    static trimArray(e) {
        return e.map((e) => e.replace(/\x00+$/, "").trim());
    }
    static readIdentifierAndData(e, t, n, r) {
        const i = Id(e, t, n, r),
            s = Ad(e.slice(t, i), r);
        return (t = i + pD.getNullTerminatorLength(r)), { id: s, data: e.slice(t, n) };
    }
    static getNullTerminatorLength(e) {
        return "utf-16le" === e ? 2 : 1;
    }
}
class fD extends Ed("id3v2") {}
const gD = new TextDecoder("ascii");
class bD {
    constructor() {
        (this.tokenizer = void 0),
            (this.id3Header = void 0),
            (this.metadata = void 0),
            (this.headerType = void 0),
            (this.options = void 0);
    }
    static removeUnsyncBytes(e) {
        let t = 0,
            n = 0;
        for (; t < e.length - 1; ) t !== n && (e[n] = e[t]), (t += 255 === e[t] && 0 === e[t + 1] ? 2 : 1), n++;
        return t < e.length && (e[n++] = e[t]), e.slice(0, n);
    }
    static getFrameHeaderLength(e) {
        switch (e) {
            case 2:
                return 6;
            case 3:
            case 4:
                return 10;
            default:
                throw yD(e);
        }
    }
    static readFrameFlags(e) {
        return {
            status: {
                tag_alter_preservation: Cd(e, 0, 6),
                file_alter_preservation: Cd(e, 0, 5),
                read_only: Cd(e, 0, 4),
            },
            format: {
                grouping_identity: Cd(e, 1, 7),
                compression: Cd(e, 1, 3),
                encryption: Cd(e, 1, 2),
                unsynchronisation: Cd(e, 1, 1),
                data_length_indicator: Cd(e, 1, 0),
            },
        };
    }
    static readFrameData(e, t, n, r, i) {
        const s = new pD(n, i);
        switch (n) {
            case 2:
                return s.readData(e, t.id, r);
            case 3:
            case 4:
                return (
                    t.flags?.format.unsynchronisation && (e = bD.removeUnsyncBytes(e)),
                    t.flags?.format.data_length_indicator && (e = e.slice(4, e.length)),
                    s.readData(e, t.id, r)
                );
            default:
                throw yD(n);
        }
    }
    static makeDescriptionTagName(e, t) {
        return e + (t ? `:${t}` : "");
    }
    async parse(e, t, n) {
        (this.tokenizer = t), (this.metadata = e), (this.options = n);
        const r = await this.tokenizer.readToken(Ld);
        if ("ID3" !== r.fileIdentifier) throw new fD("expected ID3-header file-identifier 'ID3' was not found");
        return (
            (this.id3Header = r),
            (this.headerType = `ID3v2.${r.version.major}`),
            r.flags.isExtendedHeader ? this.parseExtendedHeader() : this.parseId3Data(r.size)
        );
    }
    async parseExtendedHeader() {
        const e = await this.tokenizer.readToken(Bd),
            t = e.size - Bd.len;
        return t > 0 ? this.parseExtendedHeaderData(t, e.size) : this.parseId3Data(this.id3Header.size - e.size);
    }
    async parseExtendedHeaderData(e, t) {
        return await this.tokenizer.ignore(e), this.parseId3Data(this.id3Header.size - t);
    }
    async parseId3Data(e) {
        const t = await this.tokenizer.readToken(new Rl(e));
        for (const n of this.parseMetadata(t))
            if ("TXXX" === n.id) n.value && (await this.handleTag(n, n.value.text, () => n.value.description));
            else
                await (Array.isArray(n.value)
                    ? Promise.all(n.value.map((e) => this.addTag(n.id, e)))
                    : this.addTag(n.id, n.value));
    }
    async handleTag(e, t, n, r = (e) => e) {
        await Promise.all(t.map((t) => this.addTag(bD.makeDescriptionTagName(e.id, n(t)), r(t))));
    }
    async addTag(e, t) {
        await this.metadata.addTag(this.headerType, e, t);
    }
    parseMetadata(e) {
        let t = 0;
        const n = [];
        for (; t !== e.length; ) {
            const r = bD.getFrameHeaderLength(this.id3Header.version.major);
            if (t + r > e.length) {
                this.metadata.addWarning("Illegal ID3v2 tag length");
                break;
            }
            const i = e.slice(t, t + r);
            t += r;
            const s = this.readFrameHeader(i, this.id3Header.version.major),
                a = e.slice(t, t + s.length);
            t += s.length;
            const o = bD.readFrameData(a, s, this.id3Header.version.major, !this.options.skipCovers, this.metadata);
            o && n.push({ id: s.id, value: o });
        }
        return n;
    }
    readFrameHeader(e, t) {
        let n;
        switch (t) {
            case 2:
                (n = { id: gD.decode(e.slice(0, 3)), length: dl.get(e, 3) }),
                    n.id.match(/[A-Z0-9]{3}/g) ||
                        this.metadata.addWarning(
                            `Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${n.id}`
                        );
                break;
            case 3:
            case 4:
                (n = {
                    id: gD.decode(e.slice(0, 4)),
                    length: (4 === t ? Fd : ml).get(e, 4),
                    flags: bD.readFrameFlags(e.slice(8, 10)),
                }),
                    n.id.match(/[A-Z0-9]{4}/g) ||
                        this.metadata.addWarning(
                            `Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${n.id}`
                        );
                break;
            default:
                throw yD(t);
        }
        return n;
    }
}
function yD(e) {
    throw new fD(`Unexpected majorVer: ${e}`);
}
const wD = Tu("music-metadata:parser:ID3");
class kD extends Uh {
    constructor() {
        super(...arguments), (this.id3parser = new bD());
    }
    static async startsWithID3v2Header(e) {
        return "ID3" === (await e.peekToken(Ld)).fileIdentifier;
    }
    async parse() {
        try {
            await this.parseID3v2();
        } catch (e) {
            if (!(e instanceof qc)) throw e;
            wD("End-of-stream");
        }
    }
    finalize() {}
    async parseID3v2() {
        if (
            (await this.tryReadId3v2Headers(),
            wD("End of ID3v2 header, go to MPEG-parser: pos=%s", this.tokenizer.position),
            await this.postId3v2Parse(),
            this.options.skipPostHeaders && this.metadata.hasAny())
        )
            this.finalize();
        else {
            const e = new um(this.metadata, this.tokenizer, this.options);
            await e.parse(), this.finalize();
        }
    }
    async tryReadId3v2Headers() {
        if ("ID3" === (await this.tokenizer.peekToken(Ld)).fileIdentifier)
            return (
                wD("Found ID3v2 header, pos=%s", this.tokenizer.position),
                await this.id3parser.parse(this.metadata, this.tokenizer, this.options),
                this.tryReadId3v2Headers()
            );
    }
}
const TD = (e, t) => {
        const n = Od(e, t, 0, 3),
            r = Od(e, t, 6, 1),
            i = Od(e, t, 7, 9) / 10;
        if (n > 0) return { type: Od(e, t, 0, 3), origin: Od(e, t, 3, 3), adjustment: r ? -i : i };
    },
    _D = {
        len: 27,
        get: (e, t) => {
            const n = ml.get(e, t + 2);
            return {
                revision: Od(e, t, 0, 4),
                vbr_method: Od(e, t, 4, 4),
                lowpass_filter: 100 * ol.get(e, t + 1),
                track_peak: 0 === n ? null : n / 2 ** 23,
                track_gain: TD(e, 6),
                album_gain: TD(e, 8),
                music_length: ml.get(e, t + 20),
                music_crc: ol.get(e, t + 24),
                header_crc: ll.get(e, t + 24),
            };
        },
    },
    vD = new Ml(4, "ascii"),
    SD = new Ml(6, "ascii"),
    ED = {
        len: 4,
        get: (e, t) => ({ frames: Nd(e, t, 31), bytes: Nd(e, t, 30), toc: Nd(e, t, 29), vbrScale: Nd(e, t, 28) }),
    };
const CD = Tu("music-metadata:parser:mpeg");
class ID extends Ed("MPEG") {}
const xD = {
        AudioObjectTypes: ["AAC Main", "AAC LC", "AAC SSR", "AAC LTP"],
        SamplingFrequencies: [
            96e3,
            88200,
            64e3,
            48e3,
            44100,
            32e3,
            24e3,
            22050,
            16e3,
            12e3,
            11025,
            8e3,
            7350,
            null,
            null,
            -1,
        ],
    },
    AD = [
        void 0,
        ["front-center"],
        ["front-left", "front-right"],
        ["front-center", "front-left", "front-right"],
        ["front-center", "front-left", "front-right", "back-center"],
        ["front-center", "front-left", "front-right", "back-left", "back-right"],
        ["front-center", "front-left", "front-right", "back-left", "back-right", "LFE-channel"],
        [
            "front-center",
            "front-left",
            "front-right",
            "side-left",
            "side-right",
            "back-left",
            "back-right",
            "LFE-channel",
        ],
    ];
class PD {
    constructor(e, t) {
        (this.bitrateIndex = null),
            (this.sampRateFreqIndex = null),
            (this.padding = null),
            (this.privateBit = null),
            (this.channelModeIndex = null),
            (this.modeExtension = null),
            (this.isOriginalMedia = null),
            (this.version = null),
            (this.bitrate = null),
            (this.samplingRate = null),
            (this.frameLength = 0),
            (this.versionIndex = Od(e, t + 1, 3, 2)),
            (this.layer = PD.LayerDescription[Od(e, t + 1, 5, 2)]),
            this.versionIndex > 1 && 0 === this.layer ? this.parseAdtsHeader(e, t) : this.parseMpegHeader(e, t),
            (this.isProtectedByCRC = !Nd(e, t + 1, 7));
    }
    calcDuration(e) {
        return null == this.samplingRate ? null : (e * this.calcSamplesPerFrame()) / this.samplingRate;
    }
    calcSamplesPerFrame() {
        return PD.samplesInFrameTable[1 === this.version ? 0 : 1][this.layer];
    }
    calculateSideInfoLength() {
        if (3 !== this.layer) return 2;
        if (3 === this.channelModeIndex) {
            if (1 === this.version) return 17;
            if (2 === this.version || 2.5 === this.version) return 9;
        } else {
            if (1 === this.version) return 32;
            if (2 === this.version || 2.5 === this.version) return 17;
        }
        return null;
    }
    calcSlotSize() {
        return [null, 4, 1, 1][this.layer];
    }
    parseMpegHeader(e, t) {
        (this.container = "MPEG"),
            (this.bitrateIndex = Od(e, t + 2, 0, 4)),
            (this.sampRateFreqIndex = Od(e, t + 2, 4, 2)),
            (this.padding = Nd(e, t + 2, 6)),
            (this.privateBit = Nd(e, t + 2, 7)),
            (this.channelModeIndex = Od(e, t + 3, 0, 2)),
            (this.modeExtension = Od(e, t + 3, 2, 2)),
            (this.isCopyrighted = Nd(e, t + 3, 4)),
            (this.isOriginalMedia = Nd(e, t + 3, 5)),
            (this.emphasis = Od(e, t + 3, 7, 2)),
            (this.version = PD.VersionID[this.versionIndex]),
            (this.channelMode = PD.ChannelMode[this.channelModeIndex]),
            (this.codec = `MPEG ${this.version} Layer ${this.layer}`);
        const n = this.calcBitrate();
        if (!n) throw new ID("Cannot determine bit-rate");
        if (((this.bitrate = 1e3 * n), (this.samplingRate = this.calcSamplingRate()), null == this.samplingRate))
            throw new ID("Cannot determine sampling-rate");
    }
    parseAdtsHeader(e, t) {
        CD("layer=0 => ADTS"),
            (this.version = 2 === this.versionIndex ? 4 : 2),
            (this.container = `ADTS/MPEG-${this.version}`);
        const n = Od(e, t + 2, 0, 2);
        (this.codec = "AAC"), (this.codecProfile = xD.AudioObjectTypes[n]), CD(`MPEG-4 audio-codec=${this.codec}`);
        const r = Od(e, t + 2, 2, 4);
        (this.samplingRate = xD.SamplingFrequencies[r]), CD(`sampling-rate=${this.samplingRate}`);
        const i = Od(e, t + 2, 7, 3);
        (this.mp4ChannelConfig = AD[i]),
            CD(`channel-config=${this.mp4ChannelConfig ? this.mp4ChannelConfig.join("+") : "?"}`),
            (this.frameLength = Od(e, t + 3, 6, 2) << 11);
    }
    calcBitrate() {
        if (0 === this.bitrateIndex || 15 === this.bitrateIndex) return null;
        if (this.version && this.bitrateIndex) {
            const e = 10 * Math.floor(this.version) + this.layer;
            return PD.bitrate_index[this.bitrateIndex][e];
        }
        return null;
    }
    calcSamplingRate() {
        return 3 === this.sampRateFreqIndex || null === this.version || null == this.sampRateFreqIndex
            ? null
            : PD.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];
    }
}
(PD.SyncByte1 = 255),
    (PD.SyncByte2 = 224),
    (PD.VersionID = [2.5, null, 2, 1]),
    (PD.LayerDescription = [0, 3, 2, 1]),
    (PD.ChannelMode = ["stereo", "joint_stereo", "dual_channel", "mono"]),
    (PD.bitrate_index = {
        1: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },
        2: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },
        3: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },
        4: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },
        5: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },
        6: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },
        7: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },
        8: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },
        9: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },
        10: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },
        11: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },
        12: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },
        13: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },
        14: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 },
    }),
    (PD.sampling_rate_freq_index = {
        1: { 0: 44100, 1: 48e3, 2: 32e3 },
        2: { 0: 22050, 1: 24e3, 2: 16e3 },
        2.5: { 0: 11025, 1: 12e3, 2: 8e3 },
    }),
    (PD.samplesInFrameTable = [
        [0, 384, 1152, 1152],
        [0, 384, 1152, 576],
    ]);
const OD = 4,
    ND = (e, t) => new PD(e, t);
const RD = Object.freeze(
    Object.defineProperty(
        {
            __proto__: null,
            MpegContentError: ID,
            MpegParser: class extends kD {
                constructor() {
                    super(...arguments),
                        (this.frameCount = 0),
                        (this.syncFrameCount = -1),
                        (this.countSkipFrameData = 0),
                        (this.totalDataLength = 0),
                        (this.bitrates = []),
                        (this.offset = 0),
                        (this.frame_size = 0),
                        (this.crc = null),
                        (this.calculateEofDuration = !1),
                        (this.samplesPerFrame = null),
                        (this.buf_frame_header = new Uint8Array(4)),
                        (this.mpegOffset = null),
                        (this.syncPeek = { buf: new Uint8Array(1024), len: 0 });
                }
                async postId3v2Parse() {
                    this.metadata.setFormat("lossless", !1), this.metadata.setAudioOnly();
                    try {
                        let e = !1;
                        for (; !e; ) await this.sync(), (e = await this.parseCommonMpegHeader());
                    } catch (e) {
                        if (!(e instanceof qc)) throw e;
                        if ((CD("End-of-stream"), this.calculateEofDuration && null !== this.samplesPerFrame)) {
                            const e = this.frameCount * this.samplesPerFrame;
                            if ((this.metadata.setFormat("numberOfSamples", e), this.metadata.format.sampleRate)) {
                                const t = e / this.metadata.format.sampleRate;
                                CD(`Calculate duration at EOF: ${t} sec.`, t), this.metadata.setFormat("duration", t);
                            }
                        }
                    }
                }
                finalize() {
                    const e = this.metadata.format,
                        t = !!this.metadata.native.ID3v1;
                    if (null !== this.mpegOffset) {
                        if (e.duration && this.tokenizer.fileInfo.size) {
                            const n = this.tokenizer.fileInfo.size - this.mpegOffset - (t ? 128 : 0);
                            e.codecProfile &&
                                "V" === e.codecProfile[0] &&
                                this.metadata.setFormat("bitrate", (8 * n) / e.duration);
                        }
                        if (this.tokenizer.fileInfo.size && "CBR" === e.codecProfile) {
                            const n = this.tokenizer.fileInfo.size - this.mpegOffset - (t ? 128 : 0);
                            if (null !== this.frame_size && null !== this.samplesPerFrame) {
                                const t = Math.round(n / this.frame_size) * this.samplesPerFrame;
                                if ((this.metadata.setFormat("numberOfSamples", t), e.sampleRate && !e.duration)) {
                                    const n = t / e.sampleRate;
                                    CD("Calculate CBR duration based on file size: %s", n),
                                        this.metadata.setFormat("duration", n);
                                }
                            }
                        }
                    }
                }
                async sync() {
                    let e = !1;
                    for (;;) {
                        let t = 0;
                        if (
                            ((this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, {
                                length: 1024,
                                mayBeLess: !0,
                            })),
                            this.syncPeek.len <= 163)
                        )
                            throw new qc();
                        for (;;) {
                            if (e && !(224 & ~this.syncPeek.buf[t]))
                                return (
                                    (this.buf_frame_header[0] = PD.SyncByte1),
                                    (this.buf_frame_header[1] = this.syncPeek.buf[t]),
                                    await this.tokenizer.ignore(t),
                                    CD(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`),
                                    this.syncFrameCount === this.frameCount &&
                                        (CD(`Re-synced MPEG stream, frameCount=${this.frameCount}`),
                                        (this.frameCount = 0),
                                        (this.frame_size = 0)),
                                    void (this.syncFrameCount = this.frameCount)
                                );
                            if (((e = !1), (t = this.syncPeek.buf.indexOf(PD.SyncByte1, t)), -1 === t)) {
                                if (this.syncPeek.len < this.syncPeek.buf.length) throw new qc();
                                await this.tokenizer.ignore(this.syncPeek.len);
                                break;
                            }
                            ++t, (e = !0);
                        }
                    }
                }
                async parseCommonMpegHeader() {
                    let e;
                    0 === this.frameCount && (this.mpegOffset = this.tokenizer.position - 1),
                        await this.tokenizer.peekBuffer(this.buf_frame_header.subarray(1), { length: 3 });
                    try {
                        e = ND(this.buf_frame_header, 0);
                    } catch (t) {
                        if ((await this.tokenizer.ignore(1), t instanceof Error))
                            return this.metadata.addWarning(`Parse error: ${t.message}`), !1;
                        throw t;
                    }
                    return (
                        await this.tokenizer.ignore(3),
                        this.metadata.setFormat("container", e.container),
                        this.metadata.setFormat("codec", e.codec),
                        this.metadata.setFormat("lossless", !1),
                        this.metadata.setFormat("sampleRate", e.samplingRate),
                        this.frameCount++,
                        null !== e.version && e.version >= 2 && 0 === e.layer
                            ? this.parseAdts(e)
                            : this.parseAudioFrameHeader(e)
                    );
                }
                async parseAudioFrameHeader(e) {
                    this.metadata.setFormat("numberOfChannels", "mono" === e.channelMode ? 1 : 2),
                        this.metadata.setFormat("bitrate", e.bitrate),
                        this.frameCount < 2e5 &&
                            CD(
                                "offset=%s MP%s bitrate=%s sample-rate=%s",
                                this.tokenizer.position - 4,
                                e.layer,
                                e.bitrate,
                                e.samplingRate
                            );
                    const t = e.calcSlotSize();
                    if (null === t) throw new ID("invalid slot_size");
                    const n = e.calcSamplesPerFrame();
                    CD(`samples_per_frame=${n}`);
                    const r = n / 8;
                    if (null !== e.bitrate && null != e.samplingRate) {
                        const n = (r * e.bitrate) / e.samplingRate + (e.padding ? t : 0);
                        this.frame_size = Math.floor(n);
                    }
                    if (
                        ((this.audioFrameHeader = e),
                        null !== e.bitrate && this.bitrates.push(e.bitrate),
                        1 === this.frameCount)
                    )
                        return (this.offset = OD), await this.skipSideInformation(), !1;
                    if (3 === this.frameCount) {
                        if (this.areAllSame(this.bitrates)) {
                            if (
                                ((this.samplesPerFrame = n),
                                this.metadata.setFormat("codecProfile", "CBR"),
                                this.tokenizer.fileInfo.size)
                            )
                                return !0;
                        } else if (this.metadata.format.duration) return !0;
                        if (!this.options.duration) return !0;
                    }
                    return (
                        this.options.duration &&
                            4 === this.frameCount &&
                            ((this.samplesPerFrame = n), (this.calculateEofDuration = !0)),
                        (this.offset = 4),
                        e.isProtectedByCRC ? (await this.parseCrc(), !1) : (await this.skipSideInformation(), !1)
                    );
                }
                async parseAdts(e) {
                    const t = new Uint8Array(3);
                    if (
                        (await this.tokenizer.readBuffer(t),
                        (e.frameLength += Od(t, 0, 0, 11)),
                        (this.totalDataLength += e.frameLength),
                        (this.samplesPerFrame = 1024),
                        null !== e.samplingRate)
                    ) {
                        const t = e.samplingRate / this.samplesPerFrame,
                            n = 8 * (0 === this.frameCount ? 0 : this.totalDataLength / this.frameCount) * t + 0.5;
                        this.metadata.setFormat("bitrate", n),
                            CD(`frame-count=${this.frameCount}, size=${e.frameLength} bytes, bit-rate=${n}`);
                    }
                    if (
                        (await this.tokenizer.ignore(e.frameLength > 7 ? e.frameLength - 7 : 1), 3 === this.frameCount)
                    ) {
                        if (
                            (this.metadata.setFormat("codecProfile", e.codecProfile),
                            e.mp4ChannelConfig &&
                                this.metadata.setFormat("numberOfChannels", e.mp4ChannelConfig.length),
                            !this.options.duration)
                        )
                            return !0;
                        this.calculateEofDuration = !0;
                    }
                    return !1;
                }
                async parseCrc() {
                    return (
                        (this.crc = await this.tokenizer.readNumber(fl)), (this.offset += 2), this.skipSideInformation()
                    );
                }
                async skipSideInformation() {
                    if (this.audioFrameHeader) {
                        const e = this.audioFrameHeader.calculateSideInfoLength();
                        if (null !== e)
                            return (
                                await this.tokenizer.readToken(new Rl(e)),
                                (this.offset += e),
                                void (await this.readXtraInfoHeader())
                            );
                    }
                }
                async readXtraInfoHeader() {
                    const e = await this.tokenizer.readToken(vD);
                    switch (((this.offset += vD.len), e)) {
                        case "Info":
                            return this.metadata.setFormat("codecProfile", "CBR"), this.readXingInfoHeader();
                        case "Xing": {
                            const e = await this.readXingInfoHeader();
                            if (null !== e.vbrScale) {
                                const n = ((t = e.vbrScale), `V${Math.floor((100 - t) / 10)}`);
                                this.metadata.setFormat("codecProfile", n);
                            }
                            return null;
                        }
                        case "Xtra":
                            break;
                        case "LAME": {
                            const e = await this.tokenizer.readToken(SD);
                            if (null !== this.frame_size && this.frame_size >= this.offset + SD.len)
                                return (
                                    (this.offset += SD.len),
                                    this.metadata.setFormat("tool", `LAME ${e}`),
                                    await this.skipFrameData(this.frame_size - this.offset),
                                    null
                                );
                            this.metadata.addWarning("Corrupt LAME header");
                            break;
                        }
                    }
                    var t;
                    const n = this.frame_size - this.offset;
                    return (
                        n < 0
                            ? this.metadata.addWarning(`Frame ${this.frameCount}corrupt: negative frameDataLeft`)
                            : await this.skipFrameData(n),
                        null
                    );
                }
                async readXingInfoHeader() {
                    const e = this.tokenizer.position,
                        t = await (async function (e) {
                            const t = await e.readToken(ED),
                                n = { numFrames: null, streamSize: null, vbrScale: null };
                            if (
                                (t.frames && (n.numFrames = await e.readToken(ml)),
                                t.bytes && (n.streamSize = await e.readToken(ml)),
                                t.toc && ((n.toc = new Uint8Array(100)), await e.readBuffer(n.toc)),
                                t.vbrScale && (n.vbrScale = await e.readToken(ml)),
                                "LAME" === (await e.peekToken(new Ml(4, "ascii"))))
                            ) {
                                await e.ignore(4), (n.lame = { version: await e.readToken(new Ml(5, "ascii")) });
                                const t = n.lame.version.match(/\d+.\d+/g);
                                if (null !== t) {
                                    const r = t[0].split(".").map((e) => Number.parseInt(e, 10));
                                    r[0] >= 3 && r[1] >= 90 && (n.lame.extended = await e.readToken(_D));
                                }
                            }
                            return n;
                        })(this.tokenizer);
                    if (
                        ((this.offset += this.tokenizer.position - e),
                        t.lame &&
                            (this.metadata.setFormat("tool", `LAME ${Pd(t.lame.version)}`),
                            t.lame.extended &&
                                (this.metadata.setFormat("trackPeakLevel", t.lame.extended.track_peak),
                                t.lame.extended.track_gain &&
                                    this.metadata.setFormat("trackGain", t.lame.extended.track_gain.adjustment),
                                t.lame.extended.album_gain &&
                                    this.metadata.setFormat("albumGain", t.lame.extended.album_gain.adjustment),
                                this.metadata.setFormat("duration", t.lame.extended.music_length / 1e3))),
                        t.streamSize && this.audioFrameHeader && null !== t.numFrames)
                    ) {
                        const e = this.audioFrameHeader.calcDuration(t.numFrames);
                        return (
                            this.metadata.setFormat("duration", e),
                            CD("Get duration from Xing header: %s", this.metadata.format.duration),
                            t
                        );
                    }
                    const n = this.frame_size - this.offset;
                    return await this.skipFrameData(n), t;
                }
                async skipFrameData(e) {
                    if (e < 0) throw new ID("frame-data-left cannot be negative");
                    await this.tokenizer.ignore(e), (this.countSkipFrameData += e);
                }
                areAllSame(e) {
                    const t = e[0];
                    return e.every((e) => e === t);
                }
            },
        },
        Symbol.toStringTag,
        { value: "Module" }
    )
);
class MD {
    static fromBin(e, t = 0) {
        return new MD(MD.decode(e, t));
    }
    static decode(e, t = 0) {
        const n = new DataView(e.buffer, t);
        return `${n.getUint32(0, !0).toString(16)}-${n.getUint16(4, !0).toString(16)}-${n.getUint16(6, !0).toString(16)}-${n.getUint16(8).toString(16)}-${Xu(e.slice(t + 10, t + 16))}`.toUpperCase();
    }
    static decodeMediaType(e) {
        switch (e.str) {
            case MD.AudioMedia.str:
                return "audio";
            case MD.VideoMedia.str:
                return "video";
            case MD.CommandMedia.str:
                return "command";
            case MD.Degradable_JPEG_Media.str:
                return "degradable-jpeg";
            case MD.FileTransferMedia.str:
                return "file-transfer";
            case MD.BinaryMedia.str:
                return "binary";
        }
    }
    static encode(e) {
        const t = new Uint8Array(16),
            n = new DataView(t.buffer);
        return (
            n.setUint32(0, Number.parseInt(e.slice(0, 8), 16), !0),
            n.setUint16(4, Number.parseInt(e.slice(9, 13), 16), !0),
            n.setUint16(6, Number.parseInt(e.slice(14, 18), 16), !0),
            t.set(Ku(e.slice(19, 23)), 8),
            t.set(Ku(e.slice(24)), 10),
            t
        );
    }
    constructor(e) {
        this.str = e;
    }
    equals(e) {
        return this.str === e.str;
    }
    toBin() {
        return MD.encode(this.str);
    }
}
function DD(e) {
    return Pd(Ad(e, "utf-16le"));
}
(MD.HeaderObject = new MD("75B22630-668E-11CF-A6D9-00AA0062CE6C")),
    (MD.DataObject = new MD("75B22636-668E-11CF-A6D9-00AA0062CE6C")),
    (MD.SimpleIndexObject = new MD("33000890-E5B1-11CF-89F4-00A0C90349CB")),
    (MD.IndexObject = new MD("D6E229D3-35DA-11D1-9034-00A0C90349BE")),
    (MD.MediaObjectIndexObject = new MD("FEB103F8-12AD-4C64-840F-2A1D2F7AD48C")),
    (MD.TimecodeIndexObject = new MD("3CB73FD0-0C4A-4803-953D-EDF7B6228F0C")),
    (MD.FilePropertiesObject = new MD("8CABDCA1-A947-11CF-8EE4-00C00C205365")),
    (MD.StreamPropertiesObject = new MD("B7DC0791-A9B7-11CF-8EE6-00C00C205365")),
    (MD.HeaderExtensionObject = new MD("5FBF03B5-A92E-11CF-8EE3-00C00C205365")),
    (MD.CodecListObject = new MD("86D15240-311D-11D0-A3A4-00A0C90348F6")),
    (MD.ScriptCommandObject = new MD("1EFB1A30-0B62-11D0-A39B-00A0C90348F6")),
    (MD.MarkerObject = new MD("F487CD01-A951-11CF-8EE6-00C00C205365")),
    (MD.BitrateMutualExclusionObject = new MD("D6E229DC-35DA-11D1-9034-00A0C90349BE")),
    (MD.ErrorCorrectionObject = new MD("75B22635-668E-11CF-A6D9-00AA0062CE6C")),
    (MD.ContentDescriptionObject = new MD("75B22633-668E-11CF-A6D9-00AA0062CE6C")),
    (MD.ExtendedContentDescriptionObject = new MD("D2D0A440-E307-11D2-97F0-00A0C95EA850")),
    (MD.ContentBrandingObject = new MD("2211B3FA-BD23-11D2-B4B7-00A0C955FC6E")),
    (MD.StreamBitratePropertiesObject = new MD("7BF875CE-468D-11D1-8D82-006097C9A2B2")),
    (MD.ContentEncryptionObject = new MD("2211B3FB-BD23-11D2-B4B7-00A0C955FC6E")),
    (MD.ExtendedContentEncryptionObject = new MD("298AE614-2622-4C17-B935-DAE07EE9289C")),
    (MD.DigitalSignatureObject = new MD("2211B3FC-BD23-11D2-B4B7-00A0C955FC6E")),
    (MD.PaddingObject = new MD("1806D474-CADF-4509-A4BA-9AABCB96AAE8")),
    (MD.ExtendedStreamPropertiesObject = new MD("14E6A5CB-C672-4332-8399-A96952065B5A")),
    (MD.AdvancedMutualExclusionObject = new MD("A08649CF-4775-4670-8A16-6E35357566CD")),
    (MD.GroupMutualExclusionObject = new MD("D1465A40-5A79-4338-B71B-E36B8FD6C249")),
    (MD.StreamPrioritizationObject = new MD("D4FED15B-88D3-454F-81F0-ED5C45999E24")),
    (MD.BandwidthSharingObject = new MD("A69609E6-517B-11D2-B6AF-00C04FD908E9")),
    (MD.LanguageListObject = new MD("7C4346A9-EFE0-4BFC-B229-393EDE415C85")),
    (MD.MetadataObject = new MD("C5F8CBEA-5BAF-4877-8467-AA8C44FA4CCA")),
    (MD.MetadataLibraryObject = new MD("44231C94-9498-49D1-A141-1D134E457054")),
    (MD.IndexParametersObject = new MD("D6E229DF-35DA-11D1-9034-00A0C90349BE")),
    (MD.MediaObjectIndexParametersObject = new MD("6B203BAD-3F11-48E4-ACA8-D7613DE2CFA7")),
    (MD.TimecodeIndexParametersObject = new MD("F55E496D-9797-4B5D-8C8B-604DFE9BFB24")),
    (MD.CompatibilityObject = new MD("26F18B5D-4584-47EC-9F5F-0E651F0452C9")),
    (MD.AdvancedContentEncryptionObject = new MD("43058533-6981-49E6-9B74-AD12CB86D58C")),
    (MD.AudioMedia = new MD("F8699E40-5B4D-11CF-A8FD-00805F5C442B")),
    (MD.VideoMedia = new MD("BC19EFC0-5B4D-11CF-A8FD-00805F5C442B")),
    (MD.CommandMedia = new MD("59DACFC0-59E6-11D0-A3AC-00A0C90348F6")),
    (MD.JFIF_Media = new MD("B61BE100-5B4E-11CF-A8FD-00805F5C442B")),
    (MD.Degradable_JPEG_Media = new MD("35907DE0-E415-11CF-A917-00805F5C442B")),
    (MD.FileTransferMedia = new MD("91BD222C-F21C-497A-8B6D-5AA86BFC0185")),
    (MD.BinaryMedia = new MD("3AFB65E2-47EF-40F2-AC2C-70A90D71D343")),
    (MD.ASF_Index_Placeholder_Object = new MD("D9AADE20-7C17-4F9C-BC28-8555DD98E2A2"));
const FD = [
    DD,
    LD,
    function (e, t = 0) {
        return 1 === BD(e, t);
    },
    function (e, t = 0) {
        return hl.get(e, t);
    },
    function (e, t = 0) {
        return Tl.get(e, t);
    },
    BD,
    LD,
];
function LD(e) {
    return new Uint8Array(e);
}
function BD(e, t = 0) {
    return cl.get(e, t);
}
class zD extends Ed("ASF") {}
const UD = {
        len: 30,
        get: (e, t) => ({
            objectId: MD.fromBin(e, t),
            objectSize: Number(Tl.get(e, t + 16)),
            numberOfHeaderObjects: hl.get(e, t + 24),
        }),
    },
    $D = { len: 24, get: (e, t) => ({ objectId: MD.fromBin(e, t), objectSize: Number(Tl.get(e, t + 16)) }) };
class VD {
    constructor(e) {
        this.len = Number(e.objectSize) - $D.len;
    }
    postProcessTag(e, t, n, r) {
        if ("WM/Picture" === t) e.push({ id: t, value: rF.fromBuffer(r) });
        else {
            const i = (function (e) {
                return FD[e];
            })(n);
            if (!i) throw new zD(`unexpected value headerType: ${n}`);
            e.push({ id: t, value: i(r) });
        }
    }
}
class WD extends VD {
    get(e, t) {
        return null;
    }
}
class jD extends VD {
    get(e, t) {
        return {
            fileId: MD.fromBin(e, t),
            fileSize: Tl.get(e, t + 16),
            creationDate: Tl.get(e, t + 24),
            dataPacketsCount: Tl.get(e, t + 32),
            playDuration: Tl.get(e, t + 40),
            sendDuration: Tl.get(e, t + 48),
            preroll: Tl.get(e, t + 56),
            flags: { broadcast: Cd(e, t + 64, 24), seekable: Cd(e, t + 64, 25) },
            minimumDataPacketSize: hl.get(e, t + 68),
            maximumDataPacketSize: hl.get(e, t + 72),
            maximumBitrate: hl.get(e, t + 76),
        };
    }
}
jD.guid = MD.FilePropertiesObject;
class HD extends VD {
    get(e, t) {
        return { streamType: MD.decodeMediaType(MD.fromBin(e, t)), errorCorrectionType: MD.fromBin(e, t + 8) };
    }
}
HD.guid = MD.StreamPropertiesObject;
class qD {
    constructor() {
        this.len = 22;
    }
    get(e, t) {
        const n = new DataView(e.buffer, t);
        return { reserved1: MD.fromBin(e, t), reserved2: n.getUint16(16, !0), extensionDataSize: n.getUint16(18, !0) };
    }
}
qD.guid = MD.HeaderExtensionObject;
const XD = { len: 20, get: (e, t) => ({ entryCount: new DataView(e.buffer, t).getUint16(16, !0) }) };
async function GD(e) {
    const t = await e.readNumber(cl);
    return (await e.readToken(new Ml(2 * t, "utf-16le"))).replace("\0", "");
}
async function KD(e) {
    const t = await e.readToken(XD),
        n = [];
    for (let r = 0; r < t.entryCount; ++r) n.push(await QD(e));
    return n;
}
async function YD(e) {
    const t = await e.readNumber(cl),
        n = new Uint8Array(t);
    return await e.readBuffer(n), n;
}
async function QD(e) {
    const t = await e.readNumber(cl);
    return {
        type: { videoCodec: !(1 & ~t), audioCodec: !(2 & ~t) },
        codecName: await GD(e),
        description: await GD(e),
        information: await YD(e),
    };
}
class JD extends VD {
    get(e, t) {
        const n = [],
            r = new DataView(e.buffer, t);
        let i = 10;
        for (let s = 0; s < JD.contentDescTags.length; ++s) {
            const a = r.getUint16(2 * s, !0);
            if (a > 0) {
                const r = JD.contentDescTags[s],
                    o = i + a;
                n.push({ id: r, value: DD(e.slice(t + i, t + o)) }), (i = o);
            }
        }
        return n;
    }
}
(JD.guid = MD.ContentDescriptionObject),
    (JD.contentDescTags = ["Title", "Author", "Copyright", "Description", "Rating"]);
class ZD extends VD {
    get(e, t) {
        const n = [],
            r = new DataView(e.buffer, t),
            i = r.getUint16(0, !0);
        let s = 2;
        for (let a = 0; a < i; a += 1) {
            const i = r.getUint16(s, !0);
            s += 2;
            const a = DD(e.slice(t + s, t + s + i));
            s += i;
            const o = r.getUint16(s, !0);
            s += 2;
            const c = r.getUint16(s, !0);
            s += 2;
            const l = e.slice(t + s, t + s + c);
            (s += c), this.postProcessTag(n, a, o, l);
        }
        return n;
    }
}
ZD.guid = MD.ExtendedContentDescriptionObject;
class eF extends VD {
    get(e, t) {
        const n = new DataView(e.buffer, t);
        return {
            startTime: Tl.get(e, t),
            endTime: Tl.get(e, t + 8),
            dataBitrate: n.getInt32(12, !0),
            bufferSize: n.getInt32(16, !0),
            initialBufferFullness: n.getInt32(20, !0),
            alternateDataBitrate: n.getInt32(24, !0),
            alternateBufferSize: n.getInt32(28, !0),
            alternateInitialBufferFullness: n.getInt32(32, !0),
            maximumObjectSize: n.getInt32(36, !0),
            flags: {
                reliableFlag: Cd(e, t + 40, 0),
                seekableFlag: Cd(e, t + 40, 1),
                resendLiveCleanpointsFlag: Cd(e, t + 40, 2),
            },
            streamNumber: n.getInt16(42, !0),
            streamLanguageId: n.getInt16(44, !0),
            averageTimePerFrame: n.getInt32(52, !0),
            streamNameCount: n.getInt32(54, !0),
            payloadExtensionSystems: n.getInt32(56, !0),
            streamNames: [],
            streamPropertiesObject: null,
        };
    }
}
eF.guid = MD.ExtendedStreamPropertiesObject;
class tF extends VD {
    get(e, t) {
        const n = [],
            r = new DataView(e.buffer, t),
            i = r.getUint16(0, !0);
        let s = 2;
        for (let a = 0; a < i; a += 1) {
            s += 4;
            const i = r.getUint16(s, !0);
            s += 2;
            const a = r.getUint16(s, !0);
            s += 2;
            const o = r.getUint32(s, !0);
            s += 4;
            const c = DD(e.slice(t + s, t + s + i));
            s += i;
            const l = e.slice(t + s, t + s + o);
            (s += o), this.postProcessTag(n, c, a, l);
        }
        return n;
    }
}
tF.guid = MD.MetadataObject;
class nF extends tF {}
nF.guid = MD.MetadataLibraryObject;
class rF {
    static fromBuffer(e) {
        return new rF(e.length).get(e, 0);
    }
    constructor(e) {
        this.len = e;
    }
    get(e, t) {
        const n = new DataView(e.buffer, t),
            r = n.getUint8(0),
            i = n.getInt32(1, !0);
        let s = 5;
        for (; 0 !== n.getUint16(s); ) s += 2;
        const a = new Ml(s - 5, "utf-16le").get(e, 5);
        for (; 0 !== n.getUint16(s); ) s += 2;
        const o = new Ml(s - 5, "utf-16le").get(e, 5);
        return { type: Rd[r], format: a, description: o, size: i, data: e.slice(s + 4) };
    }
}
const iF = Tu("music-metadata:parser:ASF");
const sF = Object.freeze(
        Object.defineProperty(
            {
                __proto__: null,
                AsfParser: class extends Uh {
                    async parse() {
                        const e = await this.tokenizer.readToken(UD);
                        if (!e.objectId.equals(MD.HeaderObject))
                            throw new zD(`expected asf header; but was not found; got: ${e.objectId.str}`);
                        try {
                            await this.parseObjectHeader(e.numberOfHeaderObjects);
                        } catch (t) {
                            iF("Error while parsing ASF: %s", t);
                        }
                    }
                    async parseObjectHeader(e) {
                        let t;
                        do {
                            const e = await this.tokenizer.readToken($D);
                            switch ((iF("header GUID=%s", e.objectId.str), e.objectId.str)) {
                                case jD.guid.str: {
                                    const t = await this.tokenizer.readToken(new jD(e));
                                    this.metadata.setFormat(
                                        "duration",
                                        Number(t.playDuration / BigInt(1e3)) / 1e4 - Number(t.preroll) / 1e3
                                    ),
                                        this.metadata.setFormat("bitrate", t.maximumBitrate);
                                    break;
                                }
                                case HD.guid.str: {
                                    const t = await this.tokenizer.readToken(new HD(e));
                                    this.metadata.setFormat("container", `ASF/${t.streamType}`);
                                    break;
                                }
                                case qD.guid.str: {
                                    const e = await this.tokenizer.readToken(new qD());
                                    await this.parseExtensionObject(e.extensionDataSize);
                                    break;
                                }
                                case JD.guid.str:
                                    (t = await this.tokenizer.readToken(new JD(e))), await this.addTags(t);
                                    break;
                                case ZD.guid.str:
                                    (t = await this.tokenizer.readToken(new ZD(e))), await this.addTags(t);
                                    break;
                                case MD.CodecListObject.str: {
                                    const e = await KD(this.tokenizer);
                                    e.forEach((e) => {
                                        this.metadata.addStreamInfo({
                                            type: e.type.videoCodec ? dd : hd,
                                            codecName: e.codecName,
                                        });
                                    });
                                    const t = e
                                        .filter((e) => e.type.audioCodec)
                                        .map((e) => e.codecName)
                                        .join("/");
                                    this.metadata.setFormat("codec", t);
                                    break;
                                }
                                case MD.StreamBitratePropertiesObject.str:
                                    await this.tokenizer.ignore(e.objectSize - $D.len);
                                    break;
                                case MD.PaddingObject.str:
                                    iF("Padding: %s bytes", e.objectSize - $D.len),
                                        await this.tokenizer.ignore(e.objectSize - $D.len);
                                    break;
                                default:
                                    this.metadata.addWarning(`Ignore ASF-Object-GUID: ${e.objectId.str}`),
                                        iF("Ignore ASF-Object-GUID: %s", e.objectId.str),
                                        await this.tokenizer.readToken(new WD(e));
                            }
                        } while (--e);
                    }
                    async addTags(e) {
                        await Promise.all(e.map(({ id: e, value: t }) => this.metadata.addTag("asf", e, t)));
                    }
                    async parseExtensionObject(e) {
                        do {
                            const t = await this.tokenizer.readToken($D),
                                n = t.objectSize - $D.len;
                            switch (t.objectId.str) {
                                case eF.guid.str:
                                    await this.tokenizer.readToken(new eF(t));
                                    break;
                                case tF.guid.str: {
                                    const e = await this.tokenizer.readToken(new tF(t));
                                    await this.addTags(e);
                                    break;
                                }
                                case nF.guid.str: {
                                    const e = await this.tokenizer.readToken(new nF(t));
                                    await this.addTags(e);
                                    break;
                                }
                                case MD.PaddingObject.str:
                                case MD.CompatibilityObject.str:
                                case MD.ASF_Index_Placeholder_Object.str:
                                    await this.tokenizer.ignore(n);
                                    break;
                                default:
                                    this.metadata.addWarning(`Ignore ASF-Object-GUID: ${t.objectId.str}`),
                                        await this.tokenizer.readToken(new WD(t));
                            }
                            e -= t.objectSize;
                        } while (e > 0);
                    }
                },
            },
            Symbol.toStringTag,
            { value: "Module" }
        )
    ),
    aF = { len: 12, get: (e, t) => ({ chunkID: Vh.get(e, t), chunkSize: Sl.get(e, t + 4) }) },
    oF = Tu("music-metadata:parser:aiff");
class cF extends Ed("DSDIFF") {}
const lF = Object.freeze(
        Object.defineProperty(
            {
                __proto__: null,
                DsdiffContentParseError: cF,
                DsdiffParser: class extends Uh {
                    async parse() {
                        const e = await this.tokenizer.readToken(aF);
                        if ("FRM8" !== e.chunkID) throw new cF("Unexpected chunk-ID");
                        this.metadata.setAudioOnly();
                        const t = (await this.tokenizer.readToken(Vh)).trim();
                        if ("DSD" === t)
                            return (
                                this.metadata.setFormat("container", `DSDIFF/${t}`),
                                this.metadata.setFormat("lossless", !0),
                                this.readFmt8Chunks(e.chunkSize - BigInt(Vh.len))
                            );
                        throw new cF(`Unsupported DSDIFF type: ${t}`);
                    }
                    async readFmt8Chunks(e) {
                        for (; e >= aF.len; ) {
                            const t = await this.tokenizer.readToken(aF);
                            oF(`Chunk id=${t.chunkID}`), await this.readData(t), (e -= BigInt(aF.len) + t.chunkSize);
                        }
                    }
                    async readData(e) {
                        oF(`Reading data of chunk[ID=${e.chunkID}, size=${e.chunkSize}]`);
                        const t = this.tokenizer.position;
                        switch (e.chunkID.trim()) {
                            case "FVER": {
                                const e = await this.tokenizer.readToken(hl);
                                oF(`DSDIFF version=${e}`);
                                break;
                            }
                            case "PROP":
                                if ("SND " !== (await this.tokenizer.readToken(Vh)))
                                    throw new cF("Unexpected PROP-chunk ID");
                                await this.handleSoundPropertyChunks(e.chunkSize - BigInt(Vh.len));
                                break;
                            case "ID3": {
                                const t = nl(await this.tokenizer.readToken(new Rl(Number(e.chunkSize))));
                                await new bD().parse(this.metadata, t, this.options);
                                break;
                            }
                            case "DSD":
                                this.metadata.format.numberOfChannels &&
                                    this.metadata.setFormat(
                                        "numberOfSamples",
                                        Number(
                                            (e.chunkSize * BigInt(8)) / BigInt(this.metadata.format.numberOfChannels)
                                        )
                                    ),
                                    this.metadata.format.numberOfSamples &&
                                        this.metadata.format.sampleRate &&
                                        this.metadata.setFormat(
                                            "duration",
                                            this.metadata.format.numberOfSamples / this.metadata.format.sampleRate
                                        );
                                break;
                            default:
                                oF(`Ignore chunk[ID=${e.chunkID}, size=${e.chunkSize}]`);
                        }
                        const n = e.chunkSize - BigInt(this.tokenizer.position - t);
                        n > 0 &&
                            (oF(`After Parsing chunk, remaining ${n} bytes`), await this.tokenizer.ignore(Number(n)));
                    }
                    async handleSoundPropertyChunks(e) {
                        for (oF(`Parsing sound-property-chunks, remainingSize=${e}`); e > 0; ) {
                            const t = await this.tokenizer.readToken(aF);
                            oF(`Sound-property-chunk[ID=${t.chunkID}, size=${t.chunkSize}]`);
                            const n = this.tokenizer.position;
                            switch (t.chunkID.trim()) {
                                case "FS": {
                                    const e = await this.tokenizer.readToken(ml);
                                    this.metadata.setFormat("sampleRate", e);
                                    break;
                                }
                                case "CHNL": {
                                    const e = await this.tokenizer.readToken(ll);
                                    this.metadata.setFormat("numberOfChannels", e),
                                        await this.handleChannelChunks(t.chunkSize - BigInt(ll.len));
                                    break;
                                }
                                case "CMPR": {
                                    const e = (await this.tokenizer.readToken(Vh)).trim(),
                                        t = await this.tokenizer.readToken(ol),
                                        n = await this.tokenizer.readToken(new Ml(t, "ascii"));
                                    "DSD" === e &&
                                        (this.metadata.setFormat("lossless", !0),
                                        this.metadata.setFormat("bitsPerSample", 1)),
                                        this.metadata.setFormat("codec", `${e} (${n})`);
                                    break;
                                }
                                case "ABSS": {
                                    const e = await this.tokenizer.readToken(ll),
                                        t = await this.tokenizer.readToken(ol),
                                        n = await this.tokenizer.readToken(ol),
                                        r = await this.tokenizer.readToken(ml);
                                    oF(`ABSS ${e}:${t}:${n}.${r}`);
                                    break;
                                }
                                case "LSCO": {
                                    const e = await this.tokenizer.readToken(ll);
                                    oF(`LSCO lsConfig=${e}`);
                                    break;
                                }
                                default:
                                    oF(`Unknown sound-property-chunk[ID=${t.chunkID}, size=${t.chunkSize}]`),
                                        await this.tokenizer.ignore(Number(t.chunkSize));
                            }
                            const r = t.chunkSize - BigInt(this.tokenizer.position - n);
                            r > 0 &&
                                (oF(`After Parsing sound-property-chunk ${t.chunkSize}, remaining ${r} bytes`),
                                await this.tokenizer.ignore(Number(r))),
                                (e -= BigInt(aF.len) + t.chunkSize),
                                oF(`Parsing sound-property-chunks, remainingSize=${e}`);
                        }
                        if (
                            this.metadata.format.lossless &&
                            this.metadata.format.sampleRate &&
                            this.metadata.format.numberOfChannels &&
                            this.metadata.format.bitsPerSample
                        ) {
                            const e =
                                this.metadata.format.sampleRate *
                                this.metadata.format.numberOfChannels *
                                this.metadata.format.bitsPerSample;
                            this.metadata.setFormat("bitrate", e);
                        }
                    }
                    async handleChannelChunks(e) {
                        oF(`Parsing channel-chunks, remainingSize=${e}`);
                        const t = [];
                        for (; e >= Vh.len; ) {
                            const n = await this.tokenizer.readToken(Vh);
                            oF(`Channel[ID=${n}]`), t.push(n), (e -= BigInt(Vh.len));
                        }
                        return oF(`Channels: ${t.join(", ")}`), t;
                    }
                },
            },
            Symbol.toStringTag,
            { value: "Module" }
        )
    ),
    uF = {
        NONE: "not compressed\tPCM\tApple Computer",
        sowt: "PCM (byte swapped)",
        fl32: "32-bit floating point IEEE 32-bit float",
        fl64: "64-bit floating point IEEE 64-bit float\tApple Computer",
        alaw: "ALaw 2:1\t8-bit ITU-T G.711 A-law",
        ulaw: "Law 2:1\t8-bit ITU-T G.711 -law\tApple Computer",
        ULAW: "CCITT G.711 u-law 8-bit ITU-T G.711 -law",
        ALAW: "CCITT G.711 A-law 8-bit ITU-T G.711 A-law",
        FL32: "Float 32\tIEEE 32-bit float ",
    };
class dF extends Ed("AIFF") {}
class hF {
    constructor(e, t) {
        this.isAifc = t;
        const n = t ? 22 : 18;
        if (e.chunkSize < n) throw new dF(`COMMON CHUNK size should always be at least ${n}`);
        this.len = e.chunkSize;
    }
    get(e, t) {
        const n = ll.get(e, t + 8) - 16398,
            r = ll.get(e, t + 8 + 2),
            i = {
                numChannels: ll.get(e, t),
                numSampleFrames: ml.get(e, t + 2),
                sampleSize: ll.get(e, t + 6),
                sampleRate: n < 0 ? r >> Math.abs(n) : r << n,
            };
        if (this.isAifc) {
            if (((i.compressionType = Vh.get(e, t + 18)), this.len > 22)) {
                const n = ol.get(e, t + 22);
                if (n > 0) {
                    if (23 + n + ((n + 1) % 2) !== this.len) throw new dF("Illegal pstring length");
                    i.compressionName = new Ml(n, "latin1").get(e, t + 23);
                } else i.compressionName = void 0;
            }
        } else i.compressionName = "PCM";
        return i;
    }
}
const mF = { len: 8, get: (e, t) => ({ chunkID: Vh.get(e, t), chunkSize: Number(BigInt(ml.get(e, t + 4))) }) },
    pF = Tu("music-metadata:parser:aiff");
const fF = Object.freeze(
        Object.defineProperty(
            {
                __proto__: null,
                AIFFParser: class extends Uh {
                    constructor() {
                        super(...arguments), (this.isCompressed = null);
                    }
                    async parse() {
                        if ("FORM" !== (await this.tokenizer.readToken(mF)).chunkID)
                            throw new dF("Invalid Chunk-ID, expected 'FORM'");
                        const e = await this.tokenizer.readToken(Vh);
                        switch (e) {
                            case "AIFF":
                                this.metadata.setFormat("container", e), (this.isCompressed = !1);
                                break;
                            case "AIFC":
                                this.metadata.setFormat("container", "AIFF-C"), (this.isCompressed = !0);
                                break;
                            default:
                                throw new dF(`Unsupported AIFF type: ${e}`);
                        }
                        this.metadata.setFormat("lossless", !this.isCompressed), this.metadata.setAudioOnly();
                        try {
                            for (
                                ;
                                !this.tokenizer.fileInfo.size ||
                                this.tokenizer.fileInfo.size - this.tokenizer.position >= mF.len;

                            ) {
                                pF(`Reading AIFF chunk at offset=${this.tokenizer.position}`);
                                const e = await this.tokenizer.readToken(mF),
                                    t = 2 * Math.round(e.chunkSize / 2),
                                    n = await this.readData(e);
                                await this.tokenizer.ignore(t - n);
                            }
                        } catch (t) {
                            if (!(t instanceof qc)) throw t;
                            pF("End-of-stream");
                        }
                    }
                    async readData(e) {
                        switch (e.chunkID) {
                            case "COMM": {
                                if (null === this.isCompressed)
                                    throw new dF("Failed to parse AIFF.COMM chunk when compression type is unknown");
                                const t = await this.tokenizer.readToken(new hF(e, this.isCompressed));
                                return (
                                    this.metadata.setFormat("bitsPerSample", t.sampleSize),
                                    this.metadata.setFormat("sampleRate", t.sampleRate),
                                    this.metadata.setFormat("numberOfChannels", t.numChannels),
                                    this.metadata.setFormat("numberOfSamples", t.numSampleFrames),
                                    this.metadata.setFormat("duration", t.numSampleFrames / t.sampleRate),
                                    (t.compressionName || t.compressionType) &&
                                        this.metadata.setFormat("codec", t.compressionName ?? uF[t.compressionType]),
                                    e.chunkSize
                                );
                            }
                            case "ID3 ": {
                                const t = nl(await this.tokenizer.readToken(new Rl(e.chunkSize)));
                                return await new bD().parse(this.metadata, t, this.options), e.chunkSize;
                            }
                            case "SSND":
                                return (
                                    this.metadata.format.duration &&
                                        this.metadata.setFormat(
                                            "bitrate",
                                            (8 * e.chunkSize) / this.metadata.format.duration
                                        ),
                                    0
                                );
                            case "NAME":
                            case "AUTH":
                            case "(c) ":
                            case "ANNO":
                                return this.readTextChunk(e);
                            default:
                                return pF(`Ignore chunk id=${e.chunkID}, size=${e.chunkSize}`), 0;
                        }
                    }
                    async readTextChunk(e) {
                        const t = (await this.tokenizer.readToken(new Ml(e.chunkSize, "ascii")))
                            .split("\0")
                            .map((e) => e.trim())
                            .filter((e) => e?.length);
                        return await Promise.all(t.map((t) => this.metadata.addTag("AIFF", e.chunkID, t))), e.chunkSize;
                    }
                },
            },
            Symbol.toStringTag,
            { value: "Module" }
        )
    ),
    gF = { len: 12, get: (e, t) => ({ id: Vh.get(e, t), size: Tl.get(e, t + 4) }) },
    bF = { len: 16, get: (e, t) => ({ fileSize: _l.get(e, t), metadataPointer: _l.get(e, t + 8) }) },
    yF = {
        len: 40,
        get: (e, t) => ({
            formatVersion: kl.get(e, t),
            formatID: kl.get(e, t + 4),
            channelType: kl.get(e, t + 8),
            channelNum: kl.get(e, t + 12),
            samplingFrequency: kl.get(e, t + 16),
            bitsPerSample: kl.get(e, t + 20),
            sampleCount: _l.get(e, t + 24),
            blockSizePerChannel: kl.get(e, t + 32),
        }),
    },
    wF = Tu("music-metadata:parser:DSF");
class kF extends Ed("DSD") {}
const TF = Object.freeze(
    Object.defineProperty(
        {
            __proto__: null,
            DsdContentParseError: kF,
            DsfParser: class extends kD {
                async postId3v2Parse() {
                    const e = this.tokenizer.position,
                        t = await this.tokenizer.readToken(gF);
                    if ("DSD " !== t.id) throw new kF("Invalid chunk signature");
                    this.metadata.setFormat("container", "DSF"),
                        this.metadata.setFormat("lossless", !0),
                        this.metadata.setAudioOnly();
                    const n = await this.tokenizer.readToken(bF);
                    if (n.metadataPointer !== BigInt(0))
                        return (
                            wF(`expect ID3v2 at offset=${n.metadataPointer}`),
                            await this.parseChunks(n.fileSize - t.size),
                            await this.tokenizer.ignore(Number(n.metadataPointer) - this.tokenizer.position - e),
                            new bD().parse(this.metadata, this.tokenizer, this.options)
                        );
                    wF("No ID3v2 tag present");
                }
                async parseChunks(e) {
                    for (; e >= gF.len; ) {
                        const t = await this.tokenizer.readToken(gF);
                        if ((wF(`Parsing chunk name=${t.id} size=${t.size}`), "fmt " === t.id)) {
                            const e = await this.tokenizer.readToken(yF);
                            this.metadata.setFormat("numberOfChannels", e.channelNum),
                                this.metadata.setFormat("sampleRate", e.samplingFrequency),
                                this.metadata.setFormat("bitsPerSample", e.bitsPerSample),
                                this.metadata.setFormat("numberOfSamples", e.sampleCount),
                                this.metadata.setFormat("duration", Number(e.sampleCount) / e.samplingFrequency);
                            const t = e.bitsPerSample * e.samplingFrequency * e.channelNum;
                            return void this.metadata.setFormat("bitrate", t);
                        }
                        this.tokenizer.ignore(Number(t.size) - gF.len), (e -= t.size);
                    }
                }
            },
        },
        Symbol.toStringTag,
        { value: "Module" }
    )
);
class _F {
    static fromBase64(e) {
        return _F.fromBuffer(Uint8Array.from(atob(e), (e) => e.charCodeAt(0)));
    }
    static fromBuffer(e) {
        return new _F(e.length).get(e, 0);
    }
    constructor(e) {
        this.len = e;
    }
    get(e, t) {
        const n = Rd[ml.get(e, t)];
        t += 4;
        const r = ml.get(e, t);
        t += 4;
        const i = new Ml(r, "utf-8").get(e, t);
        t += r;
        const s = ml.get(e, t);
        t += 4;
        const a = new Ml(s, "utf-8").get(e, t);
        t += s;
        const o = ml.get(e, t);
        t += 4;
        const c = ml.get(e, t);
        t += 4;
        const l = ml.get(e, t);
        t += 4;
        const u = ml.get(e, t);
        t += 4;
        const d = ml.get(e, t);
        t += 4;
        return {
            type: n,
            format: i,
            description: a,
            width: o,
            height: c,
            colour_depth: l,
            indexed_color: u,
            data: Uint8Array.from(e.slice(t, t + d)),
        };
    }
}
const vF = 7,
    SF = (e, t) => ({ packetType: ol.get(e, t), vorbis: new Ml(6, "ascii").get(e, t + 1) }),
    EF = (e, t) => ({
        version: hl.get(e, t + 0),
        channelMode: ol.get(e, t + 4),
        sampleRate: hl.get(e, t + 5),
        bitrateMax: hl.get(e, t + 9),
        bitrateNominal: hl.get(e, t + 13),
        bitrateMin: hl.get(e, t + 17),
    });
class CF {
    constructor(e, t) {
        (this.data = e), (this.offset = t);
    }
    readInt32() {
        const e = hl.get(this.data, this.offset);
        return (this.offset += 4), e;
    }
    readStringUtf8() {
        const e = this.readInt32(),
            t = new TextDecoder("utf-8").decode(this.data.subarray(this.offset, this.offset + e));
        return (this.offset += e), t;
    }
    parseUserComment() {
        const e = this.offset,
            t = this.readStringUtf8(),
            n = t.indexOf("=");
        return { key: t.slice(0, n).toUpperCase(), value: t.slice(n + 1), len: this.offset - e };
    }
}
const IF = Tu("music-metadata:parser:ogg:vorbis1");
class xF extends Ed("Vorbis") {}
class AF {
    constructor(e, t) {
        (this.pageSegments = []), (this.durationOnLastPage = !0), (this.metadata = e), (this.options = t);
    }
    async parsePage(e, t) {
        if (((this.lastPageHeader = e), e.headerType.firstPage)) this.parseFirstPage(e, t);
        else {
            if (e.headerType.continued) {
                if (0 === this.pageSegments.length) throw new xF("Cannot continue on previous page");
                this.pageSegments.push(t);
            }
            if (e.headerType.lastPage || !e.headerType.continued) {
                if (this.pageSegments.length > 0) {
                    const e = AF.mergeUint8Arrays(this.pageSegments);
                    await this.parseFullPage(e);
                }
                this.pageSegments = e.headerType.lastPage ? [] : [t];
            }
        }
    }
    static mergeUint8Arrays(e) {
        const t = e.reduce((e, t) => e + t.length, 0),
            n = new Uint8Array(t);
        return (
            e.forEach((e, t, r) => {
                const i = r.slice(0, t).reduce((e, t) => e + t.length, 0);
                n.set(e, i);
            }),
            n
        );
    }
    async flush() {
        await this.parseFullPage(AF.mergeUint8Arrays(this.pageSegments));
    }
    async parseUserComment(e, t) {
        const n = new CF(e, t).parseUserComment();
        return await this.addTag(n.key, n.value), n.len;
    }
    async addTag(e, t) {
        if ("METADATA_BLOCK_PICTURE" === e && "string" == typeof t) {
            if (this.options.skipCovers) return void IF("Ignore picture");
            (t = _F.fromBase64(t)), IF(`Push picture: id=${e}, format=${t.format}`);
        } else IF(`Push tag: id=${e}, value=${t}`);
        await this.metadata.addTag("vorbis", e, t);
    }
    calculateDuration() {
        this.lastPageHeader &&
            this.metadata.format.sampleRate &&
            this.lastPageHeader.absoluteGranulePosition >= 0 &&
            (this.metadata.setFormat("numberOfSamples", this.lastPageHeader.absoluteGranulePosition),
            this.metadata.setFormat(
                "duration",
                this.lastPageHeader.absoluteGranulePosition / this.metadata.format.sampleRate
            ));
    }
    parseFirstPage(e, t) {
        this.metadata.setFormat("codec", "Vorbis I"), this.metadata.setFormat("hasAudio", !0), IF("Parse first page");
        const n = SF(t, 0);
        if ("vorbis" !== n.vorbis) throw new xF("Metadata does not look like Vorbis");
        if (1 !== n.packetType) throw new xF("First Ogg page should be type 1: the identification header");
        {
            const e = EF(t, vF);
            this.metadata.setFormat("sampleRate", e.sampleRate),
                this.metadata.setFormat("bitrate", e.bitrateNominal),
                this.metadata.setFormat("numberOfChannels", e.channelMode),
                IF(
                    "sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s",
                    e.sampleRate,
                    e.bitrateNominal,
                    e.channelMode
                );
        }
    }
    async parseFullPage(e) {
        const t = SF(e, 0);
        if ((IF("Parse full page: type=%s, byteLength=%s", t.packetType, e.byteLength), 3 === t.packetType))
            return this.parseUserCommentList(e, vF);
    }
    async parseUserCommentList(e, t) {
        const n = hl.get(e, t);
        (t += 4), (t += n);
        let r = hl.get(e, t);
        for (t += 4; r-- > 0; ) t += await this.parseUserComment(e, t);
    }
}
const PF = 0,
    OF = 1,
    NF = 2,
    RF = 3,
    MF = 4,
    DF = 5,
    FF = 6,
    LF = { len: 4, get: (e, t) => ({ lastBlock: Cd(e, t, 7), type: Od(e, t, 1, 7), length: dl.get(e, t + 1) }) },
    BF = {
        len: 34,
        get: (e, t) => ({
            minimumBlockSize: ll.get(e, t),
            maximumBlockSize: ll.get(e, t + 2) / 1e3,
            minimumFrameSize: dl.get(e, t + 4),
            maximumFrameSize: dl.get(e, t + 7),
            sampleRate: dl.get(e, t + 10) >> 4,
            channels: Od(e, t + 12, 4, 3) + 1,
            bitsPerSample: Od(e, t + 12, 7, 5) + 1,
            totalSamples: Od(e, t + 13, 4, 36),
            fileMD5: new Rl(16).get(e, t + 18),
        }),
    },
    zF = Tu("music-metadata:parser:FLAC");
class UF extends Ed("FLAC") {}
class $F extends kD {
    constructor() {
        super(...arguments), (this.vorbisParser = new AF(this.metadata, this.options)), (this.padding = 0);
    }
    async postId3v2Parse() {
        if ("fLaC" !== (await this.tokenizer.readToken(Vh)).toString()) throw new UF("Invalid FLAC preamble");
        let e;
        do {
            (e = await this.tokenizer.readToken(LF)), await this.parseDataBlock(e);
        } while (!e.lastBlock);
        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {
            const e = this.tokenizer.fileInfo.size - this.tokenizer.position;
            this.metadata.setFormat("bitrate", (8 * e) / this.metadata.format.duration);
        }
    }
    async parseDataBlock(e) {
        switch ((zF(`blockHeader type=${e.type}, length=${e.length}`), e.type)) {
            case PF:
                return this.readBlockStreamInfo(e.length);
            case OF:
                this.padding += e.length;
                break;
            case NF:
            case RF:
                break;
            case MF:
                return this.readComment(e.length);
            case DF:
                break;
            case FF:
                return void (await this.parsePicture(e.length));
            default:
                this.metadata.addWarning(`Unknown block type: ${e.type}`);
        }
        return this.tokenizer.ignore(e.length).then();
    }
    async readBlockStreamInfo(e) {
        if (e !== BF.len) throw new UF("Unexpected block-stream-info length");
        const t = await this.tokenizer.readToken(BF);
        this.metadata.setFormat("container", "FLAC"), this.processsStreamInfo(t);
    }
    processsStreamInfo(e) {
        this.metadata.setFormat("codec", "FLAC"),
            this.metadata.setFormat("hasAudio", !0),
            this.metadata.setFormat("lossless", !0),
            this.metadata.setFormat("numberOfChannels", e.channels),
            this.metadata.setFormat("bitsPerSample", e.bitsPerSample),
            this.metadata.setFormat("sampleRate", e.sampleRate),
            e.totalSamples > 0 && this.metadata.setFormat("duration", e.totalSamples / e.sampleRate);
    }
    async readComment(e) {
        const t = await this.tokenizer.readToken(new Rl(e));
        return this.parseComment(t);
    }
    async parseComment(e) {
        const t = new CF(e, 0);
        t.readStringUtf8();
        const n = t.readInt32(),
            r = new Array(n);
        for (let i = 0; i < n; i++) r[i] = t.parseUserComment();
        await Promise.all(r.map((e) => this.addTag(e.key, e.value)));
    }
    async parsePicture(e) {
        return this.options.skipCovers
            ? this.tokenizer.ignore(e)
            : this.addPictureTag(await this.tokenizer.readToken(new _F(e)));
    }
    addPictureTag(e) {
        return this.addTag("METADATA_BLOCK_PICTURE", e);
    }
    addTag(e, t) {
        return this.vorbisParser.addTag(e, t);
    }
}
const VF = Object.freeze(
        Object.defineProperty({ __proto__: null, FlacParser: $F }, Symbol.toStringTag, { value: "Module" })
    ),
    WF = 0,
    jF = 1,
    HF = 2,
    qF = 3,
    XF = 4,
    GF = 5,
    KF = {
        name: "dtd",
        container: {
            440786851: {
                name: "ebml",
                container: {
                    17030: { name: "ebmlVersion", value: jF },
                    17143: { name: "ebmlReadVersion", value: jF },
                    17138: { name: "ebmlMaxIDWidth", value: jF },
                    17139: { name: "ebmlMaxSizeWidth", value: jF },
                    17026: { name: "docType", value: WF },
                    17031: { name: "docTypeVersion", value: jF },
                    17029: { name: "docTypeReadVersion", value: jF },
                },
            },
            408125543: {
                name: "segment",
                container: {
                    290298740: {
                        name: "seekHead",
                        container: {
                            19899: {
                                name: "seek",
                                multiple: !0,
                                container: { 21419: { name: "id", value: XF }, 21420: { name: "position", value: jF } },
                            },
                        },
                    },
                    357149030: {
                        name: "info",
                        container: {
                            29604: { name: "uid", value: HF },
                            29572: { name: "filename", value: WF },
                            3979555: { name: "prevUID", value: HF },
                            3965867: { name: "prevFilename", value: WF },
                            4110627: { name: "nextUID", value: HF },
                            4096955: { name: "nextFilename", value: WF },
                            2807729: { name: "timecodeScale", value: jF },
                            17545: { name: "duration", value: GF },
                            17505: { name: "dateUTC", value: jF },
                            31657: { name: "title", value: WF },
                            19840: { name: "muxingApp", value: WF },
                            22337: { name: "writingApp", value: WF },
                        },
                    },
                    524531317: {
                        name: "cluster",
                        multiple: !0,
                        container: {
                            231: { name: "timecode", value: HF },
                            22743: { name: "silentTracks ", multiple: !0 },
                            167: { name: "position", value: HF },
                            171: { name: "prevSize", value: HF },
                            160: { name: "blockGroup" },
                            163: { name: "simpleBlock" },
                        },
                    },
                    374648427: {
                        name: "tracks",
                        container: {
                            174: {
                                name: "entries",
                                multiple: !0,
                                container: {
                                    215: { name: "trackNumber", value: jF },
                                    29637: { name: "uid", value: HF },
                                    131: { name: "trackType", value: jF },
                                    185: { name: "flagEnabled", value: qF },
                                    136: { name: "flagDefault", value: qF },
                                    21930: { name: "flagForced", value: qF },
                                    156: { name: "flagLacing", value: qF },
                                    28135: { name: "minCache", value: jF },
                                    28136: { name: "maxCache", value: jF },
                                    2352003: { name: "defaultDuration", value: jF },
                                    2306383: { name: "timecodeScale", value: GF },
                                    21358: { name: "name", value: WF },
                                    2274716: { name: "language", value: WF },
                                    134: { name: "codecID", value: WF },
                                    25506: { name: "codecPrivate", value: XF },
                                    2459272: { name: "codecName", value: WF },
                                    3839639: { name: "codecSettings", value: WF },
                                    3883072: { name: "codecInfoUrl", value: WF },
                                    2536e3: { name: "codecDownloadUrl", value: WF },
                                    170: { name: "codecDecodeAll", value: qF },
                                    28587: { name: "trackOverlay", value: jF },
                                    224: {
                                        name: "video",
                                        container: {
                                            154: { name: "flagInterlaced", value: qF },
                                            21432: { name: "stereoMode", value: jF },
                                            176: { name: "pixelWidth", value: jF },
                                            186: { name: "pixelHeight", value: jF },
                                            21680: { name: "displayWidth", value: jF },
                                            21690: { name: "displayHeight", value: jF },
                                            21683: { name: "aspectRatioType", value: jF },
                                            3061028: { name: "colourSpace", value: jF },
                                            3126563: { name: "gammaValue", value: GF },
                                        },
                                    },
                                    225: {
                                        name: "audio",
                                        container: {
                                            181: { name: "samplingFrequency", value: GF },
                                            30901: { name: "outputSamplingFrequency", value: GF },
                                            159: { name: "channels", value: jF },
                                            148: { name: "channels", value: jF },
                                            32123: { name: "channelPositions", value: XF },
                                            25188: { name: "bitDepth", value: jF },
                                        },
                                    },
                                    28032: {
                                        name: "contentEncodings",
                                        container: {
                                            25152: {
                                                name: "contentEncoding",
                                                container: {
                                                    20529: { name: "order", value: jF },
                                                    20530: { name: "scope", value: qF },
                                                    20531: { name: "type", value: jF },
                                                    20532: {
                                                        name: "contentEncoding",
                                                        container: {
                                                            16980: { name: "contentCompAlgo", value: jF },
                                                            16981: { name: "contentCompSettings", value: XF },
                                                        },
                                                    },
                                                    20533: {
                                                        name: "contentEncoding",
                                                        container: {
                                                            18401: { name: "contentEncAlgo", value: jF },
                                                            18402: { name: "contentEncKeyID", value: XF },
                                                            18403: { name: "contentSignature ", value: XF },
                                                            18404: { name: "ContentSigKeyID  ", value: XF },
                                                            18405: { name: "contentSigAlgo ", value: jF },
                                                            18406: { name: "contentSigHashAlgo ", value: jF },
                                                        },
                                                    },
                                                    25188: { name: "bitDepth", value: jF },
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                    475249515: {
                        name: "cues",
                        container: {
                            187: {
                                name: "cuePoint",
                                container: {
                                    179: { name: "cueTime", value: HF },
                                    183: {
                                        name: "positions",
                                        container: {
                                            247: { name: "track", value: jF },
                                            241: { name: "clusterPosition", value: jF },
                                            21368: { name: "blockNumber", value: jF },
                                            234: { name: "codecState", value: jF },
                                            219: {
                                                name: "reference",
                                                container: {
                                                    150: { name: "time", value: jF },
                                                    151: { name: "cluster", value: jF },
                                                    21343: { name: "number", value: jF },
                                                    235: { name: "codecState", value: jF },
                                                },
                                            },
                                            240: { name: "relativePosition", value: jF },
                                        },
                                    },
                                },
                            },
                        },
                    },
                    423732329: {
                        name: "attachments",
                        container: {
                            24999: {
                                name: "attachedFiles",
                                multiple: !0,
                                container: {
                                    18046: { name: "description", value: WF },
                                    18030: { name: "name", value: WF },
                                    18016: { name: "mimeType", value: WF },
                                    18012: { name: "data", value: XF },
                                    18094: { name: "uid", value: HF },
                                },
                            },
                        },
                    },
                    272869232: {
                        name: "chapters",
                        container: {
                            17849: {
                                name: "editionEntry",
                                container: {
                                    182: {
                                        name: "chapterAtom",
                                        container: {
                                            29636: { name: "uid", value: HF },
                                            145: { name: "timeStart", value: jF },
                                            146: { name: "timeEnd", value: HF },
                                            152: { name: "hidden", value: qF },
                                            17816: { name: "enabled", value: HF },
                                            143: {
                                                name: "track",
                                                container: {
                                                    137: { name: "trackNumber", value: HF },
                                                    128: {
                                                        name: "display",
                                                        container: {
                                                            133: { name: "string", value: WF },
                                                            17276: { name: "language ", value: WF },
                                                            17278: { name: "country ", value: WF },
                                                        },
                                                    },
                                                },
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    },
                    307544935: {
                        name: "tags",
                        container: {
                            29555: {
                                name: "tag",
                                multiple: !0,
                                container: {
                                    25536: {
                                        name: "target",
                                        container: {
                                            25541: { name: "tagTrackUID", value: HF },
                                            25540: { name: "tagChapterUID", value: jF },
                                            25542: { name: "tagAttachmentUID", value: HF },
                                            25546: { name: "targetType", value: WF },
                                            26826: { name: "targetTypeValue", value: jF },
                                            25545: { name: "tagEditionUID", value: HF },
                                        },
                                    },
                                    26568: {
                                        name: "simpleTags",
                                        multiple: !0,
                                        container: {
                                            17827: { name: "name", value: WF },
                                            17543: { name: "string", value: WF },
                                            17541: { name: "binary", value: XF },
                                            17530: { name: "language", value: WF },
                                            17531: { name: "languageIETF", value: WF },
                                            17540: { name: "default", value: qF },
                                        },
                                    },
                                },
                            },
                        },
                    },
                },
            },
        },
    },
    YF = Tu("music-metadata:parser:ebml");
class QF extends Ed("EBML") {}
const JF = 0,
    ZF = 2,
    eL = 3,
    tL = 4,
    nL = 5;
class rL {
    constructor(e) {
        (this.padding = 0),
            (this.parserMap = new Map()),
            (this.ebmlMaxIDLength = 4),
            (this.ebmlMaxSizeLength = 8),
            (this.tokenizer = e),
            this.parserMap.set(jF, (e) => this.readUint(e)),
            this.parserMap.set(WF, (e) => this.readString(e)),
            this.parserMap.set(XF, (e) => this.readBuffer(e)),
            this.parserMap.set(HF, async (e) => this.readBuffer(e)),
            this.parserMap.set(qF, (e) => this.readFlag(e)),
            this.parserMap.set(GF, (e) => this.readFloat(e));
    }
    async iterate(e, t, n) {
        return this.parseContainer(sL(e), t, n);
    }
    async parseContainer(e, t, n) {
        const r = {};
        for (; this.tokenizer.position < t; ) {
            let s;
            const a = this.tokenizer.position;
            try {
                s = await this.readElement();
            } catch (i) {
                if (i instanceof qc) break;
                throw i;
            }
            const o = e.container[s.id];
            if (o) {
                switch (n.startNext(o)) {
                    case JF:
                        if (
                            (s.id,
                            YF(
                                `Read element: name=${aL(o)}{id=0x${s.id.toString(16)}, container=${!!o.container}} at position=${a}`
                            ),
                            o.container)
                        ) {
                            const e = await this.parseContainer(
                                o,
                                s.len >= 0 ? this.tokenizer.position + s.len : -1,
                                n
                            );
                            o.multiple ? (r[o.name] || (r[o.name] = []), r[o.name].push(e)) : (r[o.name] = e),
                                await n.elementValue(o, e, a);
                        } else {
                            const e = this.parserMap.get(o.value);
                            if ("function" == typeof e) {
                                const t = await e(s);
                                (r[o.name] = t), await n.elementValue(o, t, a);
                            }
                        }
                        break;
                    case nL:
                        YF(
                            `Go to next element: name=${aL(o)}, element.id=0x${s.id}, container=${!!o.container} at position=${a}`
                        );
                        break;
                    case ZF:
                        YF(
                            `Ignore element: name=${aL(o)}, element.id=0x${s.id}, container=${!!o.container} at position=${a}`
                        ),
                            await this.tokenizer.ignore(s.len);
                        break;
                    case eL:
                        YF(
                            `Ignore remaining container, at: name=${aL(o)}, element.id=0x${s.id}, container=${!!o.container} at position=${a}`
                        ),
                            await this.tokenizer.ignore(t - this.tokenizer.position);
                        break;
                    case tL:
                        return (
                            YF(
                                `Terminate parsing at element: name=${aL(o)}, element.id=0x${s.id}, container=${!!o.container} at position=${a}`
                            ),
                            r
                        );
                }
            } else if (236 === s.id) (this.padding += s.len), await this.tokenizer.ignore(s.len);
            else
                YF(`parseEbml: parent=${aL(e)}, unknown child: id=${s.id.toString(16)} at position=${a}`),
                    (this.padding += s.len),
                    await this.tokenizer.ignore(s.len);
        }
        return r;
    }
    async readVintData(e) {
        const t = await this.tokenizer.peekNumber(ol);
        let n = 128,
            r = 1;
        for (; 0 === (t & n); ) {
            if (r > e) throw new QF("VINT value exceeding maximum size");
            ++r, (n >>= 1);
        }
        const i = new Uint8Array(r);
        return await this.tokenizer.readBuffer(i), i;
    }
    async readElement() {
        const e = await this.readVintData(this.ebmlMaxIDLength),
            t = await this.readVintData(this.ebmlMaxSizeLength);
        return (t[0] ^= 128 >> (t.length - 1)), { id: iL(e, e.length), len: iL(t, t.length) };
    }
    async readFloat(e) {
        switch (e.len) {
            case 0:
                return 0;
            case 4:
                return this.tokenizer.readNumber(Il);
            case 8:
            case 10:
                return this.tokenizer.readNumber(Al);
            default:
                throw new QF(`Invalid IEEE-754 float length: ${e.len}`);
        }
    }
    async readFlag(e) {
        return 1 === (await this.readUint(e));
    }
    async readUint(e) {
        return iL(await this.readBuffer(e), e.len);
    }
    async readString(e) {
        return (await this.tokenizer.readToken(new Ml(e.len, "utf-8"))).replace(/\x00.*$/g, "");
    }
    async readBuffer(e) {
        const t = new Uint8Array(e.len);
        return await this.tokenizer.readBuffer(t), t;
    }
}
function iL(e, t) {
    return Number(
        (function (e, t) {
            const n = new Uint8Array(8),
                r = e.subarray(0, t);
            try {
                return n.set(r, 8 - t), vl.get(n, 0);
            } catch (i) {
                return BigInt(-1);
            }
        })(e, t)
    );
}
function sL(e) {
    return (
        e.container &&
            Object.keys(e.container)
                .map((t) => {
                    const n = e.container[t];
                    return (n.id = Number.parseInt(t)), n;
                })
                .forEach((t) => {
                    (t.parent = e), sL(t);
                }),
        e
    );
}
function aL(e) {
    let t = "";
    return e.parent && "dtd" !== e.parent.name && (t += `${aL(e.parent)}/`), t + e.name;
}
const oL = Tu("music-metadata:parser:matroska");
const cL = Object.freeze(
        Object.defineProperty(
            {
                __proto__: null,
                MatroskaParser: class extends Uh {
                    constructor() {
                        super(...arguments),
                            (this.seekHeadOffset = 0),
                            (this.flagUseIndexToSkipClusters = this.options.mkvUseIndex ?? !1);
                    }
                    async parse() {
                        const e = this.tokenizer.fileInfo.size ?? Number.MAX_SAFE_INTEGER,
                            t = new rL(this.tokenizer);
                        oL("Initializing DTD end MatroskaIterator"),
                            await t.iterate(KF, e, {
                                startNext: (e) => {
                                    switch (e.id) {
                                        case 475249515:
                                            return oL(`Skip element: name=${e.name}, id=0x${e.id.toString(16)}`), ZF;
                                        case 524531317:
                                            if (this.flagUseIndexToSkipClusters && this.seekHead) {
                                                const e = this.seekHead.seek.find(
                                                    (e) => e.position + this.seekHeadOffset > this.tokenizer.position
                                                );
                                                if (e) {
                                                    const t =
                                                        e.position + this.seekHeadOffset - this.tokenizer.position;
                                                    return (
                                                        oL(`Use index to go to next position, ignoring ${t} bytes`),
                                                        this.tokenizer.ignore(t),
                                                        nL
                                                    );
                                                }
                                            }
                                            return ZF;
                                        default:
                                            return JF;
                                    }
                                },
                                elementValue: async (e, t, n) => {
                                    switch ((oL(`Received: name=${e.name}, value=${t}`), e.id)) {
                                        case 17026:
                                            this.metadata.setFormat("container", `EBML/${t}`);
                                            break;
                                        case 290298740:
                                            (this.seekHead = t), (this.seekHeadOffset = n);
                                            break;
                                        case 357149030:
                                            {
                                                const e = t,
                                                    n = e.timecodeScale ? e.timecodeScale : 1e6;
                                                if ("number" == typeof e.duration) {
                                                    const t = (e.duration * n) / 1e9;
                                                    await this.addTag("segment:title", e.title),
                                                        this.metadata.setFormat("duration", Number(t));
                                                }
                                            }
                                            break;
                                        case 374648427:
                                            {
                                                const e = t;
                                                if (e?.entries) {
                                                    e.entries.forEach((e) => {
                                                        const t = {
                                                            codecName: e.codecID.replace("A_", "").replace("V_", ""),
                                                            codecSettings: e.codecSettings,
                                                            flagDefault: e.flagDefault,
                                                            flagLacing: e.flagLacing,
                                                            flagEnabled: e.flagEnabled,
                                                            language: e.language,
                                                            name: e.name,
                                                            type: e.trackType,
                                                            audio: e.audio,
                                                            video: e.video,
                                                        };
                                                        this.metadata.addStreamInfo(t);
                                                    });
                                                    const t = e.entries
                                                        .filter((e) => e.trackType === hd)
                                                        .reduce(
                                                            (e, t) =>
                                                                e
                                                                    ? (t.flagDefault && !e.flagDefault) ||
                                                                      t.trackNumber < e.trackNumber
                                                                        ? t
                                                                        : e
                                                                    : t,
                                                            null
                                                        );
                                                    t &&
                                                        (this.metadata.setFormat("codec", t.codecID.replace("A_", "")),
                                                        this.metadata.setFormat(
                                                            "sampleRate",
                                                            t.audio.samplingFrequency
                                                        ),
                                                        this.metadata.setFormat("numberOfChannels", t.audio.channels));
                                                }
                                            }
                                            break;
                                        case 307544935:
                                            {
                                                const e = t;
                                                await Promise.all(
                                                    e.tag.map(async (e) => {
                                                        const t = e.target,
                                                            n = t?.targetTypeValue
                                                                ? ud[t.targetTypeValue]
                                                                : t?.targetType
                                                                  ? t.targetType
                                                                  : "track";
                                                        await Promise.all(
                                                            e.simpleTags.map(async (e) => {
                                                                const t = e.string ? e.string : e.binary;
                                                                await this.addTag(`${n}:${e.name}`, t);
                                                            })
                                                        );
                                                    })
                                                );
                                            }
                                            break;
                                        case 423732329: {
                                            const e = t;
                                            await Promise.all(
                                                e.attachedFiles
                                                    .filter((e) => e.mimeType.startsWith("image/"))
                                                    .map((e) =>
                                                        this.addTag("picture", {
                                                            data: e.data,
                                                            format: e.mimeType,
                                                            description: e.description,
                                                            name: e.name,
                                                        })
                                                    )
                                            );
                                        }
                                    }
                                },
                            });
                    }
                    async addTag(e, t) {
                        await this.metadata.addTag("matroska", e, t);
                    }
                },
            },
            Symbol.toStringTag,
            { value: "Module" }
        )
    ),
    lL = Tu("music-metadata:parser:MP4:atom");
class uL extends Ed("MP4") {}
const dL = {
        len: 8,
        get: (e, t) => {
            const n = ml.get(e, t);
            if (n < 0) throw new uL("Invalid atom header length");
            return { length: BigInt(n), name: new Ml(4, "latin1").get(e, t + 4) };
        },
        put: (e, t, n) => (ml.put(e, t, Number(n.length)), Vh.put(e, t + 4, n.name)),
    },
    hL = vl,
    mL = { len: 4, get: (e, t) => ({ type: new Ml(4, "ascii").get(e, t) }) };
class pL {
    constructor(e, t, n) {
        if (e < t) throw new uL(`Atom ${n} expected to be ${t}, but specifies ${e} bytes long.`);
        e > t && lL(`Warning: atom ${n} expected to be ${t}, but was actually ${e} bytes long.`), (this.len = e);
    }
}
const fL = (e, t) => {
    const n = ml.get(e, t) - 2082844800;
    return new Date(1e3 * n);
};
class gL extends pL {
    constructor(e) {
        super(e, 24, "mdhd");
    }
    get(e, t) {
        return {
            version: ol.get(e, t + 0),
            flags: dl.get(e, t + 1),
            creationTime: fL(e, t + 4),
            modificationTime: fL(e, t + 8),
            timeScale: ml.get(e, t + 12),
            duration: ml.get(e, t + 16),
            language: ll.get(e, t + 20),
            quality: ll.get(e, t + 22),
        };
    }
}
class bL extends pL {
    constructor(e) {
        super(e, 100, "mvhd");
    }
    get(e, t) {
        return {
            version: ol.get(e, t),
            flags: dl.get(e, t + 1),
            creationTime: fL(e, t + 4),
            modificationTime: fL(e, t + 8),
            timeScale: ml.get(e, t + 12),
            duration: ml.get(e, t + 16),
            preferredRate: ml.get(e, t + 20),
            preferredVolume: ll.get(e, t + 24),
            previewTime: ml.get(e, t + 72),
            previewDuration: ml.get(e, t + 76),
            posterTime: ml.get(e, t + 80),
            selectionTime: ml.get(e, t + 84),
            selectionDuration: ml.get(e, t + 88),
            currentTime: ml.get(e, t + 92),
            nextTrackID: ml.get(e, t + 96),
        };
    }
}
class yL {
    constructor(e) {
        this.len = e;
    }
    get(e, t) {
        return {
            type: { set: ol.get(e, t + 0), type: dl.get(e, t + 1) },
            locale: dl.get(e, t + 4),
            value: new Rl(this.len - 8).get(e, t + 8),
        };
    }
}
class wL {
    constructor(e) {
        this.len = e;
    }
    get(e, t) {
        return { version: ol.get(e, t), flags: dl.get(e, t + 1), name: new Ml(this.len - 4, "utf-8").get(e, t + 4) };
    }
}
class kL {
    constructor(e) {
        this.len = e;
    }
    get(e, t) {
        return {
            version: ol.get(e, t),
            flags: dl.get(e, t + 1),
            creationTime: fL(e, t + 4),
            modificationTime: fL(e, t + 8),
            trackId: ml.get(e, t + 12),
            duration: ml.get(e, t + 20),
            layer: ll.get(e, t + 24),
            alternateGroup: ll.get(e, t + 26),
            volume: ll.get(e, t + 28),
        };
    }
}
const TL = 8,
    _L = (e, t) => ({ version: ol.get(e, t), flags: dl.get(e, t + 1), numberOfEntries: ml.get(e, t + 4) });
class vL {
    constructor(e) {
        this.len = e;
    }
    get(e, t) {
        const n = this.len - 12;
        return {
            dataFormat: Vh.get(e, t),
            dataReferenceIndex: ll.get(e, t + 10),
            description: n > 0 ? new Rl(n).get(e, t + 12) : void 0,
        };
    }
}
class SL {
    constructor(e) {
        this.len = e;
    }
    get(e, t) {
        const n = _L(e, t);
        t += TL;
        const r = [];
        for (let i = 0; i < n.numberOfEntries; ++i) {
            const n = ml.get(e, t);
            (t += ml.len), r.push(new vL(n - ml.len).get(e, t)), (t += n);
        }
        return { header: n, table: r };
    }
}
const EL = { len: 8, get: (e, t) => ({ version: fl.get(e, t), revision: fl.get(e, t + 2), vendor: wl.get(e, t + 4) }) },
    CL = {
        len: 12,
        get: (e, t) => ({
            numAudioChannels: fl.get(e, t + 0),
            sampleSize: fl.get(e, t + 2),
            compressionId: fl.get(e, t + 4),
            packetSize: fl.get(e, t + 6),
            sampleRate: ll.get(e, t + 8) + ll.get(e, t + 10) / 1e4,
        }),
    };
class IL {
    constructor(e, t) {
        (this.len = e), (this.token = t);
    }
    get(e, t) {
        const n = wl.get(e, t + 4);
        return {
            version: pl.get(e, t + 0),
            flags: yl.get(e, t + 1),
            numberOfEntries: n,
            entries: DL(e, this.token, t + 8, this.len - 8, n),
        };
    }
}
const xL = { len: 8, get: (e, t) => ({ count: wl.get(e, t + 0), duration: wl.get(e, t + 4) }) };
class AL extends IL {
    constructor(e) {
        super(e, xL);
    }
}
const PL = {
    len: 12,
    get: (e, t) => ({
        firstChunk: wl.get(e, t),
        samplesPerChunk: wl.get(e, t + 4),
        sampleDescriptionId: wl.get(e, t + 8),
    }),
};
class OL extends IL {
    constructor(e) {
        super(e, PL);
    }
}
class NL {
    constructor(e) {
        this.len = e;
    }
    get(e, t) {
        const n = wl.get(e, t + 8);
        return {
            version: pl.get(e, t),
            flags: yl.get(e, t + 1),
            sampleSize: wl.get(e, t + 4),
            numberOfEntries: n,
            entries: DL(e, wl, t + 12, this.len - 12, n),
        };
    }
}
class RL extends IL {
    constructor(e) {
        super(e, wl), (this.len = e);
    }
}
class ML {
    constructor(e) {
        this.len = e;
    }
    get(e, t) {
        const n = fl.get(e, t + 0);
        return new Ml(n, "utf-8").get(e, t + 2);
    }
}
function DL(e, t, n, r, i) {
    if ((lL(`remainingLen=${r}, numberOfEntries=${i} * token-len=${t.len}`), 0 === r)) return [];
    if (r !== i * t.len) throw new uL("mismatch number-of-entries with remaining atom-length");
    const s = [];
    for (let a = 0; a < i; ++a) s.push(t.get(e, n)), (n += t.len);
    return s;
}
class FL {
    constructor(e) {
        this.len = e;
    }
    get(e, t) {
        const n = t + 1,
            r = {
                version: pl.get(e, t),
                flags: {
                    baseDataOffsetPresent: Cd(e, n + 2, 0),
                    sampleDescriptionIndexPresent: Cd(e, n + 2, 1),
                    defaultSampleDurationPresent: Cd(e, n + 2, 3),
                    defaultSampleSizePresent: Cd(e, n + 2, 4),
                    defaultSampleFlagsPresent: Cd(e, n + 2, 5),
                    defaultDurationIsEmpty: Cd(e, n, 0),
                    defaultBaseIsMoof: Cd(e, n, 1),
                },
                trackId: ml.get(e, 4),
            };
        let i = 8;
        return (
            r.flags.baseDataOffsetPresent && ((r.baseDataOffset = vl.get(e, i)), (i += 8)),
            r.flags.sampleDescriptionIndexPresent && ((r.sampleDescriptionIndex = ml.get(e, i)), (i += 4)),
            r.flags.defaultSampleDurationPresent && ((r.defaultSampleDuration = ml.get(e, i)), (i += 4)),
            r.flags.defaultSampleSizePresent && ((r.defaultSampleSize = ml.get(e, i)), (i += 4)),
            r.flags.defaultSampleFlagsPresent && (r.defaultSampleFlags = ml.get(e, i)),
            r
        );
    }
}
class LL {
    constructor(e) {
        this.len = e;
    }
    get(e, t) {
        const n = t + 1,
            r = {
                version: pl.get(e, t),
                flags: {
                    dataOffsetPresent: Cd(e, n + 2, 0),
                    firstSampleFlagsPresent: Cd(e, n + 2, 2),
                    sampleDurationPresent: Cd(e, n + 1, 0),
                    sampleSizePresent: Cd(e, n + 1, 1),
                    sampleFlagsPresent: Cd(e, n + 1, 2),
                    sampleCompositionTimeOffsetsPresent: Cd(e, n + 1, 3),
                },
                sampleCount: ml.get(e, t + 4),
                samples: [],
            };
        let i = t + 8;
        r.flags.dataOffsetPresent && ((r.dataOffset = ml.get(e, i)), (i += 4)),
            r.flags.firstSampleFlagsPresent && ((r.firstSampleFlags = ml.get(e, i)), (i += 4));
        for (let s = 0; s < r.sampleCount; ++s) {
            if (i >= this.len) {
                lL("TrackRunBox size mismatch");
                break;
            }
            const t = {};
            r.flags.sampleDurationPresent && ((t.sampleDuration = ml.get(e, i)), (i += 4)),
                r.flags.sampleSizePresent && ((t.sampleSize = ml.get(e, i)), (i += 4)),
                r.flags.sampleFlagsPresent && ((t.sampleFlags = ml.get(e, i)), (i += 4)),
                r.flags.sampleCompositionTimeOffsetsPresent &&
                    ((t.sampleCompositionTimeOffset = ml.get(e, i)), (i += 4)),
                r.samples.push(t);
        }
        return r;
    }
}
class BL {
    constructor(e) {
        this.len = e;
    }
    get(e, t) {
        const n = new Ml(4, "utf-8");
        return {
            version: pl.get(e, t),
            flags: dl.get(e, t + 1),
            componentType: n.get(e, t + 4),
            handlerType: n.get(e, t + 8),
            componentName: new Ml(this.len - 28, "utf-8").get(e, t + 28),
        };
    }
}
class zL {
    constructor(e) {
        this.len = e;
    }
    get(e, t) {
        let n = 0;
        const r = [];
        for (; n < this.len; ) r.push(ml.get(e, t + n)), (n += 4);
        return r;
    }
}
const UL = Tu("music-metadata:parser:MP4:Atom");
class $L {
    static async readAtom(e, t, n, r) {
        const i = e.position;
        UL(`Reading next token on offset=${i}...`);
        const s = await e.readToken(dL),
            a = 1n === s.length;
        a && (s.length = await e.readToken(hL));
        const o = new $L(s, a, n),
            c = o.getPayloadLength(r);
        return (
            UL(`parse atom name=${o.atomPath}, extended=${o.extended}, offset=${i}, len=${o.header.length}`),
            await o.readData(e, t, c),
            o
        );
    }
    constructor(e, t, n) {
        (this.header = e),
            (this.extended = t),
            (this.parent = n),
            (this.children = []),
            (this.atomPath = (this.parent ? `${this.parent.atomPath}.` : "") + this.header.name);
    }
    getHeaderLength() {
        return this.extended ? 16 : 8;
    }
    getPayloadLength(e) {
        return (0n === this.header.length ? e : Number(this.header.length)) - this.getHeaderLength();
    }
    async readAtoms(e, t, n) {
        for (; n > 0; ) {
            const r = await $L.readAtom(e, t, this, n);
            this.children.push(r), (n -= 0n === r.header.length ? n : Number(r.header.length));
        }
    }
    async readData(e, t, n) {
        switch (this.header.name) {
            case "moov":
            case "udta":
            case "mdia":
            case "minf":
            case "stbl":
            case "<id>":
            case "ilst":
            case "tref":
            case "moof":
                return this.readAtoms(e, t, this.getPayloadLength(n));
            case "meta": {
                const r = "hdlr" === (await e.peekToken(dL)).name ? 0 : 4;
                return await e.ignore(r), this.readAtoms(e, t, this.getPayloadLength(n) - r);
            }
            default:
                return t(this, n);
        }
    }
}
const VL = Tu("music-metadata:parser:MP4"),
    WL = {
        raw: { lossy: !1, format: "raw" },
        MAC3: { lossy: !0, format: "MACE 3:1" },
        MAC6: { lossy: !0, format: "MACE 6:1" },
        ima4: { lossy: !0, format: "IMA 4:1" },
        ulaw: { lossy: !0, format: "uLaw 2:1" },
        alaw: { lossy: !0, format: "uLaw 2:1" },
        Qclp: { lossy: !0, format: "QUALCOMM PureVoice" },
        ".mp3": { lossy: !0, format: "MPEG-1 layer 3" },
        alac: { lossy: !1, format: "ALAC" },
        "ac-3": { lossy: !0, format: "AC-3" },
        mp4a: { lossy: !0, format: "MPEG-4/AAC" },
        mp4s: { lossy: !0, format: "MP4S" },
        c608: { lossy: !0, format: "CEA-608" },
        c708: { lossy: !0, format: "CEA-708" },
    };
function jL(e, t, n) {
    return n.indexOf(e) === t;
}
class HL extends Uh {
    constructor() {
        super(...arguments),
            (this.tracks = new Map()),
            (this.hasVideoTrack = !1),
            (this.hasAudioTrack = !0),
            (this.atomParsers = {
                mvhd: async (e) => {
                    const t = await this.tokenizer.readToken(new bL(e));
                    this.metadata.setFormat("creationTime", t.creationTime),
                        this.metadata.setFormat("modificationTime", t.modificationTime);
                },
                chap: async (e) => {
                    const t = this.getTrackDescription(),
                        n = [];
                    for (; e >= ml.len; ) n.push(await this.tokenizer.readNumber(ml)), (e -= ml.len);
                    t.chapterList = n;
                },
                mdat: async (e) => {
                    if (((this.audioLengthInBytes = e), this.calculateBitRate(), this.options.includeChapters)) {
                        const t = [...this.tracks.values()].filter((e) => e.chapterList);
                        if (1 === t.length) {
                            const n = t[0].chapterList,
                                r = [...this.tracks.values()].filter((e) => -1 !== n.indexOf(e.header.trackId));
                            if (1 === r.length) return this.parseChapterTrack(r[0], t[0], e);
                        }
                    }
                    await this.tokenizer.ignore(e);
                },
                ftyp: async (e) => {
                    const t = [];
                    for (; e > 0; ) {
                        const n = await this.tokenizer.readToken(mL);
                        e -= mL.len;
                        const r = n.type.replace(/\W/g, "");
                        r.length > 0 && t.push(r);
                    }
                    VL(`ftyp: ${t.join("/")}`);
                    const n = t.filter(jL).join("/");
                    this.metadata.setFormat("container", n);
                },
                stsd: async (e) => {
                    const t = await this.tokenizer.readToken(new SL(e));
                    this.getTrackDescription().soundSampleDescription = t.table.map((e) =>
                        this.parseSoundSampleDescription(e)
                    );
                },
                stsz: async (e) => {
                    const t = await this.tokenizer.readToken(new NL(e)),
                        n = this.getTrackDescription();
                    (n.sampleSize = t.sampleSize), (n.sampleSizeTable = t.entries);
                },
                date: async (e) => {
                    const t = await this.tokenizer.readToken(new Ml(e, "utf-8"));
                    await this.addTag("date", t);
                },
            });
    }
    static read_BE_Integer(e, t) {
        const n = (t ? "INT" : "UINT") + 8 * e.length + (e.length > 1 ? "_BE" : ""),
            r = Dl[n];
        if (!r) throw new uL(`Token for integer type not found: "${n}"`);
        return Number(r.get(e, 0));
    }
    async parse() {
        (this.hasVideoTrack = !1), (this.hasAudioTrack = !0), this.tracks.clear();
        let e = this.tokenizer.fileInfo.size || 0;
        for (; !this.tokenizer.fileInfo.size || e > 0; ) {
            try {
                if ("\0\0\0\0" === (await this.tokenizer.peekToken(dL)).name) {
                    const e = `Error at offset=${this.tokenizer.position}: box.id=0`;
                    VL(e), this.addWarning(e);
                    break;
                }
            } catch (r) {
                if (!(r instanceof Error)) throw r;
                {
                    const e = `Error at offset=${this.tokenizer.position}: ${r.message}`;
                    VL(e), this.addWarning(e);
                }
                break;
            }
            const t = await $L.readAtom(this.tokenizer, (e, t) => this.handleAtom(e, t), null, e);
            e -= t.header.length === BigInt(0) ? e : Number(t.header.length);
        }
        const t = [];
        this.tracks.forEach((e) => {
            const n = [];
            e.soundSampleDescription.forEach((e) => {
                const t = {},
                    r = WL[e.dataFormat];
                if (
                    (r ? (n.push(r.format), (t.codecName = r.format)) : (t.codecName = `<${e.dataFormat}>`),
                    e.description)
                ) {
                    const { description: n } = e;
                    n.sampleRate > 0 &&
                        ((t.type = hd),
                        (t.audio = {
                            samplingFrequency: n.sampleRate,
                            bitDepth: n.sampleSize,
                            channels: n.numAudioChannels,
                        }));
                }
                this.metadata.addStreamInfo(t);
            }),
                n.length >= 1 && t.push(n.join("/"));
        }),
            t.length > 0 && this.metadata.setFormat("codec", t.filter(jL).join("+"));
        const n = [...this.tracks.values()].filter(
            (e) =>
                e.soundSampleDescription.length >= 1 &&
                e.soundSampleDescription[0].description &&
                e.soundSampleDescription[0].description.numAudioChannels > 0
        );
        if (n.length >= 1) {
            const e = n[0];
            if (e.media.header && e.media.header.timeScale > 0)
                if (e.media.header.duration > 0) {
                    VL("Using duration defined on audio track");
                    const t = e.media.header.duration / e.media.header.timeScale;
                    this.metadata.setFormat("duration", t);
                } else if (e.fragments.length > 0) {
                    VL("Calculate duration defined in track fragments");
                    let t = 0;
                    for (const n of e.fragments) {
                        const e = n.header.defaultSampleDuration;
                        for (const r of n.trackRun.samples) {
                            const n = r.sampleDuration ?? e;
                            if (null == n)
                                throw new Error("Missing sampleDuration and no default_sample_duration in tfhd");
                            t += n;
                        }
                    }
                    this.metadata.setFormat("duration", t / e.media.header.timeScale);
                }
            const t = e.soundSampleDescription[0];
            if (
                t.description &&
                e.media.header &&
                (this.metadata.setFormat("sampleRate", t.description.sampleRate),
                this.metadata.setFormat("bitsPerSample", t.description.sampleSize),
                this.metadata.setFormat("numberOfChannels", t.description.numAudioChannels),
                0 === e.media.header.timeScale && e.timeToSampleTable.length > 0)
            ) {
                const n =
                    e.timeToSampleTable.map((e) => e.count * e.duration).reduce((e, t) => e + t) /
                    t.description.sampleRate;
                this.metadata.setFormat("duration", n);
            }
            const r = WL[t.dataFormat];
            r && this.metadata.setFormat("lossless", !r.lossy), this.calculateBitRate();
        }
        this.metadata.setFormat("hasAudio", this.hasAudioTrack),
            this.metadata.setFormat("hasVideo", this.hasVideoTrack);
    }
    async handleAtom(e, t) {
        if (e.parent)
            switch (e.parent.header.name) {
                case "ilst":
                case "<id>":
                    return this.parseMetadataItemData(e);
                case "moov":
                    if ("trak" === e.header.name) return this.parseTrackBox(e);
                    break;
                case "moof":
                    if ("traf" === e.header.name) return this.parseTrackFragmentBox(e);
            }
        if (this.atomParsers[e.header.name]) return this.atomParsers[e.header.name](t);
        VL(`No parser for atom path=${e.atomPath}, payload-len=${t}, ignoring atom`), await this.tokenizer.ignore(t);
    }
    getTrackDescription() {
        const e = [...this.tracks.values()];
        return e[e.length - 1];
    }
    calculateBitRate() {
        this.audioLengthInBytes &&
            this.metadata.format.duration &&
            this.metadata.setFormat("bitrate", (8 * this.audioLengthInBytes) / this.metadata.format.duration);
    }
    async addTag(e, t) {
        await this.metadata.addTag("iTunes", e, t);
    }
    addWarning(e) {
        VL(`Warning: ${e}`), this.metadata.addWarning(e);
    }
    parseMetadataItemData(e) {
        let t = e.header.name;
        return e.readAtoms(
            this.tokenizer,
            async (e, n) => {
                const r = e.getPayloadLength(n);
                switch (e.header.name) {
                    case "data":
                        return this.parseValueAtom(t, e);
                    case "name":
                    case "mean":
                    case "rate": {
                        const e = await this.tokenizer.readToken(new wL(r));
                        t += `:${e.name}`;
                        break;
                    }
                    default: {
                        const n = await this.tokenizer.readToken(new Rl(r));
                        this.addWarning(
                            `Unsupported meta-item: ${t}[${e.header.name}] => value=${Xu(n)} ascii=${Wu(n, "ascii")}`
                        );
                    }
                }
            },
            e.getPayloadLength(0)
        );
    }
    async parseValueAtom(e, t) {
        const n = await this.tokenizer.readToken(new yL(Number(t.header.length) - dL.len));
        if (0 !== n.type.set) throw new uL(`Unsupported type-set != 0: ${n.type.set}`);
        switch (n.type.type) {
            case 0:
                switch (e) {
                    case "trkn":
                    case "disk": {
                        const t = ol.get(n.value, 3),
                            r = ol.get(n.value, 5);
                        await this.addTag(e, `${t}/${r}`);
                        break;
                    }
                    case "gnre": {
                        const t = ol.get(n.value, 1),
                            r = om[t - 1];
                        await this.addTag(e, r);
                        break;
                    }
                    case "rate": {
                        const t = new TextDecoder("ascii").decode(n.value);
                        await this.addTag(e, t);
                        break;
                    }
                    default:
                        VL(`unknown proprietary value type for: ${t.atomPath}`);
                }
                break;
            case 1:
            case 18:
                await this.addTag(e, new TextDecoder("utf-8").decode(n.value));
                break;
            case 13:
                if (this.options.skipCovers) break;
                await this.addTag(e, { format: "image/jpeg", data: Uint8Array.from(n.value) });
                break;
            case 14:
                if (this.options.skipCovers) break;
                await this.addTag(e, { format: "image/png", data: Uint8Array.from(n.value) });
                break;
            case 21:
                await this.addTag(e, HL.read_BE_Integer(n.value, !0));
                break;
            case 22:
                await this.addTag(e, HL.read_BE_Integer(n.value, !1));
                break;
            case 65:
                await this.addTag(e, ol.get(n.value, 0));
                break;
            case 66:
                await this.addTag(e, ll.get(n.value, 0));
                break;
            case 67:
                await this.addTag(e, ml.get(n.value, 0));
                break;
            default:
                this.addWarning(`atom key=${e}, has unknown well-known-type (data-type): ${n.type.type}`);
        }
    }
    async parseTrackBox(e) {
        const t = { media: {}, fragments: [] };
        await e.readAtoms(
            this.tokenizer,
            async (e, n) => {
                const r = e.getPayloadLength(n);
                switch (e.header.name) {
                    case "chap": {
                        const e = await this.tokenizer.readToken(new zL(n));
                        t.chapterList = e;
                        break;
                    }
                    case "tkhd":
                        t.header = await this.tokenizer.readToken(new kL(r));
                        break;
                    case "hdlr":
                        switch (((t.handler = await this.tokenizer.readToken(new BL(r))), t.handler.handlerType)) {
                            case "audi":
                                VL("Contains audio track"), (this.hasAudioTrack = !0);
                                break;
                            case "vide":
                                VL("Contains video track"), (this.hasVideoTrack = !0);
                        }
                        break;
                    case "mdhd": {
                        const e = await this.tokenizer.readToken(new gL(r));
                        t.media.header = e;
                        break;
                    }
                    case "stco": {
                        const e = await this.tokenizer.readToken(new RL(r));
                        t.chunkOffsetTable = e.entries;
                        break;
                    }
                    case "stsc": {
                        const e = await this.tokenizer.readToken(new OL(r));
                        t.sampleToChunkTable = e.entries;
                        break;
                    }
                    case "stsd": {
                        const e = await this.tokenizer.readToken(new SL(r));
                        t.soundSampleDescription = e.table.map((e) => this.parseSoundSampleDescription(e));
                        break;
                    }
                    case "stts": {
                        const e = await this.tokenizer.readToken(new AL(r));
                        t.timeToSampleTable = e.entries;
                        break;
                    }
                    case "stsz": {
                        const e = await this.tokenizer.readToken(new NL(r));
                        (t.sampleSize = e.sampleSize), (t.sampleSizeTable = e.entries);
                        break;
                    }
                    case "dinf":
                    case "vmhd":
                    case "smhd":
                        VL(`Ignoring: ${e.header.name}`), await this.tokenizer.ignore(r);
                        break;
                    default:
                        VL(`Unexpected track box: ${e.header.name}`), await this.tokenizer.ignore(r);
                }
            },
            e.getPayloadLength(0)
        ),
            this.tracks.set(t.header.trackId, t);
    }
    parseTrackFragmentBox(e) {
        let t;
        return e.readAtoms(
            this.tokenizer,
            async (e, n) => {
                const r = e.getPayloadLength(n);
                switch (e.header.name) {
                    case "tfhd": {
                        const r = new FL(e.getPayloadLength(n));
                        t = await this.tokenizer.readToken(r);
                        break;
                    }
                    case "tfdt":
                        await this.tokenizer.ignore(r);
                        break;
                    case "trun": {
                        const e = new LL(r),
                            n = await this.tokenizer.readToken(e);
                        if (t) {
                            const e = this.tracks.get(t.trackId);
                            e?.fragments.push({ header: t, trackRun: n });
                        }
                        break;
                    }
                    default:
                        VL(`Unexpected box: ${e.header.name}`), await this.tokenizer.ignore(r);
                }
            },
            e.getPayloadLength(0)
        );
    }
    parseSoundSampleDescription(e) {
        const t = { dataFormat: e.dataFormat, dataReferenceIndex: e.dataReferenceIndex };
        let n = 0;
        if (e.description) {
            const r = EL.get(e.description, n);
            (n += EL.len),
                0 === r.version || 1 === r.version
                    ? (t.description = CL.get(e.description, n))
                    : VL(`Warning: sound-sample-description ${r} not implemented`);
        }
        return t;
    }
    async parseChapterTrack(e, t, n) {
        if (!e.sampleSize && e.chunkOffsetTable.length !== e.sampleSizeTable.length)
            throw new Error("Expected equal chunk-offset-table & sample-size-table length.");
        const r = [];
        for (let i = 0; i < e.chunkOffsetTable.length && n > 0; ++i) {
            const s = e.timeToSampleTable.slice(0, i).reduce((e, t) => e + t.duration, 0),
                a = e.chunkOffsetTable[i] - this.tokenizer.position,
                o = e.sampleSize > 0 ? e.sampleSize : e.sampleSizeTable[i];
            if ((n -= a + o) < 0) throw new uL("Chapter chunk exceeding token length");
            await this.tokenizer.ignore(a);
            const c = await this.tokenizer.readToken(new ML(o));
            VL(`Chapter ${i + 1}: ${c}`);
            const l = {
                title: c,
                timeScale: e.media.header ? e.media.header.timeScale : 0,
                start: s,
                sampleOffset: this.findSampleOffset(t, this.tokenizer.position),
            };
            VL(`Chapter title=${l.title}, offset=${l.sampleOffset}/${t.header.duration}`), r.push(l);
        }
        this.metadata.setFormat("chapters", r), await this.tokenizer.ignore(n);
    }
    findSampleOffset(e, t) {
        let n = 0;
        for (; n < e.chunkOffsetTable.length && e.chunkOffsetTable[n] < t; ) ++n;
        return this.getChunkDuration(n + 1, e);
    }
    getChunkDuration(e, t) {
        let n = 0,
            r = t.timeToSampleTable[n].count,
            i = t.timeToSampleTable[n].duration,
            s = 1,
            a = this.getSamplesPerChunk(s, t.sampleToChunkTable),
            o = 0;
        for (; s < e; ) {
            const e = Math.min(r, a);
            (o += e * i),
                (r -= e),
                (a -= e),
                0 === a
                    ? (++s, (a = this.getSamplesPerChunk(s, t.sampleToChunkTable)))
                    : (++n, (r = t.timeToSampleTable[n].count), (i = t.timeToSampleTable[n].duration));
        }
        return o;
    }
    getSamplesPerChunk(e, t) {
        for (let n = 0; n < t.length - 1; ++n)
            if (e >= t[n].firstChunk && e < t[n + 1].firstChunk) return t[n].samplesPerChunk;
        return t[t.length - 1].samplesPerChunk;
    }
}
const qL = Object.freeze(
        Object.defineProperty({ __proto__: null, MP4Parser: HL }, Symbol.toStringTag, { value: "Module" })
    ),
    XL = Tu("music-metadata:parser:musepack:sv8"),
    GL = new Ml(2, "latin1"),
    KL = { len: 5, get: (e, t) => ({ crc: hl.get(e, t), streamVersion: ol.get(e, t + 4) }) },
    YL = {
        len: 2,
        get: (e, t) => ({
            sampleFrequency: [44100, 48e3, 37800, 32e3][Od(e, t, 0, 3)],
            maxUsedBands: Od(e, t, 3, 5),
            channelCount: Od(e, t + 1, 0, 4) + 1,
            msUsed: Nd(e, t + 1, 4),
            audioBlockFrames: Od(e, t + 1, 5, 3),
        }),
    };
class QL {
    get tokenizer() {
        return this._tokenizer;
    }
    set tokenizer(e) {
        this._tokenizer = e;
    }
    constructor(e) {
        this._tokenizer = e;
    }
    async readPacketHeader() {
        const e = await this.tokenizer.readToken(GL),
            t = await this.readVariableSizeField();
        return { key: e, payloadLength: t.value - 2 - t.len };
    }
    async readStreamHeader(e) {
        const t = {};
        XL(`Reading SH at offset=${this.tokenizer.position}`);
        const n = await this.tokenizer.readToken(KL);
        (e -= KL.len), Object.assign(t, n), XL(`SH.streamVersion = ${n.streamVersion}`);
        const r = await this.readVariableSizeField();
        (e -= r.len), (t.sampleCount = r.value);
        const i = await this.readVariableSizeField();
        (e -= i.len), (t.beginningOfSilence = i.value);
        const s = await this.tokenizer.readToken(YL);
        return (e -= YL.len), Object.assign(t, s), await this.tokenizer.ignore(e), t;
    }
    async readVariableSizeField(e = 1, t = 0) {
        let n = await this.tokenizer.readNumber(ol);
        return 128 & n ? ((n &= 127), (n += t), this.readVariableSizeField(e + 1, n << 7)) : { len: e, value: t + n };
    }
}
class JL extends Ed("Musepack") {}
const ZL = Tu("music-metadata:parser:musepack");
class eB extends Uh {
    constructor() {
        super(...arguments), (this.audioLength = 0);
    }
    async parse() {
        if ("MPCK" !== (await this.tokenizer.readToken(Vh))) throw new JL("Invalid Magic number");
        return this.metadata.setFormat("container", "Musepack, SV8"), this.parsePacket();
    }
    async parsePacket() {
        const e = new QL(this.tokenizer);
        for (;;) {
            const t = await e.readPacketHeader();
            switch ((ZL(`packet-header key=${t.key}, payloadLength=${t.payloadLength}`), t.key)) {
                case "SH": {
                    const n = await e.readStreamHeader(t.payloadLength);
                    this.metadata.setFormat("numberOfSamples", n.sampleCount),
                        this.metadata.setFormat("sampleRate", n.sampleFrequency),
                        this.metadata.setFormat("duration", n.sampleCount / n.sampleFrequency),
                        this.metadata.setFormat("numberOfChannels", n.channelCount);
                    break;
                }
                case "AP":
                    (this.audioLength += t.payloadLength), await this.tokenizer.ignore(t.payloadLength);
                    break;
                case "RG":
                case "EI":
                case "SO":
                case "ST":
                case "CT":
                    await this.tokenizer.ignore(t.payloadLength);
                    break;
                case "SE":
                    return (
                        this.metadata.format.duration &&
                            this.metadata.setFormat("bitrate", (8 * this.audioLength) / this.metadata.format.duration),
                        rm(this.metadata, this.tokenizer, this.options)
                    );
                default:
                    throw new JL(`Unexpected header: ${t.key}`);
            }
        }
    }
}
class tB {
    constructor(e) {
        (this.pos = 0), (this.dword = null), (this.tokenizer = e);
    }
    async read(e) {
        for (; null === this.dword; ) this.dword = await this.tokenizer.readToken(hl);
        let t = this.dword;
        return (
            (this.pos += e),
            this.pos < 32
                ? ((t >>>= 32 - this.pos), t & ((1 << e) - 1))
                : ((this.pos -= 32),
                  0 === this.pos
                      ? ((this.dword = null), t & ((1 << e) - 1))
                      : ((this.dword = await this.tokenizer.readToken(hl)),
                        this.pos && ((t <<= this.pos), (t |= this.dword >>> (32 - this.pos))),
                        t & ((1 << e) - 1)))
        );
    }
    async ignore(e) {
        if (this.pos > 0) {
            const t = 32 - this.pos;
            (this.dword = null), (e -= t), (this.pos = 0);
        }
        const t = e % 32,
            n = (e - t) / 32;
        return await this.tokenizer.ignore(4 * n), this.read(t);
    }
}
const nB = {
        len: 24,
        get: (e, t) => {
            const n = {
                signature: new TextDecoder("latin1").decode(e.subarray(t, t + 3)),
                streamMinorVersion: Od(e, t + 3, 0, 4),
                streamMajorVersion: Od(e, t + 3, 4, 4),
                frameCount: hl.get(e, t + 4),
                maxLevel: cl.get(e, t + 8),
                sampleFrequency: [44100, 48e3, 37800, 32e3][Od(e, t + 10, 0, 2)],
                link: Od(e, t + 10, 2, 2),
                profile: Od(e, t + 10, 4, 4),
                maxBand: Od(e, t + 11, 0, 6),
                intensityStereo: Nd(e, t + 11, 6),
                midSideStereo: Nd(e, t + 11, 7),
                titlePeak: cl.get(e, t + 12),
                titleGain: cl.get(e, t + 14),
                albumPeak: cl.get(e, t + 16),
                albumGain: cl.get(e, t + 18),
                lastFrameLength: (hl.get(e, t + 20) >>> 20) & 2047,
                trueGapless: Nd(e, t + 23, 0),
            };
            return (n.lastFrameLength = n.trueGapless ? (hl.get(e, 20) >>> 20) & 2047 : 0), n;
        },
    },
    rB = Tu("music-metadata:parser:musepack");
class iB extends Uh {
    constructor() {
        super(...arguments), (this.bitreader = null), (this.audioLength = 0), (this.duration = null);
    }
    async parse() {
        const e = await this.tokenizer.readToken(nB);
        if ("MP+" !== e.signature) throw new JL("Unexpected magic number");
        rB(`stream-version=${e.streamMajorVersion}.${e.streamMinorVersion}`),
            this.metadata.setFormat("container", "Musepack, SV7"),
            this.metadata.setFormat("sampleRate", e.sampleFrequency);
        const t = 1152 * (e.frameCount - 1) + e.lastFrameLength;
        this.metadata.setFormat("numberOfSamples", t),
            (this.duration = t / e.sampleFrequency),
            this.metadata.setFormat("duration", this.duration),
            (this.bitreader = new tB(this.tokenizer)),
            this.metadata.setFormat("numberOfChannels", e.midSideStereo || e.intensityStereo ? 2 : 1);
        const n = await this.bitreader.read(8);
        return (
            this.metadata.setFormat("codec", (n / 100).toFixed(2)),
            await this.skipAudioData(e.frameCount),
            rB(`End of audio stream, switching to APEv2, offset=${this.tokenizer.position}`),
            rm(this.metadata, this.tokenizer, this.options)
        );
    }
    async skipAudioData(e) {
        for (; e-- > 0; ) {
            const e = await this.bitreader.read(20);
            (this.audioLength += 20 + e), await this.bitreader.ignore(e);
        }
        const t = await this.bitreader.read(11);
        (this.audioLength += t),
            null !== this.duration && this.metadata.setFormat("bitrate", this.audioLength / this.duration);
    }
}
const sB = Tu("music-metadata:parser:musepack");
const aB = Object.freeze(
    Object.defineProperty(
        {
            __proto__: null,
            MusepackParser: class extends kD {
                async postId3v2Parse() {
                    let e;
                    switch (await this.tokenizer.peekToken(new Ml(3, "latin1"))) {
                        case "MP+":
                            sB("Stream-version 7"), (e = new iB(this.metadata, this.tokenizer, this.options));
                            break;
                        case "MPC":
                            sB("Stream-version 8"), (e = new eB(this.metadata, this.tokenizer, this.options));
                            break;
                        default:
                            throw new JL("Invalid signature prefix");
                    }
                    return this.metadata.setAudioOnly(), e.parse();
                }
            },
        },
        Symbol.toStringTag,
        { value: "Module" }
    )
);
class oB extends Ed("Opus") {}
class cB {
    constructor(e) {
        if (e < 19) throw new oB("ID-header-page 0 should be at least 19 bytes long");
        this.len = e;
    }
    get(e, t) {
        return {
            magicSignature: new Ml(8, "ascii").get(e, t + 0),
            version: ol.get(e, t + 8),
            channelCount: ol.get(e, t + 9),
            preSkip: cl.get(e, t + 10),
            inputSampleRate: hl.get(e, t + 12),
            outputGain: cl.get(e, t + 16),
            channelMapping: ol.get(e, t + 18),
        };
    }
}
class lB extends AF {
    constructor(e, t, n) {
        super(e, t), (this.idHeader = null), (this.lastPos = -1), (this.tokenizer = n), (this.durationOnLastPage = !0);
    }
    parseFirstPage(e, t) {
        if (
            (this.metadata.setFormat("codec", "Opus"),
            (this.idHeader = new cB(t.length).get(t, 0)),
            "OpusHead" !== this.idHeader.magicSignature)
        )
            throw new oB("Illegal ogg/Opus magic-signature");
        this.metadata.setFormat("sampleRate", this.idHeader.inputSampleRate),
            this.metadata.setFormat("numberOfChannels", this.idHeader.channelCount),
            this.metadata.setAudioOnly();
    }
    async parseFullPage(e) {
        if ("OpusTags" === new Ml(8, "ascii").get(e, 0))
            await this.parseUserCommentList(e, 8), (this.lastPos = this.tokenizer.position - e.length);
    }
    calculateDuration() {
        if (
            this.lastPageHeader &&
            this.metadata.format.sampleRate &&
            this.lastPageHeader.absoluteGranulePosition >= 0
        ) {
            const e = this.lastPageHeader.absoluteGranulePosition - this.idHeader.preSkip;
            if (
                (this.metadata.setFormat("numberOfSamples", e),
                this.metadata.setFormat("duration", e / 48e3),
                -1 !== this.lastPos && this.tokenizer.fileInfo.size && this.metadata.format.duration)
            ) {
                const e = this.tokenizer.fileInfo.size - this.lastPos;
                this.metadata.setFormat("bitrate", (8 * e) / this.metadata.format.duration);
            }
        }
    }
}
const uB = (e, t) => ({
        speex: new Ml(8, "ascii").get(e, t + 0),
        version: xd(new Ml(20, "ascii").get(e, t + 8)),
        version_id: kl.get(e, t + 28),
        header_size: kl.get(e, t + 32),
        rate: kl.get(e, t + 36),
        mode: kl.get(e, t + 40),
        mode_bitstream_version: kl.get(e, t + 44),
        nb_channels: kl.get(e, t + 48),
        bitrate: kl.get(e, t + 52),
        frame_size: kl.get(e, t + 56),
        vbr: kl.get(e, t + 60),
        frames_per_packet: kl.get(e, t + 64),
        extra_headers: kl.get(e, t + 68),
        reserved1: kl.get(e, t + 72),
        reserved2: kl.get(e, t + 76),
    }),
    dB = Tu("music-metadata:parser:ogg:speex");
class hB extends AF {
    constructor(e, t, n) {
        super(e, t);
    }
    parseFirstPage(e, t) {
        dB("First Ogg/Speex page");
        const n = uB(t, 0);
        this.metadata.setFormat("codec", `Speex ${n.version}`),
            this.metadata.setFormat("numberOfChannels", n.nb_channels),
            this.metadata.setFormat("sampleRate", n.rate),
            -1 !== n.bitrate && this.metadata.setFormat("bitrate", n.bitrate),
            this.metadata.setAudioOnly();
    }
}
const mB = (e, t) => ({
        id: new Ml(7, "ascii").get(e, t),
        vmaj: ol.get(e, t + 7),
        vmin: ol.get(e, t + 8),
        vrev: ol.get(e, t + 9),
        vmbw: ll.get(e, t + 10),
        vmbh: ll.get(e, t + 17),
        nombr: dl.get(e, t + 37),
        nqual: ol.get(e, t + 40),
    }),
    pB = Tu("music-metadata:parser:ogg:theora");
class fB {
    constructor(e, t, n) {
        (this.durationOnLastPage = !1), (this.metadata = e);
    }
    async parsePage(e, t) {
        e.headerType.firstPage && (await this.parseFirstPage(e, t));
    }
    calculateDuration() {
        pB("duration calculation not implemented");
    }
    async parseFirstPage(e, t) {
        pB("First Ogg/Theora page"), this.metadata.setFormat("codec", "Theora");
        const n = mB(t, 0);
        this.metadata.setFormat("bitrate", n.nombr), this.metadata.setFormat("hasVideo", !0);
    }
    flush() {
        return Promise.resolve();
    }
}
const gB = {
    len: 27,
    get: (e, t) => ({
        capturePattern: new Ml(4, "latin1").get(e, t),
        version: ol.get(e, t + 4),
        headerType: { continued: Cd(e, t + 5, 0), firstPage: Cd(e, t + 5, 1), lastPage: Cd(e, t + 5, 2) },
        absoluteGranulePosition: Number(Tl.get(e, t + 6)),
        streamSerialNumber: hl.get(e, t + 14),
        pageSequenceNo: hl.get(e, t + 18),
        pageChecksum: hl.get(e, t + 22),
        page_segments: ol.get(e, t + 26),
    }),
};
class bB {
    static sum(e, t, n) {
        const r = new DataView(e.buffer, 0);
        let i = 0;
        for (let s = t; s < t + n; ++s) i += r.getUint8(s);
        return i;
    }
    constructor(e) {
        this.len = e.page_segments;
    }
    get(e, t) {
        return { totalPageSize: bB.sum(e, t, this.len) };
    }
}
const yB = Tu("music-metadata:parser:ogg:theora");
class wB {
    constructor(e, t, n) {
        (this.durationOnLastPage = !1),
            (this.metadata = e),
            (this.options = t),
            (this.tokenizer = n),
            (this.flacParser = new $F(this.metadata, this.tokenizer, t));
    }
    async parsePage(e, t) {
        e.headerType.firstPage && (await this.parseFirstPage(e, t));
    }
    calculateDuration() {
        yB("duration calculation not implemented");
    }
    async parseFirstPage(e, t) {
        yB("First Ogg/FLAC page");
        if ("fLaC" !== (await Vh.get(t, 9)).toString()) throw new Error("Invalid FLAC preamble");
        const n = await LF.get(t, 13);
        await this.parseDataBlock(n, t.subarray(13 + LF.len));
    }
    async parseDataBlock(e, t) {
        switch ((yB(`blockHeader type=${e.type}, length=${e.length}`), e.type)) {
            case PF: {
                const e = BF.get(t, 0);
                return this.flacParser.processsStreamInfo(e);
            }
            case OF:
            case NF:
            case RF:
                break;
            case MF:
                return this.flacParser.parseComment(t);
            case FF:
                if (!this.options.skipCovers) {
                    const e = new _F(t.length).get(t, 0);
                    return this.flacParser.addPictureTag(e);
                }
                break;
            default:
                this.metadata.addWarning(`Unknown block type: ${e.type}`);
        }
        return this.tokenizer.ignore(e.length).then();
    }
    flush() {
        return Promise.resolve();
    }
}
class kB extends Ed("Ogg") {}
const TB = Tu("music-metadata:parser:ogg");
class _B {
    constructor(e, t, n) {
        (this.pageNumber = 0), (this.closed = !1), (this.metadata = e), (this.streamSerial = t), (this.options = n);
    }
    async parsePage(e, t) {
        (this.pageNumber = t.pageSequenceNo),
            TB("serial=%s page#=%s, Ogg.id=%s", t.streamSerialNumber, t.pageSequenceNo, t.capturePattern);
        const n = await e.readToken(new bB(t));
        TB("totalPageSize=%s", n.totalPageSize);
        const r = await e.readToken(new Rl(n.totalPageSize));
        if (
            (TB(
                "firstPage=%s, lastPage=%s, continued=%s",
                t.headerType.firstPage,
                t.headerType.lastPage,
                t.headerType.continued
            ),
            t.headerType.firstPage)
        ) {
            this.metadata.setFormat("container", "Ogg");
            const n = r.slice(0, 7),
                i = Array.from(n)
                    .filter((e) => e >= 32 && e <= 126)
                    .map((e) => String.fromCharCode(e))
                    .join("");
            switch (i) {
                case "vorbis":
                    TB(`Set Ogg stream serial ${t.streamSerialNumber}, codec=Vorbis`),
                        (this.pageConsumer = new AF(this.metadata, this.options));
                    break;
                case "OpusHea":
                    TB("Set page consumer to Ogg/Opus"), (this.pageConsumer = new lB(this.metadata, this.options, e));
                    break;
                case "Speex  ":
                    TB("Set page consumer to Ogg/Speex"), (this.pageConsumer = new hB(this.metadata, this.options, e));
                    break;
                case "fishead":
                case "theora":
                    TB("Set page consumer to Ogg/Theora"), (this.pageConsumer = new fB(this.metadata, this.options, e));
                    break;
                case "FLAC":
                    TB("Set page consumer to Vorbis"), (this.pageConsumer = new wB(this.metadata, this.options, e));
                    break;
                default:
                    throw new kB(`Ogg codec not recognized (id=${i}`);
            }
        }
        if ((t.headerType.lastPage && (this.closed = !0), !this.pageConsumer))
            throw new Error("pageConsumer should be initialized");
        await this.pageConsumer.parsePage(t, r);
    }
}
const vB = Object.freeze(
        Object.defineProperty(
            {
                __proto__: null,
                OggContentError: kB,
                OggParser: class extends Uh {
                    constructor() {
                        super(...arguments), (this.streams = new Map());
                    }
                    async parse() {
                        let e;
                        this.streams = new Map();
                        try {
                            do {
                                if (((e = await this.tokenizer.readToken(gB)), "OggS" !== e.capturePattern))
                                    throw new kB("Invalid Ogg capture pattern");
                                let t = this.streams.get(e.streamSerialNumber);
                                if (
                                    (t ||
                                        ((t = new _B(this.metadata, e.streamSerialNumber, this.options)),
                                        this.streams.set(e.streamSerialNumber, t)),
                                    await t.parsePage(this.tokenizer, e),
                                    t.pageNumber > 12 &&
                                        (!this.options.duration ||
                                            ![...this.streams.values()].find(
                                                (e) => e.pageConsumer?.durationOnLastPage
                                            )))
                                ) {
                                    TB("Stop processing Ogg stream");
                                    break;
                                }
                            } while (![...this.streams.values()].every((e) => e.closed));
                        } catch (t) {
                            if (t instanceof qc) TB("Reached end-of-stream");
                            else {
                                if (!(t instanceof kB)) throw t;
                                this.metadata.addWarning(`Corrupt Ogg content at ${this.tokenizer.position}`);
                            }
                        }
                        for (const n of this.streams.values())
                            n.closed ||
                                (this.metadata.addWarning(
                                    `End-of-stream reached before reaching last page in Ogg stream serial=${n.streamSerial}`
                                ),
                                await n.pageConsumer?.flush()),
                                n.pageConsumer?.calculateDuration();
                    }
                },
            },
            Symbol.toStringTag,
            { value: "Module" }
        )
    ),
    SB = [6e3, 8e3, 9600, 11025, 12e3, 16e3, 22050, 24e3, 32e3, 44100, 48e3, 64e3, 88200, 96e3, 192e3, -1],
    EB = {
        len: 32,
        get: (e, t) => {
            const n = hl.get(e, t + 24),
                r = {
                    BlockID: Vh.get(e, t),
                    blockSize: hl.get(e, t + 4),
                    version: cl.get(e, t + 8),
                    totalSamples: hl.get(e, t + 12),
                    blockIndex: hl.get(e, t + 16),
                    blockSamples: hl.get(e, t + 20),
                    flags: {
                        bitsPerSample: 8 * (1 + xB(n, 0, 2)),
                        isMono: IB(n, 2),
                        isHybrid: IB(n, 3),
                        isJointStereo: IB(n, 4),
                        crossChannel: IB(n, 5),
                        hybridNoiseShaping: IB(n, 6),
                        floatingPoint: IB(n, 7),
                        samplingRate: SB[xB(n, 23, 4)],
                        isDSD: IB(n, 31),
                    },
                    crc: new Rl(4).get(e, t + 28),
                };
            return r.flags.isDSD && (r.totalSamples *= 8), r;
        },
    },
    CB = {
        len: 1,
        get: (e, t) => ({
            functionId: xB(e[t], 0, 6),
            isOptional: IB(e[t], 5),
            isOddSize: IB(e[t], 6),
            largeBlock: IB(e[t], 7),
        }),
    };
function IB(e, t) {
    return 1 === xB(e, t, 1);
}
function xB(e, t, n) {
    return (e >>> t) & (4294967295 >>> (32 - n));
}
const AB = Tu("music-metadata:parser:WavPack");
class PB extends Ed("WavPack") {}
const OB = Object.freeze(
        Object.defineProperty(
            {
                __proto__: null,
                WavPackContentError: PB,
                WavPackParser: class extends Uh {
                    constructor() {
                        super(...arguments), (this.audioDataSize = 0);
                    }
                    async parse() {
                        return (
                            this.metadata.setAudioOnly(),
                            (this.audioDataSize = 0),
                            await this.parseWavPackBlocks(),
                            rm(this.metadata, this.tokenizer, this.options)
                        );
                    }
                    async parseWavPackBlocks() {
                        do {
                            if ("wvpk" !== (await this.tokenizer.peekToken(Vh))) break;
                            const e = await this.tokenizer.readToken(EB);
                            if ("wvpk" !== e.BlockID) throw new PB("Invalid WavPack Block-ID");
                            AB(`WavPack header blockIndex=${e.blockIndex}, len=${EB.len}`),
                                0 !== e.blockIndex ||
                                    this.metadata.format.container ||
                                    (this.metadata.setFormat("container", "WavPack"),
                                    this.metadata.setFormat("lossless", !e.flags.isHybrid),
                                    this.metadata.setFormat("bitsPerSample", e.flags.bitsPerSample),
                                    e.flags.isDSD ||
                                        (this.metadata.setFormat("sampleRate", e.flags.samplingRate),
                                        this.metadata.setFormat("duration", e.totalSamples / e.flags.samplingRate)),
                                    this.metadata.setFormat("numberOfChannels", e.flags.isMono ? 1 : 2),
                                    this.metadata.setFormat("numberOfSamples", e.totalSamples),
                                    this.metadata.setFormat("codec", e.flags.isDSD ? "DSD" : "PCM"));
                            const t = e.blockSize - (EB.len - 8);
                            await (0 === e.blockIndex ? this.parseMetadataSubBlock(e, t) : this.tokenizer.ignore(t)),
                                e.blockSamples > 0 && (this.audioDataSize += e.blockSize);
                        } while (
                            !this.tokenizer.fileInfo.size ||
                            this.tokenizer.fileInfo.size - this.tokenizer.position >= EB.len
                        );
                        this.metadata.format.duration &&
                            this.metadata.setFormat(
                                "bitrate",
                                (8 * this.audioDataSize) / this.metadata.format.duration
                            );
                    }
                    async parseMetadataSubBlock(e, t) {
                        let n = t;
                        for (; n > CB.len; ) {
                            const t = await this.tokenizer.readToken(CB),
                                r = await this.tokenizer.readNumber(t.largeBlock ? ul : ol),
                                i = new Uint8Array(2 * r - (t.isOddSize ? 1 : 0));
                            switch (
                                (await this.tokenizer.readBuffer(i),
                                AB(
                                    `Metadata Sub-Blocks functionId=0x${t.functionId.toString(16)}, id.largeBlock=${t.largeBlock},data-size=${i.length}`
                                ),
                                t.functionId)
                            ) {
                                case 0:
                                    break;
                                case 14: {
                                    AB("ID_DSD_BLOCK");
                                    const t = 1 << ol.get(i, 0),
                                        n = e.flags.samplingRate * t * 8;
                                    if (!e.flags.isDSD) throw new PB("Only expect DSD block if DSD-flag is set");
                                    this.metadata.setFormat("sampleRate", n),
                                        this.metadata.setFormat("duration", e.totalSamples / n);
                                    break;
                                }
                                case 36:
                                    AB("ID_ALT_TRAILER: trailer for non-wav files");
                                    break;
                                case 38:
                                    this.metadata.setFormat("audioMD5", i);
                                    break;
                                case 47:
                                    AB(`ID_BLOCK_CHECKSUM: checksum=${Xu(i)}`);
                                    break;
                                default:
                                    AB(
                                        `Ignore unsupported meta-sub-block-id functionId=0x${t.functionId.toString(16)}`
                                    );
                            }
                            (n -= CB.len + (t.largeBlock ? ul.len : ol.len) + 2 * r),
                                AB(`remainingLength=${n}`),
                                t.isOddSize && this.tokenizer.ignore(1);
                        }
                        if (0 !== n) throw new PB("metadata-sub-block should fit it remaining length");
                    }
                },
            },
            Symbol.toStringTag,
            { value: "Module" }
        )
    ),
    NB = { len: 8, get: (e, t) => ({ chunkID: new Ml(4, "latin1").get(e, t), chunkSize: hl.get(e, t + 4) }) };
class RB {
    constructor(e) {
        (this.tagHeader = e), (this.len = e.chunkSize), (this.len += 1 & this.len);
    }
    get(e, t) {
        return new Ml(this.tagHeader.chunkSize, "ascii").get(e, t);
    }
}
class MB extends Ed("Wave") {}
const DB = 1,
    FB = 2,
    LB = 3,
    BB = 5632,
    zB = 5634,
    UB = 255,
    $B = 146,
    VB = 8192,
    WB = 576,
    jB = 577,
    HB = 9,
    qB = 8193,
    XB = 80,
    GB = {
        [DB]: "PCM",
        [FB]: "ADPCM",
        [LB]: "IEEE_FLOAT",
        [BB]: "MPEG_ADTS_AAC",
        [zB]: "MPEG_LOAS",
        [UB]: "RAW_AAC1",
        [$B]: "DOLBY_AC3_SPDIF",
        [VB]: "DVM",
        [WB]: "RAW_SPORT",
        [jB]: "ESST_AC3",
        [HB]: "DRM",
        [qB]: "DTS2",
        [XB]: "MPEG",
    };
class KB {
    constructor(e) {
        if (e.chunkSize < 16) throw new MB("Invalid chunk size");
        this.len = e.chunkSize;
    }
    get(e, t) {
        return {
            wFormatTag: cl.get(e, t),
            nChannels: cl.get(e, t + 2),
            nSamplesPerSec: hl.get(e, t + 4),
            nAvgBytesPerSec: hl.get(e, t + 8),
            nBlockAlign: cl.get(e, t + 12),
            wBitsPerSample: cl.get(e, t + 14),
        };
    }
}
class YB {
    constructor(e) {
        if (e.chunkSize < 4) throw new MB("Invalid fact chunk size.");
        this.len = e.chunkSize;
    }
    get(e, t) {
        return { dwSampleLength: hl.get(e, t) };
    }
}
const QB = {
        len: 420,
        get: (e, t) => ({
            description: Pd(new Ml(256, "ascii").get(e, t)).trim(),
            originator: Pd(new Ml(32, "ascii").get(e, t + 256)).trim(),
            originatorReference: Pd(new Ml(32, "ascii").get(e, t + 288)).trim(),
            originationDate: Pd(new Ml(10, "ascii").get(e, t + 320)).trim(),
            originationTime: Pd(new Ml(8, "ascii").get(e, t + 330)).trim(),
            timeReferenceLow: hl.get(e, t + 338),
            timeReferenceHigh: hl.get(e, t + 342),
            version: cl.get(e, t + 346),
            umid: new Rl(64).get(e, t + 348),
            loudnessValue: cl.get(e, t + 412),
            maxTruePeakLevel: cl.get(e, t + 414),
            maxMomentaryLoudness: cl.get(e, t + 416),
            maxShortTermLoudness: cl.get(e, t + 418),
        }),
    },
    JB = Tu("music-metadata:parser:RIFF");
const ZB = Object.freeze(
    Object.defineProperty(
        {
            __proto__: null,
            WaveParser: class extends Uh {
                constructor() {
                    super(...arguments), (this.blockAlign = 0);
                }
                async parse() {
                    const e = await this.tokenizer.readToken(NB);
                    if ((JB(`pos=${this.tokenizer.position}, parse: chunkID=${e.chunkID}`), "RIFF" === e.chunkID))
                        return (
                            this.metadata.setAudioOnly(),
                            this.parseRiffChunk(e.chunkSize).catch((e) => {
                                if (!(e instanceof qc)) throw e;
                            })
                        );
                }
                async parseRiffChunk(e) {
                    const t = await this.tokenizer.readToken(Vh);
                    if ((this.metadata.setFormat("container", t), "WAVE" === t)) return this.readWaveChunk(e - Vh.len);
                    throw new MB(`Unsupported RIFF format: RIFF/${t}`);
                }
                async readWaveChunk(e) {
                    for (; e >= NB.len; ) {
                        const t = await this.tokenizer.readToken(NB);
                        switch (
                            ((e -= NB.len + t.chunkSize),
                            t.chunkSize > e && this.metadata.addWarning("Data chunk size exceeds file size"),
                            (this.header = t),
                            JB(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${t.chunkID}`),
                            t.chunkID)
                        ) {
                            case "LIST":
                                await this.parseListTag(t);
                                break;
                            case "fact":
                                this.metadata.setFormat("lossless", !1),
                                    (this.fact = await this.tokenizer.readToken(new YB(t)));
                                break;
                            case "fmt ": {
                                const e = await this.tokenizer.readToken(new KB(t));
                                let n = GB[e.wFormatTag];
                                n || (JB(`WAVE/non-PCM format=${e.wFormatTag}`), (n = `non-PCM (${e.wFormatTag})`)),
                                    this.metadata.setFormat("codec", n),
                                    this.metadata.setFormat("bitsPerSample", e.wBitsPerSample),
                                    this.metadata.setFormat("sampleRate", e.nSamplesPerSec),
                                    this.metadata.setFormat("numberOfChannels", e.nChannels),
                                    this.metadata.setFormat("bitrate", e.nBlockAlign * e.nSamplesPerSec * 8),
                                    (this.blockAlign = e.nBlockAlign);
                                break;
                            }
                            case "id3 ":
                            case "ID3 ": {
                                const e = nl(await this.tokenizer.readToken(new Rl(t.chunkSize)));
                                await new bD().parse(this.metadata, e, this.options);
                                break;
                            }
                            case "data": {
                                !1 !== this.metadata.format.lossless && this.metadata.setFormat("lossless", !0);
                                let e = t.chunkSize;
                                if (this.tokenizer.fileInfo.size) {
                                    const t = this.tokenizer.fileInfo.size - this.tokenizer.position;
                                    t < e &&
                                        (this.metadata.addWarning("data chunk length exceeding file length"), (e = t));
                                }
                                const n = this.fact
                                    ? this.fact.dwSampleLength
                                    : 4294967295 === e
                                      ? void 0
                                      : e / this.blockAlign;
                                n &&
                                    (this.metadata.setFormat("numberOfSamples", n),
                                    this.metadata.format.sampleRate &&
                                        this.metadata.setFormat("duration", n / this.metadata.format.sampleRate)),
                                    "ADPCM" === this.metadata.format.codec
                                        ? this.metadata.setFormat("bitrate", 352e3)
                                        : this.metadata.format.sampleRate &&
                                          this.metadata.setFormat(
                                              "bitrate",
                                              this.blockAlign * this.metadata.format.sampleRate * 8
                                          ),
                                    await this.tokenizer.ignore(t.chunkSize);
                                break;
                            }
                            case "bext": {
                                const e = await this.tokenizer.readToken(QB);
                                Object.keys(e).forEach((t) => {
                                    this.metadata.addTag("exif", `bext.${t}`, e[t]);
                                });
                                const n = t.chunkSize - QB.len;
                                await this.tokenizer.ignore(n);
                                break;
                            }
                            case "\0\0\0\0":
                                JB(`Ignore padding chunk: RIFF/${t.chunkID} of ${t.chunkSize} bytes`),
                                    this.metadata.addWarning(`Ignore chunk: RIFF/${t.chunkID}`),
                                    await this.tokenizer.ignore(t.chunkSize);
                                break;
                            default:
                                JB(`Ignore chunk: RIFF/${t.chunkID} of ${t.chunkSize} bytes`),
                                    this.metadata.addWarning(`Ignore chunk: RIFF/${t.chunkID}`),
                                    await this.tokenizer.ignore(t.chunkSize);
                        }
                        this.header.chunkSize % 2 == 1 && (JB("Read odd padding byte"), await this.tokenizer.ignore(1));
                    }
                }
                async parseListTag(e) {
                    const t = await this.tokenizer.readToken(new Ml(4, "latin1"));
                    return (
                        JB("pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s", this.tokenizer.position, t),
                        "INFO" === t
                            ? this.parseRiffInfoTags(e.chunkSize - 4)
                            : (this.metadata.addWarning(`Ignore chunk: RIFF/WAVE/LIST/${t}`),
                              JB(`Ignoring chunkID=RIFF/WAVE/LIST/${t}`),
                              this.tokenizer.ignore(e.chunkSize - 4).then())
                    );
                }
                async parseRiffInfoTags(e) {
                    for (; e >= 8; ) {
                        const t = await this.tokenizer.readToken(NB),
                            n = new RB(t),
                            r = await this.tokenizer.readToken(n);
                        this.addTag(t.chunkID, Pd(r)), (e -= 8 + n.len);
                    }
                    if (0 !== e) throw new MB(`Illegal remaining size: ${e}`);
                }
                addTag(e, t) {
                    this.metadata.addTag("exif", e, t);
                }
            },
        },
        Symbol.toStringTag,
        { value: "Module" }
    )
);
export {
    nA as $, Hc as _, Rr as A, Hs as a,
    _x as a0,
    wx as a1,
    Wx as a2,
    Mx as a3,
    Rx as a4,
    Nx as a5,
    Ox as a6,
    Gx as a7,
    Un as a8,
    sn as a9,
    uD as aa,
    Va as ab,
    ea as ac,
    ci as ad,
    si as ae,
    ee as af,
    Xs as ag,
    Ho as ah,
    dc as ai, In as B, Kt as b, Mr as C, zs as c, Go as D, fr as d, io as E, Dt as e, xs as F, Ys as f, Gt as G, Vr as g, Xo as H, qr as h, os as I, Jr as i, Ht as J, qs as j, HE as K, Ks as k, QE as L, Us as l, WE as M, _a as m, Ov as N, Z as n, Dv as O, Ms as o, pA as P, hm as p, Ut as Q, G as q, aa as R, ai as r, ti as S, mm as s, yP as T, ke as t, GE as U, Zt as u, ei as V, jo as v, Or as W, $n as w, Jx as X, ii as x, ax as Y, $k as y, vx as Z, rc as z
};

